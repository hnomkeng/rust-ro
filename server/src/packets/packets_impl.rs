// Generated by tools/packets_db/main.rs
// Auto generated file do not edit manually

#![allow(dead_code)]

use crate::packets::packets::*;
use byteorder::{LittleEndian, WriteBytesExt, BigEndian};
use std::any::Any;
use std::convert::TryInto;

impl PacketCaLogin {
    pub fn from(buffer: &[u8]) -> PacketCaLogin {
        PacketCaLogin {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            version: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            id:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            passwd:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[30..54].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[30..54]);
                dst
            },
            client_type: u8::from_le_bytes([buffer[54]]),
            client_type_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[54..55]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.client_type).unwrap();
        self.client_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.version_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.passwd_raw.to_vec());
        wtr.append(&mut self.client_type_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_version(&mut self, value: u32) {
        self.version = value;
    }
    pub fn set_version_raw(&mut self, value: [u8; 4]) {
        self.version_raw = value;
    }
    pub fn set_id(&mut self, value: [char; 24]) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 24]) {
        self.id_raw = value;
    }
    pub fn set_passwd(&mut self, value: [char; 24]) {
        self.passwd = value;
    }
    pub fn set_passwd_raw(&mut self, value: [u8; 24]) {
        self.passwd_raw = value;
    }
    pub fn set_client_type(&mut self, value: u8) {
        self.client_type = value;
    }
    pub fn set_client_type_raw(&mut self, value: [u8; 1]) {
        self.client_type_raw = value;
    }
    pub fn new() -> PacketCaLogin {
        PacketCaLogin {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x64, 0x0]),
        packet_id_raw: [0x64, 0x0],
        version: 0,
        version_raw: [0; 4],
        id: [0 as char; 24],
        id_raw: [0; 24],
        passwd: [0 as char; 24],
        passwd_raw: [0; 24],
        client_type: 0,
        client_type_raw: [0; 1],
        }
    }
}

impl Packet for PacketCaLogin {
    fn id(&self) -> &str {
       "0x6400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketChEnter {
    pub fn from(buffer: &[u8]) -> PacketChEnter {
        PacketChEnter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            auth_code: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            user_level: u32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            user_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            client_type: u16::from_le_bytes([buffer[14], buffer[15]]),
            client_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            sex: u8::from_le_bytes([buffer[16]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[16..17]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.user_level).unwrap();
        self.user_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.client_type).unwrap();
        self.client_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.auth_code_raw.to_vec());
        wtr.append(&mut self.user_level_raw.to_vec());
        wtr.append(&mut self.client_type_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_auth_code(&mut self, value: i32) {
        self.auth_code = value;
    }
    pub fn set_auth_code_raw(&mut self, value: [u8; 4]) {
        self.auth_code_raw = value;
    }
    pub fn set_user_level(&mut self, value: u32) {
        self.user_level = value;
    }
    pub fn set_user_level_raw(&mut self, value: [u8; 4]) {
        self.user_level_raw = value;
    }
    pub fn set_client_type(&mut self, value: u16) {
        self.client_type = value;
    }
    pub fn set_client_type_raw(&mut self, value: [u8; 2]) {
        self.client_type_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn new() -> PacketChEnter {
        PacketChEnter {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x65, 0x0]),
        packet_id_raw: [0x65, 0x0],
        aid: 0,
        aid_raw: [0; 4],
        auth_code: 0,
        auth_code_raw: [0; 4],
        user_level: 0,
        user_level_raw: [0; 4],
        client_type: 0,
        client_type_raw: [0; 2],
        sex: 0,
        sex_raw: [0; 1],
        }
    }
}

impl Packet for PacketChEnter {
    fn id(&self) -> &str {
       "0x6500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketChSelectChar {
    pub fn from(buffer: &[u8]) -> PacketChSelectChar {
        PacketChSelectChar {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            char_num: u8::from_le_bytes([buffer[2]]),
            char_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.char_num).unwrap();
        self.char_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.char_num_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_char_num(&mut self, value: u8) {
        self.char_num = value;
    }
    pub fn set_char_num_raw(&mut self, value: [u8; 1]) {
        self.char_num_raw = value;
    }
    pub fn new() -> PacketChSelectChar {
        PacketChSelectChar {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x66, 0x0]),
        packet_id_raw: [0x66, 0x0],
        char_num: 0,
        char_num_raw: [0; 1],
        }
    }
}

impl Packet for PacketChSelectChar {
    fn id(&self) -> &str {
       "0x6600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketChMakeChar {
    pub fn from(buffer: &[u8]) -> PacketChMakeChar {
        PacketChMakeChar {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            str: u8::from_le_bytes([buffer[26]]),
            str_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[26..27]);
                dst
            },
            agi: u8::from_le_bytes([buffer[27]]),
            agi_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[27..28]);
                dst
            },
            vit: u8::from_le_bytes([buffer[28]]),
            vit_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[28..29]);
                dst
            },
            int: u8::from_le_bytes([buffer[29]]),
            int_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[29..30]);
                dst
            },
            dex: u8::from_le_bytes([buffer[30]]),
            dex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[30..31]);
                dst
            },
            luk: u8::from_le_bytes([buffer[31]]),
            luk_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[31..32]);
                dst
            },
            char_num: u8::from_le_bytes([buffer[32]]),
            char_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[32..33]);
                dst
            },
            head_pal: i16::from_le_bytes([buffer[33], buffer[34]]),
            head_pal_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            head: i16::from_le_bytes([buffer[35], buffer[36]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[35..37]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.str).unwrap();
        self.str_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.agi).unwrap();
        self.agi_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.vit).unwrap();
        self.vit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.int).unwrap();
        self.int_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dex).unwrap();
        self.dex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.luk).unwrap();
        self.luk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.char_num).unwrap();
        self.char_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_pal).unwrap();
        self.head_pal_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.str_raw.to_vec());
        wtr.append(&mut self.agi_raw.to_vec());
        wtr.append(&mut self.vit_raw.to_vec());
        wtr.append(&mut self.int_raw.to_vec());
        wtr.append(&mut self.dex_raw.to_vec());
        wtr.append(&mut self.luk_raw.to_vec());
        wtr.append(&mut self.char_num_raw.to_vec());
        wtr.append(&mut self.head_pal_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_str(&mut self, value: u8) {
        self.str = value;
    }
    pub fn set_str_raw(&mut self, value: [u8; 1]) {
        self.str_raw = value;
    }
    pub fn set_agi(&mut self, value: u8) {
        self.agi = value;
    }
    pub fn set_agi_raw(&mut self, value: [u8; 1]) {
        self.agi_raw = value;
    }
    pub fn set_vit(&mut self, value: u8) {
        self.vit = value;
    }
    pub fn set_vit_raw(&mut self, value: [u8; 1]) {
        self.vit_raw = value;
    }
    pub fn set_int(&mut self, value: u8) {
        self.int = value;
    }
    pub fn set_int_raw(&mut self, value: [u8; 1]) {
        self.int_raw = value;
    }
    pub fn set_dex(&mut self, value: u8) {
        self.dex = value;
    }
    pub fn set_dex_raw(&mut self, value: [u8; 1]) {
        self.dex_raw = value;
    }
    pub fn set_luk(&mut self, value: u8) {
        self.luk = value;
    }
    pub fn set_luk_raw(&mut self, value: [u8; 1]) {
        self.luk_raw = value;
    }
    pub fn set_char_num(&mut self, value: u8) {
        self.char_num = value;
    }
    pub fn set_char_num_raw(&mut self, value: [u8; 1]) {
        self.char_num_raw = value;
    }
    pub fn set_head_pal(&mut self, value: i16) {
        self.head_pal = value;
    }
    pub fn set_head_pal_raw(&mut self, value: [u8; 2]) {
        self.head_pal_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn new() -> PacketChMakeChar {
        PacketChMakeChar {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x67, 0x0]),
        packet_id_raw: [0x67, 0x0],
        name: [0 as char; 24],
        name_raw: [0; 24],
        str: 0,
        str_raw: [0; 1],
        agi: 0,
        agi_raw: [0; 1],
        vit: 0,
        vit_raw: [0; 1],
        int: 0,
        int_raw: [0; 1],
        dex: 0,
        dex_raw: [0; 1],
        luk: 0,
        luk_raw: [0; 1],
        char_num: 0,
        char_num_raw: [0; 1],
        head_pal: 0,
        head_pal_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        }
    }
}

impl Packet for PacketChMakeChar {
    fn id(&self) -> &str {
       "0x6700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketChDeleteChar {
    pub fn from(buffer: &[u8]) -> PacketChDeleteChar {
        PacketChDeleteChar {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            key:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[6..46].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            key_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[6..46]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.key {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.key_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.key_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_key(&mut self, value: [char; 40]) {
        self.key = value;
    }
    pub fn set_key_raw(&mut self, value: [u8; 40]) {
        self.key_raw = value;
    }
    pub fn new() -> PacketChDeleteChar {
        PacketChDeleteChar {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x68, 0x0]),
        packet_id_raw: [0x68, 0x0],
        gid: 0,
        gid_raw: [0; 4],
        key: [0 as char; 40],
        key_raw: [0; 40],
        }
    }
}

impl Packet for PacketChDeleteChar {
    fn id(&self) -> &str {
       "0x6800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcAcceptLogin {
    pub fn from(buffer: &[u8]) -> PacketAcAcceptLogin {
        let iter_count = (&buffer.len() - 47) / 32;
        let mut vec_field: Vec<ServerAddr> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 47 + (32 * (i - 1));
            let end_pos = 47 + 32 * i;
            vec_field.push(ServerAddr::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketAcAcceptLogin {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            auth_code: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            aid: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            user_level: u32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            user_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            last_login_ip: u32::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19]]),
            last_login_ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[16..20]);
                dst
            },
            last_login_time:  {
                let mut dst: [char; 26] = [0 as char; 26];
                for (index, byte) in buffer[20..46].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            last_login_time_raw: {
                let mut dst: [u8; 26] = [0u8; 26];
                dst.clone_from_slice(&buffer[20..46]);
                dst
            },
            sex: u8::from_le_bytes([buffer[46]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[46..47]);
                dst
            },
            server_list: vec_field.clone(),
            server_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.user_level).unwrap();
        self.user_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.last_login_ip).unwrap();
        self.last_login_ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.last_login_time {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.last_login_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        self.server_list_raw = {
            self.server_list.iter_mut().for_each(|item| item.fill_raw());
            self.server_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.auth_code_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.user_level_raw.to_vec());
        wtr.append(&mut self.last_login_ip_raw.to_vec());
        wtr.append(&mut self.last_login_time_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        self.server_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_auth_code(&mut self, value: i32) {
        self.auth_code = value;
    }
    pub fn set_auth_code_raw(&mut self, value: [u8; 4]) {
        self.auth_code_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_user_level(&mut self, value: u32) {
        self.user_level = value;
    }
    pub fn set_user_level_raw(&mut self, value: [u8; 4]) {
        self.user_level_raw = value;
    }
    pub fn set_last_login_ip(&mut self, value: u32) {
        self.last_login_ip = value;
    }
    pub fn set_last_login_ip_raw(&mut self, value: [u8; 4]) {
        self.last_login_ip_raw = value;
    }
    pub fn set_last_login_time(&mut self, value: [char; 26]) {
        self.last_login_time = value;
    }
    pub fn set_last_login_time_raw(&mut self, value: [u8; 26]) {
        self.last_login_time_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_server_list(&mut self, value: Vec<ServerAddr>) {
        self.server_list = value;
    }
    pub fn set_server_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.server_list_raw = value;
    }
    pub fn new() -> PacketAcAcceptLogin {
        PacketAcAcceptLogin {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x69, 0x0]),
        packet_id_raw: [0x69, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        auth_code: 0,
        auth_code_raw: [0; 4],
        aid: 0,
        aid_raw: [0; 4],
        user_level: 0,
        user_level_raw: [0; 4],
        last_login_ip: 0,
        last_login_ip_raw: [0; 4],
        last_login_time: [0 as char; 26],
        last_login_time_raw: [0; 26],
        sex: 0,
        sex_raw: [0; 1],
        server_list: vec![],
        server_list_raw: vec![],
        }
    }
}

impl Packet for PacketAcAcceptLogin {
    fn id(&self) -> &str {
       "0x6900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcAcceptLogin2 {
    pub fn from(buffer: &[u8]) -> PacketAcAcceptLogin2 {
        let iter_count = (&buffer.len() - 64) / 160;
        let mut vec_field: Vec<ServerAddr2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 64 + (160 * (i - 1));
            let end_pos = 64 + 160 * i;
            vec_field.push(ServerAddr2::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketAcAcceptLogin2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            auth_code: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            aid: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            user_level: u32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            user_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            last_login_ip: u32::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19]]),
            last_login_ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[16..20]);
                dst
            },
            last_login_time:  {
                let mut dst: [char; 26] = [0 as char; 26];
                for (index, byte) in buffer[20..46].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            last_login_time_raw: {
                let mut dst: [u8; 26] = [0u8; 26];
                dst.clone_from_slice(&buffer[20..46]);
                dst
            },
            sex: u8::from_le_bytes([buffer[46]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[46..47]);
                dst
            },
            twitter_auth_token:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[47..63].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            twitter_auth_token_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[47..63]);
                dst
            },
            twitter_flag: u8::from_le_bytes([buffer[63]]),
            twitter_flag_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[63..64]);
                dst
            },
            server_list: vec_field.clone(),
            server_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.user_level).unwrap();
        self.user_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.last_login_ip).unwrap();
        self.last_login_ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.last_login_time {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.last_login_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.twitter_auth_token {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.twitter_auth_token_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.twitter_flag).unwrap();
        self.twitter_flag_raw = wtr.try_into().unwrap();
        self.server_list_raw = {
            self.server_list.iter_mut().for_each(|item| item.fill_raw());
            self.server_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.auth_code_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.user_level_raw.to_vec());
        wtr.append(&mut self.last_login_ip_raw.to_vec());
        wtr.append(&mut self.last_login_time_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.twitter_auth_token_raw.to_vec());
        wtr.append(&mut self.twitter_flag_raw.to_vec());
        self.server_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_auth_code(&mut self, value: i32) {
        self.auth_code = value;
    }
    pub fn set_auth_code_raw(&mut self, value: [u8; 4]) {
        self.auth_code_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_user_level(&mut self, value: u32) {
        self.user_level = value;
    }
    pub fn set_user_level_raw(&mut self, value: [u8; 4]) {
        self.user_level_raw = value;
    }
    pub fn set_last_login_ip(&mut self, value: u32) {
        self.last_login_ip = value;
    }
    pub fn set_last_login_ip_raw(&mut self, value: [u8; 4]) {
        self.last_login_ip_raw = value;
    }
    pub fn set_last_login_time(&mut self, value: [char; 26]) {
        self.last_login_time = value;
    }
    pub fn set_last_login_time_raw(&mut self, value: [u8; 26]) {
        self.last_login_time_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_twitter_auth_token(&mut self, value: [char; 16]) {
        self.twitter_auth_token = value;
    }
    pub fn set_twitter_auth_token_raw(&mut self, value: [u8; 16]) {
        self.twitter_auth_token_raw = value;
    }
    pub fn set_twitter_flag(&mut self, value: u8) {
        self.twitter_flag = value;
    }
    pub fn set_twitter_flag_raw(&mut self, value: [u8; 1]) {
        self.twitter_flag_raw = value;
    }
    pub fn set_server_list(&mut self, value: Vec<ServerAddr2>) {
        self.server_list = value;
    }
    pub fn set_server_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.server_list_raw = value;
    }
    pub fn new() -> PacketAcAcceptLogin2 {
        PacketAcAcceptLogin2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xc4, 0x0a]),
        packet_id_raw: [0xc4, 0x0a],
        packet_length: 0,
        packet_length_raw: [0; 2],
        auth_code: 0,
        auth_code_raw: [0; 4],
        aid: 0,
        aid_raw: [0; 4],
        user_level: 0,
        user_level_raw: [0; 4],
        last_login_ip: 0,
        last_login_ip_raw: [0; 4],
        last_login_time: [0 as char; 26],
        last_login_time_raw: [0; 26],
        sex: 0,
        sex_raw: [0; 1],
        twitter_auth_token: [0 as char; 16],
        twitter_auth_token_raw: [0; 16],
        twitter_flag: 0,
        twitter_flag_raw: [0; 1],
        server_list: vec![],
        server_list_raw: vec![],
        }
    }
}

impl Packet for PacketAcAcceptLogin2 {
    fn id(&self) -> &str {
       "0xc40a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcRefuseLogin {
    pub fn from(buffer: &[u8]) -> PacketAcRefuseLogin {
        PacketAcRefuseLogin {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: u8::from_le_bytes([buffer[2]]),
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            block_date:  {
                let mut dst: [char; 20] = [0 as char; 20];
                for (index, byte) in buffer[3..23].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            block_date_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[3..23]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.block_date {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.block_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        wtr.append(&mut self.block_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u8) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 1]) {
        self.error_code_raw = value;
    }
    pub fn set_block_date(&mut self, value: [char; 20]) {
        self.block_date = value;
    }
    pub fn set_block_date_raw(&mut self, value: [u8; 20]) {
        self.block_date_raw = value;
    }
    pub fn new() -> PacketAcRefuseLogin {
        PacketAcRefuseLogin {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x6a, 0x0]),
        packet_id_raw: [0x6a, 0x0],
        error_code: 0,
        error_code_raw: [0; 1],
        block_date: [0 as char; 20],
        block_date_raw: [0; 20],
        }
    }
}

impl Packet for PacketAcRefuseLogin {
    fn id(&self) -> &str {
       "0x6a00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcAcceptEnterNeoUnion {
    pub fn from(buffer: &[u8]) -> PacketHcAcceptEnterNeoUnion {
        let iter_count = (&buffer.len() - 27) / 155;
        let mut vec_field: Vec<CharacterInfoNeoUnion> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 27 + (155 * (i - 1));
            let end_pos = 27 + 155 * i;
            vec_field.push(CharacterInfoNeoUnion::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketHcAcceptEnterNeoUnion {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            total_slot_num: u8::from_le_bytes([buffer[4]]),
            total_slot_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            premium_start_slot: u8::from_le_bytes([buffer[5]]),
            premium_start_slot_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            premium_end_slot: u8::from_le_bytes([buffer[6]]),
            premium_end_slot_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            dummy1_beginbilling: i8::from_le_bytes([buffer[7]]),
            dummy1_beginbilling_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[7..8]);
                dst
            },
            code: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            time1: u32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            time1_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            time2: u32::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19]]),
            time2_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[16..20]);
                dst
            },
            dummy2_endbilling:  {
                let mut dst: [char; 7] = [0 as char; 7];
                for (index, byte) in buffer[20..27].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            dummy2_endbilling_raw: {
                let mut dst: [u8; 7] = [0u8; 7];
                dst.clone_from_slice(&buffer[20..27]);
                dst
            },
            char_info: vec_field.clone(),
            char_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.total_slot_num).unwrap();
        self.total_slot_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.premium_start_slot).unwrap();
        self.premium_start_slot_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.premium_end_slot).unwrap();
        self.premium_end_slot_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.dummy1_beginbilling).unwrap();
        self.dummy1_beginbilling_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.code).unwrap();
        self.code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.time1).unwrap();
        self.time1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.time2).unwrap();
        self.time2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.dummy2_endbilling {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.dummy2_endbilling_raw = wtr.try_into().unwrap();
        self.char_info_raw = {
            self.char_info.iter_mut().for_each(|item| item.fill_raw());
            self.char_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.total_slot_num_raw.to_vec());
        wtr.append(&mut self.premium_start_slot_raw.to_vec());
        wtr.append(&mut self.premium_end_slot_raw.to_vec());
        wtr.append(&mut self.dummy1_beginbilling_raw.to_vec());
        wtr.append(&mut self.code_raw.to_vec());
        wtr.append(&mut self.time1_raw.to_vec());
        wtr.append(&mut self.time2_raw.to_vec());
        wtr.append(&mut self.dummy2_endbilling_raw.to_vec());
        self.char_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_total_slot_num(&mut self, value: u8) {
        self.total_slot_num = value;
    }
    pub fn set_total_slot_num_raw(&mut self, value: [u8; 1]) {
        self.total_slot_num_raw = value;
    }
    pub fn set_premium_start_slot(&mut self, value: u8) {
        self.premium_start_slot = value;
    }
    pub fn set_premium_start_slot_raw(&mut self, value: [u8; 1]) {
        self.premium_start_slot_raw = value;
    }
    pub fn set_premium_end_slot(&mut self, value: u8) {
        self.premium_end_slot = value;
    }
    pub fn set_premium_end_slot_raw(&mut self, value: [u8; 1]) {
        self.premium_end_slot_raw = value;
    }
    pub fn set_dummy1_beginbilling(&mut self, value: i8) {
        self.dummy1_beginbilling = value;
    }
    pub fn set_dummy1_beginbilling_raw(&mut self, value: [u8; 1]) {
        self.dummy1_beginbilling_raw = value;
    }
    pub fn set_code(&mut self, value: u32) {
        self.code = value;
    }
    pub fn set_code_raw(&mut self, value: [u8; 4]) {
        self.code_raw = value;
    }
    pub fn set_time1(&mut self, value: u32) {
        self.time1 = value;
    }
    pub fn set_time1_raw(&mut self, value: [u8; 4]) {
        self.time1_raw = value;
    }
    pub fn set_time2(&mut self, value: u32) {
        self.time2 = value;
    }
    pub fn set_time2_raw(&mut self, value: [u8; 4]) {
        self.time2_raw = value;
    }
    pub fn set_dummy2_endbilling(&mut self, value: [char; 7]) {
        self.dummy2_endbilling = value;
    }
    pub fn set_dummy2_endbilling_raw(&mut self, value: [u8; 7]) {
        self.dummy2_endbilling_raw = value;
    }
    pub fn set_char_info(&mut self, value: Vec<CharacterInfoNeoUnion>) {
        self.char_info = value;
    }
    pub fn set_char_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.char_info_raw = value;
    }
    pub fn new() -> PacketHcAcceptEnterNeoUnion {
        PacketHcAcceptEnterNeoUnion {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x6b, 0x0]),
        packet_id_raw: [0x6b, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        total_slot_num: 0,
        total_slot_num_raw: [0; 1],
        premium_start_slot: 0,
        premium_start_slot_raw: [0; 1],
        premium_end_slot: 0,
        premium_end_slot_raw: [0; 1],
        dummy1_beginbilling: 0,
        dummy1_beginbilling_raw: [0; 1],
        code: 0,
        code_raw: [0; 4],
        time1: 0,
        time1_raw: [0; 4],
        time2: 0,
        time2_raw: [0; 4],
        dummy2_endbilling: [0 as char; 7],
        dummy2_endbilling_raw: [0; 7],
        char_info: vec![],
        char_info_raw: vec![],
        }
    }
}

impl Packet for PacketHcAcceptEnterNeoUnion {
    fn id(&self) -> &str {
       "0x6b00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcRefuseEnter {
    pub fn from(buffer: &[u8]) -> PacketHcRefuseEnter {
        PacketHcRefuseEnter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: u8::from_le_bytes([buffer[2]]),
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u8) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 1]) {
        self.error_code_raw = value;
    }
    pub fn new() -> PacketHcRefuseEnter {
        PacketHcRefuseEnter {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x6c, 0x0]),
        packet_id_raw: [0x6c, 0x0],
        error_code: 0,
        error_code_raw: [0; 1],
        }
    }
}

impl Packet for PacketHcRefuseEnter {
    fn id(&self) -> &str {
       "0x6c00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcAcceptMakecharNeoUnion {
    pub fn from(buffer: &[u8]) -> PacketHcAcceptMakecharNeoUnion {
        PacketHcAcceptMakecharNeoUnion {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            charinfo: CharacterInfoNeoUnion::from(&buffer[2..buffer.len()]),
            charinfo_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.charinfo.fill_raw();
        self.charinfo_raw = self.charinfo.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.charinfo_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_charinfo(&mut self, value: CharacterInfoNeoUnion) {
        self.charinfo = value;
    }
    pub fn set_charinfo_raw(&mut self, value: Vec<u8>) {
        self.charinfo_raw = value;
    }
    pub fn new() -> PacketHcAcceptMakecharNeoUnion {
        PacketHcAcceptMakecharNeoUnion {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x6d, 0x0]),
        packet_id_raw: [0x6d, 0x0],
        charinfo: CharacterInfoNeoUnion::new(),
        charinfo_raw: vec![],
        }
    }
}

impl Packet for PacketHcAcceptMakecharNeoUnion {
    fn id(&self) -> &str {
       "0x6d00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcRefuseMakechar {
    pub fn from(buffer: &[u8]) -> PacketHcRefuseMakechar {
        PacketHcRefuseMakechar {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: u8::from_le_bytes([buffer[2]]),
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u8) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 1]) {
        self.error_code_raw = value;
    }
    pub fn new() -> PacketHcRefuseMakechar {
        PacketHcRefuseMakechar {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x6e, 0x0]),
        packet_id_raw: [0x6e, 0x0],
        error_code: 0,
        error_code_raw: [0; 1],
        }
    }
}

impl Packet for PacketHcRefuseMakechar {
    fn id(&self) -> &str {
       "0x6e00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcAcceptDeletechar {
    pub fn from(buffer: &[u8]) -> PacketHcAcceptDeletechar {
        PacketHcAcceptDeletechar {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketHcAcceptDeletechar {
        PacketHcAcceptDeletechar {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x6f, 0x0]),
        packet_id_raw: [0x6f, 0x0],
        }
    }
}

impl Packet for PacketHcAcceptDeletechar {
    fn id(&self) -> &str {
       "0x6f00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcRefuseDeletechar {
    pub fn from(buffer: &[u8]) -> PacketHcRefuseDeletechar {
        PacketHcRefuseDeletechar {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: u8::from_le_bytes([buffer[2]]),
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u8) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 1]) {
        self.error_code_raw = value;
    }
    pub fn new() -> PacketHcRefuseDeletechar {
        PacketHcRefuseDeletechar {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x70, 0x0]),
        packet_id_raw: [0x70, 0x0],
        error_code: 0,
        error_code_raw: [0; 1],
        }
    }
}

impl Packet for PacketHcRefuseDeletechar {
    fn id(&self) -> &str {
       "0x7000"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcNotifyZonesvr {
    pub fn from(buffer: &[u8]) -> PacketHcNotifyZonesvr {
        PacketHcNotifyZonesvr {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[6..22].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[6..22]);
                dst
            },
            addr: ZserverAddr::from(&buffer[22..buffer.len()]),
            addr_raw: buffer[22..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        self.addr.fill_raw();
        self.addr_raw = self.addr.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.addr_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_addr(&mut self, value: ZserverAddr) {
        self.addr = value;
    }
    pub fn set_addr_raw(&mut self, value: Vec<u8>) {
        self.addr_raw = value;
    }
    pub fn new() -> PacketHcNotifyZonesvr {
        PacketHcNotifyZonesvr {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x71, 0x0]),
        packet_id_raw: [0x71, 0x0],
        gid: 0,
        gid_raw: [0; 4],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        addr: ZserverAddr::new(),
        addr_raw: vec![],
        }
    }
}

impl Packet for PacketHcNotifyZonesvr {
    fn id(&self) -> &str {
       "0x7100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzEnter {
    pub fn from(buffer: &[u8]) -> PacketCzEnter {
        PacketCzEnter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            auth_code: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            client_time: u32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            client_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
            sex: u8::from_le_bytes([buffer[18]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[18..19]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.client_time).unwrap();
        self.client_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.auth_code_raw.to_vec());
        wtr.append(&mut self.client_time_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_auth_code(&mut self, value: i32) {
        self.auth_code = value;
    }
    pub fn set_auth_code_raw(&mut self, value: [u8; 4]) {
        self.auth_code_raw = value;
    }
    pub fn set_client_time(&mut self, value: u32) {
        self.client_time = value;
    }
    pub fn set_client_time_raw(&mut self, value: [u8; 4]) {
        self.client_time_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn new() -> PacketCzEnter {
        PacketCzEnter {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x72, 0x0]),
        packet_id_raw: [0x72, 0x0],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        auth_code: 0,
        auth_code_raw: [0; 4],
        client_time: 0,
        client_time_raw: [0; 4],
        sex: 0,
        sex_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzEnter {
    fn id(&self) -> &str {
       "0x7200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAcceptEnter {
    pub fn from(buffer: &[u8]) -> PacketZcAcceptEnter {
        PacketZcAcceptEnter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            start_time: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[6..9].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[6..9]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[9]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[10]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.start_time_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_start_time(&mut self, value: u32) {
        self.start_time = value;
    }
    pub fn set_start_time_raw(&mut self, value: [u8; 4]) {
        self.start_time_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [char; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn new() -> PacketZcAcceptEnter {
        PacketZcAcceptEnter {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x73, 0x0]),
        packet_id_raw: [0x73, 0x0],
        start_time: 0,
        start_time_raw: [0; 4],
        pos_dir: [0 as char; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAcceptEnter {
    fn id(&self) -> &str {
       "0x7300"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcRefuseEnter {
    pub fn from(buffer: &[u8]) -> PacketZcRefuseEnter {
        PacketZcRefuseEnter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: u8::from_le_bytes([buffer[2]]),
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u8) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 1]) {
        self.error_code_raw = value;
    }
    pub fn new() -> PacketZcRefuseEnter {
        PacketZcRefuseEnter {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x74, 0x0]),
        packet_id_raw: [0x74, 0x0],
        error_code: 0,
        error_code_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcRefuseEnter {
    fn id(&self) -> &str {
       "0x7400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyInitchar {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyInitchar {
        PacketZcNotifyInitchar {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            gid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            style: i16::from_le_bytes([buffer[8], buffer[9]]),
            style_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            item: u8::from_le_bytes([buffer[10]]),
            item_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.style).unwrap();
        self.style_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item).unwrap();
        self.item_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.style_raw.to_vec());
        wtr.append(&mut self.item_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_style(&mut self, value: i16) {
        self.style = value;
    }
    pub fn set_style_raw(&mut self, value: [u8; 2]) {
        self.style_raw = value;
    }
    pub fn set_item(&mut self, value: u8) {
        self.item = value;
    }
    pub fn set_item_raw(&mut self, value: [u8; 1]) {
        self.item_raw = value;
    }
    pub fn new() -> PacketZcNotifyInitchar {
        PacketZcNotifyInitchar {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x75, 0x0]),
        packet_id_raw: [0x75, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        gid: 0,
        gid_raw: [0; 4],
        style: 0,
        style_raw: [0; 2],
        item: 0,
        item_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcNotifyInitchar {
    fn id(&self) -> &str {
       "0x7500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyUpdatechar {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyUpdatechar {
        PacketZcNotifyUpdatechar {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            style: i16::from_le_bytes([buffer[6], buffer[7]]),
            style_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            item: u8::from_le_bytes([buffer[8]]),
            item_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.style).unwrap();
        self.style_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item).unwrap();
        self.item_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.style_raw.to_vec());
        wtr.append(&mut self.item_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_style(&mut self, value: i16) {
        self.style = value;
    }
    pub fn set_style_raw(&mut self, value: [u8; 2]) {
        self.style_raw = value;
    }
    pub fn set_item(&mut self, value: u8) {
        self.item = value;
    }
    pub fn set_item_raw(&mut self, value: [u8; 1]) {
        self.item_raw = value;
    }
    pub fn new() -> PacketZcNotifyUpdatechar {
        PacketZcNotifyUpdatechar {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x76, 0x0]),
        packet_id_raw: [0x76, 0x0],
        gid: 0,
        gid_raw: [0; 4],
        style: 0,
        style_raw: [0; 2],
        item: 0,
        item_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcNotifyUpdatechar {
    fn id(&self) -> &str {
       "0x7600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyUpdateplayer {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyUpdateplayer {
        PacketZcNotifyUpdateplayer {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            style: i16::from_le_bytes([buffer[2], buffer[3]]),
            style_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item: u8::from_le_bytes([buffer[4]]),
            item_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.style).unwrap();
        self.style_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item).unwrap();
        self.item_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.style_raw.to_vec());
        wtr.append(&mut self.item_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_style(&mut self, value: i16) {
        self.style = value;
    }
    pub fn set_style_raw(&mut self, value: [u8; 2]) {
        self.style_raw = value;
    }
    pub fn set_item(&mut self, value: u8) {
        self.item = value;
    }
    pub fn set_item_raw(&mut self, value: [u8; 1]) {
        self.item_raw = value;
    }
    pub fn new() -> PacketZcNotifyUpdateplayer {
        PacketZcNotifyUpdateplayer {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x77, 0x0]),
        packet_id_raw: [0x77, 0x0],
        style: 0,
        style_raw: [0; 2],
        item: 0,
        item_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcNotifyUpdateplayer {
    fn id(&self) -> &str {
       "0x7700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyStandentry {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyStandentry {
        PacketZcNotifyStandentry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            objecttype: u8::from_le_bytes([buffer[2]]),
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            gid: u32::from_le_bytes([buffer[3], buffer[4], buffer[5], buffer[6]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[3..7]);
                dst
            },
            speed: i16::from_le_bytes([buffer[7], buffer[8]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[7..9]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[9], buffer[10]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[11], buffer[12]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            effect_state: i16::from_le_bytes([buffer[13], buffer[14]]),
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[13..15]);
                dst
            },
            job: i16::from_le_bytes([buffer[15], buffer[16]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[15..17]);
                dst
            },
            head: i16::from_le_bytes([buffer[17], buffer[18]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[17..19]);
                dst
            },
            weapon: i16::from_le_bytes([buffer[19], buffer[20]]),
            weapon_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[21], buffer[22]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[21..23]);
                dst
            },
            shield: i16::from_le_bytes([buffer[23], buffer[24]]),
            shield_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[23..25]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[25], buffer[26]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[25..27]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[27], buffer[28]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[27..29]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[29], buffer[30]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[29..31]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[31], buffer[32]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[31..33]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[33], buffer[34]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            guid: u32::from_le_bytes([buffer[35], buffer[36], buffer[37], buffer[38]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[35..39]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[39], buffer[40]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[39..41]);
                dst
            },
            honor: i16::from_le_bytes([buffer[41], buffer[42]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[41..43]);
                dst
            },
            virtue: i16::from_le_bytes([buffer[43], buffer[44]]),
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[43..45]);
                dst
            },
            is_pkmode_on: buffer[45] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[45..46]);
                dst
            },
            sex: u8::from_le_bytes([buffer[46]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[46..47]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[47..50].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[47..50]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[50]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[50..51]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[51]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[51..52]);
                dst
            },
            state: u8::from_le_bytes([buffer[52]]),
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[52..53]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[53], buffer[54]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[53..55]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.objecttype_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.shield_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_objecttype(&mut self, value: u8) {
        self.objecttype = value;
    }
    pub fn set_objecttype_raw(&mut self, value: [u8; 1]) {
        self.objecttype_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i16) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 2]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i16) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 2]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_shield(&mut self, value: i16) {
        self.shield = value;
    }
    pub fn set_shield_raw(&mut self, value: [u8; 2]) {
        self.shield_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i16) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 2]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [char; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_state(&mut self, value: u8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new() -> PacketZcNotifyStandentry {
        PacketZcNotifyStandentry {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x78, 0x0]),
        packet_id_raw: [0x78, 0x0],
        objecttype: 0,
        objecttype_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 2],
        accessory: 0,
        accessory_raw: [0; 2],
        shield: 0,
        shield_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 2],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0 as char; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        state: 0,
        state_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyStandentry {
    fn id(&self) -> &str {
       "0x7800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyNewentry {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyNewentry {
        PacketZcNotifyNewentry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i16::from_le_bytes([buffer[12], buffer[13]]),
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: i16::from_le_bytes([buffer[14], buffer[15]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            head: i16::from_le_bytes([buffer[16], buffer[17]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            weapon: i16::from_le_bytes([buffer[18], buffer[19]]),
            weapon_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[20], buffer[21]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
            shield: i16::from_le_bytes([buffer[22], buffer[23]]),
            shield_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[22..24]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[24], buffer[25]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[26], buffer[27]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[28], buffer[29]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[30], buffer[31]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[32], buffer[33]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            guid: u32::from_le_bytes([buffer[34], buffer[35], buffer[36], buffer[37]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[34..38]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[38], buffer[39]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[38..40]);
                dst
            },
            honor: i16::from_le_bytes([buffer[40], buffer[41]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            virtue: i16::from_le_bytes([buffer[42], buffer[43]]),
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            is_pkmode_on: buffer[44] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[44..45]);
                dst
            },
            sex: u8::from_le_bytes([buffer[45]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[45..46]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[46..49].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[46..49]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[49]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[50]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[50..51]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[51], buffer[52]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[51..53]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.shield_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i16) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 2]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i16) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 2]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_shield(&mut self, value: i16) {
        self.shield = value;
    }
    pub fn set_shield_raw(&mut self, value: [u8; 2]) {
        self.shield_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i16) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 2]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [char; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new() -> PacketZcNotifyNewentry {
        PacketZcNotifyNewentry {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x79, 0x0]),
        packet_id_raw: [0x79, 0x0],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 2],
        accessory: 0,
        accessory_raw: [0; 2],
        shield: 0,
        shield_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 2],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0 as char; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyNewentry {
    fn id(&self) -> &str {
       "0x7900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyActentry {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyActentry {
        PacketZcNotifyActentry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i16::from_le_bytes([buffer[12], buffer[13]]),
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: i16::from_le_bytes([buffer[14], buffer[15]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            head: i16::from_le_bytes([buffer[16], buffer[17]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            weapon: i16::from_le_bytes([buffer[18], buffer[19]]),
            weapon_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[20], buffer[21]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
            shield: i16::from_le_bytes([buffer[22], buffer[23]]),
            shield_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[22..24]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[24], buffer[25]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[26], buffer[27]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[28], buffer[29]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[30], buffer[31]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[32], buffer[33]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            guid: u32::from_le_bytes([buffer[34], buffer[35], buffer[36], buffer[37]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[34..38]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[38], buffer[39]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[38..40]);
                dst
            },
            honor: i16::from_le_bytes([buffer[40], buffer[41]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            virtue: i16::from_le_bytes([buffer[42], buffer[43]]),
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            is_pkmode_on: buffer[44] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[44..45]);
                dst
            },
            sex: u8::from_le_bytes([buffer[45]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[45..46]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[46..49].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[46..49]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[49]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[50]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[50..51]);
                dst
            },
            action: u8::from_le_bytes([buffer[51]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[51..52]);
                dst
            },
            act_start_time: u32::from_le_bytes([buffer[52], buffer[53], buffer[54], buffer[55]]),
            act_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[52..56]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[56], buffer[57]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[56..58]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.act_start_time).unwrap();
        self.act_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.shield_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        wtr.append(&mut self.act_start_time_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i16) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 2]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i16) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 2]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_shield(&mut self, value: i16) {
        self.shield = value;
    }
    pub fn set_shield_raw(&mut self, value: [u8; 2]) {
        self.shield_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i16) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 2]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [char; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn set_act_start_time(&mut self, value: u32) {
        self.act_start_time = value;
    }
    pub fn set_act_start_time_raw(&mut self, value: [u8; 4]) {
        self.act_start_time_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new() -> PacketZcNotifyActentry {
        PacketZcNotifyActentry {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7a, 0x0]),
        packet_id_raw: [0x7a, 0x0],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 2],
        accessory: 0,
        accessory_raw: [0; 2],
        shield: 0,
        shield_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 2],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0 as char; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        action: 0,
        action_raw: [0; 1],
        act_start_time: 0,
        act_start_time_raw: [0; 4],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyActentry {
    fn id(&self) -> &str {
       "0x7a00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyMoveentry {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMoveentry {
        PacketZcNotifyMoveentry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i16::from_le_bytes([buffer[12], buffer[13]]),
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: i16::from_le_bytes([buffer[14], buffer[15]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            head: i16::from_le_bytes([buffer[16], buffer[17]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            weapon: i16::from_le_bytes([buffer[18], buffer[19]]),
            weapon_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[20], buffer[21]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
            move_start_time: u32::from_le_bytes([buffer[22], buffer[23], buffer[24], buffer[25]]),
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[22..26]);
                dst
            },
            shield: i16::from_le_bytes([buffer[26], buffer[27]]),
            shield_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[28], buffer[29]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[30], buffer[31]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[32], buffer[33]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[34], buffer[35]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[36], buffer[37]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[36..38]);
                dst
            },
            guid: u32::from_le_bytes([buffer[38], buffer[39], buffer[40], buffer[41]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[38..42]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[42], buffer[43]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            honor: i16::from_le_bytes([buffer[44], buffer[45]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[44..46]);
                dst
            },
            virtue: i16::from_le_bytes([buffer[46], buffer[47]]),
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[46..48]);
                dst
            },
            is_pkmode_on: buffer[48] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[48..49]);
                dst
            },
            sex: u8::from_le_bytes([buffer[49]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            move_data:  {
                let mut dst: [u16; 6] = [0 as u16; 6];
                for (index, byte) in buffer[50..56].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            },
            move_data_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[50..56]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[56]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[56..57]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[57]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[57..58]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[58], buffer[59]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[58..60]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.move_start_time_raw.to_vec());
        wtr.append(&mut self.shield_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.move_data_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i16) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 2]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i16) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 2]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_move_start_time(&mut self, value: u32) {
        self.move_start_time = value;
    }
    pub fn set_move_start_time_raw(&mut self, value: [u8; 4]) {
        self.move_start_time_raw = value;
    }
    pub fn set_shield(&mut self, value: i16) {
        self.shield = value;
    }
    pub fn set_shield_raw(&mut self, value: [u8; 2]) {
        self.shield_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i16) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 2]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_move_data(&mut self, value: [u16; 6]) {
        self.move_data = value;
    }
    pub fn set_move_data_raw(&mut self, value: [u8; 6]) {
        self.move_data_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new() -> PacketZcNotifyMoveentry {
        PacketZcNotifyMoveentry {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7b, 0x0]),
        packet_id_raw: [0x7b, 0x0],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 2],
        accessory: 0,
        accessory_raw: [0; 2],
        move_start_time: 0,
        move_start_time_raw: [0; 4],
        shield: 0,
        shield_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 2],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        move_data: [0; 6],
        move_data_raw: [0; 6],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyMoveentry {
    fn id(&self) -> &str {
       "0x7b00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyStandentryNpc {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyStandentryNpc {
        PacketZcNotifyStandentryNpc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            objecttype: u8::from_le_bytes([buffer[2]]),
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            gid: u32::from_le_bytes([buffer[3], buffer[4], buffer[5], buffer[6]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[3..7]);
                dst
            },
            speed: i16::from_le_bytes([buffer[7], buffer[8]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[7..9]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[9], buffer[10]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[11], buffer[12]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            effect_state: i16::from_le_bytes([buffer[13], buffer[14]]),
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[13..15]);
                dst
            },
            head: i16::from_le_bytes([buffer[15], buffer[16]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[15..17]);
                dst
            },
            weapon: i16::from_le_bytes([buffer[17], buffer[18]]),
            weapon_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[17..19]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[19], buffer[20]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            job: i16::from_le_bytes([buffer[21], buffer[22]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[21..23]);
                dst
            },
            shield: i16::from_le_bytes([buffer[23], buffer[24]]),
            shield_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[23..25]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[25], buffer[26]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[25..27]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[27], buffer[28]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[27..29]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[29], buffer[30]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[29..31]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[31], buffer[32]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[31..33]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[33], buffer[34]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            is_pkmode_on: buffer[35] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[35..36]);
                dst
            },
            sex: u8::from_le_bytes([buffer[36]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[36..37]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[37..40].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[37..40]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[40]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[40..41]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[41]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[41..42]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.objecttype_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.shield_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_objecttype(&mut self, value: u8) {
        self.objecttype = value;
    }
    pub fn set_objecttype_raw(&mut self, value: [u8; 1]) {
        self.objecttype_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i16) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 2]) {
        self.effect_state_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i16) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 2]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_shield(&mut self, value: i16) {
        self.shield = value;
    }
    pub fn set_shield_raw(&mut self, value: [u8; 2]) {
        self.shield_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [char; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn new() -> PacketZcNotifyStandentryNpc {
        PacketZcNotifyStandentryNpc {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7c, 0x0]),
        packet_id_raw: [0x7c, 0x0],
        objecttype: 0,
        objecttype_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 2],
        accessory: 0,
        accessory_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        shield: 0,
        shield_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0 as char; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcNotifyStandentryNpc {
    fn id(&self) -> &str {
       "0x7c00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzNotifyActorinit {
    pub fn from(buffer: &[u8]) -> PacketCzNotifyActorinit {
        PacketCzNotifyActorinit {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzNotifyActorinit {
        PacketCzNotifyActorinit {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7d, 0x0]),
        packet_id_raw: [0x7d, 0x0],
        }
    }
}

impl Packet for PacketCzNotifyActorinit {
    fn id(&self) -> &str {
       "0x7d00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRequestTime {
    pub fn from(buffer: &[u8]) -> PacketCzRequestTime {
        PacketCzRequestTime {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            client_time: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            client_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.client_time).unwrap();
        self.client_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.client_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_client_time(&mut self, value: u32) {
        self.client_time = value;
    }
    pub fn set_client_time_raw(&mut self, value: [u8; 4]) {
        self.client_time_raw = value;
    }
    pub fn new() -> PacketCzRequestTime {
        PacketCzRequestTime {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7e, 0x0]),
        packet_id_raw: [0x7e, 0x0],
        client_time: 0,
        client_time_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzRequestTime {
    fn id(&self) -> &str {
       "0x7e00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyTime {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyTime {
        PacketZcNotifyTime {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            time: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.time).unwrap();
        self.time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_time(&mut self, value: u32) {
        self.time = value;
    }
    pub fn set_time_raw(&mut self, value: [u8; 4]) {
        self.time_raw = value;
    }
    pub fn new() -> PacketZcNotifyTime {
        PacketZcNotifyTime {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7f, 0x0]),
        packet_id_raw: [0x7f, 0x0],
        time: 0,
        time_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyTime {
    fn id(&self) -> &str {
       "0x7f00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyVanish {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyVanish {
        PacketZcNotifyVanish {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketZcNotifyVanish {
        PacketZcNotifyVanish {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x80, 0x0]),
        packet_id_raw: [0x80, 0x0],
        gid: 0,
        gid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcNotifyVanish {
    fn id(&self) -> &str {
       "0x8000"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketScNotifyBan {
    pub fn from(buffer: &[u8]) -> PacketScNotifyBan {
        PacketScNotifyBan {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: u8::from_le_bytes([buffer[2]]),
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u8) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 1]) {
        self.error_code_raw = value;
    }
    pub fn new() -> PacketScNotifyBan {
        PacketScNotifyBan {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x81, 0x0]),
        packet_id_raw: [0x81, 0x0],
        error_code: 0,
        error_code_raw: [0; 1],
        }
    }
}

impl Packet for PacketScNotifyBan {
    fn id(&self) -> &str {
       "0x8100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRequestQuit {
    pub fn from(buffer: &[u8]) -> PacketCzRequestQuit {
        PacketCzRequestQuit {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzRequestQuit {
        PacketCzRequestQuit {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x82, 0x0]),
        packet_id_raw: [0x82, 0x0],
        }
    }
}

impl Packet for PacketCzRequestQuit {
    fn id(&self) -> &str {
       "0x8200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAcceptQuit {
    pub fn from(buffer: &[u8]) -> PacketZcAcceptQuit {
        PacketZcAcceptQuit {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketZcAcceptQuit {
        PacketZcAcceptQuit {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x83, 0x0]),
        packet_id_raw: [0x83, 0x0],
        }
    }
}

impl Packet for PacketZcAcceptQuit {
    fn id(&self) -> &str {
       "0x8300"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcRefuseQuit {
    pub fn from(buffer: &[u8]) -> PacketZcRefuseQuit {
        PacketZcRefuseQuit {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketZcRefuseQuit {
        PacketZcRefuseQuit {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x84, 0x0]),
        packet_id_raw: [0x84, 0x0],
        }
    }
}

impl Packet for PacketZcRefuseQuit {
    fn id(&self) -> &str {
       "0x8400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRequestMove {
    pub fn from(buffer: &[u8]) -> PacketCzRequestMove {
        PacketCzRequestMove {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            dest:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[2..5].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            dest_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[2..5]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.dest {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.dest_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.dest_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_dest(&mut self, value: [char; 3]) {
        self.dest = value;
    }
    pub fn set_dest_raw(&mut self, value: [u8; 3]) {
        self.dest_raw = value;
    }
    pub fn new() -> PacketCzRequestMove {
        PacketCzRequestMove {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x85, 0x0]),
        packet_id_raw: [0x85, 0x0],
        dest: [0 as char; 3],
        dest_raw: [0; 3],
        }
    }
}

impl Packet for PacketCzRequestMove {
    fn id(&self) -> &str {
       "0x8500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyMove {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMove {
        PacketZcNotifyMove {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            move_data:  {
                let mut dst: [u16; 6] = [0 as u16; 6];
                for (index, byte) in buffer[6..12].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            },
            move_data_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[6..12]);
                dst
            },
            move_start_time: u32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.move_data_raw.to_vec());
        wtr.append(&mut self.move_start_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_move_data(&mut self, value: [u16; 6]) {
        self.move_data = value;
    }
    pub fn set_move_data_raw(&mut self, value: [u8; 6]) {
        self.move_data_raw = value;
    }
    pub fn set_move_start_time(&mut self, value: u32) {
        self.move_start_time = value;
    }
    pub fn set_move_start_time_raw(&mut self, value: [u8; 4]) {
        self.move_start_time_raw = value;
    }
    pub fn new() -> PacketZcNotifyMove {
        PacketZcNotifyMove {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x86, 0x0]),
        packet_id_raw: [0x86, 0x0],
        gid: 0,
        gid_raw: [0; 4],
        move_data: [0; 6],
        move_data_raw: [0; 6],
        move_start_time: 0,
        move_start_time_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyMove {
    fn id(&self) -> &str {
       "0x8600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyPlayermove {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyPlayermove {
        PacketZcNotifyPlayermove {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            move_start_time: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            move_data:  {
                let mut dst: [u16; 6] = [0 as u16; 6];
                for (index, byte) in buffer[6..12].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            },
            move_data_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[6..12]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.move_start_time_raw.to_vec());
        wtr.append(&mut self.move_data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_move_start_time(&mut self, value: u32) {
        self.move_start_time = value;
    }
    pub fn set_move_start_time_raw(&mut self, value: [u8; 4]) {
        self.move_start_time_raw = value;
    }
    pub fn set_move_data(&mut self, value: [u16; 6]) {
        self.move_data = value;
    }
    pub fn set_move_data_raw(&mut self, value: [u8; 6]) {
        self.move_data_raw = value;
    }
    pub fn new() -> PacketZcNotifyPlayermove {
        PacketZcNotifyPlayermove {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x87, 0x0]),
        packet_id_raw: [0x87, 0x0],
        move_start_time: 0,
        move_start_time_raw: [0; 4],
        move_data: [0; 6],
        move_data_raw: [0; 6],
        }
    }
}

impl Packet for PacketZcNotifyPlayermove {
    fn id(&self) -> &str {
       "0x8700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcStopmove {
    pub fn from(buffer: &[u8]) -> PacketZcStopmove {
        PacketZcStopmove {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[6], buffer[7]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[8], buffer[9]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn new() -> PacketZcStopmove {
        PacketZcStopmove {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x88, 0x0]),
        packet_id_raw: [0x88, 0x0],
        aid: 0,
        aid_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcStopmove {
    fn id(&self) -> &str {
       "0x8800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRequestAct {
    pub fn from(buffer: &[u8]) -> PacketCzRequestAct {
        PacketCzRequestAct {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            target_gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            target_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            action: u8::from_le_bytes([buffer[6]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_gid).unwrap();
        self.target_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.target_gid_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_target_gid(&mut self, value: u32) {
        self.target_gid = value;
    }
    pub fn set_target_gid_raw(&mut self, value: [u8; 4]) {
        self.target_gid_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn new() -> PacketCzRequestAct {
        PacketCzRequestAct {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x89, 0x0]),
        packet_id_raw: [0x89, 0x0],
        target_gid: 0,
        target_gid_raw: [0; 4],
        action: 0,
        action_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzRequestAct {
    fn id(&self) -> &str {
       "0x8900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyAct {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyAct {
        PacketZcNotifyAct {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            target_gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            start_time: u32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            attack_mt: i32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            attack_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
            attacked_mt: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            attacked_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
            damage: i16::from_le_bytes([buffer[22], buffer[23]]),
            damage_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[22..24]);
                dst
            },
            count: i16::from_le_bytes([buffer[24], buffer[25]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            action: u8::from_le_bytes([buffer[26]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[26..27]);
                dst
            },
            left_damage: i16::from_le_bytes([buffer[27], buffer[28]]),
            left_damage_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[27..29]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_gid).unwrap();
        self.target_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attack_mt).unwrap();
        self.attack_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attacked_mt).unwrap();
        self.attacked_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.damage).unwrap();
        self.damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.left_damage).unwrap();
        self.left_damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.target_gid_raw.to_vec());
        wtr.append(&mut self.start_time_raw.to_vec());
        wtr.append(&mut self.attack_mt_raw.to_vec());
        wtr.append(&mut self.attacked_mt_raw.to_vec());
        wtr.append(&mut self.damage_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        wtr.append(&mut self.left_damage_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_target_gid(&mut self, value: u32) {
        self.target_gid = value;
    }
    pub fn set_target_gid_raw(&mut self, value: [u8; 4]) {
        self.target_gid_raw = value;
    }
    pub fn set_start_time(&mut self, value: u32) {
        self.start_time = value;
    }
    pub fn set_start_time_raw(&mut self, value: [u8; 4]) {
        self.start_time_raw = value;
    }
    pub fn set_attack_mt(&mut self, value: i32) {
        self.attack_mt = value;
    }
    pub fn set_attack_mt_raw(&mut self, value: [u8; 4]) {
        self.attack_mt_raw = value;
    }
    pub fn set_attacked_mt(&mut self, value: i32) {
        self.attacked_mt = value;
    }
    pub fn set_attacked_mt_raw(&mut self, value: [u8; 4]) {
        self.attacked_mt_raw = value;
    }
    pub fn set_damage(&mut self, value: i16) {
        self.damage = value;
    }
    pub fn set_damage_raw(&mut self, value: [u8; 2]) {
        self.damage_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn set_left_damage(&mut self, value: i16) {
        self.left_damage = value;
    }
    pub fn set_left_damage_raw(&mut self, value: [u8; 2]) {
        self.left_damage_raw = value;
    }
    pub fn new() -> PacketZcNotifyAct {
        PacketZcNotifyAct {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x8a, 0x0]),
        packet_id_raw: [0x8a, 0x0],
        gid: 0,
        gid_raw: [0; 4],
        target_gid: 0,
        target_gid_raw: [0; 4],
        start_time: 0,
        start_time_raw: [0; 4],
        attack_mt: 0,
        attack_mt_raw: [0; 4],
        attacked_mt: 0,
        attacked_mt_raw: [0; 4],
        damage: 0,
        damage_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        action: 0,
        action_raw: [0; 1],
        left_damage: 0,
        left_damage_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyAct {
    fn id(&self) -> &str {
       "0x8a00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyActPosition {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyActPosition {
        PacketZcNotifyActPosition {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            target_gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            start_time: u32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[14], buffer[15]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[16], buffer[17]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            damage: i16::from_le_bytes([buffer[18], buffer[19]]),
            damage_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            count: i16::from_le_bytes([buffer[20], buffer[21]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
            action: u8::from_le_bytes([buffer[22]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[22..23]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_gid).unwrap();
        self.target_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.damage).unwrap();
        self.damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.target_gid_raw.to_vec());
        wtr.append(&mut self.start_time_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.damage_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_target_gid(&mut self, value: u32) {
        self.target_gid = value;
    }
    pub fn set_target_gid_raw(&mut self, value: [u8; 4]) {
        self.target_gid_raw = value;
    }
    pub fn set_start_time(&mut self, value: u32) {
        self.start_time = value;
    }
    pub fn set_start_time_raw(&mut self, value: [u8; 4]) {
        self.start_time_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_damage(&mut self, value: i16) {
        self.damage = value;
    }
    pub fn set_damage_raw(&mut self, value: [u8; 2]) {
        self.damage_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn new() -> PacketZcNotifyActPosition {
        PacketZcNotifyActPosition {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x8b, 0x0]),
        packet_id_raw: [0x8b, 0x0],
        gid: 0,
        gid_raw: [0; 4],
        target_gid: 0,
        target_gid_raw: [0; 4],
        start_time: 0,
        start_time_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        damage: 0,
        damage_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        action: 0,
        action_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcNotifyActPosition {
    fn id(&self) -> &str {
       "0x8b00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRequestChat {
    pub fn from(buffer: &[u8]) -> PacketCzRequestChat {
        PacketCzRequestChat {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            msg_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketCzRequestChat {
        PacketCzRequestChat {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x8c, 0x0]),
        packet_id_raw: [0x8c, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketCzRequestChat {
    fn id(&self) -> &str {
       "0x8c00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyChat {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyChat {
        PacketZcNotifyChat {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            gid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[8..buffer.len()]).to_string(),
            msg_raw: buffer[8..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketZcNotifyChat {
        PacketZcNotifyChat {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x8d, 0x0]),
        packet_id_raw: [0x8d, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        gid: 0,
        gid_raw: [0; 4],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcNotifyChat {
    fn id(&self) -> &str {
       "0x8d00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyPlayerchat {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyPlayerchat {
        PacketZcNotifyPlayerchat {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            msg_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketZcNotifyPlayerchat {
        PacketZcNotifyPlayerchat {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x8e, 0x0]),
        packet_id_raw: [0x8e, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcNotifyPlayerchat {
    fn id(&self) -> &str {
       "0x8e00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketServerEntryAck {
    pub fn from(buffer: &[u8]) -> PacketServerEntryAck {
        PacketServerEntryAck {
            raw: buffer.to_vec(),
            header: i16::from_le_bytes([buffer[0], buffer[1]]),
            header_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.header).unwrap();
        self.header_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.header_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_header(&mut self, value: i16) {
        self.header = value;
    }
    pub fn set_header_raw(&mut self, value: [u8; 2]) {
        self.header_raw = value;
    }
    pub fn set_aid(&mut self, value: i32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketServerEntryAck {
        PacketServerEntryAck {
        raw: vec![],
        header: 0,
        header_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketServerEntryAck {
    fn id(&self) -> &str {
       "0x8f00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzContactnpc {
    pub fn from(buffer: &[u8]) -> PacketCzContactnpc {
        PacketCzContactnpc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketCzContactnpc {
        PacketCzContactnpc {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x90, 0x0]),
        packet_id_raw: [0x90, 0x0],
        naid: 0,
        naid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzContactnpc {
    fn id(&self) -> &str {
       "0x9000"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNpcackMapmove {
    pub fn from(buffer: &[u8]) -> PacketZcNpcackMapmove {
        PacketZcNpcackMapmove {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[2..18].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[2..18]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[18], buffer[19]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[20], buffer[21]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn new() -> PacketZcNpcackMapmove {
        PacketZcNpcackMapmove {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x91, 0x0]),
        packet_id_raw: [0x91, 0x0],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNpcackMapmove {
    fn id(&self) -> &str {
       "0x9100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNpcackServermove {
    pub fn from(buffer: &[u8]) -> PacketZcNpcackServermove {
        PacketZcNpcackServermove {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[2..18].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[2..18]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[18], buffer[19]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[20], buffer[21]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
            addr: ZserverAddr::from(&buffer[22..buffer.len()]),
            addr_raw: buffer[22..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        self.addr.fill_raw();
        self.addr_raw = self.addr.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.addr_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_addr(&mut self, value: ZserverAddr) {
        self.addr = value;
    }
    pub fn set_addr_raw(&mut self, value: Vec<u8>) {
        self.addr_raw = value;
    }
    pub fn new() -> PacketZcNpcackServermove {
        PacketZcNpcackServermove {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x92, 0x0]),
        packet_id_raw: [0x92, 0x0],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        addr: ZserverAddr::new(),
        addr_raw: vec![],
        }
    }
}

impl Packet for PacketZcNpcackServermove {
    fn id(&self) -> &str {
       "0x9200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNpcackEnable {
    pub fn from(buffer: &[u8]) -> PacketZcNpcackEnable {
        PacketZcNpcackEnable {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketZcNpcackEnable {
        PacketZcNpcackEnable {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x93, 0x0]),
        packet_id_raw: [0x93, 0x0],
        }
    }
}

impl Packet for PacketZcNpcackEnable {
    fn id(&self) -> &str {
       "0x9300"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqname {
    pub fn from(buffer: &[u8]) -> PacketCzReqname {
        PacketCzReqname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketCzReqname {
        PacketCzReqname {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x94, 0x0]),
        packet_id_raw: [0x94, 0x0],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqname {
    fn id(&self) -> &str {
       "0x9400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckReqname {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqname {
        PacketZcAckReqname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            cname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            cname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.cname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.cname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.cname_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_cname(&mut self, value: [char; 24]) {
        self.cname = value;
    }
    pub fn set_cname_raw(&mut self, value: [u8; 24]) {
        self.cname_raw = value;
    }
    pub fn new() -> PacketZcAckReqname {
        PacketZcAckReqname {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x95, 0x0]),
        packet_id_raw: [0x95, 0x0],
        aid: 0,
        aid_raw: [0; 4],
        cname: [0 as char; 24],
        cname_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcAckReqname {
    fn id(&self) -> &str {
       "0x9500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzWhisper {
    pub fn from(buffer: &[u8]) -> PacketCzWhisper {
        PacketCzWhisper {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            receiver:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            receiver_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[44..buffer.len()]).to_string(),
            msg_raw: buffer[44..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.receiver {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.receiver_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.receiver_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_receiver(&mut self, value: [char; 24]) {
        self.receiver = value;
    }
    pub fn set_receiver_raw(&mut self, value: [u8; 24]) {
        self.receiver_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketCzWhisper {
        PacketCzWhisper {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x96, 0x0]),
        packet_id_raw: [0x96, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        receiver: [0 as char; 24],
        receiver_raw: [0; 24],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketCzWhisper {
    fn id(&self) -> &str {
       "0x9600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcWhisper {
    pub fn from(buffer: &[u8]) -> PacketZcWhisper {
        PacketZcWhisper {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            sender:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            sender_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[44..buffer.len()]).to_string(),
            msg_raw: buffer[44..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sender {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sender_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.sender_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_sender(&mut self, value: [char; 24]) {
        self.sender = value;
    }
    pub fn set_sender_raw(&mut self, value: [u8; 24]) {
        self.sender_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketZcWhisper {
        PacketZcWhisper {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x97, 0x0]),
        packet_id_raw: [0x97, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        sender: [0 as char; 24],
        sender_raw: [0; 24],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcWhisper {
    fn id(&self) -> &str {
       "0x9700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckWhisper {
    pub fn from(buffer: &[u8]) -> PacketZcAckWhisper {
        PacketZcAckWhisper {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcAckWhisper {
        PacketZcAckWhisper {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x98, 0x0]),
        packet_id_raw: [0x98, 0x0],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckWhisper {
    fn id(&self) -> &str {
       "0x9800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzBroadcast {
    pub fn from(buffer: &[u8]) -> PacketCzBroadcast {
        PacketCzBroadcast {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            msg_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketCzBroadcast {
        PacketCzBroadcast {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x99, 0x0]),
        packet_id_raw: [0x99, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketCzBroadcast {
    fn id(&self) -> &str {
       "0x9900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcBroadcast {
    pub fn from(buffer: &[u8]) -> PacketZcBroadcast {
        PacketZcBroadcast {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            msg_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketZcBroadcast {
        PacketZcBroadcast {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x9a, 0x0]),
        packet_id_raw: [0x9a, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcBroadcast {
    fn id(&self) -> &str {
       "0x9a00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzChangeDirection {
    pub fn from(buffer: &[u8]) -> PacketCzChangeDirection {
        PacketCzChangeDirection {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[2], buffer[3]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            dir: u8::from_le_bytes([buffer[4]]),
            dir_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dir).unwrap();
        self.dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.dir_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_dir(&mut self, value: u8) {
        self.dir = value;
    }
    pub fn set_dir_raw(&mut self, value: [u8; 1]) {
        self.dir_raw = value;
    }
    pub fn new() -> PacketCzChangeDirection {
        PacketCzChangeDirection {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x9b, 0x0]),
        packet_id_raw: [0x9b, 0x0],
        head_dir: 0,
        head_dir_raw: [0; 2],
        dir: 0,
        dir_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzChangeDirection {
    fn id(&self) -> &str {
       "0x9b00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcChangeDirection {
    pub fn from(buffer: &[u8]) -> PacketZcChangeDirection {
        PacketZcChangeDirection {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[6], buffer[7]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            dir: u8::from_le_bytes([buffer[8]]),
            dir_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dir).unwrap();
        self.dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.dir_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_dir(&mut self, value: u8) {
        self.dir = value;
    }
    pub fn set_dir_raw(&mut self, value: [u8; 1]) {
        self.dir_raw = value;
    }
    pub fn new() -> PacketZcChangeDirection {
        PacketZcChangeDirection {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x9c, 0x0]),
        packet_id_raw: [0x9c, 0x0],
        aid: 0,
        aid_raw: [0; 4],
        head_dir: 0,
        head_dir_raw: [0; 2],
        dir: 0,
        dir_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcChangeDirection {
    fn id(&self) -> &str {
       "0x9c00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcItemEntry {
    pub fn from(buffer: &[u8]) -> PacketZcItemEntry {
        PacketZcItemEntry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itaid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            itaid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            itid: u16::from_le_bytes([buffer[6], buffer[7]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            is_identified: buffer[8] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[9], buffer[10]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[11], buffer[12]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            count: i16::from_le_bytes([buffer[13], buffer[14]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[13..15]);
                dst
            },
            sub_x: u8::from_le_bytes([buffer[15]]),
            sub_x_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[15..16]);
                dst
            },
            sub_y: u8::from_le_bytes([buffer[16]]),
            sub_y_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[16..17]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.itaid).unwrap();
        self.itaid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sub_x).unwrap();
        self.sub_x_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sub_y).unwrap();
        self.sub_y_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itaid_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.sub_x_raw.to_vec());
        wtr.append(&mut self.sub_y_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itaid(&mut self, value: u32) {
        self.itaid = value;
    }
    pub fn set_itaid_raw(&mut self, value: [u8; 4]) {
        self.itaid_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_sub_x(&mut self, value: u8) {
        self.sub_x = value;
    }
    pub fn set_sub_x_raw(&mut self, value: [u8; 1]) {
        self.sub_x_raw = value;
    }
    pub fn set_sub_y(&mut self, value: u8) {
        self.sub_y = value;
    }
    pub fn set_sub_y_raw(&mut self, value: [u8; 1]) {
        self.sub_y_raw = value;
    }
    pub fn new() -> PacketZcItemEntry {
        PacketZcItemEntry {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x9d, 0x0]),
        packet_id_raw: [0x9d, 0x0],
        itaid: 0,
        itaid_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        sub_x: 0,
        sub_x_raw: [0; 1],
        sub_y: 0,
        sub_y_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcItemEntry {
    fn id(&self) -> &str {
       "0x9d00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcItemFallEntry {
    pub fn from(buffer: &[u8]) -> PacketZcItemFallEntry {
        PacketZcItemFallEntry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itaid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            itaid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            itid: u16::from_le_bytes([buffer[6], buffer[7]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            is_identified: buffer[8] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[9], buffer[10]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[11], buffer[12]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            sub_x: u8::from_le_bytes([buffer[13]]),
            sub_x_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[13..14]);
                dst
            },
            sub_y: u8::from_le_bytes([buffer[14]]),
            sub_y_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
            count: i16::from_le_bytes([buffer[15], buffer[16]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[15..17]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.itaid).unwrap();
        self.itaid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sub_x).unwrap();
        self.sub_x_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sub_y).unwrap();
        self.sub_y_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itaid_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.sub_x_raw.to_vec());
        wtr.append(&mut self.sub_y_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itaid(&mut self, value: u32) {
        self.itaid = value;
    }
    pub fn set_itaid_raw(&mut self, value: [u8; 4]) {
        self.itaid_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_sub_x(&mut self, value: u8) {
        self.sub_x = value;
    }
    pub fn set_sub_x_raw(&mut self, value: [u8; 1]) {
        self.sub_x_raw = value;
    }
    pub fn set_sub_y(&mut self, value: u8) {
        self.sub_y = value;
    }
    pub fn set_sub_y_raw(&mut self, value: [u8; 1]) {
        self.sub_y_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketZcItemFallEntry {
        PacketZcItemFallEntry {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x9e, 0x0]),
        packet_id_raw: [0x9e, 0x0],
        itaid: 0,
        itaid_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        sub_x: 0,
        sub_x_raw: [0; 1],
        sub_y: 0,
        sub_y_raw: [0; 1],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcItemFallEntry {
    fn id(&self) -> &str {
       "0x9e00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzItemPickup {
    pub fn from(buffer: &[u8]) -> PacketCzItemPickup {
        PacketCzItemPickup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itaid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            itaid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.itaid).unwrap();
        self.itaid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itaid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itaid(&mut self, value: u32) {
        self.itaid = value;
    }
    pub fn set_itaid_raw(&mut self, value: [u8; 4]) {
        self.itaid_raw = value;
    }
    pub fn new() -> PacketCzItemPickup {
        PacketCzItemPickup {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x9f, 0x0]),
        packet_id_raw: [0x9f, 0x0],
        itaid: 0,
        itaid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzItemPickup {
    fn id(&self) -> &str {
       "0x9f00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcItemPickupAck {
    pub fn from(buffer: &[u8]) -> PacketZcItemPickupAck {
        PacketZcItemPickupAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: u16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            itid: u16::from_le_bytes([buffer[6], buffer[7]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            is_identified: buffer[8] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            is_damaged: buffer[9] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[10]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[11..19]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[11..19]);
                dst
            },
            location: u16::from_le_bytes([buffer[19], buffer[20]]),
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            atype: u8::from_le_bytes([buffer[21]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[21..22]);
                dst
            },
            result: u8::from_le_bytes([buffer[22]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[22..23]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        wtr.append(&mut self.location_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: u16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn set_location(&mut self, value: u16) {
        self.location = value;
    }
    pub fn set_location_raw(&mut self, value: [u8; 2]) {
        self.location_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcItemPickupAck {
        PacketZcItemPickupAck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xa0, 0x0]),
        packet_id_raw: [0xa0, 0x0],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        location: 0,
        location_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcItemPickupAck {
    fn id(&self) -> &str {
       "0xa000"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcItemDisappear {
    pub fn from(buffer: &[u8]) -> PacketZcItemDisappear {
        PacketZcItemDisappear {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itaid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            itaid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.itaid).unwrap();
        self.itaid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itaid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itaid(&mut self, value: u32) {
        self.itaid = value;
    }
    pub fn set_itaid_raw(&mut self, value: [u8; 4]) {
        self.itaid_raw = value;
    }
    pub fn new() -> PacketZcItemDisappear {
        PacketZcItemDisappear {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xa1, 0x0]),
        packet_id_raw: [0xa1, 0x0],
        itaid: 0,
        itaid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcItemDisappear {
    fn id(&self) -> &str {
       "0xa100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzItemThrow {
    pub fn from(buffer: &[u8]) -> PacketCzItemThrow {
        PacketCzItemThrow {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketCzItemThrow {
        PacketCzItemThrow {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xa2, 0x0]),
        packet_id_raw: [0xa2, 0x0],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzItemThrow {
    fn id(&self) -> &str {
       "0xa200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNormalItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcNormalItemlist {
        let iter_count = (&buffer.len() - 4) / 10;
        let mut vec_field: Vec<NormalitemExtrainfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (10 * (i - 1));
            let end_pos = 4 + 10 * i;
            vec_field.push(NormalitemExtrainfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcNormalItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<NormalitemExtrainfo>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new() -> PacketZcNormalItemlist {
        PacketZcNormalItemlist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xa3, 0x0]),
        packet_id_raw: [0xa3, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcNormalItemlist {
    fn id(&self) -> &str {
       "0xa300"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcEquipmentItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcEquipmentItemlist {
        let iter_count = (&buffer.len() - 4) / 20;
        let mut vec_field: Vec<EquipmentitemExtrainfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (20 * (i - 1));
            let end_pos = 4 + 20 * i;
            vec_field.push(EquipmentitemExtrainfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcEquipmentItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new() -> PacketZcEquipmentItemlist {
        PacketZcEquipmentItemlist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xa4, 0x0]),
        packet_id_raw: [0xa4, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcEquipmentItemlist {
    fn id(&self) -> &str {
       "0xa400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcStoreNormalItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcStoreNormalItemlist {
        let iter_count = (&buffer.len() - 4) / 10;
        let mut vec_field: Vec<NormalitemExtrainfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (10 * (i - 1));
            let end_pos = 4 + 10 * i;
            vec_field.push(NormalitemExtrainfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcStoreNormalItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<NormalitemExtrainfo>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new() -> PacketZcStoreNormalItemlist {
        PacketZcStoreNormalItemlist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xa5, 0x0]),
        packet_id_raw: [0xa5, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcStoreNormalItemlist {
    fn id(&self) -> &str {
       "0xa500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcStoreEquipmentItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcStoreEquipmentItemlist {
        let iter_count = (&buffer.len() - 4) / 20;
        let mut vec_field: Vec<EquipmentitemExtrainfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (20 * (i - 1));
            let end_pos = 4 + 20 * i;
            vec_field.push(EquipmentitemExtrainfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcStoreEquipmentItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new() -> PacketZcStoreEquipmentItemlist {
        PacketZcStoreEquipmentItemlist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xa6, 0x0]),
        packet_id_raw: [0xa6, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcStoreEquipmentItemlist {
    fn id(&self) -> &str {
       "0xa600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzUseItem {
    pub fn from(buffer: &[u8]) -> PacketCzUseItem {
        PacketCzUseItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketCzUseItem {
        PacketCzUseItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xa7, 0x0]),
        packet_id_raw: [0xa7, 0x0],
        index: 0,
        index_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzUseItem {
    fn id(&self) -> &str {
       "0xa700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcUseItemAck {
    pub fn from(buffer: &[u8]) -> PacketZcUseItemAck {
        PacketZcUseItemAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            result: buffer[6] == 1,
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_result(&mut self, value: bool) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcUseItemAck {
        PacketZcUseItemAck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xa8, 0x0]),
        packet_id_raw: [0xa8, 0x0],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        result: false,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcUseItemAck {
    fn id(&self) -> &str {
       "0xa800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqWearEquip {
    pub fn from(buffer: &[u8]) -> PacketCzReqWearEquip {
        PacketCzReqWearEquip {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            wear_location: u16::from_le_bytes([buffer[4], buffer[5]]),
            wear_location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_location).unwrap();
        self.wear_location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.wear_location_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_wear_location(&mut self, value: u16) {
        self.wear_location = value;
    }
    pub fn set_wear_location_raw(&mut self, value: [u8; 2]) {
        self.wear_location_raw = value;
    }
    pub fn new() -> PacketCzReqWearEquip {
        PacketCzReqWearEquip {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xa9, 0x0]),
        packet_id_raw: [0xa9, 0x0],
        index: 0,
        index_raw: [0; 2],
        wear_location: 0,
        wear_location_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqWearEquip {
    fn id(&self) -> &str {
       "0xa900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcReqWearEquipAck {
    pub fn from(buffer: &[u8]) -> PacketZcReqWearEquipAck {
        PacketZcReqWearEquipAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            wear_location: u16::from_le_bytes([buffer[4], buffer[5]]),
            wear_location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            result: u8::from_le_bytes([buffer[6]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_location).unwrap();
        self.wear_location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.wear_location_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_wear_location(&mut self, value: u16) {
        self.wear_location = value;
    }
    pub fn set_wear_location_raw(&mut self, value: [u8; 2]) {
        self.wear_location_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcReqWearEquipAck {
        PacketZcReqWearEquipAck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xaa, 0x0]),
        packet_id_raw: [0xaa, 0x0],
        index: 0,
        index_raw: [0; 2],
        wear_location: 0,
        wear_location_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcReqWearEquipAck {
    fn id(&self) -> &str {
       "0xaa00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqTakeoffEquip {
    pub fn from(buffer: &[u8]) -> PacketCzReqTakeoffEquip {
        PacketCzReqTakeoffEquip {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn new() -> PacketCzReqTakeoffEquip {
        PacketCzReqTakeoffEquip {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xab, 0x0]),
        packet_id_raw: [0xab, 0x0],
        index: 0,
        index_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqTakeoffEquip {
    fn id(&self) -> &str {
       "0xab00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcReqTakeoffEquipAck {
    pub fn from(buffer: &[u8]) -> PacketZcReqTakeoffEquipAck {
        PacketZcReqTakeoffEquipAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            wear_location: u16::from_le_bytes([buffer[4], buffer[5]]),
            wear_location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            result: buffer[6] == 1,
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_location).unwrap();
        self.wear_location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.wear_location_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_wear_location(&mut self, value: u16) {
        self.wear_location = value;
    }
    pub fn set_wear_location_raw(&mut self, value: [u8; 2]) {
        self.wear_location_raw = value;
    }
    pub fn set_result(&mut self, value: bool) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcReqTakeoffEquipAck {
        PacketZcReqTakeoffEquipAck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xac, 0x0]),
        packet_id_raw: [0xac, 0x0],
        index: 0,
        index_raw: [0; 2],
        wear_location: 0,
        wear_location_raw: [0; 2],
        result: false,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcReqTakeoffEquipAck {
    fn id(&self) -> &str {
       "0xac00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcItemThrowAck {
    pub fn from(buffer: &[u8]) -> PacketZcItemThrowAck {
        PacketZcItemThrowAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketZcItemThrowAck {
        PacketZcItemThrowAck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xaf, 0x0]),
        packet_id_raw: [0xaf, 0x0],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcItemThrowAck {
    fn id(&self) -> &str {
       "0xaf00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcParChange {
    pub fn from(buffer: &[u8]) -> PacketZcParChange {
        PacketZcParChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            var_id: u16::from_le_bytes([buffer[2], buffer[3]]),
            var_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var_id).unwrap();
        self.var_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.var_id_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_var_id(&mut self, value: u16) {
        self.var_id = value;
    }
    pub fn set_var_id_raw(&mut self, value: [u8; 2]) {
        self.var_id_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketZcParChange {
        PacketZcParChange {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xb0, 0x0]),
        packet_id_raw: [0xb0, 0x0],
        var_id: 0,
        var_id_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcParChange {
    fn id(&self) -> &str {
       "0xb000"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcLongparChange {
    pub fn from(buffer: &[u8]) -> PacketZcLongparChange {
        PacketZcLongparChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            var_id: u16::from_le_bytes([buffer[2], buffer[3]]),
            var_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            amount: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            amount_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var_id).unwrap();
        self.var_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.amount).unwrap();
        self.amount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.var_id_raw.to_vec());
        wtr.append(&mut self.amount_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_var_id(&mut self, value: u16) {
        self.var_id = value;
    }
    pub fn set_var_id_raw(&mut self, value: [u8; 2]) {
        self.var_id_raw = value;
    }
    pub fn set_amount(&mut self, value: i32) {
        self.amount = value;
    }
    pub fn set_amount_raw(&mut self, value: [u8; 4]) {
        self.amount_raw = value;
    }
    pub fn new() -> PacketZcLongparChange {
        PacketZcLongparChange {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xb1, 0x0]),
        packet_id_raw: [0xb1, 0x0],
        var_id: 0,
        var_id_raw: [0; 2],
        amount: 0,
        amount_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcLongparChange {
    fn id(&self) -> &str {
       "0xb100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRestart {
    pub fn from(buffer: &[u8]) -> PacketCzRestart {
        PacketCzRestart {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: u8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketCzRestart {
        PacketCzRestart {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xb2, 0x0]),
        packet_id_raw: [0xb2, 0x0],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzRestart {
    fn id(&self) -> &str {
       "0xb200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcRestartAck {
    pub fn from(buffer: &[u8]) -> PacketZcRestartAck {
        PacketZcRestartAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: u8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketZcRestartAck {
        PacketZcRestartAck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xb3, 0x0]),
        packet_id_raw: [0xb3, 0x0],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcRestartAck {
    fn id(&self) -> &str {
       "0xb300"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSayDialog {
    pub fn from(buffer: &[u8]) -> PacketZcSayDialog {
        PacketZcSayDialog {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            naid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[8..buffer.len()]).to_string(),
            msg_raw: buffer[8..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketZcSayDialog {
        PacketZcSayDialog {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xb4, 0x0]),
        packet_id_raw: [0xb4, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        naid: 0,
        naid_raw: [0; 4],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcSayDialog {
    fn id(&self) -> &str {
       "0xb400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcWaitDialog {
    pub fn from(buffer: &[u8]) -> PacketZcWaitDialog {
        PacketZcWaitDialog {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn new() -> PacketZcWaitDialog {
        PacketZcWaitDialog {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xb5, 0x0]),
        packet_id_raw: [0xb5, 0x0],
        naid: 0,
        naid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcWaitDialog {
    fn id(&self) -> &str {
       "0xb500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcCloseDialog {
    pub fn from(buffer: &[u8]) -> PacketZcCloseDialog {
        PacketZcCloseDialog {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn new() -> PacketZcCloseDialog {
        PacketZcCloseDialog {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xb6, 0x0]),
        packet_id_raw: [0xb6, 0x0],
        naid: 0,
        naid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcCloseDialog {
    fn id(&self) -> &str {
       "0xb600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMenuList {
    pub fn from(buffer: &[u8]) -> PacketZcMenuList {
        PacketZcMenuList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            naid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[8..buffer.len()]).to_string(),
            msg_raw: buffer[8..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketZcMenuList {
        PacketZcMenuList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xb7, 0x0]),
        packet_id_raw: [0xb7, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        naid: 0,
        naid_raw: [0; 4],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcMenuList {
    fn id(&self) -> &str {
       "0xb700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzChooseMenu {
    pub fn from(buffer: &[u8]) -> PacketCzChooseMenu {
        PacketCzChooseMenu {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            num: u8::from_le_bytes([buffer[6]]),
            num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.num).unwrap();
        self.num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        wtr.append(&mut self.num_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn set_num(&mut self, value: u8) {
        self.num = value;
    }
    pub fn set_num_raw(&mut self, value: [u8; 1]) {
        self.num_raw = value;
    }
    pub fn new() -> PacketCzChooseMenu {
        PacketCzChooseMenu {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xb8, 0x0]),
        packet_id_raw: [0xb8, 0x0],
        naid: 0,
        naid_raw: [0; 4],
        num: 0,
        num_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzChooseMenu {
    fn id(&self) -> &str {
       "0xb800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqNextScript {
    pub fn from(buffer: &[u8]) -> PacketCzReqNextScript {
        PacketCzReqNextScript {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn new() -> PacketCzReqNextScript {
        PacketCzReqNextScript {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xb9, 0x0]),
        packet_id_raw: [0xb9, 0x0],
        naid: 0,
        naid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqNextScript {
    fn id(&self) -> &str {
       "0xb900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqStatus {
    pub fn from(buffer: &[u8]) -> PacketCzReqStatus {
        PacketCzReqStatus {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzReqStatus {
        PacketCzReqStatus {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xba, 0x0]),
        packet_id_raw: [0xba, 0x0],
        }
    }
}

impl Packet for PacketCzReqStatus {
    fn id(&self) -> &str {
       "0xba00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzStatusChange {
    pub fn from(buffer: &[u8]) -> PacketCzStatusChange {
        PacketCzStatusChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            status_id: u16::from_le_bytes([buffer[2], buffer[3]]),
            status_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            change_amount: u8::from_le_bytes([buffer[4]]),
            change_amount_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.status_id).unwrap();
        self.status_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.change_amount).unwrap();
        self.change_amount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.status_id_raw.to_vec());
        wtr.append(&mut self.change_amount_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_status_id(&mut self, value: u16) {
        self.status_id = value;
    }
    pub fn set_status_id_raw(&mut self, value: [u8; 2]) {
        self.status_id_raw = value;
    }
    pub fn set_change_amount(&mut self, value: u8) {
        self.change_amount = value;
    }
    pub fn set_change_amount_raw(&mut self, value: [u8; 1]) {
        self.change_amount_raw = value;
    }
    pub fn new() -> PacketCzStatusChange {
        PacketCzStatusChange {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xbb, 0x0]),
        packet_id_raw: [0xbb, 0x0],
        status_id: 0,
        status_id_raw: [0; 2],
        change_amount: 0,
        change_amount_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzStatusChange {
    fn id(&self) -> &str {
       "0xbb00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcStatusChangeAck {
    pub fn from(buffer: &[u8]) -> PacketZcStatusChangeAck {
        PacketZcStatusChangeAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            status_id: u16::from_le_bytes([buffer[2], buffer[3]]),
            status_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            result: buffer[4] == 1,
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            value: u8::from_le_bytes([buffer[5]]),
            value_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.status_id).unwrap();
        self.status_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.status_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_status_id(&mut self, value: u16) {
        self.status_id = value;
    }
    pub fn set_status_id_raw(&mut self, value: [u8; 2]) {
        self.status_id_raw = value;
    }
    pub fn set_result(&mut self, value: bool) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn set_value(&mut self, value: u8) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 1]) {
        self.value_raw = value;
    }
    pub fn new() -> PacketZcStatusChangeAck {
        PacketZcStatusChangeAck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xbc, 0x0]),
        packet_id_raw: [0xbc, 0x0],
        status_id: 0,
        status_id_raw: [0; 2],
        result: false,
        result_raw: [0; 1],
        value: 0,
        value_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcStatusChangeAck {
    fn id(&self) -> &str {
       "0xbc00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcStatus {
    pub fn from(buffer: &[u8]) -> PacketZcStatus {
        PacketZcStatus {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            point: i16::from_le_bytes([buffer[2], buffer[3]]),
            point_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            str: u8::from_le_bytes([buffer[4]]),
            str_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            standard_str: u8::from_le_bytes([buffer[5]]),
            standard_str_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            agi: u8::from_le_bytes([buffer[6]]),
            agi_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            standard_agi: u8::from_le_bytes([buffer[7]]),
            standard_agi_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[7..8]);
                dst
            },
            vit: u8::from_le_bytes([buffer[8]]),
            vit_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            standard_vit: u8::from_le_bytes([buffer[9]]),
            standard_vit_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            int: u8::from_le_bytes([buffer[10]]),
            int_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            standard_int: u8::from_le_bytes([buffer[11]]),
            standard_int_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            dex: u8::from_le_bytes([buffer[12]]),
            dex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
            standard_dex: u8::from_le_bytes([buffer[13]]),
            standard_dex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[13..14]);
                dst
            },
            luk: u8::from_le_bytes([buffer[14]]),
            luk_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
            standard_luk: u8::from_le_bytes([buffer[15]]),
            standard_luk_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[15..16]);
                dst
            },
            att_power: i16::from_le_bytes([buffer[16], buffer[17]]),
            att_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            refining_power: i16::from_le_bytes([buffer[18], buffer[19]]),
            refining_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            max_matt_power: i16::from_le_bytes([buffer[20], buffer[21]]),
            max_matt_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
            min_matt_power: i16::from_le_bytes([buffer[22], buffer[23]]),
            min_matt_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[22..24]);
                dst
            },
            itemdef_power: i16::from_le_bytes([buffer[24], buffer[25]]),
            itemdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            plusdef_power: i16::from_le_bytes([buffer[26], buffer[27]]),
            plusdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            mdef_power: i16::from_le_bytes([buffer[28], buffer[29]]),
            mdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            plusmdef_power: i16::from_le_bytes([buffer[30], buffer[31]]),
            plusmdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            hit_success_value: i16::from_le_bytes([buffer[32], buffer[33]]),
            hit_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            avoid_success_value: i16::from_le_bytes([buffer[34], buffer[35]]),
            avoid_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            plus_avoid_success_value: i16::from_le_bytes([buffer[36], buffer[37]]),
            plus_avoid_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[36..38]);
                dst
            },
            critical_success_value: i16::from_le_bytes([buffer[38], buffer[39]]),
            critical_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[38..40]);
                dst
            },
            aspd: i16::from_le_bytes([buffer[40], buffer[41]]),
            aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            plus_aspd: i16::from_le_bytes([buffer[42], buffer[43]]),
            plus_aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.str).unwrap();
        self.str_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_str).unwrap();
        self.standard_str_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.agi).unwrap();
        self.agi_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_agi).unwrap();
        self.standard_agi_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.vit).unwrap();
        self.vit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_vit).unwrap();
        self.standard_vit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.int).unwrap();
        self.int_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_int).unwrap();
        self.standard_int_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dex).unwrap();
        self.dex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_dex).unwrap();
        self.standard_dex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.luk).unwrap();
        self.luk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_luk).unwrap();
        self.standard_luk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.att_power).unwrap();
        self.att_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.refining_power).unwrap();
        self.refining_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_matt_power).unwrap();
        self.max_matt_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.min_matt_power).unwrap();
        self.min_matt_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.itemdef_power).unwrap();
        self.itemdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plusdef_power).unwrap();
        self.plusdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef_power).unwrap();
        self.mdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plusmdef_power).unwrap();
        self.plusmdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hit_success_value).unwrap();
        self.hit_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.avoid_success_value).unwrap();
        self.avoid_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plus_avoid_success_value).unwrap();
        self.plus_avoid_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.critical_success_value).unwrap();
        self.critical_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.aspd).unwrap();
        self.aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plus_aspd).unwrap();
        self.plus_aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        wtr.append(&mut self.str_raw.to_vec());
        wtr.append(&mut self.standard_str_raw.to_vec());
        wtr.append(&mut self.agi_raw.to_vec());
        wtr.append(&mut self.standard_agi_raw.to_vec());
        wtr.append(&mut self.vit_raw.to_vec());
        wtr.append(&mut self.standard_vit_raw.to_vec());
        wtr.append(&mut self.int_raw.to_vec());
        wtr.append(&mut self.standard_int_raw.to_vec());
        wtr.append(&mut self.dex_raw.to_vec());
        wtr.append(&mut self.standard_dex_raw.to_vec());
        wtr.append(&mut self.luk_raw.to_vec());
        wtr.append(&mut self.standard_luk_raw.to_vec());
        wtr.append(&mut self.att_power_raw.to_vec());
        wtr.append(&mut self.refining_power_raw.to_vec());
        wtr.append(&mut self.max_matt_power_raw.to_vec());
        wtr.append(&mut self.min_matt_power_raw.to_vec());
        wtr.append(&mut self.itemdef_power_raw.to_vec());
        wtr.append(&mut self.plusdef_power_raw.to_vec());
        wtr.append(&mut self.mdef_power_raw.to_vec());
        wtr.append(&mut self.plusmdef_power_raw.to_vec());
        wtr.append(&mut self.hit_success_value_raw.to_vec());
        wtr.append(&mut self.avoid_success_value_raw.to_vec());
        wtr.append(&mut self.plus_avoid_success_value_raw.to_vec());
        wtr.append(&mut self.critical_success_value_raw.to_vec());
        wtr.append(&mut self.aspd_raw.to_vec());
        wtr.append(&mut self.plus_aspd_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_point(&mut self, value: i16) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 2]) {
        self.point_raw = value;
    }
    pub fn set_str(&mut self, value: u8) {
        self.str = value;
    }
    pub fn set_str_raw(&mut self, value: [u8; 1]) {
        self.str_raw = value;
    }
    pub fn set_standard_str(&mut self, value: u8) {
        self.standard_str = value;
    }
    pub fn set_standard_str_raw(&mut self, value: [u8; 1]) {
        self.standard_str_raw = value;
    }
    pub fn set_agi(&mut self, value: u8) {
        self.agi = value;
    }
    pub fn set_agi_raw(&mut self, value: [u8; 1]) {
        self.agi_raw = value;
    }
    pub fn set_standard_agi(&mut self, value: u8) {
        self.standard_agi = value;
    }
    pub fn set_standard_agi_raw(&mut self, value: [u8; 1]) {
        self.standard_agi_raw = value;
    }
    pub fn set_vit(&mut self, value: u8) {
        self.vit = value;
    }
    pub fn set_vit_raw(&mut self, value: [u8; 1]) {
        self.vit_raw = value;
    }
    pub fn set_standard_vit(&mut self, value: u8) {
        self.standard_vit = value;
    }
    pub fn set_standard_vit_raw(&mut self, value: [u8; 1]) {
        self.standard_vit_raw = value;
    }
    pub fn set_int(&mut self, value: u8) {
        self.int = value;
    }
    pub fn set_int_raw(&mut self, value: [u8; 1]) {
        self.int_raw = value;
    }
    pub fn set_standard_int(&mut self, value: u8) {
        self.standard_int = value;
    }
    pub fn set_standard_int_raw(&mut self, value: [u8; 1]) {
        self.standard_int_raw = value;
    }
    pub fn set_dex(&mut self, value: u8) {
        self.dex = value;
    }
    pub fn set_dex_raw(&mut self, value: [u8; 1]) {
        self.dex_raw = value;
    }
    pub fn set_standard_dex(&mut self, value: u8) {
        self.standard_dex = value;
    }
    pub fn set_standard_dex_raw(&mut self, value: [u8; 1]) {
        self.standard_dex_raw = value;
    }
    pub fn set_luk(&mut self, value: u8) {
        self.luk = value;
    }
    pub fn set_luk_raw(&mut self, value: [u8; 1]) {
        self.luk_raw = value;
    }
    pub fn set_standard_luk(&mut self, value: u8) {
        self.standard_luk = value;
    }
    pub fn set_standard_luk_raw(&mut self, value: [u8; 1]) {
        self.standard_luk_raw = value;
    }
    pub fn set_att_power(&mut self, value: i16) {
        self.att_power = value;
    }
    pub fn set_att_power_raw(&mut self, value: [u8; 2]) {
        self.att_power_raw = value;
    }
    pub fn set_refining_power(&mut self, value: i16) {
        self.refining_power = value;
    }
    pub fn set_refining_power_raw(&mut self, value: [u8; 2]) {
        self.refining_power_raw = value;
    }
    pub fn set_max_matt_power(&mut self, value: i16) {
        self.max_matt_power = value;
    }
    pub fn set_max_matt_power_raw(&mut self, value: [u8; 2]) {
        self.max_matt_power_raw = value;
    }
    pub fn set_min_matt_power(&mut self, value: i16) {
        self.min_matt_power = value;
    }
    pub fn set_min_matt_power_raw(&mut self, value: [u8; 2]) {
        self.min_matt_power_raw = value;
    }
    pub fn set_itemdef_power(&mut self, value: i16) {
        self.itemdef_power = value;
    }
    pub fn set_itemdef_power_raw(&mut self, value: [u8; 2]) {
        self.itemdef_power_raw = value;
    }
    pub fn set_plusdef_power(&mut self, value: i16) {
        self.plusdef_power = value;
    }
    pub fn set_plusdef_power_raw(&mut self, value: [u8; 2]) {
        self.plusdef_power_raw = value;
    }
    pub fn set_mdef_power(&mut self, value: i16) {
        self.mdef_power = value;
    }
    pub fn set_mdef_power_raw(&mut self, value: [u8; 2]) {
        self.mdef_power_raw = value;
    }
    pub fn set_plusmdef_power(&mut self, value: i16) {
        self.plusmdef_power = value;
    }
    pub fn set_plusmdef_power_raw(&mut self, value: [u8; 2]) {
        self.plusmdef_power_raw = value;
    }
    pub fn set_hit_success_value(&mut self, value: i16) {
        self.hit_success_value = value;
    }
    pub fn set_hit_success_value_raw(&mut self, value: [u8; 2]) {
        self.hit_success_value_raw = value;
    }
    pub fn set_avoid_success_value(&mut self, value: i16) {
        self.avoid_success_value = value;
    }
    pub fn set_avoid_success_value_raw(&mut self, value: [u8; 2]) {
        self.avoid_success_value_raw = value;
    }
    pub fn set_plus_avoid_success_value(&mut self, value: i16) {
        self.plus_avoid_success_value = value;
    }
    pub fn set_plus_avoid_success_value_raw(&mut self, value: [u8; 2]) {
        self.plus_avoid_success_value_raw = value;
    }
    pub fn set_critical_success_value(&mut self, value: i16) {
        self.critical_success_value = value;
    }
    pub fn set_critical_success_value_raw(&mut self, value: [u8; 2]) {
        self.critical_success_value_raw = value;
    }
    pub fn set_aspd(&mut self, value: i16) {
        self.aspd = value;
    }
    pub fn set_aspd_raw(&mut self, value: [u8; 2]) {
        self.aspd_raw = value;
    }
    pub fn set_plus_aspd(&mut self, value: i16) {
        self.plus_aspd = value;
    }
    pub fn set_plus_aspd_raw(&mut self, value: [u8; 2]) {
        self.plus_aspd_raw = value;
    }
    pub fn new() -> PacketZcStatus {
        PacketZcStatus {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xbd, 0x0]),
        packet_id_raw: [0xbd, 0x0],
        point: 0,
        point_raw: [0; 2],
        str: 0,
        str_raw: [0; 1],
        standard_str: 0,
        standard_str_raw: [0; 1],
        agi: 0,
        agi_raw: [0; 1],
        standard_agi: 0,
        standard_agi_raw: [0; 1],
        vit: 0,
        vit_raw: [0; 1],
        standard_vit: 0,
        standard_vit_raw: [0; 1],
        int: 0,
        int_raw: [0; 1],
        standard_int: 0,
        standard_int_raw: [0; 1],
        dex: 0,
        dex_raw: [0; 1],
        standard_dex: 0,
        standard_dex_raw: [0; 1],
        luk: 0,
        luk_raw: [0; 1],
        standard_luk: 0,
        standard_luk_raw: [0; 1],
        att_power: 0,
        att_power_raw: [0; 2],
        refining_power: 0,
        refining_power_raw: [0; 2],
        max_matt_power: 0,
        max_matt_power_raw: [0; 2],
        min_matt_power: 0,
        min_matt_power_raw: [0; 2],
        itemdef_power: 0,
        itemdef_power_raw: [0; 2],
        plusdef_power: 0,
        plusdef_power_raw: [0; 2],
        mdef_power: 0,
        mdef_power_raw: [0; 2],
        plusmdef_power: 0,
        plusmdef_power_raw: [0; 2],
        hit_success_value: 0,
        hit_success_value_raw: [0; 2],
        avoid_success_value: 0,
        avoid_success_value_raw: [0; 2],
        plus_avoid_success_value: 0,
        plus_avoid_success_value_raw: [0; 2],
        critical_success_value: 0,
        critical_success_value_raw: [0; 2],
        aspd: 0,
        aspd_raw: [0; 2],
        plus_aspd: 0,
        plus_aspd_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcStatus {
    fn id(&self) -> &str {
       "0xbd00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcStatusChange {
    pub fn from(buffer: &[u8]) -> PacketZcStatusChange {
        PacketZcStatusChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            status_id: u16::from_le_bytes([buffer[2], buffer[3]]),
            status_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            value: u8::from_le_bytes([buffer[4]]),
            value_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.status_id).unwrap();
        self.status_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.status_id_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_status_id(&mut self, value: u16) {
        self.status_id = value;
    }
    pub fn set_status_id_raw(&mut self, value: [u8; 2]) {
        self.status_id_raw = value;
    }
    pub fn set_value(&mut self, value: u8) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 1]) {
        self.value_raw = value;
    }
    pub fn new() -> PacketZcStatusChange {
        PacketZcStatusChange {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xbe, 0x0]),
        packet_id_raw: [0xbe, 0x0],
        status_id: 0,
        status_id_raw: [0; 2],
        value: 0,
        value_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcStatusChange {
    fn id(&self) -> &str {
       "0xbe00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqEmotion {
    pub fn from(buffer: &[u8]) -> PacketCzReqEmotion {
        PacketCzReqEmotion {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: u8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketCzReqEmotion {
        PacketCzReqEmotion {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xbf, 0x0]),
        packet_id_raw: [0xbf, 0x0],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzReqEmotion {
    fn id(&self) -> &str {
       "0xbf00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcEmotion {
    pub fn from(buffer: &[u8]) -> PacketZcEmotion {
        PacketZcEmotion {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketZcEmotion {
        PacketZcEmotion {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xc0, 0x0]),
        packet_id_raw: [0xc0, 0x0],
        gid: 0,
        gid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcEmotion {
    fn id(&self) -> &str {
       "0xc000"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqUserCount {
    pub fn from(buffer: &[u8]) -> PacketCzReqUserCount {
        PacketCzReqUserCount {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzReqUserCount {
        PacketCzReqUserCount {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xc1, 0x0]),
        packet_id_raw: [0xc1, 0x0],
        }
    }
}

impl Packet for PacketCzReqUserCount {
    fn id(&self) -> &str {
       "0xc100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcUserCount {
    pub fn from(buffer: &[u8]) -> PacketZcUserCount {
        PacketZcUserCount {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            count: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketZcUserCount {
        PacketZcUserCount {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xc2, 0x0]),
        packet_id_raw: [0xc2, 0x0],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcUserCount {
    fn id(&self) -> &str {
       "0xc200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSpriteChange {
    pub fn from(buffer: &[u8]) -> PacketZcSpriteChange {
        PacketZcSpriteChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            value: u8::from_le_bytes([buffer[7]]),
            value_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[7..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_value(&mut self, value: u8) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 1]) {
        self.value_raw = value;
    }
    pub fn new() -> PacketZcSpriteChange {
        PacketZcSpriteChange {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xc3, 0x0]),
        packet_id_raw: [0xc3, 0x0],
        gid: 0,
        gid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        value: 0,
        value_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcSpriteChange {
    fn id(&self) -> &str {
       "0xc300"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSelectDealtype {
    pub fn from(buffer: &[u8]) -> PacketZcSelectDealtype {
        PacketZcSelectDealtype {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn new() -> PacketZcSelectDealtype {
        PacketZcSelectDealtype {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xc4, 0x0]),
        packet_id_raw: [0xc4, 0x0],
        naid: 0,
        naid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcSelectDealtype {
    fn id(&self) -> &str {
       "0xc400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzAckSelectDealtype {
    pub fn from(buffer: &[u8]) -> PacketCzAckSelectDealtype {
        PacketCzAckSelectDealtype {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketCzAckSelectDealtype {
        PacketCzAckSelectDealtype {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xc5, 0x0]),
        packet_id_raw: [0xc5, 0x0],
        naid: 0,
        naid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzAckSelectDealtype {
    fn id(&self) -> &str {
       "0xc500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPcPurchaseItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcPcPurchaseItemlist {
        let iter_count = (&buffer.len() - 4) / 11;
        let mut vec_field: Vec<PurchaseItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (11 * (i - 1));
            let end_pos = 4 + 11 * i;
            vec_field.push(PurchaseItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPcPurchaseItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<PurchaseItem>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new() -> PacketZcPcPurchaseItemlist {
        PacketZcPcPurchaseItemlist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xc6, 0x0]),
        packet_id_raw: [0xc6, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcPcPurchaseItemlist {
    fn id(&self) -> &str {
       "0xc600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPcSellItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcPcSellItemlist {
        let iter_count = (&buffer.len() - 4) / 10;
        let mut vec_field: Vec<SellItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (10 * (i - 1));
            let end_pos = 4 + 10 * i;
            vec_field.push(SellItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPcSellItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<SellItem>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new() -> PacketZcPcSellItemlist {
        PacketZcPcSellItemlist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xc7, 0x0]),
        packet_id_raw: [0xc7, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcPcSellItemlist {
    fn id(&self) -> &str {
       "0xc700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzPcPurchaseItemlist {
    pub fn from(buffer: &[u8]) -> PacketCzPcPurchaseItemlist {
        let iter_count = (&buffer.len() - 4) / 4;
        let mut vec_field: Vec<CzPurchaseItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (4 * (i - 1));
            let end_pos = 4 + 4 * i;
            vec_field.push(CzPurchaseItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzPcPurchaseItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<CzPurchaseItem>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new() -> PacketCzPcPurchaseItemlist {
        PacketCzPcPurchaseItemlist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xc8, 0x0]),
        packet_id_raw: [0xc8, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketCzPcPurchaseItemlist {
    fn id(&self) -> &str {
       "0xc800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzPcSellItemlist {
    pub fn from(buffer: &[u8]) -> PacketCzPcSellItemlist {
        let iter_count = (&buffer.len() - 4) / 4;
        let mut vec_field: Vec<CzSellItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (4 * (i - 1));
            let end_pos = 4 + 4 * i;
            vec_field.push(CzSellItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzPcSellItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<CzSellItem>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new() -> PacketCzPcSellItemlist {
        PacketCzPcSellItemlist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xc9, 0x0]),
        packet_id_raw: [0xc9, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketCzPcSellItemlist {
    fn id(&self) -> &str {
       "0xc900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPcPurchaseResult {
    pub fn from(buffer: &[u8]) -> PacketZcPcPurchaseResult {
        PacketZcPcPurchaseResult {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcPcPurchaseResult {
        PacketZcPcPurchaseResult {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xca, 0x0]),
        packet_id_raw: [0xca, 0x0],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcPcPurchaseResult {
    fn id(&self) -> &str {
       "0xca00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPcSellResult {
    pub fn from(buffer: &[u8]) -> PacketZcPcSellResult {
        PacketZcPcSellResult {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcPcSellResult {
        PacketZcPcSellResult {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xcb, 0x0]),
        packet_id_raw: [0xcb, 0x0],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcPcSellResult {
    fn id(&self) -> &str {
       "0xcb00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzDisconnectCharacter {
    pub fn from(buffer: &[u8]) -> PacketCzDisconnectCharacter {
        PacketCzDisconnectCharacter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketCzDisconnectCharacter {
        PacketCzDisconnectCharacter {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xcc, 0x0]),
        packet_id_raw: [0xcc, 0x0],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzDisconnectCharacter {
    fn id(&self) -> &str {
       "0xcc00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckDisconnectCharacter {
    pub fn from(buffer: &[u8]) -> PacketZcAckDisconnectCharacter {
        PacketZcAckDisconnectCharacter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcAckDisconnectCharacter {
        PacketZcAckDisconnectCharacter {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xcd, 0x0]),
        packet_id_raw: [0xcd, 0x0],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckDisconnectCharacter {
    fn id(&self) -> &str {
       "0xcd00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzDisconnectAllCharacter {
    pub fn from(buffer: &[u8]) -> PacketCzDisconnectAllCharacter {
        PacketCzDisconnectAllCharacter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzDisconnectAllCharacter {
        PacketCzDisconnectAllCharacter {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xce, 0x0]),
        packet_id_raw: [0xce, 0x0],
        }
    }
}

impl Packet for PacketCzDisconnectAllCharacter {
    fn id(&self) -> &str {
       "0xce00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzSettingWhisperPc {
    pub fn from(buffer: &[u8]) -> PacketCzSettingWhisperPc {
        PacketCzSettingWhisperPc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            atype: u8::from_le_bytes([buffer[26]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[26..27]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketCzSettingWhisperPc {
        PacketCzSettingWhisperPc {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xcf, 0x0]),
        packet_id_raw: [0xcf, 0x0],
        name: [0 as char; 24],
        name_raw: [0; 24],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzSettingWhisperPc {
    fn id(&self) -> &str {
       "0xcf00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzSettingWhisperState {
    pub fn from(buffer: &[u8]) -> PacketCzSettingWhisperState {
        PacketCzSettingWhisperState {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: u8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketCzSettingWhisperState {
        PacketCzSettingWhisperState {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xd0, 0x0]),
        packet_id_raw: [0xd0, 0x0],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzSettingWhisperState {
    fn id(&self) -> &str {
       "0xd000"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSettingWhisperPc {
    pub fn from(buffer: &[u8]) -> PacketZcSettingWhisperPc {
        PacketZcSettingWhisperPc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: u8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            result: u8::from_le_bytes([buffer[3]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[3..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcSettingWhisperPc {
        PacketZcSettingWhisperPc {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xd1, 0x0]),
        packet_id_raw: [0xd1, 0x0],
        atype: 0,
        atype_raw: [0; 1],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcSettingWhisperPc {
    fn id(&self) -> &str {
       "0xd100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSettingWhisperState {
    pub fn from(buffer: &[u8]) -> PacketZcSettingWhisperState {
        PacketZcSettingWhisperState {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: u8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            result: u8::from_le_bytes([buffer[3]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[3..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcSettingWhisperState {
        PacketZcSettingWhisperState {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xd2, 0x0]),
        packet_id_raw: [0xd2, 0x0],
        atype: 0,
        atype_raw: [0; 1],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcSettingWhisperState {
    fn id(&self) -> &str {
       "0xd200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqWhisperList {
    pub fn from(buffer: &[u8]) -> PacketCzReqWhisperList {
        PacketCzReqWhisperList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzReqWhisperList {
        PacketCzReqWhisperList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xd3, 0x0]),
        packet_id_raw: [0xd3, 0x0],
        }
    }
}

impl Packet for PacketCzReqWhisperList {
    fn id(&self) -> &str {
       "0xd300"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcWhisperList {
    pub fn from(buffer: &[u8]) -> PacketZcWhisperList {
        let iter_count = (&buffer.len() - 4) / 24;
        let mut vec_field: Vec<WhisperItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (24 * (i - 1));
            let end_pos = 4 + 24 * i;
            vec_field.push(WhisperItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcWhisperList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            wisper_list: vec_field.clone(),
            wisper_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.wisper_list_raw = {
            self.wisper_list.iter_mut().for_each(|item| item.fill_raw());
            self.wisper_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.wisper_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_wisper_list(&mut self, value: Vec<WhisperItem>) {
        self.wisper_list = value;
    }
    pub fn set_wisper_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.wisper_list_raw = value;
    }
    pub fn new() -> PacketZcWhisperList {
        PacketZcWhisperList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xd4, 0x0]),
        packet_id_raw: [0xd4, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        wisper_list: vec![],
        wisper_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcWhisperList {
    fn id(&self) -> &str {
       "0xd400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzCreateChatroom {
    pub fn from(buffer: &[u8]) -> PacketCzCreateChatroom {
        PacketCzCreateChatroom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            size: i16::from_le_bytes([buffer[4], buffer[5]]),
            size_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            passwd:  {
                let mut dst: [char; 8] = [0 as char; 8];
                for (index, byte) in buffer[7..15].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[7..15]);
                dst
            },
            title: String::from_utf8_lossy(&buffer[15..buffer.len()]).to_string(),
            title_raw: buffer[15..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.size).unwrap();
        self.size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
        self.title_raw = self.title.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.size_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.passwd_raw.to_vec());
        wtr.append(&mut self.title_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_size(&mut self, value: i16) {
        self.size = value;
    }
    pub fn set_size_raw(&mut self, value: [u8; 2]) {
        self.size_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_passwd(&mut self, value: [char; 8]) {
        self.passwd = value;
    }
    pub fn set_passwd_raw(&mut self, value: [u8; 8]) {
        self.passwd_raw = value;
    }
    pub fn set_title(&mut self, value: String) {
        self.title = value;
    }
    pub fn set_title_raw(&mut self, value: Vec<u8>) {
        self.title_raw = value;
    }
    pub fn new() -> PacketCzCreateChatroom {
        PacketCzCreateChatroom {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xd5, 0x0]),
        packet_id_raw: [0xd5, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        size: 0,
        size_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        passwd: [0 as char; 8],
        passwd_raw: [0; 8],
        title: String::new(),
        title_raw: vec![],
        }
    }
}

impl Packet for PacketCzCreateChatroom {
    fn id(&self) -> &str {
       "0xd500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckCreateChatroom {
    pub fn from(buffer: &[u8]) -> PacketZcAckCreateChatroom {
        PacketZcAckCreateChatroom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcAckCreateChatroom {
        PacketZcAckCreateChatroom {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xd6, 0x0]),
        packet_id_raw: [0xd6, 0x0],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckCreateChatroom {
    fn id(&self) -> &str {
       "0xd600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcRoomNewentry {
    pub fn from(buffer: &[u8]) -> PacketZcRoomNewentry {
        PacketZcRoomNewentry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            room_id: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            room_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            maxcount: i16::from_le_bytes([buffer[12], buffer[13]]),
            maxcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            curcount: i16::from_le_bytes([buffer[14], buffer[15]]),
            curcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            atype: u8::from_le_bytes([buffer[16]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[16..17]);
                dst
            },
            title: String::from_utf8_lossy(&buffer[17..buffer.len()]).to_string(),
            title_raw: buffer[17..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.room_id).unwrap();
        self.room_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.maxcount).unwrap();
        self.maxcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.curcount).unwrap();
        self.curcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        self.title_raw = self.title.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.room_id_raw.to_vec());
        wtr.append(&mut self.maxcount_raw.to_vec());
        wtr.append(&mut self.curcount_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.title_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_room_id(&mut self, value: u32) {
        self.room_id = value;
    }
    pub fn set_room_id_raw(&mut self, value: [u8; 4]) {
        self.room_id_raw = value;
    }
    pub fn set_maxcount(&mut self, value: i16) {
        self.maxcount = value;
    }
    pub fn set_maxcount_raw(&mut self, value: [u8; 2]) {
        self.maxcount_raw = value;
    }
    pub fn set_curcount(&mut self, value: i16) {
        self.curcount = value;
    }
    pub fn set_curcount_raw(&mut self, value: [u8; 2]) {
        self.curcount_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_title(&mut self, value: String) {
        self.title = value;
    }
    pub fn set_title_raw(&mut self, value: Vec<u8>) {
        self.title_raw = value;
    }
    pub fn new() -> PacketZcRoomNewentry {
        PacketZcRoomNewentry {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xd7, 0x0]),
        packet_id_raw: [0xd7, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        room_id: 0,
        room_id_raw: [0; 4],
        maxcount: 0,
        maxcount_raw: [0; 2],
        curcount: 0,
        curcount_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        title: String::new(),
        title_raw: vec![],
        }
    }
}

impl Packet for PacketZcRoomNewentry {
    fn id(&self) -> &str {
       "0xd700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcDestroyRoom {
    pub fn from(buffer: &[u8]) -> PacketZcDestroyRoom {
        PacketZcDestroyRoom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            room_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            room_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.room_id).unwrap();
        self.room_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.room_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_room_id(&mut self, value: u32) {
        self.room_id = value;
    }
    pub fn set_room_id_raw(&mut self, value: [u8; 4]) {
        self.room_id_raw = value;
    }
    pub fn new() -> PacketZcDestroyRoom {
        PacketZcDestroyRoom {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xd8, 0x0]),
        packet_id_raw: [0xd8, 0x0],
        room_id: 0,
        room_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDestroyRoom {
    fn id(&self) -> &str {
       "0xd800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqEnterRoom {
    pub fn from(buffer: &[u8]) -> PacketCzReqEnterRoom {
        PacketCzReqEnterRoom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            room_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            room_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            passwd:  {
                let mut dst: [char; 8] = [0 as char; 8];
                for (index, byte) in buffer[6..14].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[6..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.room_id).unwrap();
        self.room_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.room_id_raw.to_vec());
        wtr.append(&mut self.passwd_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_room_id(&mut self, value: u32) {
        self.room_id = value;
    }
    pub fn set_room_id_raw(&mut self, value: [u8; 4]) {
        self.room_id_raw = value;
    }
    pub fn set_passwd(&mut self, value: [char; 8]) {
        self.passwd = value;
    }
    pub fn set_passwd_raw(&mut self, value: [u8; 8]) {
        self.passwd_raw = value;
    }
    pub fn new() -> PacketCzReqEnterRoom {
        PacketCzReqEnterRoom {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xd9, 0x0]),
        packet_id_raw: [0xd9, 0x0],
        room_id: 0,
        room_id_raw: [0; 4],
        passwd: [0 as char; 8],
        passwd_raw: [0; 8],
        }
    }
}

impl Packet for PacketCzReqEnterRoom {
    fn id(&self) -> &str {
       "0xd900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcRefuseEnterRoom {
    pub fn from(buffer: &[u8]) -> PacketZcRefuseEnterRoom {
        PacketZcRefuseEnterRoom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcRefuseEnterRoom {
        PacketZcRefuseEnterRoom {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xda, 0x0]),
        packet_id_raw: [0xda, 0x0],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcRefuseEnterRoom {
    fn id(&self) -> &str {
       "0xda00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcEnterRoom {
    pub fn from(buffer: &[u8]) -> PacketZcEnterRoom {
        let iter_count = (&buffer.len() - 8) / 28;
        let mut vec_field: Vec<RoomMember> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (28 * (i - 1));
            let end_pos = 8 + 28 * i;
            vec_field.push(RoomMember::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcEnterRoom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            room_id: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            room_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            member_list: vec_field.clone(),
            member_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.room_id).unwrap();
        self.room_id_raw = wtr.try_into().unwrap();
        self.member_list_raw = {
            self.member_list.iter_mut().for_each(|item| item.fill_raw());
            self.member_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.room_id_raw.to_vec());
        self.member_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_room_id(&mut self, value: u32) {
        self.room_id = value;
    }
    pub fn set_room_id_raw(&mut self, value: [u8; 4]) {
        self.room_id_raw = value;
    }
    pub fn set_member_list(&mut self, value: Vec<RoomMember>) {
        self.member_list = value;
    }
    pub fn set_member_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.member_list_raw = value;
    }
    pub fn new() -> PacketZcEnterRoom {
        PacketZcEnterRoom {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xdb, 0x0]),
        packet_id_raw: [0xdb, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        room_id: 0,
        room_id_raw: [0; 4],
        member_list: vec![],
        member_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcEnterRoom {
    fn id(&self) -> &str {
       "0xdb00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMemberNewentry {
    pub fn from(buffer: &[u8]) -> PacketZcMemberNewentry {
        PacketZcMemberNewentry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            curcount: i16::from_le_bytes([buffer[2], buffer[3]]),
            curcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.curcount).unwrap();
        self.curcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.curcount_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_curcount(&mut self, value: i16) {
        self.curcount = value;
    }
    pub fn set_curcount_raw(&mut self, value: [u8; 2]) {
        self.curcount_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new() -> PacketZcMemberNewentry {
        PacketZcMemberNewentry {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xdc, 0x0]),
        packet_id_raw: [0xdc, 0x0],
        curcount: 0,
        curcount_raw: [0; 2],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcMemberNewentry {
    fn id(&self) -> &str {
       "0xdc00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMemberExit {
    pub fn from(buffer: &[u8]) -> PacketZcMemberExit {
        PacketZcMemberExit {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            curcount: i16::from_le_bytes([buffer[2], buffer[3]]),
            curcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
            atype: u8::from_le_bytes([buffer[28]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[28..29]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.curcount).unwrap();
        self.curcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.curcount_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_curcount(&mut self, value: i16) {
        self.curcount = value;
    }
    pub fn set_curcount_raw(&mut self, value: [u8; 2]) {
        self.curcount_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketZcMemberExit {
        PacketZcMemberExit {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xdd, 0x0]),
        packet_id_raw: [0xdd, 0x0],
        curcount: 0,
        curcount_raw: [0; 2],
        name: [0 as char; 24],
        name_raw: [0; 24],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcMemberExit {
    fn id(&self) -> &str {
       "0xdd00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzChangeChatroom {
    pub fn from(buffer: &[u8]) -> PacketCzChangeChatroom {
        PacketCzChangeChatroom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            size: i16::from_le_bytes([buffer[4], buffer[5]]),
            size_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            passwd:  {
                let mut dst: [char; 8] = [0 as char; 8];
                for (index, byte) in buffer[7..15].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[7..15]);
                dst
            },
            title: String::from_utf8_lossy(&buffer[15..buffer.len()]).to_string(),
            title_raw: buffer[15..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.size).unwrap();
        self.size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
        self.title_raw = self.title.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.size_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.passwd_raw.to_vec());
        wtr.append(&mut self.title_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_size(&mut self, value: i16) {
        self.size = value;
    }
    pub fn set_size_raw(&mut self, value: [u8; 2]) {
        self.size_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_passwd(&mut self, value: [char; 8]) {
        self.passwd = value;
    }
    pub fn set_passwd_raw(&mut self, value: [u8; 8]) {
        self.passwd_raw = value;
    }
    pub fn set_title(&mut self, value: String) {
        self.title = value;
    }
    pub fn set_title_raw(&mut self, value: Vec<u8>) {
        self.title_raw = value;
    }
    pub fn new() -> PacketCzChangeChatroom {
        PacketCzChangeChatroom {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xde, 0x0]),
        packet_id_raw: [0xde, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        size: 0,
        size_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        passwd: [0 as char; 8],
        passwd_raw: [0; 8],
        title: String::new(),
        title_raw: vec![],
        }
    }
}

impl Packet for PacketCzChangeChatroom {
    fn id(&self) -> &str {
       "0xde00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcChangeChatroom {
    pub fn from(buffer: &[u8]) -> PacketZcChangeChatroom {
        PacketZcChangeChatroom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            room_id: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            room_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            maxcount: i16::from_le_bytes([buffer[12], buffer[13]]),
            maxcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            curcount: i16::from_le_bytes([buffer[14], buffer[15]]),
            curcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            atype: u8::from_le_bytes([buffer[16]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[16..17]);
                dst
            },
            title: String::from_utf8_lossy(&buffer[17..buffer.len()]).to_string(),
            title_raw: buffer[17..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.room_id).unwrap();
        self.room_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.maxcount).unwrap();
        self.maxcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.curcount).unwrap();
        self.curcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        self.title_raw = self.title.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.room_id_raw.to_vec());
        wtr.append(&mut self.maxcount_raw.to_vec());
        wtr.append(&mut self.curcount_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.title_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_room_id(&mut self, value: u32) {
        self.room_id = value;
    }
    pub fn set_room_id_raw(&mut self, value: [u8; 4]) {
        self.room_id_raw = value;
    }
    pub fn set_maxcount(&mut self, value: i16) {
        self.maxcount = value;
    }
    pub fn set_maxcount_raw(&mut self, value: [u8; 2]) {
        self.maxcount_raw = value;
    }
    pub fn set_curcount(&mut self, value: i16) {
        self.curcount = value;
    }
    pub fn set_curcount_raw(&mut self, value: [u8; 2]) {
        self.curcount_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_title(&mut self, value: String) {
        self.title = value;
    }
    pub fn set_title_raw(&mut self, value: Vec<u8>) {
        self.title_raw = value;
    }
    pub fn new() -> PacketZcChangeChatroom {
        PacketZcChangeChatroom {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xdf, 0x0]),
        packet_id_raw: [0xdf, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        room_id: 0,
        room_id_raw: [0; 4],
        maxcount: 0,
        maxcount_raw: [0; 2],
        curcount: 0,
        curcount_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        title: String::new(),
        title_raw: vec![],
        }
    }
}

impl Packet for PacketZcChangeChatroom {
    fn id(&self) -> &str {
       "0xdf00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqRoleChange {
    pub fn from(buffer: &[u8]) -> PacketCzReqRoleChange {
        PacketCzReqRoleChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            role: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            role_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.role).unwrap();
        self.role_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.role_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_role(&mut self, value: u32) {
        self.role = value;
    }
    pub fn set_role_raw(&mut self, value: [u8; 4]) {
        self.role_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new() -> PacketCzReqRoleChange {
        PacketCzReqRoleChange {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xe0, 0x0]),
        packet_id_raw: [0xe0, 0x0],
        role: 0,
        role_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzReqRoleChange {
    fn id(&self) -> &str {
       "0xe000"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcRoleChange {
    pub fn from(buffer: &[u8]) -> PacketZcRoleChange {
        PacketZcRoleChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            role: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            role_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.role).unwrap();
        self.role_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.role_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_role(&mut self, value: u32) {
        self.role = value;
    }
    pub fn set_role_raw(&mut self, value: [u8; 4]) {
        self.role_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new() -> PacketZcRoleChange {
        PacketZcRoleChange {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xe1, 0x0]),
        packet_id_raw: [0xe1, 0x0],
        role: 0,
        role_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcRoleChange {
    fn id(&self) -> &str {
       "0xe100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqExpelMember {
    pub fn from(buffer: &[u8]) -> PacketCzReqExpelMember {
        PacketCzReqExpelMember {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new() -> PacketCzReqExpelMember {
        PacketCzReqExpelMember {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xe2, 0x0]),
        packet_id_raw: [0xe2, 0x0],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzReqExpelMember {
    fn id(&self) -> &str {
       "0xe200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzExitRoom {
    pub fn from(buffer: &[u8]) -> PacketCzExitRoom {
        PacketCzExitRoom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzExitRoom {
        PacketCzExitRoom {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xe3, 0x0]),
        packet_id_raw: [0xe3, 0x0],
        }
    }
}

impl Packet for PacketCzExitRoom {
    fn id(&self) -> &str {
       "0xe300"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketCzReqExchangeItem {
        PacketCzReqExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketCzReqExchangeItem {
        PacketCzReqExchangeItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xe4, 0x0]),
        packet_id_raw: [0xe4, 0x0],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqExchangeItem {
    fn id(&self) -> &str {
       "0xe400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcReqExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketZcReqExchangeItem {
        PacketZcReqExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new() -> PacketZcReqExchangeItem {
        PacketZcReqExchangeItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xe5, 0x0]),
        packet_id_raw: [0xe5, 0x0],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcReqExchangeItem {
    fn id(&self) -> &str {
       "0xe500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzAckExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketCzAckExchangeItem {
        PacketCzAckExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketCzAckExchangeItem {
        PacketCzAckExchangeItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xe6, 0x0]),
        packet_id_raw: [0xe6, 0x0],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzAckExchangeItem {
    fn id(&self) -> &str {
       "0xe600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketZcAckExchangeItem {
        PacketZcAckExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcAckExchangeItem {
        PacketZcAckExchangeItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xe7, 0x0]),
        packet_id_raw: [0xe7, 0x0],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckExchangeItem {
    fn id(&self) -> &str {
       "0xe700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzAddExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketCzAddExchangeItem {
        PacketCzAddExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketCzAddExchangeItem {
        PacketCzAddExchangeItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xe8, 0x0]),
        packet_id_raw: [0xe8, 0x0],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzAddExchangeItem {
    fn id(&self) -> &str {
       "0xe800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAddExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketZcAddExchangeItem {
        PacketZcAddExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            count: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            itid: u16::from_le_bytes([buffer[6], buffer[7]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            is_identified: buffer[8] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            is_damaged: buffer[9] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[10]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[11..19]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[11..19]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new() -> PacketZcAddExchangeItem {
        PacketZcAddExchangeItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xe9, 0x0]),
        packet_id_raw: [0xe9, 0x0],
        count: 0,
        count_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        }
    }
}

impl Packet for PacketZcAddExchangeItem {
    fn id(&self) -> &str {
       "0xe900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckAddExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketZcAckAddExchangeItem {
        PacketZcAckAddExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            result: u8::from_le_bytes([buffer[4]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcAckAddExchangeItem {
        PacketZcAckAddExchangeItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xea, 0x0]),
        packet_id_raw: [0xea, 0x0],
        index: 0,
        index_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckAddExchangeItem {
    fn id(&self) -> &str {
       "0xea00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzConcludeExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketCzConcludeExchangeItem {
        PacketCzConcludeExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzConcludeExchangeItem {
        PacketCzConcludeExchangeItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xeb, 0x0]),
        packet_id_raw: [0xeb, 0x0],
        }
    }
}

impl Packet for PacketCzConcludeExchangeItem {
    fn id(&self) -> &str {
       "0xeb00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcConcludeExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketZcConcludeExchangeItem {
        PacketZcConcludeExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            who: u8::from_le_bytes([buffer[2]]),
            who_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.who).unwrap();
        self.who_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.who_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_who(&mut self, value: u8) {
        self.who = value;
    }
    pub fn set_who_raw(&mut self, value: [u8; 1]) {
        self.who_raw = value;
    }
    pub fn new() -> PacketZcConcludeExchangeItem {
        PacketZcConcludeExchangeItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xec, 0x0]),
        packet_id_raw: [0xec, 0x0],
        who: 0,
        who_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcConcludeExchangeItem {
    fn id(&self) -> &str {
       "0xec00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzCancelExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketCzCancelExchangeItem {
        PacketCzCancelExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzCancelExchangeItem {
        PacketCzCancelExchangeItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xed, 0x0]),
        packet_id_raw: [0xed, 0x0],
        }
    }
}

impl Packet for PacketCzCancelExchangeItem {
    fn id(&self) -> &str {
       "0xed00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcCancelExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketZcCancelExchangeItem {
        PacketZcCancelExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketZcCancelExchangeItem {
        PacketZcCancelExchangeItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xee, 0x0]),
        packet_id_raw: [0xee, 0x0],
        }
    }
}

impl Packet for PacketZcCancelExchangeItem {
    fn id(&self) -> &str {
       "0xee00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzExecExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketCzExecExchangeItem {
        PacketCzExecExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzExecExchangeItem {
        PacketCzExecExchangeItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xef, 0x0]),
        packet_id_raw: [0xef, 0x0],
        }
    }
}

impl Packet for PacketCzExecExchangeItem {
    fn id(&self) -> &str {
       "0xef00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcExecExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketZcExecExchangeItem {
        PacketZcExecExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcExecExchangeItem {
        PacketZcExecExchangeItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xf0, 0x0]),
        packet_id_raw: [0xf0, 0x0],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcExecExchangeItem {
    fn id(&self) -> &str {
       "0xf000"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcExchangeitemUndo {
    pub fn from(buffer: &[u8]) -> PacketZcExchangeitemUndo {
        PacketZcExchangeitemUndo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketZcExchangeitemUndo {
        PacketZcExchangeitemUndo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xf1, 0x0]),
        packet_id_raw: [0xf1, 0x0],
        }
    }
}

impl Packet for PacketZcExchangeitemUndo {
    fn id(&self) -> &str {
       "0xf100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyStoreitemCountinfo {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyStoreitemCountinfo {
        PacketZcNotifyStoreitemCountinfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            cur_count: i16::from_le_bytes([buffer[2], buffer[3]]),
            cur_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            max_count: i16::from_le_bytes([buffer[4], buffer[5]]),
            max_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.cur_count).unwrap();
        self.cur_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_count).unwrap();
        self.max_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.cur_count_raw.to_vec());
        wtr.append(&mut self.max_count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_cur_count(&mut self, value: i16) {
        self.cur_count = value;
    }
    pub fn set_cur_count_raw(&mut self, value: [u8; 2]) {
        self.cur_count_raw = value;
    }
    pub fn set_max_count(&mut self, value: i16) {
        self.max_count = value;
    }
    pub fn set_max_count_raw(&mut self, value: [u8; 2]) {
        self.max_count_raw = value;
    }
    pub fn new() -> PacketZcNotifyStoreitemCountinfo {
        PacketZcNotifyStoreitemCountinfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xf2, 0x0]),
        packet_id_raw: [0xf2, 0x0],
        cur_count: 0,
        cur_count_raw: [0; 2],
        max_count: 0,
        max_count_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyStoreitemCountinfo {
    fn id(&self) -> &str {
       "0xf200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzMoveItemFromBodyToStore {
    pub fn from(buffer: &[u8]) -> PacketCzMoveItemFromBodyToStore {
        PacketCzMoveItemFromBodyToStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketCzMoveItemFromBodyToStore {
        PacketCzMoveItemFromBodyToStore {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xf3, 0x0]),
        packet_id_raw: [0xf3, 0x0],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMoveItemFromBodyToStore {
    fn id(&self) -> &str {
       "0xf300"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAddItemToStore {
    pub fn from(buffer: &[u8]) -> PacketZcAddItemToStore {
        PacketZcAddItemToStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            itid: u16::from_le_bytes([buffer[8], buffer[9]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            is_identified: buffer[10] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            is_damaged: buffer[11] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[12]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[13..21]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[13..21]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new() -> PacketZcAddItemToStore {
        PacketZcAddItemToStore {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xf4, 0x0]),
        packet_id_raw: [0xf4, 0x0],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        }
    }
}

impl Packet for PacketZcAddItemToStore {
    fn id(&self) -> &str {
       "0xf400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzMoveItemFromStoreToBody {
    pub fn from(buffer: &[u8]) -> PacketCzMoveItemFromStoreToBody {
        PacketCzMoveItemFromStoreToBody {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketCzMoveItemFromStoreToBody {
        PacketCzMoveItemFromStoreToBody {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xf5, 0x0]),
        packet_id_raw: [0xf5, 0x0],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMoveItemFromStoreToBody {
    fn id(&self) -> &str {
       "0xf500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcDeleteItemFromStore {
    pub fn from(buffer: &[u8]) -> PacketZcDeleteItemFromStore {
        PacketZcDeleteItemFromStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketZcDeleteItemFromStore {
        PacketZcDeleteItemFromStore {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xf6, 0x0]),
        packet_id_raw: [0xf6, 0x0],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDeleteItemFromStore {
    fn id(&self) -> &str {
       "0xf600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzCloseStore {
    pub fn from(buffer: &[u8]) -> PacketCzCloseStore {
        PacketCzCloseStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzCloseStore {
        PacketCzCloseStore {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xf7, 0x0]),
        packet_id_raw: [0xf7, 0x0],
        }
    }
}

impl Packet for PacketCzCloseStore {
    fn id(&self) -> &str {
       "0xf700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcCloseStore {
    pub fn from(buffer: &[u8]) -> PacketZcCloseStore {
        PacketZcCloseStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketZcCloseStore {
        PacketZcCloseStore {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xf8, 0x0]),
        packet_id_raw: [0xf8, 0x0],
        }
    }
}

impl Packet for PacketZcCloseStore {
    fn id(&self) -> &str {
       "0xf800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzMakeGroup {
    pub fn from(buffer: &[u8]) -> PacketCzMakeGroup {
        PacketCzMakeGroup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            group_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.group_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_group_name(&mut self, value: [char; 24]) {
        self.group_name = value;
    }
    pub fn set_group_name_raw(&mut self, value: [u8; 24]) {
        self.group_name_raw = value;
    }
    pub fn new() -> PacketCzMakeGroup {
        PacketCzMakeGroup {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xf9, 0x0]),
        packet_id_raw: [0xf9, 0x0],
        group_name: [0 as char; 24],
        group_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzMakeGroup {
    fn id(&self) -> &str {
       "0xf900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckMakeGroup {
    pub fn from(buffer: &[u8]) -> PacketZcAckMakeGroup {
        PacketZcAckMakeGroup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcAckMakeGroup {
        PacketZcAckMakeGroup {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xfa, 0x0]),
        packet_id_raw: [0xfa, 0x0],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckMakeGroup {
    fn id(&self) -> &str {
       "0xfa00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcGroupList {
    pub fn from(buffer: &[u8]) -> PacketZcGroupList {
        let iter_count = (&buffer.len() - 28) / 46;
        let mut vec_field: Vec<GroupmemberInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 28 + (46 * (i - 1));
            let end_pos = 28 + 46 * i;
            vec_field.push(GroupmemberInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcGroupList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            group_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
            group_info: vec_field.clone(),
            group_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();
        self.group_info_raw = {
            self.group_info.iter_mut().for_each(|item| item.fill_raw());
            self.group_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.group_name_raw.to_vec());
        self.group_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_group_name(&mut self, value: [char; 24]) {
        self.group_name = value;
    }
    pub fn set_group_name_raw(&mut self, value: [u8; 24]) {
        self.group_name_raw = value;
    }
    pub fn set_group_info(&mut self, value: Vec<GroupmemberInfo>) {
        self.group_info = value;
    }
    pub fn set_group_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.group_info_raw = value;
    }
    pub fn new() -> PacketZcGroupList {
        PacketZcGroupList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xfb, 0x0]),
        packet_id_raw: [0xfb, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        group_name: [0 as char; 24],
        group_name_raw: [0; 24],
        group_info: vec![],
        group_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcGroupList {
    fn id(&self) -> &str {
       "0xfb00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqJoinGroup {
    pub fn from(buffer: &[u8]) -> PacketCzReqJoinGroup {
        PacketCzReqJoinGroup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketCzReqJoinGroup {
        PacketCzReqJoinGroup {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xfc, 0x0]),
        packet_id_raw: [0xfc, 0x0],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqJoinGroup {
    fn id(&self) -> &str {
       "0xfc00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckReqJoinGroup {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqJoinGroup {
        PacketZcAckReqJoinGroup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            answer: u8::from_le_bytes([buffer[26]]),
            answer_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[26..27]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        wtr.append(&mut self.answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn set_answer(&mut self, value: u8) {
        self.answer = value;
    }
    pub fn set_answer_raw(&mut self, value: [u8; 1]) {
        self.answer_raw = value;
    }
    pub fn new() -> PacketZcAckReqJoinGroup {
        PacketZcAckReqJoinGroup {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xfd, 0x0]),
        packet_id_raw: [0xfd, 0x0],
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        answer: 0,
        answer_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckReqJoinGroup {
    fn id(&self) -> &str {
       "0xfd00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcReqJoinGroup {
    pub fn from(buffer: &[u8]) -> PacketZcReqJoinGroup {
        PacketZcReqJoinGroup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            grid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            grid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            group_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.grid).unwrap();
        self.grid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.grid_raw.to_vec());
        wtr.append(&mut self.group_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_grid(&mut self, value: u32) {
        self.grid = value;
    }
    pub fn set_grid_raw(&mut self, value: [u8; 4]) {
        self.grid_raw = value;
    }
    pub fn set_group_name(&mut self, value: [char; 24]) {
        self.group_name = value;
    }
    pub fn set_group_name_raw(&mut self, value: [u8; 24]) {
        self.group_name_raw = value;
    }
    pub fn new() -> PacketZcReqJoinGroup {
        PacketZcReqJoinGroup {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xfe, 0x0]),
        packet_id_raw: [0xfe, 0x0],
        grid: 0,
        grid_raw: [0; 4],
        group_name: [0 as char; 24],
        group_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcReqJoinGroup {
    fn id(&self) -> &str {
       "0xfe00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzJoinGroup {
    pub fn from(buffer: &[u8]) -> PacketCzJoinGroup {
        PacketCzJoinGroup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            grid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            grid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            answer: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            answer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.grid).unwrap();
        self.grid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.grid_raw.to_vec());
        wtr.append(&mut self.answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_grid(&mut self, value: u32) {
        self.grid = value;
    }
    pub fn set_grid_raw(&mut self, value: [u8; 4]) {
        self.grid_raw = value;
    }
    pub fn set_answer(&mut self, value: i32) {
        self.answer = value;
    }
    pub fn set_answer_raw(&mut self, value: [u8; 4]) {
        self.answer_raw = value;
    }
    pub fn new() -> PacketCzJoinGroup {
        PacketCzJoinGroup {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xff, 0x0]),
        packet_id_raw: [0xff, 0x0],
        grid: 0,
        grid_raw: [0; 4],
        answer: 0,
        answer_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzJoinGroup {
    fn id(&self) -> &str {
       "0xff00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqLeaveGroup {
    pub fn from(buffer: &[u8]) -> PacketCzReqLeaveGroup {
        PacketCzReqLeaveGroup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzReqLeaveGroup {
        PacketCzReqLeaveGroup {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x10, 0x0]),
        packet_id_raw: [0x10, 0x0],
        }
    }
}

impl Packet for PacketCzReqLeaveGroup {
    fn id(&self) -> &str {
       "0x0100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcGroupinfoChange {
    pub fn from(buffer: &[u8]) -> PacketZcGroupinfoChange {
        PacketZcGroupinfoChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            exp_option: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            exp_option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.exp_option).unwrap();
        self.exp_option_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.exp_option_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_exp_option(&mut self, value: u32) {
        self.exp_option = value;
    }
    pub fn set_exp_option_raw(&mut self, value: [u8; 4]) {
        self.exp_option_raw = value;
    }
    pub fn new() -> PacketZcGroupinfoChange {
        PacketZcGroupinfoChange {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x10, 0x1]),
        packet_id_raw: [0x10, 0x1],
        exp_option: 0,
        exp_option_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcGroupinfoChange {
    fn id(&self) -> &str {
       "0x0101"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzChangeGroupexpoption {
    pub fn from(buffer: &[u8]) -> PacketCzChangeGroupexpoption {
        PacketCzChangeGroupexpoption {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            exp_option: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            exp_option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.exp_option).unwrap();
        self.exp_option_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.exp_option_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_exp_option(&mut self, value: u32) {
        self.exp_option = value;
    }
    pub fn set_exp_option_raw(&mut self, value: [u8; 4]) {
        self.exp_option_raw = value;
    }
    pub fn new() -> PacketCzChangeGroupexpoption {
        PacketCzChangeGroupexpoption {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x10, 0x2]),
        packet_id_raw: [0x10, 0x2],
        exp_option: 0,
        exp_option_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzChangeGroupexpoption {
    fn id(&self) -> &str {
       "0x0102"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqExpelGroupMember {
    pub fn from(buffer: &[u8]) -> PacketCzReqExpelGroupMember {
        PacketCzReqExpelGroupMember {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn new() -> PacketCzReqExpelGroupMember {
        PacketCzReqExpelGroupMember {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x10, 0x3]),
        packet_id_raw: [0x10, 0x3],
        aid: 0,
        aid_raw: [0; 4],
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzReqExpelGroupMember {
    fn id(&self) -> &str {
       "0x0103"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAddMemberToGroup {
    pub fn from(buffer: &[u8]) -> PacketZcAddMemberToGroup {
        PacketZcAddMemberToGroup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            role: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            role_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[10], buffer[11]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[12], buffer[13]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            state: u8::from_le_bytes([buffer[14]]),
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
            group_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[15..39].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[15..39]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[39..63].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[39..63]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[63..79].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[63..79]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.role).unwrap();
        self.role_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.role_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.group_name_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_role(&mut self, value: u32) {
        self.role = value;
    }
    pub fn set_role_raw(&mut self, value: [u8; 4]) {
        self.role_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_state(&mut self, value: u8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_group_name(&mut self, value: [char; 24]) {
        self.group_name = value;
    }
    pub fn set_group_name_raw(&mut self, value: [u8; 24]) {
        self.group_name_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn new() -> PacketZcAddMemberToGroup {
        PacketZcAddMemberToGroup {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x10, 0x4]),
        packet_id_raw: [0x10, 0x4],
        aid: 0,
        aid_raw: [0; 4],
        role: 0,
        role_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        state: 0,
        state_raw: [0; 1],
        group_name: [0 as char; 24],
        group_name_raw: [0; 24],
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        }
    }
}

impl Packet for PacketZcAddMemberToGroup {
    fn id(&self) -> &str {
       "0x0104"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcDeleteMemberFromGroup {
    pub fn from(buffer: &[u8]) -> PacketZcDeleteMemberFromGroup {
        PacketZcDeleteMemberFromGroup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            result: u8::from_le_bytes([buffer[30]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[30..31]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcDeleteMemberFromGroup {
        PacketZcDeleteMemberFromGroup {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x10, 0x5]),
        packet_id_raw: [0x10, 0x5],
        aid: 0,
        aid_raw: [0; 4],
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcDeleteMemberFromGroup {
    fn id(&self) -> &str {
       "0x0105"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyHpToGroupm {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyHpToGroupm {
        PacketZcNotifyHpToGroupm {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            hp: i16::from_le_bytes([buffer[6], buffer[7]]),
            hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            maxhp: i16::from_le_bytes([buffer[8], buffer[9]]),
            maxhp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.maxhp).unwrap();
        self.maxhp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.maxhp_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_hp(&mut self, value: i16) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 2]) {
        self.hp_raw = value;
    }
    pub fn set_maxhp(&mut self, value: i16) {
        self.maxhp = value;
    }
    pub fn set_maxhp_raw(&mut self, value: [u8; 2]) {
        self.maxhp_raw = value;
    }
    pub fn new() -> PacketZcNotifyHpToGroupm {
        PacketZcNotifyHpToGroupm {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x10, 0x6]),
        packet_id_raw: [0x10, 0x6],
        aid: 0,
        aid_raw: [0; 4],
        hp: 0,
        hp_raw: [0; 2],
        maxhp: 0,
        maxhp_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyHpToGroupm {
    fn id(&self) -> &str {
       "0x0106"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyPositionToGroupm {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyPositionToGroupm {
        PacketZcNotifyPositionToGroupm {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[6], buffer[7]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[8], buffer[9]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn new() -> PacketZcNotifyPositionToGroupm {
        PacketZcNotifyPositionToGroupm {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x10, 0x7]),
        packet_id_raw: [0x10, 0x7],
        aid: 0,
        aid_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyPositionToGroupm {
    fn id(&self) -> &str {
       "0x0107"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRequestChatParty {
    pub fn from(buffer: &[u8]) -> PacketCzRequestChatParty {
        PacketCzRequestChatParty {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            msg_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketCzRequestChatParty {
        PacketCzRequestChatParty {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x10, 0x8]),
        packet_id_raw: [0x10, 0x8],
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketCzRequestChatParty {
    fn id(&self) -> &str {
       "0x0108"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyChatParty {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyChatParty {
        PacketZcNotifyChatParty {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[8..buffer.len()]).to_string(),
            msg_raw: buffer[8..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketZcNotifyChatParty {
        PacketZcNotifyChatParty {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x10, 0x9]),
        packet_id_raw: [0x10, 0x9],
        packet_length: 0,
        packet_length_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcNotifyChatParty {
    fn id(&self) -> &str {
       "0x0109"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMvpGettingItem {
    pub fn from(buffer: &[u8]) -> PacketZcMvpGettingItem {
        PacketZcMvpGettingItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new() -> PacketZcMvpGettingItem {
        PacketZcMvpGettingItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x10, 0xa]),
        packet_id_raw: [0x10, 0xa],
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcMvpGettingItem {
    fn id(&self) -> &str {
       "0x010a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMvpGettingSpecialExp {
    pub fn from(buffer: &[u8]) -> PacketZcMvpGettingSpecialExp {
        PacketZcMvpGettingSpecialExp {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            exp: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.exp).unwrap();
        self.exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.exp_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_exp(&mut self, value: u32) {
        self.exp = value;
    }
    pub fn set_exp_raw(&mut self, value: [u8; 4]) {
        self.exp_raw = value;
    }
    pub fn new() -> PacketZcMvpGettingSpecialExp {
        PacketZcMvpGettingSpecialExp {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x10, 0xb]),
        packet_id_raw: [0x10, 0xb],
        exp: 0,
        exp_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcMvpGettingSpecialExp {
    fn id(&self) -> &str {
       "0x010b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMvp {
    pub fn from(buffer: &[u8]) -> PacketZcMvp {
        PacketZcMvp {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketZcMvp {
        PacketZcMvp {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x10, 0xc]),
        packet_id_raw: [0x10, 0xc],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcMvp {
    fn id(&self) -> &str {
       "0x010c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcThrowMvpitem {
    pub fn from(buffer: &[u8]) -> PacketZcThrowMvpitem {
        PacketZcThrowMvpitem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketZcThrowMvpitem {
        PacketZcThrowMvpitem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x10, 0xd]),
        packet_id_raw: [0x10, 0xd],
        }
    }
}

impl Packet for PacketZcThrowMvpitem {
    fn id(&self) -> &str {
       "0x010d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSkillinfoUpdate {
    pub fn from(buffer: &[u8]) -> PacketZcSkillinfoUpdate {
        PacketZcSkillinfoUpdate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            level: i16::from_le_bytes([buffer[4], buffer[5]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            spcost: i16::from_le_bytes([buffer[6], buffer[7]]),
            spcost_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            attack_range: i16::from_le_bytes([buffer[8], buffer[9]]),
            attack_range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            upgradable: buffer[10] == 1,
            upgradable_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.spcost).unwrap();
        self.spcost_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.attack_range).unwrap();
        self.attack_range_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.upgradable as u8).unwrap();
        self.upgradable_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.spcost_raw.to_vec());
        wtr.append(&mut self.attack_range_raw.to_vec());
        wtr.append(&mut self.upgradable_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_spcost(&mut self, value: i16) {
        self.spcost = value;
    }
    pub fn set_spcost_raw(&mut self, value: [u8; 2]) {
        self.spcost_raw = value;
    }
    pub fn set_attack_range(&mut self, value: i16) {
        self.attack_range = value;
    }
    pub fn set_attack_range_raw(&mut self, value: [u8; 2]) {
        self.attack_range_raw = value;
    }
    pub fn set_upgradable(&mut self, value: bool) {
        self.upgradable = value;
    }
    pub fn set_upgradable_raw(&mut self, value: [u8; 1]) {
        self.upgradable_raw = value;
    }
    pub fn new() -> PacketZcSkillinfoUpdate {
        PacketZcSkillinfoUpdate {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x10, 0xe]),
        packet_id_raw: [0x10, 0xe],
        skid: 0,
        skid_raw: [0; 2],
        level: 0,
        level_raw: [0; 2],
        spcost: 0,
        spcost_raw: [0; 2],
        attack_range: 0,
        attack_range_raw: [0; 2],
        upgradable: false,
        upgradable_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcSkillinfoUpdate {
    fn id(&self) -> &str {
       "0x010e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSkillinfoList {
    pub fn from(buffer: &[u8]) -> PacketZcSkillinfoList {
        let iter_count = (&buffer.len() - 4) / 37;
        let mut vec_field: Vec<SKILLINFO> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (37 * (i - 1));
            let end_pos = 4 + 37 * i;
            vec_field.push(SKILLINFO::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcSkillinfoList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            skill_list: vec_field.clone(),
            skill_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.skill_list_raw = {
            self.skill_list.iter_mut().for_each(|item| item.fill_raw());
            self.skill_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.skill_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_skill_list(&mut self, value: Vec<SKILLINFO>) {
        self.skill_list = value;
    }
    pub fn set_skill_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.skill_list_raw = value;
    }
    pub fn new() -> PacketZcSkillinfoList {
        PacketZcSkillinfoList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x10, 0xf]),
        packet_id_raw: [0x10, 0xf],
        packet_length: 0,
        packet_length_raw: [0; 2],
        skill_list: vec![],
        skill_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcSkillinfoList {
    fn id(&self) -> &str {
       "0x010f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckTouseskill {
    pub fn from(buffer: &[u8]) -> PacketZcAckTouseskill {
        PacketZcAckTouseskill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            num: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            result: buffer[8] == 1,
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            cause: u8::from_le_bytes([buffer[9]]),
            cause_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.num).unwrap();
        self.num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.cause).unwrap();
        self.cause_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.num_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.cause_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_num(&mut self, value: u32) {
        self.num = value;
    }
    pub fn set_num_raw(&mut self, value: [u8; 4]) {
        self.num_raw = value;
    }
    pub fn set_result(&mut self, value: bool) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn set_cause(&mut self, value: u8) {
        self.cause = value;
    }
    pub fn set_cause_raw(&mut self, value: [u8; 1]) {
        self.cause_raw = value;
    }
    pub fn new() -> PacketZcAckTouseskill {
        PacketZcAckTouseskill {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x11, 0x0]),
        packet_id_raw: [0x11, 0x0],
        skid: 0,
        skid_raw: [0; 2],
        num: 0,
        num_raw: [0; 4],
        result: false,
        result_raw: [0; 1],
        cause: 0,
        cause_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckTouseskill {
    fn id(&self) -> &str {
       "0x0110"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAddSkill {
    pub fn from(buffer: &[u8]) -> PacketZcAddSkill {
        PacketZcAddSkill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            data: SKILLINFO::from(&buffer[2..buffer.len()]),
            data_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.data.fill_raw();
        self.data_raw = self.data.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_data(&mut self, value: SKILLINFO) {
        self.data = value;
    }
    pub fn set_data_raw(&mut self, value: Vec<u8>) {
        self.data_raw = value;
    }
    pub fn new() -> PacketZcAddSkill {
        PacketZcAddSkill {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x11, 0x1]),
        packet_id_raw: [0x11, 0x1],
        data: SKILLINFO::new(),
        data_raw: vec![],
        }
    }
}

impl Packet for PacketZcAddSkill {
    fn id(&self) -> &str {
       "0x0111"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzUpgradeSkilllevel {
    pub fn from(buffer: &[u8]) -> PacketCzUpgradeSkilllevel {
        PacketCzUpgradeSkilllevel {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn new() -> PacketCzUpgradeSkilllevel {
        PacketCzUpgradeSkilllevel {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x11, 0x2]),
        packet_id_raw: [0x11, 0x2],
        skid: 0,
        skid_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzUpgradeSkilllevel {
    fn id(&self) -> &str {
       "0x0112"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzUseSkill {
    pub fn from(buffer: &[u8]) -> PacketCzUseSkill {
        PacketCzUseSkill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            selected_level: i16::from_le_bytes([buffer[2], buffer[3]]),
            selected_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            skid: u16::from_le_bytes([buffer[4], buffer[5]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            target_id: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.selected_level).unwrap();
        self.selected_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.selected_level_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.target_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_selected_level(&mut self, value: i16) {
        self.selected_level = value;
    }
    pub fn set_selected_level_raw(&mut self, value: [u8; 2]) {
        self.selected_level_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_target_id(&mut self, value: u32) {
        self.target_id = value;
    }
    pub fn set_target_id_raw(&mut self, value: [u8; 4]) {
        self.target_id_raw = value;
    }
    pub fn new() -> PacketCzUseSkill {
        PacketCzUseSkill {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x11, 0x3]),
        packet_id_raw: [0x11, 0x3],
        selected_level: 0,
        selected_level_raw: [0; 2],
        skid: 0,
        skid_raw: [0; 2],
        target_id: 0,
        target_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzUseSkill {
    fn id(&self) -> &str {
       "0x0113"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifySkill {
    pub fn from(buffer: &[u8]) -> PacketZcNotifySkill {
        PacketZcNotifySkill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            target_id: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            start_time: u32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            attack_mt: i32::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19]]),
            attack_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[16..20]);
                dst
            },
            attacked_mt: i32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            attacked_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
            damage: i16::from_le_bytes([buffer[24], buffer[25]]),
            damage_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            level: i16::from_le_bytes([buffer[26], buffer[27]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            count: i16::from_le_bytes([buffer[28], buffer[29]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            action: u8::from_le_bytes([buffer[30]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[30..31]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attack_mt).unwrap();
        self.attack_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attacked_mt).unwrap();
        self.attacked_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.damage).unwrap();
        self.damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.target_id_raw.to_vec());
        wtr.append(&mut self.start_time_raw.to_vec());
        wtr.append(&mut self.attack_mt_raw.to_vec());
        wtr.append(&mut self.attacked_mt_raw.to_vec());
        wtr.append(&mut self.damage_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_target_id(&mut self, value: u32) {
        self.target_id = value;
    }
    pub fn set_target_id_raw(&mut self, value: [u8; 4]) {
        self.target_id_raw = value;
    }
    pub fn set_start_time(&mut self, value: u32) {
        self.start_time = value;
    }
    pub fn set_start_time_raw(&mut self, value: [u8; 4]) {
        self.start_time_raw = value;
    }
    pub fn set_attack_mt(&mut self, value: i32) {
        self.attack_mt = value;
    }
    pub fn set_attack_mt_raw(&mut self, value: [u8; 4]) {
        self.attack_mt_raw = value;
    }
    pub fn set_attacked_mt(&mut self, value: i32) {
        self.attacked_mt = value;
    }
    pub fn set_attacked_mt_raw(&mut self, value: [u8; 4]) {
        self.attacked_mt_raw = value;
    }
    pub fn set_damage(&mut self, value: i16) {
        self.damage = value;
    }
    pub fn set_damage_raw(&mut self, value: [u8; 2]) {
        self.damage_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn new() -> PacketZcNotifySkill {
        PacketZcNotifySkill {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x11, 0x4]),
        packet_id_raw: [0x11, 0x4],
        skid: 0,
        skid_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        target_id: 0,
        target_id_raw: [0; 4],
        start_time: 0,
        start_time_raw: [0; 4],
        attack_mt: 0,
        attack_mt_raw: [0; 4],
        attacked_mt: 0,
        attacked_mt_raw: [0; 4],
        damage: 0,
        damage_raw: [0; 2],
        level: 0,
        level_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        action: 0,
        action_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcNotifySkill {
    fn id(&self) -> &str {
       "0x0114"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifySkillPosition {
    pub fn from(buffer: &[u8]) -> PacketZcNotifySkillPosition {
        PacketZcNotifySkillPosition {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            target_id: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            start_time: u32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            attack_mt: i32::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19]]),
            attack_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[16..20]);
                dst
            },
            attacked_mt: i32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            attacked_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[24], buffer[25]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[26], buffer[27]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            damage: i16::from_le_bytes([buffer[28], buffer[29]]),
            damage_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            level: i16::from_le_bytes([buffer[30], buffer[31]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            count: i16::from_le_bytes([buffer[32], buffer[33]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            action: u8::from_le_bytes([buffer[34]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[34..35]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attack_mt).unwrap();
        self.attack_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attacked_mt).unwrap();
        self.attacked_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.damage).unwrap();
        self.damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.target_id_raw.to_vec());
        wtr.append(&mut self.start_time_raw.to_vec());
        wtr.append(&mut self.attack_mt_raw.to_vec());
        wtr.append(&mut self.attacked_mt_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.damage_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_target_id(&mut self, value: u32) {
        self.target_id = value;
    }
    pub fn set_target_id_raw(&mut self, value: [u8; 4]) {
        self.target_id_raw = value;
    }
    pub fn set_start_time(&mut self, value: u32) {
        self.start_time = value;
    }
    pub fn set_start_time_raw(&mut self, value: [u8; 4]) {
        self.start_time_raw = value;
    }
    pub fn set_attack_mt(&mut self, value: i32) {
        self.attack_mt = value;
    }
    pub fn set_attack_mt_raw(&mut self, value: [u8; 4]) {
        self.attack_mt_raw = value;
    }
    pub fn set_attacked_mt(&mut self, value: i32) {
        self.attacked_mt = value;
    }
    pub fn set_attacked_mt_raw(&mut self, value: [u8; 4]) {
        self.attacked_mt_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_damage(&mut self, value: i16) {
        self.damage = value;
    }
    pub fn set_damage_raw(&mut self, value: [u8; 2]) {
        self.damage_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn new() -> PacketZcNotifySkillPosition {
        PacketZcNotifySkillPosition {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x11, 0x5]),
        packet_id_raw: [0x11, 0x5],
        skid: 0,
        skid_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        target_id: 0,
        target_id_raw: [0; 4],
        start_time: 0,
        start_time_raw: [0; 4],
        attack_mt: 0,
        attack_mt_raw: [0; 4],
        attacked_mt: 0,
        attacked_mt_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        damage: 0,
        damage_raw: [0; 2],
        level: 0,
        level_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        action: 0,
        action_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcNotifySkillPosition {
    fn id(&self) -> &str {
       "0x0115"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzUseSkillToground {
    pub fn from(buffer: &[u8]) -> PacketCzUseSkillToground {
        PacketCzUseSkillToground {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            selected_level: i16::from_le_bytes([buffer[2], buffer[3]]),
            selected_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            skid: u16::from_le_bytes([buffer[4], buffer[5]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[6], buffer[7]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[8], buffer[9]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.selected_level).unwrap();
        self.selected_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.selected_level_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_selected_level(&mut self, value: i16) {
        self.selected_level = value;
    }
    pub fn set_selected_level_raw(&mut self, value: [u8; 2]) {
        self.selected_level_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn new() -> PacketCzUseSkillToground {
        PacketCzUseSkillToground {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x11, 0x6]),
        packet_id_raw: [0x11, 0x6],
        selected_level: 0,
        selected_level_raw: [0; 2],
        skid: 0,
        skid_raw: [0; 2],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzUseSkillToground {
    fn id(&self) -> &str {
       "0x0116"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyGroundskill {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyGroundskill {
        PacketZcNotifyGroundskill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            level: i16::from_le_bytes([buffer[8], buffer[9]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[10], buffer[11]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[12], buffer[13]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            start_time: u32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.start_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_start_time(&mut self, value: u32) {
        self.start_time = value;
    }
    pub fn set_start_time_raw(&mut self, value: [u8; 4]) {
        self.start_time_raw = value;
    }
    pub fn new() -> PacketZcNotifyGroundskill {
        PacketZcNotifyGroundskill {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x11, 0x7]),
        packet_id_raw: [0x11, 0x7],
        skid: 0,
        skid_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        level: 0,
        level_raw: [0; 2],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        start_time: 0,
        start_time_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyGroundskill {
    fn id(&self) -> &str {
       "0x0117"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzCancelLockon {
    pub fn from(buffer: &[u8]) -> PacketCzCancelLockon {
        PacketCzCancelLockon {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzCancelLockon {
        PacketCzCancelLockon {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x11, 0x8]),
        packet_id_raw: [0x11, 0x8],
        }
    }
}

impl Packet for PacketCzCancelLockon {
    fn id(&self) -> &str {
       "0x0118"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcStateChange {
    pub fn from(buffer: &[u8]) -> PacketZcStateChange {
        PacketZcStateChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[6], buffer[7]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            effect_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            is_pkmode_on: buffer[12] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i16) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 2]) {
        self.effect_state_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn new() -> PacketZcStateChange {
        PacketZcStateChange {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x11, 0x9]),
        packet_id_raw: [0x11, 0x9],
        aid: 0,
        aid_raw: [0; 4],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 2],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcStateChange {
    fn id(&self) -> &str {
       "0x0119"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcUseSkill {
    pub fn from(buffer: &[u8]) -> PacketZcUseSkill {
        PacketZcUseSkill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            level: i16::from_le_bytes([buffer[4], buffer[5]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            target_aid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            src_aid: u32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            src_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            result: buffer[14] == 1,
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_aid).unwrap();
        self.target_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.src_aid).unwrap();
        self.src_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.target_aid_raw.to_vec());
        wtr.append(&mut self.src_aid_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_target_aid(&mut self, value: u32) {
        self.target_aid = value;
    }
    pub fn set_target_aid_raw(&mut self, value: [u8; 4]) {
        self.target_aid_raw = value;
    }
    pub fn set_src_aid(&mut self, value: u32) {
        self.src_aid = value;
    }
    pub fn set_src_aid_raw(&mut self, value: [u8; 4]) {
        self.src_aid_raw = value;
    }
    pub fn set_result(&mut self, value: bool) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcUseSkill {
        PacketZcUseSkill {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x11, 0xa]),
        packet_id_raw: [0x11, 0xa],
        skid: 0,
        skid_raw: [0; 2],
        level: 0,
        level_raw: [0; 2],
        target_aid: 0,
        target_aid_raw: [0; 4],
        src_aid: 0,
        src_aid_raw: [0; 4],
        result: false,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcUseSkill {
    fn id(&self) -> &str {
       "0x011a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzSelectWarppoint {
    pub fn from(buffer: &[u8]) -> PacketCzSelectWarppoint {
        PacketCzSelectWarppoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[4..20].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[4..20]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn new() -> PacketCzSelectWarppoint {
        PacketCzSelectWarppoint {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x11, 0xb]),
        packet_id_raw: [0x11, 0xb],
        skid: 0,
        skid_raw: [0; 2],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        }
    }
}

impl Packet for PacketCzSelectWarppoint {
    fn id(&self) -> &str {
       "0x011b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcWarplist {
    pub fn from(buffer: &[u8]) -> PacketZcWarplist {
        PacketZcWarplist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            map_name:  {
                let mut dst: [char; 4] = [0 as char; 4];
                for (index, byte) in buffer[4..8].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 4]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 4]) {
        self.map_name_raw = value;
    }
    pub fn new() -> PacketZcWarplist {
        PacketZcWarplist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x11, 0xc]),
        packet_id_raw: [0x11, 0xc],
        skid: 0,
        skid_raw: [0; 2],
        map_name: [0 as char; 4],
        map_name_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcWarplist {
    fn id(&self) -> &str {
       "0x011c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRememberWarppoint {
    pub fn from(buffer: &[u8]) -> PacketCzRememberWarppoint {
        PacketCzRememberWarppoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzRememberWarppoint {
        PacketCzRememberWarppoint {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x11, 0xd]),
        packet_id_raw: [0x11, 0xd],
        }
    }
}

impl Packet for PacketCzRememberWarppoint {
    fn id(&self) -> &str {
       "0x011d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckRememberWarppoint {
    pub fn from(buffer: &[u8]) -> PacketZcAckRememberWarppoint {
        PacketZcAckRememberWarppoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: u8::from_le_bytes([buffer[2]]),
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u8) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 1]) {
        self.error_code_raw = value;
    }
    pub fn new() -> PacketZcAckRememberWarppoint {
        PacketZcAckRememberWarppoint {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x11, 0xe]),
        packet_id_raw: [0x11, 0xe],
        error_code: 0,
        error_code_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckRememberWarppoint {
    fn id(&self) -> &str {
       "0x011e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSkillEntry {
    pub fn from(buffer: &[u8]) -> PacketZcSkillEntry {
        PacketZcSkillEntry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            creator_aid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            creator_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[10], buffer[11]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[12], buffer[13]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: u8::from_le_bytes([buffer[14]]),
            job_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
            is_visible: buffer[15] == 1,
            is_visible_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[15..16]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.creator_aid).unwrap();
        self.creator_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_visible as u8).unwrap();
        self.is_visible_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.creator_aid_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.is_visible_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_creator_aid(&mut self, value: u32) {
        self.creator_aid = value;
    }
    pub fn set_creator_aid_raw(&mut self, value: [u8; 4]) {
        self.creator_aid_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_job(&mut self, value: u8) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 1]) {
        self.job_raw = value;
    }
    pub fn set_is_visible(&mut self, value: bool) {
        self.is_visible = value;
    }
    pub fn set_is_visible_raw(&mut self, value: [u8; 1]) {
        self.is_visible_raw = value;
    }
    pub fn new() -> PacketZcSkillEntry {
        PacketZcSkillEntry {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x11, 0xf]),
        packet_id_raw: [0x11, 0xf],
        aid: 0,
        aid_raw: [0; 4],
        creator_aid: 0,
        creator_aid_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        job: 0,
        job_raw: [0; 1],
        is_visible: false,
        is_visible_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcSkillEntry {
    fn id(&self) -> &str {
       "0x011f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSkillDisappear {
    pub fn from(buffer: &[u8]) -> PacketZcSkillDisappear {
        PacketZcSkillDisappear {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketZcSkillDisappear {
        PacketZcSkillDisappear {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x12, 0x0]),
        packet_id_raw: [0x12, 0x0],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcSkillDisappear {
    fn id(&self) -> &str {
       "0x0120"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyCartitemCountinfo {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyCartitemCountinfo {
        PacketZcNotifyCartitemCountinfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            cur_count: i16::from_le_bytes([buffer[2], buffer[3]]),
            cur_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            max_count: i16::from_le_bytes([buffer[4], buffer[5]]),
            max_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            cur_weight: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            cur_weight_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            max_weight: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            max_weight_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.cur_count).unwrap();
        self.cur_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_count).unwrap();
        self.max_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.cur_weight).unwrap();
        self.cur_weight_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_weight).unwrap();
        self.max_weight_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.cur_count_raw.to_vec());
        wtr.append(&mut self.max_count_raw.to_vec());
        wtr.append(&mut self.cur_weight_raw.to_vec());
        wtr.append(&mut self.max_weight_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_cur_count(&mut self, value: i16) {
        self.cur_count = value;
    }
    pub fn set_cur_count_raw(&mut self, value: [u8; 2]) {
        self.cur_count_raw = value;
    }
    pub fn set_max_count(&mut self, value: i16) {
        self.max_count = value;
    }
    pub fn set_max_count_raw(&mut self, value: [u8; 2]) {
        self.max_count_raw = value;
    }
    pub fn set_cur_weight(&mut self, value: i32) {
        self.cur_weight = value;
    }
    pub fn set_cur_weight_raw(&mut self, value: [u8; 4]) {
        self.cur_weight_raw = value;
    }
    pub fn set_max_weight(&mut self, value: i32) {
        self.max_weight = value;
    }
    pub fn set_max_weight_raw(&mut self, value: [u8; 4]) {
        self.max_weight_raw = value;
    }
    pub fn new() -> PacketZcNotifyCartitemCountinfo {
        PacketZcNotifyCartitemCountinfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x12, 0x1]),
        packet_id_raw: [0x12, 0x1],
        cur_count: 0,
        cur_count_raw: [0; 2],
        max_count: 0,
        max_count_raw: [0; 2],
        cur_weight: 0,
        cur_weight_raw: [0; 4],
        max_weight: 0,
        max_weight_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyCartitemCountinfo {
    fn id(&self) -> &str {
       "0x0121"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcCartEquipmentItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcCartEquipmentItemlist {
        let iter_count = (&buffer.len() - 4) / 20;
        let mut vec_field: Vec<EquipmentitemExtrainfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (20 * (i - 1));
            let end_pos = 4 + 20 * i;
            vec_field.push(EquipmentitemExtrainfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcCartEquipmentItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new() -> PacketZcCartEquipmentItemlist {
        PacketZcCartEquipmentItemlist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x12, 0x2]),
        packet_id_raw: [0x12, 0x2],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcCartEquipmentItemlist {
    fn id(&self) -> &str {
       "0x0122"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcCartNormalItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcCartNormalItemlist {
        let iter_count = (&buffer.len() - 4) / 10;
        let mut vec_field: Vec<NormalitemExtrainfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (10 * (i - 1));
            let end_pos = 4 + 10 * i;
            vec_field.push(NormalitemExtrainfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcCartNormalItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<NormalitemExtrainfo>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new() -> PacketZcCartNormalItemlist {
        PacketZcCartNormalItemlist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x12, 0x3]),
        packet_id_raw: [0x12, 0x3],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcCartNormalItemlist {
    fn id(&self) -> &str {
       "0x0123"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAddItemToCart {
    pub fn from(buffer: &[u8]) -> PacketZcAddItemToCart {
        PacketZcAddItemToCart {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            itid: u16::from_le_bytes([buffer[8], buffer[9]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            is_identified: buffer[10] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            is_damaged: buffer[11] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[12]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[13..21]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[13..21]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new() -> PacketZcAddItemToCart {
        PacketZcAddItemToCart {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x12, 0x4]),
        packet_id_raw: [0x12, 0x4],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        }
    }
}

impl Packet for PacketZcAddItemToCart {
    fn id(&self) -> &str {
       "0x0124"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcDeleteItemFromCart {
    pub fn from(buffer: &[u8]) -> PacketZcDeleteItemFromCart {
        PacketZcDeleteItemFromCart {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketZcDeleteItemFromCart {
        PacketZcDeleteItemFromCart {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x12, 0x5]),
        packet_id_raw: [0x12, 0x5],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDeleteItemFromCart {
    fn id(&self) -> &str {
       "0x0125"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzMoveItemFromBodyToCart {
    pub fn from(buffer: &[u8]) -> PacketCzMoveItemFromBodyToCart {
        PacketCzMoveItemFromBodyToCart {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketCzMoveItemFromBodyToCart {
        PacketCzMoveItemFromBodyToCart {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x12, 0x6]),
        packet_id_raw: [0x12, 0x6],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMoveItemFromBodyToCart {
    fn id(&self) -> &str {
       "0x0126"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzMoveItemFromCartToBody {
    pub fn from(buffer: &[u8]) -> PacketCzMoveItemFromCartToBody {
        PacketCzMoveItemFromCartToBody {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketCzMoveItemFromCartToBody {
        PacketCzMoveItemFromCartToBody {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x12, 0x7]),
        packet_id_raw: [0x12, 0x7],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMoveItemFromCartToBody {
    fn id(&self) -> &str {
       "0x0127"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzMoveItemFromStoreToCart {
    pub fn from(buffer: &[u8]) -> PacketCzMoveItemFromStoreToCart {
        PacketCzMoveItemFromStoreToCart {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketCzMoveItemFromStoreToCart {
        PacketCzMoveItemFromStoreToCart {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x12, 0x8]),
        packet_id_raw: [0x12, 0x8],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMoveItemFromStoreToCart {
    fn id(&self) -> &str {
       "0x0128"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzMoveItemFromCartToStore {
    pub fn from(buffer: &[u8]) -> PacketCzMoveItemFromCartToStore {
        PacketCzMoveItemFromCartToStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketCzMoveItemFromCartToStore {
        PacketCzMoveItemFromCartToStore {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x12, 0x9]),
        packet_id_raw: [0x12, 0x9],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMoveItemFromCartToStore {
    fn id(&self) -> &str {
       "0x0129"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqCartoff {
    pub fn from(buffer: &[u8]) -> PacketCzReqCartoff {
        PacketCzReqCartoff {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzReqCartoff {
        PacketCzReqCartoff {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x12, 0xa]),
        packet_id_raw: [0x12, 0xa],
        }
    }
}

impl Packet for PacketCzReqCartoff {
    fn id(&self) -> &str {
       "0x012a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcCartoff {
    pub fn from(buffer: &[u8]) -> PacketZcCartoff {
        PacketZcCartoff {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketZcCartoff {
        PacketZcCartoff {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x12, 0xb]),
        packet_id_raw: [0x12, 0xb],
        }
    }
}

impl Packet for PacketZcCartoff {
    fn id(&self) -> &str {
       "0x012b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckAdditemToCart {
    pub fn from(buffer: &[u8]) -> PacketZcAckAdditemToCart {
        PacketZcAckAdditemToCart {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcAckAdditemToCart {
        PacketZcAckAdditemToCart {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x12, 0xc]),
        packet_id_raw: [0x12, 0xc],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckAdditemToCart {
    fn id(&self) -> &str {
       "0x012c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcOpenstore {
    pub fn from(buffer: &[u8]) -> PacketZcOpenstore {
        PacketZcOpenstore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itemcount: i16::from_le_bytes([buffer[2], buffer[3]]),
            itemcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.itemcount).unwrap();
        self.itemcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itemcount_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itemcount(&mut self, value: i16) {
        self.itemcount = value;
    }
    pub fn set_itemcount_raw(&mut self, value: [u8; 2]) {
        self.itemcount_raw = value;
    }
    pub fn new() -> PacketZcOpenstore {
        PacketZcOpenstore {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x12, 0xd]),
        packet_id_raw: [0x12, 0xd],
        itemcount: 0,
        itemcount_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcOpenstore {
    fn id(&self) -> &str {
       "0x012d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqClosestore {
    pub fn from(buffer: &[u8]) -> PacketCzReqClosestore {
        PacketCzReqClosestore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzReqClosestore {
        PacketCzReqClosestore {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x12, 0xe]),
        packet_id_raw: [0x12, 0xe],
        }
    }
}

impl Packet for PacketCzReqClosestore {
    fn id(&self) -> &str {
       "0x012e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqOpenstore {
    pub fn from(buffer: &[u8]) -> PacketCzReqOpenstore {
        let iter_count = (&buffer.len() - 84) / 8;
        let mut vec_field: Vec<StoreItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 84 + (8 * (i - 1));
            let end_pos = 84 + 8 * i;
            vec_field.push(StoreItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzReqOpenstore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            store_name:  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[4..84].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            store_name_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[4..84]);
                dst
            },
            store_list: vec_field.clone(),
            store_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.store_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.store_name_raw = wtr.try_into().unwrap();
        self.store_list_raw = {
            self.store_list.iter_mut().for_each(|item| item.fill_raw());
            self.store_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.store_name_raw.to_vec());
        self.store_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_store_name(&mut self, value: [char; 80]) {
        self.store_name = value;
    }
    pub fn set_store_name_raw(&mut self, value: [u8; 80]) {
        self.store_name_raw = value;
    }
    pub fn set_store_list(&mut self, value: Vec<StoreItem>) {
        self.store_list = value;
    }
    pub fn set_store_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.store_list_raw = value;
    }
    pub fn new() -> PacketCzReqOpenstore {
        PacketCzReqOpenstore {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x12, 0xf]),
        packet_id_raw: [0x12, 0xf],
        packet_length: 0,
        packet_length_raw: [0; 2],
        store_name: [0 as char; 80],
        store_name_raw: [0; 80],
        store_list: vec![],
        store_list_raw: vec![],
        }
    }
}

impl Packet for PacketCzReqOpenstore {
    fn id(&self) -> &str {
       "0x012f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqBuyFrommc {
    pub fn from(buffer: &[u8]) -> PacketCzReqBuyFrommc {
        PacketCzReqBuyFrommc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketCzReqBuyFrommc {
        PacketCzReqBuyFrommc {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x13, 0x0]),
        packet_id_raw: [0x13, 0x0],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqBuyFrommc {
    fn id(&self) -> &str {
       "0x0130"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcStoreEntry {
    pub fn from(buffer: &[u8]) -> PacketZcStoreEntry {
        PacketZcStoreEntry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            maker_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            store_name:  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[6..86].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            store_name_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[6..86]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.store_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.store_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.maker_aid_raw.to_vec());
        wtr.append(&mut self.store_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_maker_aid(&mut self, value: u32) {
        self.maker_aid = value;
    }
    pub fn set_maker_aid_raw(&mut self, value: [u8; 4]) {
        self.maker_aid_raw = value;
    }
    pub fn set_store_name(&mut self, value: [char; 80]) {
        self.store_name = value;
    }
    pub fn set_store_name_raw(&mut self, value: [u8; 80]) {
        self.store_name_raw = value;
    }
    pub fn new() -> PacketZcStoreEntry {
        PacketZcStoreEntry {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x13, 0x1]),
        packet_id_raw: [0x13, 0x1],
        maker_aid: 0,
        maker_aid_raw: [0; 4],
        store_name: [0 as char; 80],
        store_name_raw: [0; 80],
        }
    }
}

impl Packet for PacketZcStoreEntry {
    fn id(&self) -> &str {
       "0x0131"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcDisappearEntry {
    pub fn from(buffer: &[u8]) -> PacketZcDisappearEntry {
        PacketZcDisappearEntry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            maker_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.maker_aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_maker_aid(&mut self, value: u32) {
        self.maker_aid = value;
    }
    pub fn set_maker_aid_raw(&mut self, value: [u8; 4]) {
        self.maker_aid_raw = value;
    }
    pub fn new() -> PacketZcDisappearEntry {
        PacketZcDisappearEntry {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x13, 0x2]),
        packet_id_raw: [0x13, 0x2],
        maker_aid: 0,
        maker_aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDisappearEntry {
    fn id(&self) -> &str {
       "0x0132"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPcPurchaseItemlistFrommc {
    pub fn from(buffer: &[u8]) -> PacketZcPcPurchaseItemlistFrommc {
        let iter_count = (&buffer.len() - 8) / 22;
        let mut vec_field: Vec<PurchaseItemFrommc> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (22 * (i - 1));
            let end_pos = 8 + 22 * i;
            vec_field.push(PurchaseItemFrommc::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPcPurchaseItemlistFrommc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<PurchaseItemFrommc>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new() -> PacketZcPcPurchaseItemlistFrommc {
        PacketZcPcPurchaseItemlistFrommc {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x13, 0x3]),
        packet_id_raw: [0x13, 0x3],
        packet_length: 0,
        packet_length_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcPcPurchaseItemlistFrommc {
    fn id(&self) -> &str {
       "0x0133"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzPcPurchaseItemlistFrommc {
    pub fn from(buffer: &[u8]) -> PacketCzPcPurchaseItemlistFrommc {
        let iter_count = (&buffer.len() - 8) / 4;
        let mut vec_field: Vec<CzPurchaseItemFrommc> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (4 * (i - 1));
            let end_pos = 8 + 4 * i;
            vec_field.push(CzPurchaseItemFrommc::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzPcPurchaseItemlistFrommc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<CzPurchaseItemFrommc>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new() -> PacketCzPcPurchaseItemlistFrommc {
        PacketCzPcPurchaseItemlistFrommc {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x13, 0x4]),
        packet_id_raw: [0x13, 0x4],
        packet_length: 0,
        packet_length_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketCzPcPurchaseItemlistFrommc {
    fn id(&self) -> &str {
       "0x0134"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPcPurchaseResultFrommc {
    pub fn from(buffer: &[u8]) -> PacketZcPcPurchaseResultFrommc {
        PacketZcPcPurchaseResultFrommc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            curcount: i16::from_le_bytes([buffer[4], buffer[5]]),
            curcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            result: u8::from_le_bytes([buffer[6]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.curcount).unwrap();
        self.curcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.curcount_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_curcount(&mut self, value: i16) {
        self.curcount = value;
    }
    pub fn set_curcount_raw(&mut self, value: [u8; 2]) {
        self.curcount_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcPcPurchaseResultFrommc {
        PacketZcPcPurchaseResultFrommc {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x13, 0x5]),
        packet_id_raw: [0x13, 0x5],
        index: 0,
        index_raw: [0; 2],
        curcount: 0,
        curcount_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcPcPurchaseResultFrommc {
    fn id(&self) -> &str {
       "0x0135"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPcPurchaseMyitemlist {
    pub fn from(buffer: &[u8]) -> PacketZcPcPurchaseMyitemlist {
        let iter_count = (&buffer.len() - 8) / 22;
        let mut vec_field: Vec<PurchaseMyitem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (22 * (i - 1));
            let end_pos = 8 + 22 * i;
            vec_field.push(PurchaseMyitem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPcPurchaseMyitemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<PurchaseMyitem>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new() -> PacketZcPcPurchaseMyitemlist {
        PacketZcPcPurchaseMyitemlist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x13, 0x6]),
        packet_id_raw: [0x13, 0x6],
        packet_length: 0,
        packet_length_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcPcPurchaseMyitemlist {
    fn id(&self) -> &str {
       "0x0136"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcDeleteitemFromMcstore {
    pub fn from(buffer: &[u8]) -> PacketZcDeleteitemFromMcstore {
        PacketZcDeleteitemFromMcstore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketZcDeleteitemFromMcstore {
        PacketZcDeleteitemFromMcstore {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x13, 0x7]),
        packet_id_raw: [0x13, 0x7],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcDeleteitemFromMcstore {
    fn id(&self) -> &str {
       "0x0137"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzPkmodeChange {
    pub fn from(buffer: &[u8]) -> PacketCzPkmodeChange {
        PacketCzPkmodeChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            is_turn_on: buffer[2] == 1,
            is_turn_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_turn_on as u8).unwrap();
        self.is_turn_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.is_turn_on_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_is_turn_on(&mut self, value: bool) {
        self.is_turn_on = value;
    }
    pub fn set_is_turn_on_raw(&mut self, value: [u8; 1]) {
        self.is_turn_on_raw = value;
    }
    pub fn new() -> PacketCzPkmodeChange {
        PacketCzPkmodeChange {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x13, 0x8]),
        packet_id_raw: [0x13, 0x8],
        is_turn_on: false,
        is_turn_on_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzPkmodeChange {
    fn id(&self) -> &str {
       "0x0138"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAttackFailureForDistance {
    pub fn from(buffer: &[u8]) -> PacketZcAttackFailureForDistance {
        PacketZcAttackFailureForDistance {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            target_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            target_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            target_xpos: i16::from_le_bytes([buffer[6], buffer[7]]),
            target_xpos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            target_ypos: i16::from_le_bytes([buffer[8], buffer[9]]),
            target_ypos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[10], buffer[11]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[12], buffer[13]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            current_att_range: i16::from_le_bytes([buffer[14], buffer[15]]),
            current_att_range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_aid).unwrap();
        self.target_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.target_xpos).unwrap();
        self.target_xpos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.target_ypos).unwrap();
        self.target_ypos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.current_att_range).unwrap();
        self.current_att_range_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.target_aid_raw.to_vec());
        wtr.append(&mut self.target_xpos_raw.to_vec());
        wtr.append(&mut self.target_ypos_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.current_att_range_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_target_aid(&mut self, value: u32) {
        self.target_aid = value;
    }
    pub fn set_target_aid_raw(&mut self, value: [u8; 4]) {
        self.target_aid_raw = value;
    }
    pub fn set_target_xpos(&mut self, value: i16) {
        self.target_xpos = value;
    }
    pub fn set_target_xpos_raw(&mut self, value: [u8; 2]) {
        self.target_xpos_raw = value;
    }
    pub fn set_target_ypos(&mut self, value: i16) {
        self.target_ypos = value;
    }
    pub fn set_target_ypos_raw(&mut self, value: [u8; 2]) {
        self.target_ypos_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_current_att_range(&mut self, value: i16) {
        self.current_att_range = value;
    }
    pub fn set_current_att_range_raw(&mut self, value: [u8; 2]) {
        self.current_att_range_raw = value;
    }
    pub fn new() -> PacketZcAttackFailureForDistance {
        PacketZcAttackFailureForDistance {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x13, 0x9]),
        packet_id_raw: [0x13, 0x9],
        target_aid: 0,
        target_aid_raw: [0; 4],
        target_xpos: 0,
        target_xpos_raw: [0; 2],
        target_ypos: 0,
        target_ypos_raw: [0; 2],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        current_att_range: 0,
        current_att_range_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAttackFailureForDistance {
    fn id(&self) -> &str {
       "0x0139"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAttackRange {
    pub fn from(buffer: &[u8]) -> PacketZcAttackRange {
        PacketZcAttackRange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            current_att_range: i16::from_le_bytes([buffer[2], buffer[3]]),
            current_att_range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.current_att_range).unwrap();
        self.current_att_range_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.current_att_range_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_current_att_range(&mut self, value: i16) {
        self.current_att_range = value;
    }
    pub fn set_current_att_range_raw(&mut self, value: [u8; 2]) {
        self.current_att_range_raw = value;
    }
    pub fn new() -> PacketZcAttackRange {
        PacketZcAttackRange {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x13, 0xa]),
        packet_id_raw: [0x13, 0xa],
        current_att_range: 0,
        current_att_range_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAttackRange {
    fn id(&self) -> &str {
       "0x013a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcActionFailure {
    pub fn from(buffer: &[u8]) -> PacketZcActionFailure {
        PacketZcActionFailure {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: i16) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 2]) {
        self.error_code_raw = value;
    }
    pub fn new() -> PacketZcActionFailure {
        PacketZcActionFailure {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x13, 0xb]),
        packet_id_raw: [0x13, 0xb],
        error_code: 0,
        error_code_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcActionFailure {
    fn id(&self) -> &str {
       "0x013b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcEquipArrow {
    pub fn from(buffer: &[u8]) -> PacketZcEquipArrow {
        PacketZcEquipArrow {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn new() -> PacketZcEquipArrow {
        PacketZcEquipArrow {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x13, 0xc]),
        packet_id_raw: [0x13, 0xc],
        index: 0,
        index_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcEquipArrow {
    fn id(&self) -> &str {
       "0x013c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcRecovery {
    pub fn from(buffer: &[u8]) -> PacketZcRecovery {
        PacketZcRecovery {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            var_id: i16::from_le_bytes([buffer[2], buffer[3]]),
            var_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            amount: i16::from_le_bytes([buffer[4], buffer[5]]),
            amount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.var_id).unwrap();
        self.var_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.amount).unwrap();
        self.amount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.var_id_raw.to_vec());
        wtr.append(&mut self.amount_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_var_id(&mut self, value: i16) {
        self.var_id = value;
    }
    pub fn set_var_id_raw(&mut self, value: [u8; 2]) {
        self.var_id_raw = value;
    }
    pub fn set_amount(&mut self, value: i16) {
        self.amount = value;
    }
    pub fn set_amount_raw(&mut self, value: [u8; 2]) {
        self.amount_raw = value;
    }
    pub fn new() -> PacketZcRecovery {
        PacketZcRecovery {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x13, 0xd]),
        packet_id_raw: [0x13, 0xd],
        var_id: 0,
        var_id_raw: [0; 2],
        amount: 0,
        amount_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcRecovery {
    fn id(&self) -> &str {
       "0x013d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcUseskillAck {
    pub fn from(buffer: &[u8]) -> PacketZcUseskillAck {
        PacketZcUseskillAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            target_id: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[10], buffer[11]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[12], buffer[13]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            skid: u16::from_le_bytes([buffer[14], buffer[15]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            property: u32::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19]]),
            property_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[16..20]);
                dst
            },
            delay_time: u32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            delay_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.property).unwrap();
        self.property_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.delay_time).unwrap();
        self.delay_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.target_id_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.property_raw.to_vec());
        wtr.append(&mut self.delay_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_target_id(&mut self, value: u32) {
        self.target_id = value;
    }
    pub fn set_target_id_raw(&mut self, value: [u8; 4]) {
        self.target_id_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_property(&mut self, value: u32) {
        self.property = value;
    }
    pub fn set_property_raw(&mut self, value: [u8; 4]) {
        self.property_raw = value;
    }
    pub fn set_delay_time(&mut self, value: u32) {
        self.delay_time = value;
    }
    pub fn set_delay_time_raw(&mut self, value: [u8; 4]) {
        self.delay_time_raw = value;
    }
    pub fn new() -> PacketZcUseskillAck {
        PacketZcUseskillAck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x13, 0xe]),
        packet_id_raw: [0x13, 0xe],
        aid: 0,
        aid_raw: [0; 4],
        target_id: 0,
        target_id_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        skid: 0,
        skid_raw: [0; 2],
        property: 0,
        property_raw: [0; 4],
        delay_time: 0,
        delay_time_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcUseskillAck {
    fn id(&self) -> &str {
       "0x013e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzItemCreate {
    pub fn from(buffer: &[u8]) -> PacketCzItemCreate {
        PacketCzItemCreate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            item_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            item_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.item_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.item_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.item_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_item_name(&mut self, value: [char; 24]) {
        self.item_name = value;
    }
    pub fn set_item_name_raw(&mut self, value: [u8; 24]) {
        self.item_name_raw = value;
    }
    pub fn new() -> PacketCzItemCreate {
        PacketCzItemCreate {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x13, 0xf]),
        packet_id_raw: [0x13, 0xf],
        item_name: [0 as char; 24],
        item_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzItemCreate {
    fn id(&self) -> &str {
       "0x013f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzMovetoMap {
    pub fn from(buffer: &[u8]) -> PacketCzMovetoMap {
        PacketCzMovetoMap {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[2..18].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[2..18]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[18], buffer[19]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[20], buffer[21]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn new() -> PacketCzMovetoMap {
        PacketCzMovetoMap {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x14, 0x0]),
        packet_id_raw: [0x14, 0x0],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzMovetoMap {
    fn id(&self) -> &str {
       "0x0140"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcCouplestatus {
    pub fn from(buffer: &[u8]) -> PacketZcCouplestatus {
        PacketZcCouplestatus {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            status_type: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            status_type_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            default_status: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            default_status_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            plus_status: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            plus_status_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.status_type).unwrap();
        self.status_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.default_status).unwrap();
        self.default_status_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.plus_status).unwrap();
        self.plus_status_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.status_type_raw.to_vec());
        wtr.append(&mut self.default_status_raw.to_vec());
        wtr.append(&mut self.plus_status_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_status_type(&mut self, value: u32) {
        self.status_type = value;
    }
    pub fn set_status_type_raw(&mut self, value: [u8; 4]) {
        self.status_type_raw = value;
    }
    pub fn set_default_status(&mut self, value: i32) {
        self.default_status = value;
    }
    pub fn set_default_status_raw(&mut self, value: [u8; 4]) {
        self.default_status_raw = value;
    }
    pub fn set_plus_status(&mut self, value: i32) {
        self.plus_status = value;
    }
    pub fn set_plus_status_raw(&mut self, value: [u8; 4]) {
        self.plus_status_raw = value;
    }
    pub fn new() -> PacketZcCouplestatus {
        PacketZcCouplestatus {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x14, 0x1]),
        packet_id_raw: [0x14, 0x1],
        status_type: 0,
        status_type_raw: [0; 4],
        default_status: 0,
        default_status_raw: [0; 4],
        plus_status: 0,
        plus_status_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcCouplestatus {
    fn id(&self) -> &str {
       "0x0141"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcOpenEditdlg {
    pub fn from(buffer: &[u8]) -> PacketZcOpenEditdlg {
        PacketZcOpenEditdlg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn new() -> PacketZcOpenEditdlg {
        PacketZcOpenEditdlg {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x14, 0x2]),
        packet_id_raw: [0x14, 0x2],
        naid: 0,
        naid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcOpenEditdlg {
    fn id(&self) -> &str {
       "0x0142"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzInputEditdlg {
    pub fn from(buffer: &[u8]) -> PacketCzInputEditdlg {
        PacketCzInputEditdlg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            value: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new() -> PacketCzInputEditdlg {
        PacketCzInputEditdlg {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x14, 0x3]),
        packet_id_raw: [0x14, 0x3],
        naid: 0,
        naid_raw: [0; 4],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzInputEditdlg {
    fn id(&self) -> &str {
       "0x0143"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcCompass {
    pub fn from(buffer: &[u8]) -> PacketZcCompass {
        PacketZcCompass {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            x_pos: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            x_pos_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            y_pos: i32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            y_pos_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
            id: u8::from_le_bytes([buffer[18]]),
            id_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[18..19]);
                dst
            },
            color: u32::from_le_bytes([buffer[19], buffer[20], buffer[21], buffer[22]]),
            color_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[19..23]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.id).unwrap();
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.color).unwrap();
        self.color_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.color_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i32) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 4]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i32) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 4]) {
        self.y_pos_raw = value;
    }
    pub fn set_id(&mut self, value: u8) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 1]) {
        self.id_raw = value;
    }
    pub fn set_color(&mut self, value: u32) {
        self.color = value;
    }
    pub fn set_color_raw(&mut self, value: [u8; 4]) {
        self.color_raw = value;
    }
    pub fn new() -> PacketZcCompass {
        PacketZcCompass {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x14, 0x4]),
        packet_id_raw: [0x14, 0x4],
        naid: 0,
        naid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 4],
        y_pos: 0,
        y_pos_raw: [0; 4],
        id: 0,
        id_raw: [0; 1],
        color: 0,
        color_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcCompass {
    fn id(&self) -> &str {
       "0x0144"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcShowImage {
    pub fn from(buffer: &[u8]) -> PacketZcShowImage {
        PacketZcShowImage {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            image_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[2..18].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            image_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[2..18]);
                dst
            },
            atype: u8::from_le_bytes([buffer[18]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[18..19]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.image_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.image_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.image_name_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_image_name(&mut self, value: [char; 16]) {
        self.image_name = value;
    }
    pub fn set_image_name_raw(&mut self, value: [u8; 16]) {
        self.image_name_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketZcShowImage {
        PacketZcShowImage {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x14, 0x5]),
        packet_id_raw: [0x14, 0x5],
        image_name: [0 as char; 16],
        image_name_raw: [0; 16],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcShowImage {
    fn id(&self) -> &str {
       "0x0145"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzCloseDialog {
    pub fn from(buffer: &[u8]) -> PacketCzCloseDialog {
        PacketCzCloseDialog {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn new() -> PacketCzCloseDialog {
        PacketCzCloseDialog {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x14, 0x6]),
        packet_id_raw: [0x14, 0x6],
        naid: 0,
        naid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzCloseDialog {
    fn id(&self) -> &str {
       "0x0146"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAutorunSkill {
    pub fn from(buffer: &[u8]) -> PacketZcAutorunSkill {
        PacketZcAutorunSkill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            data: SKILLINFO::from(&buffer[2..buffer.len()]),
            data_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.data.fill_raw();
        self.data_raw = self.data.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_data(&mut self, value: SKILLINFO) {
        self.data = value;
    }
    pub fn set_data_raw(&mut self, value: Vec<u8>) {
        self.data_raw = value;
    }
    pub fn new() -> PacketZcAutorunSkill {
        PacketZcAutorunSkill {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x14, 0x7]),
        packet_id_raw: [0x14, 0x7],
        data: SKILLINFO::new(),
        data_raw: vec![],
        }
    }
}

impl Packet for PacketZcAutorunSkill {
    fn id(&self) -> &str {
       "0x0147"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcResurrection {
    pub fn from(buffer: &[u8]) -> PacketZcResurrection {
        PacketZcResurrection {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: i16::from_le_bytes([buffer[6], buffer[7]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketZcResurrection {
        PacketZcResurrection {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x14, 0x8]),
        packet_id_raw: [0x14, 0x8],
        aid: 0,
        aid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcResurrection {
    fn id(&self) -> &str {
       "0x0148"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqGiveMannerPoint {
    pub fn from(buffer: &[u8]) -> PacketCzReqGiveMannerPoint {
        PacketCzReqGiveMannerPoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            other_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            other_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            point: i16::from_le_bytes([buffer[7], buffer[8]]),
            point_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[7..9]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.other_aid).unwrap();
        self.other_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.other_aid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_other_aid(&mut self, value: u32) {
        self.other_aid = value;
    }
    pub fn set_other_aid_raw(&mut self, value: [u8; 4]) {
        self.other_aid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_point(&mut self, value: i16) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 2]) {
        self.point_raw = value;
    }
    pub fn new() -> PacketCzReqGiveMannerPoint {
        PacketCzReqGiveMannerPoint {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x14, 0x9]),
        packet_id_raw: [0x14, 0x9],
        other_aid: 0,
        other_aid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        point: 0,
        point_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqGiveMannerPoint {
    fn id(&self) -> &str {
       "0x0149"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckGiveMannerPoint {
    pub fn from(buffer: &[u8]) -> PacketZcAckGiveMannerPoint {
        PacketZcAckGiveMannerPoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u32) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 4]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcAckGiveMannerPoint {
        PacketZcAckGiveMannerPoint {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x14, 0xa]),
        packet_id_raw: [0x14, 0xa],
        result: 0,
        result_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcAckGiveMannerPoint {
    fn id(&self) -> &str {
       "0x014a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyMannerPointGiven {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMannerPointGiven {
        PacketZcNotifyMannerPointGiven {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: u8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            other_char_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[3..27].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            other_char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[3..27]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.other_char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.other_char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.other_char_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_other_char_name(&mut self, value: [char; 24]) {
        self.other_char_name = value;
    }
    pub fn set_other_char_name_raw(&mut self, value: [u8; 24]) {
        self.other_char_name_raw = value;
    }
    pub fn new() -> PacketZcNotifyMannerPointGiven {
        PacketZcNotifyMannerPointGiven {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x14, 0xb]),
        packet_id_raw: [0x14, 0xb],
        atype: 0,
        atype_raw: [0; 1],
        other_char_name: [0 as char; 24],
        other_char_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcNotifyMannerPointGiven {
    fn id(&self) -> &str {
       "0x014b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMyguildBasicInfo {
    pub fn from(buffer: &[u8]) -> PacketZcMyguildBasicInfo {
        let iter_count = (&buffer.len() - 4) / 32;
        let mut vec_field: Vec<RelatedGuild> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (32 * (i - 1));
            let end_pos = 4 + 32 * i;
            vec_field.push(RelatedGuild::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcMyguildBasicInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            related_guild_list: vec_field.clone(),
            related_guild_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.related_guild_list_raw = {
            self.related_guild_list.iter_mut().for_each(|item| item.fill_raw());
            self.related_guild_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.related_guild_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_related_guild_list(&mut self, value: Vec<RelatedGuild>) {
        self.related_guild_list = value;
    }
    pub fn set_related_guild_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.related_guild_list_raw = value;
    }
    pub fn new() -> PacketZcMyguildBasicInfo {
        PacketZcMyguildBasicInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x14, 0xc]),
        packet_id_raw: [0x14, 0xc],
        packet_length: 0,
        packet_length_raw: [0; 2],
        related_guild_list: vec![],
        related_guild_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcMyguildBasicInfo {
    fn id(&self) -> &str {
       "0x014c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqGuildMenuinterface {
    pub fn from(buffer: &[u8]) -> PacketCzReqGuildMenuinterface {
        PacketCzReqGuildMenuinterface {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzReqGuildMenuinterface {
        PacketCzReqGuildMenuinterface {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x14, 0xd]),
        packet_id_raw: [0x14, 0xd],
        }
    }
}

impl Packet for PacketCzReqGuildMenuinterface {
    fn id(&self) -> &str {
       "0x014d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckGuildMenuinterface {
    pub fn from(buffer: &[u8]) -> PacketZcAckGuildMenuinterface {
        PacketZcAckGuildMenuinterface {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            guild_memu_flag: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            guild_memu_flag_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.guild_memu_flag).unwrap();
        self.guild_memu_flag_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.guild_memu_flag_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_guild_memu_flag(&mut self, value: i32) {
        self.guild_memu_flag = value;
    }
    pub fn set_guild_memu_flag_raw(&mut self, value: [u8; 4]) {
        self.guild_memu_flag_raw = value;
    }
    pub fn new() -> PacketZcAckGuildMenuinterface {
        PacketZcAckGuildMenuinterface {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x14, 0xe]),
        packet_id_raw: [0x14, 0xe],
        guild_memu_flag: 0,
        guild_memu_flag_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcAckGuildMenuinterface {
    fn id(&self) -> &str {
       "0x014e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqGuildMenu {
    pub fn from(buffer: &[u8]) -> PacketCzReqGuildMenu {
        PacketCzReqGuildMenu {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketCzReqGuildMenu {
        PacketCzReqGuildMenu {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x14, 0xf]),
        packet_id_raw: [0x14, 0xf],
        atype: 0,
        atype_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqGuildMenu {
    fn id(&self) -> &str {
       "0x014f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcGuildInfo {
    pub fn from(buffer: &[u8]) -> PacketZcGuildInfo {
        PacketZcGuildInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            level: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            user_num: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            user_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            max_user_num: i32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            max_user_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
            user_average_level: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            user_average_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
            exp: i32::from_le_bytes([buffer[22], buffer[23], buffer[24], buffer[25]]),
            exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[22..26]);
                dst
            },
            max_exp: i32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            max_exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
            point: i32::from_le_bytes([buffer[30], buffer[31], buffer[32], buffer[33]]),
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[30..34]);
                dst
            },
            honor: i32::from_le_bytes([buffer[34], buffer[35], buffer[36], buffer[37]]),
            honor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[34..38]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[38], buffer[39], buffer[40], buffer[41]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[38..42]);
                dst
            },
            emblem_version: i32::from_le_bytes([buffer[42], buffer[43], buffer[44], buffer[45]]),
            emblem_version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[42..46]);
                dst
            },
            guildname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[46..70].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            guildname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[46..70]);
                dst
            },
            master_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[70..94].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            master_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[70..94]);
                dst
            },
            manage_land:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[94..110].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            manage_land_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[94..110]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.user_num).unwrap();
        self.user_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_user_num).unwrap();
        self.max_user_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.user_average_level).unwrap();
        self.user_average_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.exp).unwrap();
        self.exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_exp).unwrap();
        self.max_exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.emblem_version).unwrap();
        self.emblem_version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.guildname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guildname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.master_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.master_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.manage_land {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.manage_land_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.user_num_raw.to_vec());
        wtr.append(&mut self.max_user_num_raw.to_vec());
        wtr.append(&mut self.user_average_level_raw.to_vec());
        wtr.append(&mut self.exp_raw.to_vec());
        wtr.append(&mut self.max_exp_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.emblem_version_raw.to_vec());
        wtr.append(&mut self.guildname_raw.to_vec());
        wtr.append(&mut self.master_name_raw.to_vec());
        wtr.append(&mut self.manage_land_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: i32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_level(&mut self, value: i32) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 4]) {
        self.level_raw = value;
    }
    pub fn set_user_num(&mut self, value: i32) {
        self.user_num = value;
    }
    pub fn set_user_num_raw(&mut self, value: [u8; 4]) {
        self.user_num_raw = value;
    }
    pub fn set_max_user_num(&mut self, value: i32) {
        self.max_user_num = value;
    }
    pub fn set_max_user_num_raw(&mut self, value: [u8; 4]) {
        self.max_user_num_raw = value;
    }
    pub fn set_user_average_level(&mut self, value: i32) {
        self.user_average_level = value;
    }
    pub fn set_user_average_level_raw(&mut self, value: [u8; 4]) {
        self.user_average_level_raw = value;
    }
    pub fn set_exp(&mut self, value: i32) {
        self.exp = value;
    }
    pub fn set_exp_raw(&mut self, value: [u8; 4]) {
        self.exp_raw = value;
    }
    pub fn set_max_exp(&mut self, value: i32) {
        self.max_exp = value;
    }
    pub fn set_max_exp_raw(&mut self, value: [u8; 4]) {
        self.max_exp_raw = value;
    }
    pub fn set_point(&mut self, value: i32) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 4]) {
        self.point_raw = value;
    }
    pub fn set_honor(&mut self, value: i32) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 4]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_emblem_version(&mut self, value: i32) {
        self.emblem_version = value;
    }
    pub fn set_emblem_version_raw(&mut self, value: [u8; 4]) {
        self.emblem_version_raw = value;
    }
    pub fn set_guildname(&mut self, value: [char; 24]) {
        self.guildname = value;
    }
    pub fn set_guildname_raw(&mut self, value: [u8; 24]) {
        self.guildname_raw = value;
    }
    pub fn set_master_name(&mut self, value: [char; 24]) {
        self.master_name = value;
    }
    pub fn set_master_name_raw(&mut self, value: [u8; 24]) {
        self.master_name_raw = value;
    }
    pub fn set_manage_land(&mut self, value: [char; 16]) {
        self.manage_land = value;
    }
    pub fn set_manage_land_raw(&mut self, value: [u8; 16]) {
        self.manage_land_raw = value;
    }
    pub fn new() -> PacketZcGuildInfo {
        PacketZcGuildInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x15, 0x0]),
        packet_id_raw: [0x15, 0x0],
        gdid: 0,
        gdid_raw: [0; 4],
        level: 0,
        level_raw: [0; 4],
        user_num: 0,
        user_num_raw: [0; 4],
        max_user_num: 0,
        max_user_num_raw: [0; 4],
        user_average_level: 0,
        user_average_level_raw: [0; 4],
        exp: 0,
        exp_raw: [0; 4],
        max_exp: 0,
        max_exp_raw: [0; 4],
        point: 0,
        point_raw: [0; 4],
        honor: 0,
        honor_raw: [0; 4],
        virtue: 0,
        virtue_raw: [0; 4],
        emblem_version: 0,
        emblem_version_raw: [0; 4],
        guildname: [0 as char; 24],
        guildname_raw: [0; 24],
        master_name: [0 as char; 24],
        master_name_raw: [0; 24],
        manage_land: [0 as char; 16],
        manage_land_raw: [0; 16],
        }
    }
}

impl Packet for PacketZcGuildInfo {
    fn id(&self) -> &str {
       "0x0150"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqGuildEmblemImg {
    pub fn from(buffer: &[u8]) -> PacketCzReqGuildEmblemImg {
        PacketCzReqGuildEmblemImg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: i32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn new() -> PacketCzReqGuildEmblemImg {
        PacketCzReqGuildEmblemImg {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x15, 0x1]),
        packet_id_raw: [0x15, 0x1],
        gdid: 0,
        gdid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqGuildEmblemImg {
    fn id(&self) -> &str {
       "0x0151"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcGuildEmblemImg {
    pub fn from(buffer: &[u8]) -> PacketZcGuildEmblemImg {
        PacketZcGuildEmblemImg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            gdid: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            emblem_version: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            emblem_version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            img: String::from_utf8_lossy(&buffer[12..buffer.len()]).to_string(),
            img_raw: buffer[12..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.emblem_version).unwrap();
        self.emblem_version_raw = wtr.try_into().unwrap();
        self.img_raw = self.img.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.emblem_version_raw.to_vec());
        wtr.append(&mut self.img_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_gdid(&mut self, value: i32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_emblem_version(&mut self, value: i32) {
        self.emblem_version = value;
    }
    pub fn set_emblem_version_raw(&mut self, value: [u8; 4]) {
        self.emblem_version_raw = value;
    }
    pub fn set_img(&mut self, value: String) {
        self.img = value;
    }
    pub fn set_img_raw(&mut self, value: Vec<u8>) {
        self.img_raw = value;
    }
    pub fn new() -> PacketZcGuildEmblemImg {
        PacketZcGuildEmblemImg {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x15, 0x2]),
        packet_id_raw: [0x15, 0x2],
        packet_length: 0,
        packet_length_raw: [0; 2],
        gdid: 0,
        gdid_raw: [0; 4],
        emblem_version: 0,
        emblem_version_raw: [0; 4],
        img: String::new(),
        img_raw: vec![],
        }
    }
}

impl Packet for PacketZcGuildEmblemImg {
    fn id(&self) -> &str {
       "0x0152"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRegisterGuildEmblemImg {
    pub fn from(buffer: &[u8]) -> PacketCzRegisterGuildEmblemImg {
        PacketCzRegisterGuildEmblemImg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            img: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            img_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.img_raw = self.img.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.img_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_img(&mut self, value: String) {
        self.img = value;
    }
    pub fn set_img_raw(&mut self, value: Vec<u8>) {
        self.img_raw = value;
    }
    pub fn new() -> PacketCzRegisterGuildEmblemImg {
        PacketCzRegisterGuildEmblemImg {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x15, 0x3]),
        packet_id_raw: [0x15, 0x3],
        packet_length: 0,
        packet_length_raw: [0; 2],
        img: String::new(),
        img_raw: vec![],
        }
    }
}

impl Packet for PacketCzRegisterGuildEmblemImg {
    fn id(&self) -> &str {
       "0x0153"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMembermgrInfo {
    pub fn from(buffer: &[u8]) -> PacketZcMembermgrInfo {
        let iter_count = (&buffer.len() - 4) / 104;
        let mut vec_field: Vec<GuildMembermgrInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (104 * (i - 1));
            let end_pos = 4 + 104 * i;
            vec_field.push(GuildMembermgrInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcMembermgrInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            member_info: vec_field.clone(),
            member_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_info_raw = {
            self.member_info.iter_mut().for_each(|item| item.fill_raw());
            self.member_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.member_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_member_info(&mut self, value: Vec<GuildMembermgrInfo>) {
        self.member_info = value;
    }
    pub fn set_member_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.member_info_raw = value;
    }
    pub fn new() -> PacketZcMembermgrInfo {
        PacketZcMembermgrInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x15, 0x4]),
        packet_id_raw: [0x15, 0x4],
        packet_length: 0,
        packet_length_raw: [0; 2],
        member_info: vec![],
        member_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcMembermgrInfo {
    fn id(&self) -> &str {
       "0x0154"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqChangeMemberpos {
    pub fn from(buffer: &[u8]) -> PacketCzReqChangeMemberpos {
        let iter_count = (&buffer.len() - 4) / 12;
        let mut vec_field: Vec<MemberPositionInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (12 * (i - 1));
            let end_pos = 4 + 12 * i;
            vec_field.push(MemberPositionInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzReqChangeMemberpos {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            member_info: vec_field.clone(),
            member_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_info_raw = {
            self.member_info.iter_mut().for_each(|item| item.fill_raw());
            self.member_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.member_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_member_info(&mut self, value: Vec<MemberPositionInfo>) {
        self.member_info = value;
    }
    pub fn set_member_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.member_info_raw = value;
    }
    pub fn new() -> PacketCzReqChangeMemberpos {
        PacketCzReqChangeMemberpos {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x15, 0x5]),
        packet_id_raw: [0x15, 0x5],
        packet_length: 0,
        packet_length_raw: [0; 2],
        member_info: vec![],
        member_info_raw: vec![],
        }
    }
}

impl Packet for PacketCzReqChangeMemberpos {
    fn id(&self) -> &str {
       "0x0155"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckReqChangeMembers {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqChangeMembers {
        let iter_count = (&buffer.len() - 4) / 12;
        let mut vec_field: Vec<MemberPositionInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (12 * (i - 1));
            let end_pos = 4 + 12 * i;
            vec_field.push(MemberPositionInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcAckReqChangeMembers {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            member_info: vec_field.clone(),
            member_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_info_raw = {
            self.member_info.iter_mut().for_each(|item| item.fill_raw());
            self.member_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.member_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_member_info(&mut self, value: Vec<MemberPositionInfo>) {
        self.member_info = value;
    }
    pub fn set_member_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.member_info_raw = value;
    }
    pub fn new() -> PacketZcAckReqChangeMembers {
        PacketZcAckReqChangeMembers {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x15, 0x6]),
        packet_id_raw: [0x15, 0x6],
        packet_length: 0,
        packet_length_raw: [0; 2],
        member_info: vec![],
        member_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcAckReqChangeMembers {
    fn id(&self) -> &str {
       "0x0156"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqOpenMemberInfo {
    pub fn from(buffer: &[u8]) -> PacketCzReqOpenMemberInfo {
        PacketCzReqOpenMemberInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: i32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketCzReqOpenMemberInfo {
        PacketCzReqOpenMemberInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x15, 0x7]),
        packet_id_raw: [0x15, 0x7],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqOpenMemberInfo {
    fn id(&self) -> &str {
       "0x0157"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckOpenMemberInfo {
    pub fn from(buffer: &[u8]) -> PacketZcAckOpenMemberInfo {
        PacketZcAckOpenMemberInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketZcAckOpenMemberInfo {
        PacketZcAckOpenMemberInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x15, 0x8]),
        packet_id_raw: [0x15, 0x8],
        }
    }
}

impl Packet for PacketZcAckOpenMemberInfo {
    fn id(&self) -> &str {
       "0x0158"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqLeaveGuild {
    pub fn from(buffer: &[u8]) -> PacketCzReqLeaveGuild {
        PacketCzReqLeaveGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            aid: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            gid: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            reason_desc:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[14..54].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            reason_desc_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[14..54]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason_desc {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_desc_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.reason_desc_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: u32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_aid(&mut self, value: i32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: i32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_reason_desc(&mut self, value: [char; 40]) {
        self.reason_desc = value;
    }
    pub fn set_reason_desc_raw(&mut self, value: [u8; 40]) {
        self.reason_desc_raw = value;
    }
    pub fn new() -> PacketCzReqLeaveGuild {
        PacketCzReqLeaveGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x15, 0x9]),
        packet_id_raw: [0x15, 0x9],
        gdid: 0,
        gdid_raw: [0; 4],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        reason_desc: [0 as char; 40],
        reason_desc_raw: [0; 40],
        }
    }
}

impl Packet for PacketCzReqLeaveGuild {
    fn id(&self) -> &str {
       "0x0159"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckLeaveGuild {
    pub fn from(buffer: &[u8]) -> PacketZcAckLeaveGuild {
        PacketZcAckLeaveGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            char_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            reason_desc:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[26..66].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            reason_desc_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[26..66]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason_desc {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_desc_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.char_name_raw.to_vec());
        wtr.append(&mut self.reason_desc_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_char_name(&mut self, value: [char; 24]) {
        self.char_name = value;
    }
    pub fn set_char_name_raw(&mut self, value: [u8; 24]) {
        self.char_name_raw = value;
    }
    pub fn set_reason_desc(&mut self, value: [char; 40]) {
        self.reason_desc = value;
    }
    pub fn set_reason_desc_raw(&mut self, value: [u8; 40]) {
        self.reason_desc_raw = value;
    }
    pub fn new() -> PacketZcAckLeaveGuild {
        PacketZcAckLeaveGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x15, 0xa]),
        packet_id_raw: [0x15, 0xa],
        char_name: [0 as char; 24],
        char_name_raw: [0; 24],
        reason_desc: [0 as char; 40],
        reason_desc_raw: [0; 40],
        }
    }
}

impl Packet for PacketZcAckLeaveGuild {
    fn id(&self) -> &str {
       "0x015a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqBanGuild {
    pub fn from(buffer: &[u8]) -> PacketCzReqBanGuild {
        PacketCzReqBanGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            aid: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            gid: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            reason_desc:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[14..54].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            reason_desc_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[14..54]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason_desc {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_desc_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.reason_desc_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: u32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_aid(&mut self, value: i32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: i32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_reason_desc(&mut self, value: [char; 40]) {
        self.reason_desc = value;
    }
    pub fn set_reason_desc_raw(&mut self, value: [u8; 40]) {
        self.reason_desc_raw = value;
    }
    pub fn new() -> PacketCzReqBanGuild {
        PacketCzReqBanGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x15, 0xb]),
        packet_id_raw: [0x15, 0xb],
        gdid: 0,
        gdid_raw: [0; 4],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        reason_desc: [0 as char; 40],
        reason_desc_raw: [0; 40],
        }
    }
}

impl Packet for PacketCzReqBanGuild {
    fn id(&self) -> &str {
       "0x015b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckBanGuild {
    pub fn from(buffer: &[u8]) -> PacketZcAckBanGuild {
        PacketZcAckBanGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            char_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            reason_desc:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[26..66].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            reason_desc_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[26..66]);
                dst
            },
            account:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[66..90].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            account_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[66..90]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason_desc {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_desc_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.account {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.account_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.char_name_raw.to_vec());
        wtr.append(&mut self.reason_desc_raw.to_vec());
        wtr.append(&mut self.account_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_char_name(&mut self, value: [char; 24]) {
        self.char_name = value;
    }
    pub fn set_char_name_raw(&mut self, value: [u8; 24]) {
        self.char_name_raw = value;
    }
    pub fn set_reason_desc(&mut self, value: [char; 40]) {
        self.reason_desc = value;
    }
    pub fn set_reason_desc_raw(&mut self, value: [u8; 40]) {
        self.reason_desc_raw = value;
    }
    pub fn set_account(&mut self, value: [char; 24]) {
        self.account = value;
    }
    pub fn set_account_raw(&mut self, value: [u8; 24]) {
        self.account_raw = value;
    }
    pub fn new() -> PacketZcAckBanGuild {
        PacketZcAckBanGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x15, 0xc]),
        packet_id_raw: [0x15, 0xc],
        char_name: [0 as char; 24],
        char_name_raw: [0; 24],
        reason_desc: [0 as char; 40],
        reason_desc_raw: [0; 40],
        account: [0 as char; 24],
        account_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcAckBanGuild {
    fn id(&self) -> &str {
       "0x015c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqDisorganizeGuild {
    pub fn from(buffer: &[u8]) -> PacketCzReqDisorganizeGuild {
        PacketCzReqDisorganizeGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            key:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[2..42].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            key_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[2..42]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.key {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.key_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.key_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_key(&mut self, value: [char; 40]) {
        self.key = value;
    }
    pub fn set_key_raw(&mut self, value: [u8; 40]) {
        self.key_raw = value;
    }
    pub fn new() -> PacketCzReqDisorganizeGuild {
        PacketCzReqDisorganizeGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x15, 0xd]),
        packet_id_raw: [0x15, 0xd],
        key: [0 as char; 40],
        key_raw: [0; 40],
        }
    }
}

impl Packet for PacketCzReqDisorganizeGuild {
    fn id(&self) -> &str {
       "0x015d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckDisorganizeGuildResult {
    pub fn from(buffer: &[u8]) -> PacketZcAckDisorganizeGuildResult {
        PacketZcAckDisorganizeGuildResult {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            reason: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            reason_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.reason).unwrap();
        self.reason_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.reason_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_reason(&mut self, value: i32) {
        self.reason = value;
    }
    pub fn set_reason_raw(&mut self, value: [u8; 4]) {
        self.reason_raw = value;
    }
    pub fn new() -> PacketZcAckDisorganizeGuildResult {
        PacketZcAckDisorganizeGuildResult {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x15, 0xe]),
        packet_id_raw: [0x15, 0xe],
        reason: 0,
        reason_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcAckDisorganizeGuildResult {
    fn id(&self) -> &str {
       "0x015e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckDisorganizeGuild {
    pub fn from(buffer: &[u8]) -> PacketZcAckDisorganizeGuild {
        PacketZcAckDisorganizeGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            reason_desc:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[2..42].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            reason_desc_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[2..42]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason_desc {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_desc_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.reason_desc_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_reason_desc(&mut self, value: [char; 40]) {
        self.reason_desc = value;
    }
    pub fn set_reason_desc_raw(&mut self, value: [u8; 40]) {
        self.reason_desc_raw = value;
    }
    pub fn new() -> PacketZcAckDisorganizeGuild {
        PacketZcAckDisorganizeGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x15, 0xf]),
        packet_id_raw: [0x15, 0xf],
        reason_desc: [0 as char; 40],
        reason_desc_raw: [0; 40],
        }
    }
}

impl Packet for PacketZcAckDisorganizeGuild {
    fn id(&self) -> &str {
       "0x015f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPositionInfo {
    pub fn from(buffer: &[u8]) -> PacketZcPositionInfo {
        let iter_count = (&buffer.len() - 4) / 16;
        let mut vec_field: Vec<GuildMemberPositionInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (16 * (i - 1));
            let end_pos = 4 + 16 * i;
            vec_field.push(GuildMemberPositionInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPositionInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            member_info: vec_field.clone(),
            member_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_info_raw = {
            self.member_info.iter_mut().for_each(|item| item.fill_raw());
            self.member_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.member_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_member_info(&mut self, value: Vec<GuildMemberPositionInfo>) {
        self.member_info = value;
    }
    pub fn set_member_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.member_info_raw = value;
    }
    pub fn new() -> PacketZcPositionInfo {
        PacketZcPositionInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x16, 0x0]),
        packet_id_raw: [0x16, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        member_info: vec![],
        member_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcPositionInfo {
    fn id(&self) -> &str {
       "0x0160"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRegChangeGuildPositioninfo {
    pub fn from(buffer: &[u8]) -> PacketCzRegChangeGuildPositioninfo {
        let iter_count = (&buffer.len() - 4) / 40;
        let mut vec_field: Vec<GuildRegPositionInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (40 * (i - 1));
            let end_pos = 4 + 40 * i;
            vec_field.push(GuildRegPositionInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzRegChangeGuildPositioninfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            member_list: vec_field.clone(),
            member_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_list_raw = {
            self.member_list.iter_mut().for_each(|item| item.fill_raw());
            self.member_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.member_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_member_list(&mut self, value: Vec<GuildRegPositionInfo>) {
        self.member_list = value;
    }
    pub fn set_member_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.member_list_raw = value;
    }
    pub fn new() -> PacketCzRegChangeGuildPositioninfo {
        PacketCzRegChangeGuildPositioninfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x16, 0x1]),
        packet_id_raw: [0x16, 0x1],
        packet_length: 0,
        packet_length_raw: [0; 2],
        member_list: vec![],
        member_list_raw: vec![],
        }
    }
}

impl Packet for PacketCzRegChangeGuildPositioninfo {
    fn id(&self) -> &str {
       "0x0161"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcGuildSkillinfo {
    pub fn from(buffer: &[u8]) -> PacketZcGuildSkillinfo {
        let iter_count = (&buffer.len() - 6) / 37;
        let mut vec_field: Vec<SKILLINFO> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 6 + (37 * (i - 1));
            let end_pos = 6 + 37 * i;
            vec_field.push(SKILLINFO::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcGuildSkillinfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            skill_point: i16::from_le_bytes([buffer[4], buffer[5]]),
            skill_point_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            skill_list: vec_field.clone(),
            skill_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.skill_point).unwrap();
        self.skill_point_raw = wtr.try_into().unwrap();
        self.skill_list_raw = {
            self.skill_list.iter_mut().for_each(|item| item.fill_raw());
            self.skill_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.skill_point_raw.to_vec());
        self.skill_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_skill_point(&mut self, value: i16) {
        self.skill_point = value;
    }
    pub fn set_skill_point_raw(&mut self, value: [u8; 2]) {
        self.skill_point_raw = value;
    }
    pub fn set_skill_list(&mut self, value: Vec<SKILLINFO>) {
        self.skill_list = value;
    }
    pub fn set_skill_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.skill_list_raw = value;
    }
    pub fn new() -> PacketZcGuildSkillinfo {
        PacketZcGuildSkillinfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x16, 0x2]),
        packet_id_raw: [0x16, 0x2],
        packet_length: 0,
        packet_length_raw: [0; 2],
        skill_point: 0,
        skill_point_raw: [0; 2],
        skill_list: vec![],
        skill_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcGuildSkillinfo {
    fn id(&self) -> &str {
       "0x0162"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcBanList {
    pub fn from(buffer: &[u8]) -> PacketZcBanList {
        let iter_count = (&buffer.len() - 4) / 88;
        let mut vec_field: Vec<GuildBanInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (88 * (i - 1));
            let end_pos = 4 + 88 * i;
            vec_field.push(GuildBanInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcBanList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            ban_list: vec_field.clone(),
            ban_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.ban_list_raw = {
            self.ban_list.iter_mut().for_each(|item| item.fill_raw());
            self.ban_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.ban_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_ban_list(&mut self, value: Vec<GuildBanInfo>) {
        self.ban_list = value;
    }
    pub fn set_ban_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.ban_list_raw = value;
    }
    pub fn new() -> PacketZcBanList {
        PacketZcBanList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x16, 0x3]),
        packet_id_raw: [0x16, 0x3],
        packet_length: 0,
        packet_length_raw: [0; 2],
        ban_list: vec![],
        ban_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcBanList {
    fn id(&self) -> &str {
       "0x0163"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcOtherGuildList {
    pub fn from(buffer: &[u8]) -> PacketZcOtherGuildList {
        let iter_count = (&buffer.len() - 4) / 36;
        let mut vec_field: Vec<OtherGuildInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (36 * (i - 1));
            let end_pos = 4 + 36 * i;
            vec_field.push(OtherGuildInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcOtherGuildList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            guild_list: vec_field.clone(),
            guild_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.guild_list_raw = {
            self.guild_list.iter_mut().for_each(|item| item.fill_raw());
            self.guild_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.guild_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_guild_list(&mut self, value: Vec<OtherGuildInfo>) {
        self.guild_list = value;
    }
    pub fn set_guild_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.guild_list_raw = value;
    }
    pub fn new() -> PacketZcOtherGuildList {
        PacketZcOtherGuildList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x16, 0x4]),
        packet_id_raw: [0x16, 0x4],
        packet_length: 0,
        packet_length_raw: [0; 2],
        guild_list: vec![],
        guild_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcOtherGuildList {
    fn id(&self) -> &str {
       "0x0164"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqMakeGuild {
    pub fn from(buffer: &[u8]) -> PacketCzReqMakeGuild {
        PacketCzReqMakeGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            gname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.gname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.gname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.gname_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_gname(&mut self, value: [char; 24]) {
        self.gname = value;
    }
    pub fn set_gname_raw(&mut self, value: [u8; 24]) {
        self.gname_raw = value;
    }
    pub fn new() -> PacketCzReqMakeGuild {
        PacketCzReqMakeGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x16, 0x5]),
        packet_id_raw: [0x16, 0x5],
        gid: 0,
        gid_raw: [0; 4],
        gname: [0 as char; 24],
        gname_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzReqMakeGuild {
    fn id(&self) -> &str {
       "0x0165"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPositionIdNameInfo {
    pub fn from(buffer: &[u8]) -> PacketZcPositionIdNameInfo {
        let iter_count = (&buffer.len() - 4) / 28;
        let mut vec_field: Vec<MemberPositionIdNameInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (28 * (i - 1));
            let end_pos = 4 + 28 * i;
            vec_field.push(MemberPositionIdNameInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPositionIdNameInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            member_list: vec_field.clone(),
            member_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_list_raw = {
            self.member_list.iter_mut().for_each(|item| item.fill_raw());
            self.member_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.member_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_member_list(&mut self, value: Vec<MemberPositionIdNameInfo>) {
        self.member_list = value;
    }
    pub fn set_member_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.member_list_raw = value;
    }
    pub fn new() -> PacketZcPositionIdNameInfo {
        PacketZcPositionIdNameInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x16, 0x6]),
        packet_id_raw: [0x16, 0x6],
        packet_length: 0,
        packet_length_raw: [0; 2],
        member_list: vec![],
        member_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcPositionIdNameInfo {
    fn id(&self) -> &str {
       "0x0166"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcResultMakeGuild {
    pub fn from(buffer: &[u8]) -> PacketZcResultMakeGuild {
        PacketZcResultMakeGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcResultMakeGuild {
        PacketZcResultMakeGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x16, 0x7]),
        packet_id_raw: [0x16, 0x7],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcResultMakeGuild {
    fn id(&self) -> &str {
       "0x0167"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqJoinGuild {
    pub fn from(buffer: &[u8]) -> PacketCzReqJoinGuild {
        PacketCzReqJoinGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            my_aid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            my_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            my_gid: u32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            my_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.my_aid).unwrap();
        self.my_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.my_gid).unwrap();
        self.my_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.my_aid_raw.to_vec());
        wtr.append(&mut self.my_gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_my_aid(&mut self, value: u32) {
        self.my_aid = value;
    }
    pub fn set_my_aid_raw(&mut self, value: [u8; 4]) {
        self.my_aid_raw = value;
    }
    pub fn set_my_gid(&mut self, value: u32) {
        self.my_gid = value;
    }
    pub fn set_my_gid_raw(&mut self, value: [u8; 4]) {
        self.my_gid_raw = value;
    }
    pub fn new() -> PacketCzReqJoinGuild {
        PacketCzReqJoinGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x16, 0x8]),
        packet_id_raw: [0x16, 0x8],
        aid: 0,
        aid_raw: [0; 4],
        my_aid: 0,
        my_aid_raw: [0; 4],
        my_gid: 0,
        my_gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqJoinGuild {
    fn id(&self) -> &str {
       "0x0168"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckReqJoinGuild {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqJoinGuild {
        PacketZcAckReqJoinGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            answer: u8::from_le_bytes([buffer[2]]),
            answer_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_answer(&mut self, value: u8) {
        self.answer = value;
    }
    pub fn set_answer_raw(&mut self, value: [u8; 1]) {
        self.answer_raw = value;
    }
    pub fn new() -> PacketZcAckReqJoinGuild {
        PacketZcAckReqJoinGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x16, 0x9]),
        packet_id_raw: [0x16, 0x9],
        answer: 0,
        answer_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckReqJoinGuild {
    fn id(&self) -> &str {
       "0x0169"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcReqJoinGuild {
    pub fn from(buffer: &[u8]) -> PacketZcReqJoinGuild {
        PacketZcReqJoinGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            guild_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            guild_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.guild_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guild_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.guild_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: u32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_guild_name(&mut self, value: [char; 24]) {
        self.guild_name = value;
    }
    pub fn set_guild_name_raw(&mut self, value: [u8; 24]) {
        self.guild_name_raw = value;
    }
    pub fn new() -> PacketZcReqJoinGuild {
        PacketZcReqJoinGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x16, 0xa]),
        packet_id_raw: [0x16, 0xa],
        gdid: 0,
        gdid_raw: [0; 4],
        guild_name: [0 as char; 24],
        guild_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcReqJoinGuild {
    fn id(&self) -> &str {
       "0x016a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzJoinGuild {
    pub fn from(buffer: &[u8]) -> PacketCzJoinGuild {
        PacketCzJoinGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            answer: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            answer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: u32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_answer(&mut self, value: i32) {
        self.answer = value;
    }
    pub fn set_answer_raw(&mut self, value: [u8; 4]) {
        self.answer_raw = value;
    }
    pub fn new() -> PacketCzJoinGuild {
        PacketCzJoinGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x16, 0xb]),
        packet_id_raw: [0x16, 0xb],
        gdid: 0,
        gdid_raw: [0; 4],
        answer: 0,
        answer_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzJoinGuild {
    fn id(&self) -> &str {
       "0x016b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcUpdateGdid {
    pub fn from(buffer: &[u8]) -> PacketZcUpdateGdid {
        PacketZcUpdateGdid {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            emblem_version: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            emblem_version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            right: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            right_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            is_master: buffer[14] == 1,
            is_master_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
            inter_sid: i32::from_le_bytes([buffer[15], buffer[16], buffer[17], buffer[18]]),
            inter_sid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[15..19]);
                dst
            },
            gname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[19..43].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            gname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[19..43]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.emblem_version).unwrap();
        self.emblem_version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.right).unwrap();
        self.right_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_master as u8).unwrap();
        self.is_master_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.inter_sid).unwrap();
        self.inter_sid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.gname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.gname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.emblem_version_raw.to_vec());
        wtr.append(&mut self.right_raw.to_vec());
        wtr.append(&mut self.is_master_raw.to_vec());
        wtr.append(&mut self.inter_sid_raw.to_vec());
        wtr.append(&mut self.gname_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: u32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_emblem_version(&mut self, value: i32) {
        self.emblem_version = value;
    }
    pub fn set_emblem_version_raw(&mut self, value: [u8; 4]) {
        self.emblem_version_raw = value;
    }
    pub fn set_right(&mut self, value: i32) {
        self.right = value;
    }
    pub fn set_right_raw(&mut self, value: [u8; 4]) {
        self.right_raw = value;
    }
    pub fn set_is_master(&mut self, value: bool) {
        self.is_master = value;
    }
    pub fn set_is_master_raw(&mut self, value: [u8; 1]) {
        self.is_master_raw = value;
    }
    pub fn set_inter_sid(&mut self, value: i32) {
        self.inter_sid = value;
    }
    pub fn set_inter_sid_raw(&mut self, value: [u8; 4]) {
        self.inter_sid_raw = value;
    }
    pub fn set_gname(&mut self, value: [char; 24]) {
        self.gname = value;
    }
    pub fn set_gname_raw(&mut self, value: [u8; 24]) {
        self.gname_raw = value;
    }
    pub fn new() -> PacketZcUpdateGdid {
        PacketZcUpdateGdid {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x16, 0xc]),
        packet_id_raw: [0x16, 0xc],
        gdid: 0,
        gdid_raw: [0; 4],
        emblem_version: 0,
        emblem_version_raw: [0; 4],
        right: 0,
        right_raw: [0; 4],
        is_master: false,
        is_master_raw: [0; 1],
        inter_sid: 0,
        inter_sid_raw: [0; 4],
        gname: [0 as char; 24],
        gname_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcUpdateGdid {
    fn id(&self) -> &str {
       "0x016c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcUpdateCharstat {
    pub fn from(buffer: &[u8]) -> PacketZcUpdateCharstat {
        PacketZcUpdateCharstat {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            status: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            status_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.status).unwrap();
        self.status_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.status_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_status(&mut self, value: i32) {
        self.status = value;
    }
    pub fn set_status_raw(&mut self, value: [u8; 4]) {
        self.status_raw = value;
    }
    pub fn new() -> PacketZcUpdateCharstat {
        PacketZcUpdateCharstat {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x16, 0xd]),
        packet_id_raw: [0x16, 0xd],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        status: 0,
        status_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcUpdateCharstat {
    fn id(&self) -> &str {
       "0x016d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzGuildNotice {
    pub fn from(buffer: &[u8]) -> PacketCzGuildNotice {
        PacketCzGuildNotice {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            subject:  {
                let mut dst: [char; 60] = [0 as char; 60];
                for (index, byte) in buffer[6..66].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            subject_raw: {
                let mut dst: [u8; 60] = [0u8; 60];
                dst.clone_from_slice(&buffer[6..66]);
                dst
            },
            notice:  {
                let mut dst: [char; 120] = [0 as char; 120];
                for (index, byte) in buffer[66..186].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            notice_raw: {
                let mut dst: [u8; 120] = [0u8; 120];
                dst.clone_from_slice(&buffer[66..186]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.subject {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.subject_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.notice {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.notice_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.subject_raw.to_vec());
        wtr.append(&mut self.notice_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: u32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_subject(&mut self, value: [char; 60]) {
        self.subject = value;
    }
    pub fn set_subject_raw(&mut self, value: [u8; 60]) {
        self.subject_raw = value;
    }
    pub fn set_notice(&mut self, value: [char; 120]) {
        self.notice = value;
    }
    pub fn set_notice_raw(&mut self, value: [u8; 120]) {
        self.notice_raw = value;
    }
    pub fn new() -> PacketCzGuildNotice {
        PacketCzGuildNotice {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x16, 0xe]),
        packet_id_raw: [0x16, 0xe],
        gdid: 0,
        gdid_raw: [0; 4],
        subject: [0 as char; 60],
        subject_raw: [0; 60],
        notice: [0 as char; 120],
        notice_raw: [0; 120],
        }
    }
}

impl Packet for PacketCzGuildNotice {
    fn id(&self) -> &str {
       "0x016e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcGuildNotice {
    pub fn from(buffer: &[u8]) -> PacketZcGuildNotice {
        PacketZcGuildNotice {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            subject:  {
                let mut dst: [char; 60] = [0 as char; 60];
                for (index, byte) in buffer[2..62].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            subject_raw: {
                let mut dst: [u8; 60] = [0u8; 60];
                dst.clone_from_slice(&buffer[2..62]);
                dst
            },
            notice:  {
                let mut dst: [char; 120] = [0 as char; 120];
                for (index, byte) in buffer[62..182].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            notice_raw: {
                let mut dst: [u8; 120] = [0u8; 120];
                dst.clone_from_slice(&buffer[62..182]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.subject {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.subject_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.notice {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.notice_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.subject_raw.to_vec());
        wtr.append(&mut self.notice_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_subject(&mut self, value: [char; 60]) {
        self.subject = value;
    }
    pub fn set_subject_raw(&mut self, value: [u8; 60]) {
        self.subject_raw = value;
    }
    pub fn set_notice(&mut self, value: [char; 120]) {
        self.notice = value;
    }
    pub fn set_notice_raw(&mut self, value: [u8; 120]) {
        self.notice_raw = value;
    }
    pub fn new() -> PacketZcGuildNotice {
        PacketZcGuildNotice {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x16, 0xf]),
        packet_id_raw: [0x16, 0xf],
        subject: [0 as char; 60],
        subject_raw: [0; 60],
        notice: [0 as char; 120],
        notice_raw: [0; 120],
        }
    }
}

impl Packet for PacketZcGuildNotice {
    fn id(&self) -> &str {
       "0x016f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqAllyGuild {
    pub fn from(buffer: &[u8]) -> PacketCzReqAllyGuild {
        PacketCzReqAllyGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            my_aid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            my_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            my_gid: u32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            my_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.my_aid).unwrap();
        self.my_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.my_gid).unwrap();
        self.my_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.my_aid_raw.to_vec());
        wtr.append(&mut self.my_gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_my_aid(&mut self, value: u32) {
        self.my_aid = value;
    }
    pub fn set_my_aid_raw(&mut self, value: [u8; 4]) {
        self.my_aid_raw = value;
    }
    pub fn set_my_gid(&mut self, value: u32) {
        self.my_gid = value;
    }
    pub fn set_my_gid_raw(&mut self, value: [u8; 4]) {
        self.my_gid_raw = value;
    }
    pub fn new() -> PacketCzReqAllyGuild {
        PacketCzReqAllyGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x17, 0x0]),
        packet_id_raw: [0x17, 0x0],
        aid: 0,
        aid_raw: [0; 4],
        my_aid: 0,
        my_aid_raw: [0; 4],
        my_gid: 0,
        my_gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqAllyGuild {
    fn id(&self) -> &str {
       "0x0170"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcReqAllyGuild {
    pub fn from(buffer: &[u8]) -> PacketZcReqAllyGuild {
        PacketZcReqAllyGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            other_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            other_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            guild_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            guild_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.other_aid).unwrap();
        self.other_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.guild_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guild_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.other_aid_raw.to_vec());
        wtr.append(&mut self.guild_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_other_aid(&mut self, value: u32) {
        self.other_aid = value;
    }
    pub fn set_other_aid_raw(&mut self, value: [u8; 4]) {
        self.other_aid_raw = value;
    }
    pub fn set_guild_name(&mut self, value: [char; 24]) {
        self.guild_name = value;
    }
    pub fn set_guild_name_raw(&mut self, value: [u8; 24]) {
        self.guild_name_raw = value;
    }
    pub fn new() -> PacketZcReqAllyGuild {
        PacketZcReqAllyGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x17, 0x1]),
        packet_id_raw: [0x17, 0x1],
        other_aid: 0,
        other_aid_raw: [0; 4],
        guild_name: [0 as char; 24],
        guild_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcReqAllyGuild {
    fn id(&self) -> &str {
       "0x0171"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzAllyGuild {
    pub fn from(buffer: &[u8]) -> PacketCzAllyGuild {
        PacketCzAllyGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            other_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            other_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            answer: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            answer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.other_aid).unwrap();
        self.other_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.other_aid_raw.to_vec());
        wtr.append(&mut self.answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_other_aid(&mut self, value: u32) {
        self.other_aid = value;
    }
    pub fn set_other_aid_raw(&mut self, value: [u8; 4]) {
        self.other_aid_raw = value;
    }
    pub fn set_answer(&mut self, value: i32) {
        self.answer = value;
    }
    pub fn set_answer_raw(&mut self, value: [u8; 4]) {
        self.answer_raw = value;
    }
    pub fn new() -> PacketCzAllyGuild {
        PacketCzAllyGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x17, 0x2]),
        packet_id_raw: [0x17, 0x2],
        other_aid: 0,
        other_aid_raw: [0; 4],
        answer: 0,
        answer_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzAllyGuild {
    fn id(&self) -> &str {
       "0x0172"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckReqAllyGuild {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqAllyGuild {
        PacketZcAckReqAllyGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            answer: u8::from_le_bytes([buffer[2]]),
            answer_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_answer(&mut self, value: u8) {
        self.answer = value;
    }
    pub fn set_answer_raw(&mut self, value: [u8; 1]) {
        self.answer_raw = value;
    }
    pub fn new() -> PacketZcAckReqAllyGuild {
        PacketZcAckReqAllyGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x17, 0x3]),
        packet_id_raw: [0x17, 0x3],
        answer: 0,
        answer_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckReqAllyGuild {
    fn id(&self) -> &str {
       "0x0173"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckChangeGuildPositioninfo {
    pub fn from(buffer: &[u8]) -> PacketZcAckChangeGuildPositioninfo {
        let iter_count = (&buffer.len() - 4) / 30;
        let mut vec_field: Vec<GuildRegPositionInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (30 * (i - 1));
            let end_pos = 4 + 30 * i;
            vec_field.push(GuildRegPositionInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcAckChangeGuildPositioninfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            member_list: vec_field.clone(),
            member_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_list_raw = {
            self.member_list.iter_mut().for_each(|item| item.fill_raw());
            self.member_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.member_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_member_list(&mut self, value: Vec<GuildRegPositionInfo>) {
        self.member_list = value;
    }
    pub fn set_member_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.member_list_raw = value;
    }
    pub fn new() -> PacketZcAckChangeGuildPositioninfo {
        PacketZcAckChangeGuildPositioninfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x17, 0x4]),
        packet_id_raw: [0x17, 0x4],
        packet_length: 0,
        packet_length_raw: [0; 2],
        member_list: vec![],
        member_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcAckChangeGuildPositioninfo {
    fn id(&self) -> &str {
       "0x0174"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqGuildMemberInfo {
    pub fn from(buffer: &[u8]) -> PacketCzReqGuildMemberInfo {
        PacketCzReqGuildMemberInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: i32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new() -> PacketCzReqGuildMemberInfo {
        PacketCzReqGuildMemberInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x17, 0x5]),
        packet_id_raw: [0x17, 0x5],
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqGuildMemberInfo {
    fn id(&self) -> &str {
       "0x0175"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckGuildMemberInfo {
    pub fn from(buffer: &[u8]) -> PacketZcAckGuildMemberInfo {
        PacketZcAckGuildMemberInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            info: GuildMemberInfo::from(&buffer[2..buffer.len()]),
            info_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.info.fill_raw();
        self.info_raw = self.info.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_info(&mut self, value: GuildMemberInfo) {
        self.info = value;
    }
    pub fn set_info_raw(&mut self, value: Vec<u8>) {
        self.info_raw = value;
    }
    pub fn new() -> PacketZcAckGuildMemberInfo {
        PacketZcAckGuildMemberInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x17, 0x6]),
        packet_id_raw: [0x17, 0x6],
        info: GuildMemberInfo::new(),
        info_raw: vec![],
        }
    }
}

impl Packet for PacketZcAckGuildMemberInfo {
    fn id(&self) -> &str {
       "0x0176"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcItemidentifyList {
    pub fn from(buffer: &[u8]) -> PacketZcItemidentifyList {
        PacketZcItemidentifyList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            itidlist:  {
                let dst: Vec<u8> = buffer[4..buffer.len()].to_vec();
                dst
            },
            itidlist_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.itidlist_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_itidlist(&mut self, value: Vec<u8>) {
        self.itidlist = value;
    }
    pub fn set_itidlist_raw(&mut self, value: Vec<u8>) {
        self.itidlist_raw = value;
    }
    pub fn new() -> PacketZcItemidentifyList {
        PacketZcItemidentifyList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x17, 0x7]),
        packet_id_raw: [0x17, 0x7],
        packet_length: 0,
        packet_length_raw: [0; 2],
        itidlist: vec![],
        itidlist_raw: vec![],
        }
    }
}

impl Packet for PacketZcItemidentifyList {
    fn id(&self) -> &str {
       "0x0177"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqItemidentify {
    pub fn from(buffer: &[u8]) -> PacketCzReqItemidentify {
        PacketCzReqItemidentify {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn new() -> PacketCzReqItemidentify {
        PacketCzReqItemidentify {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x17, 0x8]),
        packet_id_raw: [0x17, 0x8],
        index: 0,
        index_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqItemidentify {
    fn id(&self) -> &str {
       "0x0178"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckItemidentify {
    pub fn from(buffer: &[u8]) -> PacketZcAckItemidentify {
        PacketZcAckItemidentify {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            result: u8::from_le_bytes([buffer[4]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcAckItemidentify {
        PacketZcAckItemidentify {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x17, 0x9]),
        packet_id_raw: [0x17, 0x9],
        index: 0,
        index_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckItemidentify {
    fn id(&self) -> &str {
       "0x0179"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqItemcompositionList {
    pub fn from(buffer: &[u8]) -> PacketCzReqItemcompositionList {
        PacketCzReqItemcompositionList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            card_index: i16::from_le_bytes([buffer[2], buffer[3]]),
            card_index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.card_index).unwrap();
        self.card_index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.card_index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_card_index(&mut self, value: i16) {
        self.card_index = value;
    }
    pub fn set_card_index_raw(&mut self, value: [u8; 2]) {
        self.card_index_raw = value;
    }
    pub fn new() -> PacketCzReqItemcompositionList {
        PacketCzReqItemcompositionList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x17, 0xa]),
        packet_id_raw: [0x17, 0xa],
        card_index: 0,
        card_index_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqItemcompositionList {
    fn id(&self) -> &str {
       "0x017a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcItemcompositionList {
    pub fn from(buffer: &[u8]) -> PacketZcItemcompositionList {
        PacketZcItemcompositionList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            itidlist:  {
                let dst: Vec<u8> = buffer[4..buffer.len()].to_vec();
                dst
            },
            itidlist_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.itidlist_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_itidlist(&mut self, value: Vec<u8>) {
        self.itidlist = value;
    }
    pub fn set_itidlist_raw(&mut self, value: Vec<u8>) {
        self.itidlist_raw = value;
    }
    pub fn new() -> PacketZcItemcompositionList {
        PacketZcItemcompositionList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x17, 0xb]),
        packet_id_raw: [0x17, 0xb],
        packet_length: 0,
        packet_length_raw: [0; 2],
        itidlist: vec![],
        itidlist_raw: vec![],
        }
    }
}

impl Packet for PacketZcItemcompositionList {
    fn id(&self) -> &str {
       "0x017b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqItemcomposition {
    pub fn from(buffer: &[u8]) -> PacketCzReqItemcomposition {
        PacketCzReqItemcomposition {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            card_index: i16::from_le_bytes([buffer[2], buffer[3]]),
            card_index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            equip_index: i16::from_le_bytes([buffer[4], buffer[5]]),
            equip_index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.card_index).unwrap();
        self.card_index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.equip_index).unwrap();
        self.equip_index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.card_index_raw.to_vec());
        wtr.append(&mut self.equip_index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_card_index(&mut self, value: i16) {
        self.card_index = value;
    }
    pub fn set_card_index_raw(&mut self, value: [u8; 2]) {
        self.card_index_raw = value;
    }
    pub fn set_equip_index(&mut self, value: i16) {
        self.equip_index = value;
    }
    pub fn set_equip_index_raw(&mut self, value: [u8; 2]) {
        self.equip_index_raw = value;
    }
    pub fn new() -> PacketCzReqItemcomposition {
        PacketCzReqItemcomposition {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x17, 0xc]),
        packet_id_raw: [0x17, 0xc],
        card_index: 0,
        card_index_raw: [0; 2],
        equip_index: 0,
        equip_index_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqItemcomposition {
    fn id(&self) -> &str {
       "0x017c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckItemcomposition {
    pub fn from(buffer: &[u8]) -> PacketZcAckItemcomposition {
        PacketZcAckItemcomposition {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            equip_index: i16::from_le_bytes([buffer[2], buffer[3]]),
            equip_index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            card_index: i16::from_le_bytes([buffer[4], buffer[5]]),
            card_index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            result: u8::from_le_bytes([buffer[6]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.equip_index).unwrap();
        self.equip_index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.card_index).unwrap();
        self.card_index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.equip_index_raw.to_vec());
        wtr.append(&mut self.card_index_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_equip_index(&mut self, value: i16) {
        self.equip_index = value;
    }
    pub fn set_equip_index_raw(&mut self, value: [u8; 2]) {
        self.equip_index_raw = value;
    }
    pub fn set_card_index(&mut self, value: i16) {
        self.card_index = value;
    }
    pub fn set_card_index_raw(&mut self, value: [u8; 2]) {
        self.card_index_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcAckItemcomposition {
        PacketZcAckItemcomposition {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x17, 0xd]),
        packet_id_raw: [0x17, 0xd],
        equip_index: 0,
        equip_index_raw: [0; 2],
        card_index: 0,
        card_index_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckItemcomposition {
    fn id(&self) -> &str {
       "0x017d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzGuildChat {
    pub fn from(buffer: &[u8]) -> PacketCzGuildChat {
        PacketCzGuildChat {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            msg_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketCzGuildChat {
        PacketCzGuildChat {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x17, 0xe]),
        packet_id_raw: [0x17, 0xe],
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketCzGuildChat {
    fn id(&self) -> &str {
       "0x017e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcGuildChat {
    pub fn from(buffer: &[u8]) -> PacketZcGuildChat {
        PacketZcGuildChat {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            msg_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketZcGuildChat {
        PacketZcGuildChat {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x17, 0xf]),
        packet_id_raw: [0x17, 0xf],
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcGuildChat {
    fn id(&self) -> &str {
       "0x017f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqHostileGuild {
    pub fn from(buffer: &[u8]) -> PacketCzReqHostileGuild {
        PacketCzReqHostileGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketCzReqHostileGuild {
        PacketCzReqHostileGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x18, 0x0]),
        packet_id_raw: [0x18, 0x0],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqHostileGuild {
    fn id(&self) -> &str {
       "0x0180"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckReqHostileGuild {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqHostileGuild {
        PacketZcAckReqHostileGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcAckReqHostileGuild {
        PacketZcAckReqHostileGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x18, 0x1]),
        packet_id_raw: [0x18, 0x1],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckReqHostileGuild {
    fn id(&self) -> &str {
       "0x0181"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMemberAdd {
    pub fn from(buffer: &[u8]) -> PacketZcMemberAdd {
        PacketZcMemberAdd {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            info: GuildMemberInfo::from(&buffer[2..buffer.len()]),
            info_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.info.fill_raw();
        self.info_raw = self.info.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_info(&mut self, value: GuildMemberInfo) {
        self.info = value;
    }
    pub fn set_info_raw(&mut self, value: Vec<u8>) {
        self.info_raw = value;
    }
    pub fn new() -> PacketZcMemberAdd {
        PacketZcMemberAdd {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x18, 0x2]),
        packet_id_raw: [0x18, 0x2],
        info: GuildMemberInfo::new(),
        info_raw: vec![],
        }
    }
}

impl Packet for PacketZcMemberAdd {
    fn id(&self) -> &str {
       "0x0182"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqDeleteRelatedGuild {
    pub fn from(buffer: &[u8]) -> PacketCzReqDeleteRelatedGuild {
        PacketCzReqDeleteRelatedGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            opponent_gdid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            opponent_gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            relation: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            relation_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.opponent_gdid).unwrap();
        self.opponent_gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.relation).unwrap();
        self.relation_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.opponent_gdid_raw.to_vec());
        wtr.append(&mut self.relation_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_opponent_gdid(&mut self, value: u32) {
        self.opponent_gdid = value;
    }
    pub fn set_opponent_gdid_raw(&mut self, value: [u8; 4]) {
        self.opponent_gdid_raw = value;
    }
    pub fn set_relation(&mut self, value: i32) {
        self.relation = value;
    }
    pub fn set_relation_raw(&mut self, value: [u8; 4]) {
        self.relation_raw = value;
    }
    pub fn new() -> PacketCzReqDeleteRelatedGuild {
        PacketCzReqDeleteRelatedGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x18, 0x3]),
        packet_id_raw: [0x18, 0x3],
        opponent_gdid: 0,
        opponent_gdid_raw: [0; 4],
        relation: 0,
        relation_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqDeleteRelatedGuild {
    fn id(&self) -> &str {
       "0x0183"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcDeleteRelatedGuild {
    pub fn from(buffer: &[u8]) -> PacketZcDeleteRelatedGuild {
        PacketZcDeleteRelatedGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            opponent_gdid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            opponent_gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            relation: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            relation_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.opponent_gdid).unwrap();
        self.opponent_gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.relation).unwrap();
        self.relation_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.opponent_gdid_raw.to_vec());
        wtr.append(&mut self.relation_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_opponent_gdid(&mut self, value: u32) {
        self.opponent_gdid = value;
    }
    pub fn set_opponent_gdid_raw(&mut self, value: [u8; 4]) {
        self.opponent_gdid_raw = value;
    }
    pub fn set_relation(&mut self, value: i32) {
        self.relation = value;
    }
    pub fn set_relation_raw(&mut self, value: [u8; 4]) {
        self.relation_raw = value;
    }
    pub fn new() -> PacketZcDeleteRelatedGuild {
        PacketZcDeleteRelatedGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x18, 0x4]),
        packet_id_raw: [0x18, 0x4],
        opponent_gdid: 0,
        opponent_gdid_raw: [0; 4],
        relation: 0,
        relation_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDeleteRelatedGuild {
    fn id(&self) -> &str {
       "0x0184"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAddRelatedGuild {
    pub fn from(buffer: &[u8]) -> PacketZcAddRelatedGuild {
        PacketZcAddRelatedGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            info: RelatedGuildInfo::from(&buffer[2..buffer.len()]),
            info_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.info.fill_raw();
        self.info_raw = self.info.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_info(&mut self, value: RelatedGuildInfo) {
        self.info = value;
    }
    pub fn set_info_raw(&mut self, value: Vec<u8>) {
        self.info_raw = value;
    }
    pub fn new() -> PacketZcAddRelatedGuild {
        PacketZcAddRelatedGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x18, 0x5]),
        packet_id_raw: [0x18, 0x5],
        info: RelatedGuildInfo::new(),
        info_raw: vec![],
        }
    }
}

impl Packet for PacketZcAddRelatedGuild {
    fn id(&self) -> &str {
       "0x0185"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCollectordead {
    pub fn from(buffer: &[u8]) -> PacketCollectordead {
        PacketCollectordead {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            server_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            server_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.server_id).unwrap();
        self.server_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.server_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_server_id(&mut self, value: u32) {
        self.server_id = value;
    }
    pub fn set_server_id_raw(&mut self, value: [u8; 4]) {
        self.server_id_raw = value;
    }
    pub fn new() -> PacketCollectordead {
        PacketCollectordead {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x18, 0x6]),
        packet_id_raw: [0x18, 0x6],
        server_id: 0,
        server_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketCollectordead {
    fn id(&self) -> &str {
       "0x0186"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketPing {
    pub fn from(buffer: &[u8]) -> PacketPing {
        PacketPing {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketPing {
        PacketPing {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x18, 0x7]),
        packet_id_raw: [0x18, 0x7],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketPing {
    fn id(&self) -> &str {
       "0x0187"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckItemrefining {
    pub fn from(buffer: &[u8]) -> PacketZcAckItemrefining {
        PacketZcAckItemrefining {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_index: i16::from_le_bytes([buffer[4], buffer[5]]),
            item_index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            refining_level: i16::from_le_bytes([buffer[6], buffer[7]]),
            refining_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.item_index).unwrap();
        self.item_index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.item_index_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn set_item_index(&mut self, value: i16) {
        self.item_index = value;
    }
    pub fn set_item_index_raw(&mut self, value: [u8; 2]) {
        self.item_index_raw = value;
    }
    pub fn set_refining_level(&mut self, value: i16) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 2]) {
        self.refining_level_raw = value;
    }
    pub fn new() -> PacketZcAckItemrefining {
        PacketZcAckItemrefining {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x18, 0x8]),
        packet_id_raw: [0x18, 0x8],
        result: 0,
        result_raw: [0; 2],
        item_index: 0,
        item_index_raw: [0; 2],
        refining_level: 0,
        refining_level_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAckItemrefining {
    fn id(&self) -> &str {
       "0x0188"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyMapinfo {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMapinfo {
        PacketZcNotifyMapinfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketZcNotifyMapinfo {
        PacketZcNotifyMapinfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x18, 0x9]),
        packet_id_raw: [0x18, 0x9],
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyMapinfo {
    fn id(&self) -> &str {
       "0x0189"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqDisconnect {
    pub fn from(buffer: &[u8]) -> PacketCzReqDisconnect {
        PacketCzReqDisconnect {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketCzReqDisconnect {
        PacketCzReqDisconnect {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x18, 0xa]),
        packet_id_raw: [0x18, 0xa],
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqDisconnect {
    fn id(&self) -> &str {
       "0x018a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckReqDisconnect {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqDisconnect {
        PacketZcAckReqDisconnect {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcAckReqDisconnect {
        PacketZcAckReqDisconnect {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x18, 0xb]),
        packet_id_raw: [0x18, 0xb],
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAckReqDisconnect {
    fn id(&self) -> &str {
       "0x018b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMonsterInfo {
    pub fn from(buffer: &[u8]) -> PacketZcMonsterInfo {
        PacketZcMonsterInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            job: i16::from_le_bytes([buffer[2], buffer[3]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            level: i16::from_le_bytes([buffer[4], buffer[5]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            size: i16::from_le_bytes([buffer[6], buffer[7]]),
            size_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            hp: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            def: i16::from_le_bytes([buffer[12], buffer[13]]),
            def_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            race_type: i16::from_le_bytes([buffer[14], buffer[15]]),
            race_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            mdef_power: i16::from_le_bytes([buffer[16], buffer[17]]),
            mdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            property: i16::from_le_bytes([buffer[18], buffer[19]]),
            property_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            property_table: MonsterInfoElement::from(&buffer[20..buffer.len()]),
            property_table_raw: buffer[20..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.size).unwrap();
        self.size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.def).unwrap();
        self.def_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.race_type).unwrap();
        self.race_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef_power).unwrap();
        self.mdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.property).unwrap();
        self.property_raw = wtr.try_into().unwrap();
        self.property_table.fill_raw();
        self.property_table_raw = self.property_table.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.size_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.def_raw.to_vec());
        wtr.append(&mut self.race_type_raw.to_vec());
        wtr.append(&mut self.mdef_power_raw.to_vec());
        wtr.append(&mut self.property_raw.to_vec());
        wtr.append(&mut self.property_table_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_size(&mut self, value: i16) {
        self.size = value;
    }
    pub fn set_size_raw(&mut self, value: [u8; 2]) {
        self.size_raw = value;
    }
    pub fn set_hp(&mut self, value: i32) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 4]) {
        self.hp_raw = value;
    }
    pub fn set_def(&mut self, value: i16) {
        self.def = value;
    }
    pub fn set_def_raw(&mut self, value: [u8; 2]) {
        self.def_raw = value;
    }
    pub fn set_race_type(&mut self, value: i16) {
        self.race_type = value;
    }
    pub fn set_race_type_raw(&mut self, value: [u8; 2]) {
        self.race_type_raw = value;
    }
    pub fn set_mdef_power(&mut self, value: i16) {
        self.mdef_power = value;
    }
    pub fn set_mdef_power_raw(&mut self, value: [u8; 2]) {
        self.mdef_power_raw = value;
    }
    pub fn set_property(&mut self, value: i16) {
        self.property = value;
    }
    pub fn set_property_raw(&mut self, value: [u8; 2]) {
        self.property_raw = value;
    }
    pub fn set_property_table(&mut self, value: MonsterInfoElement) {
        self.property_table = value;
    }
    pub fn set_property_table_raw(&mut self, value: Vec<u8>) {
        self.property_table_raw = value;
    }
    pub fn new() -> PacketZcMonsterInfo {
        PacketZcMonsterInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x18, 0xc]),
        packet_id_raw: [0x18, 0xc],
        job: 0,
        job_raw: [0; 2],
        level: 0,
        level_raw: [0; 2],
        size: 0,
        size_raw: [0; 2],
        hp: 0,
        hp_raw: [0; 4],
        def: 0,
        def_raw: [0; 2],
        race_type: 0,
        race_type_raw: [0; 2],
        mdef_power: 0,
        mdef_power_raw: [0; 2],
        property: 0,
        property_raw: [0; 2],
        property_table: MonsterInfoElement::new(),
        property_table_raw: vec![],
        }
    }
}

impl Packet for PacketZcMonsterInfo {
    fn id(&self) -> &str {
       "0x018c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMakableitemlist {
    pub fn from(buffer: &[u8]) -> PacketZcMakableitemlist {
        PacketZcMakableitemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            info: MakableitemInfo::from(&buffer[4..buffer.len()]),
            info_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.info.fill_raw();
        self.info_raw = self.info.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_info(&mut self, value: MakableitemInfo) {
        self.info = value;
    }
    pub fn set_info_raw(&mut self, value: Vec<u8>) {
        self.info_raw = value;
    }
    pub fn new() -> PacketZcMakableitemlist {
        PacketZcMakableitemlist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x18, 0xd]),
        packet_id_raw: [0x18, 0xd],
        packet_length: 0,
        packet_length_raw: [0; 2],
        info: MakableitemInfo::new(),
        info_raw: vec![],
        }
    }
}

impl Packet for PacketZcMakableitemlist {
    fn id(&self) -> &str {
       "0x018d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqmakingitem {
    pub fn from(buffer: &[u8]) -> PacketCzReqmakingitem {
        PacketCzReqmakingitem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            info: MakableitemInfo::from(&buffer[2..buffer.len()]),
            info_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.info.fill_raw();
        self.info_raw = self.info.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_info(&mut self, value: MakableitemInfo) {
        self.info = value;
    }
    pub fn set_info_raw(&mut self, value: Vec<u8>) {
        self.info_raw = value;
    }
    pub fn new() -> PacketCzReqmakingitem {
        PacketCzReqmakingitem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x18, 0xe]),
        packet_id_raw: [0x18, 0xe],
        info: MakableitemInfo::new(),
        info_raw: vec![],
        }
    }
}

impl Packet for PacketCzReqmakingitem {
    fn id(&self) -> &str {
       "0x018e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckReqmakingitem {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqmakingitem {
        PacketZcAckReqmakingitem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            itid: u16::from_le_bytes([buffer[4], buffer[5]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new() -> PacketZcAckReqmakingitem {
        PacketZcAckReqmakingitem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x18, 0xf]),
        packet_id_raw: [0x18, 0xf],
        result: 0,
        result_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAckReqmakingitem {
    fn id(&self) -> &str {
       "0x018f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzUseSkillTogroundWithtalkbox {
    pub fn from(buffer: &[u8]) -> PacketCzUseSkillTogroundWithtalkbox {
        PacketCzUseSkillTogroundWithtalkbox {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            selected_level: i16::from_le_bytes([buffer[2], buffer[3]]),
            selected_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            skid: u16::from_le_bytes([buffer[4], buffer[5]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[6], buffer[7]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[8], buffer[9]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            contents:  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[10..90].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            contents_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[10..90]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.selected_level).unwrap();
        self.selected_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.contents {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.contents_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.selected_level_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.contents_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_selected_level(&mut self, value: i16) {
        self.selected_level = value;
    }
    pub fn set_selected_level_raw(&mut self, value: [u8; 2]) {
        self.selected_level_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_contents(&mut self, value: [char; 80]) {
        self.contents = value;
    }
    pub fn set_contents_raw(&mut self, value: [u8; 80]) {
        self.contents_raw = value;
    }
    pub fn new() -> PacketCzUseSkillTogroundWithtalkbox {
        PacketCzUseSkillTogroundWithtalkbox {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x19, 0x0]),
        packet_id_raw: [0x19, 0x0],
        selected_level: 0,
        selected_level_raw: [0; 2],
        skid: 0,
        skid_raw: [0; 2],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        contents: [0 as char; 80],
        contents_raw: [0; 80],
        }
    }
}

impl Packet for PacketCzUseSkillTogroundWithtalkbox {
    fn id(&self) -> &str {
       "0x0190"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcTalkboxChatcontents {
    pub fn from(buffer: &[u8]) -> PacketZcTalkboxChatcontents {
        PacketZcTalkboxChatcontents {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            contents:  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[6..86].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            contents_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[6..86]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.contents {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.contents_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.contents_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_contents(&mut self, value: [char; 80]) {
        self.contents = value;
    }
    pub fn set_contents_raw(&mut self, value: [u8; 80]) {
        self.contents_raw = value;
    }
    pub fn new() -> PacketZcTalkboxChatcontents {
        PacketZcTalkboxChatcontents {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x19, 0x1]),
        packet_id_raw: [0x19, 0x1],
        aid: 0,
        aid_raw: [0; 4],
        contents: [0 as char; 80],
        contents_raw: [0; 80],
        }
    }
}

impl Packet for PacketZcTalkboxChatcontents {
    fn id(&self) -> &str {
       "0x0191"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcUpdateMapinfo {
    pub fn from(buffer: &[u8]) -> PacketZcUpdateMapinfo {
        PacketZcUpdateMapinfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[2], buffer[3]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[4], buffer[5]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            atype: i16::from_le_bytes([buffer[6], buffer[7]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[8..24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[8..24]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn new() -> PacketZcUpdateMapinfo {
        PacketZcUpdateMapinfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x19, 0x2]),
        packet_id_raw: [0x19, 0x2],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 2],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        }
    }
}

impl Packet for PacketZcUpdateMapinfo {
    fn id(&self) -> &str {
       "0x0192"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqnameBygid {
    pub fn from(buffer: &[u8]) -> PacketCzReqnameBygid {
        PacketCzReqnameBygid {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new() -> PacketCzReqnameBygid {
        PacketCzReqnameBygid {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x19, 0x3]),
        packet_id_raw: [0x19, 0x3],
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqnameBygid {
    fn id(&self) -> &str {
       "0x0193"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckReqnameBygid {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqnameBygid {
        PacketZcAckReqnameBygid {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            cname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            cname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.cname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.cname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.cname_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_cname(&mut self, value: [char; 24]) {
        self.cname = value;
    }
    pub fn set_cname_raw(&mut self, value: [u8; 24]) {
        self.cname_raw = value;
    }
    pub fn new() -> PacketZcAckReqnameBygid {
        PacketZcAckReqnameBygid {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x19, 0x4]),
        packet_id_raw: [0x19, 0x4],
        gid: 0,
        gid_raw: [0; 4],
        cname: [0 as char; 24],
        cname_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcAckReqnameBygid {
    fn id(&self) -> &str {
       "0x0194"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckReqnameall {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqnameall {
        PacketZcAckReqnameall {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            cname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            cname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            pname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[30..54].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[30..54]);
                dst
            },
            gname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[54..78].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            gname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[54..78]);
                dst
            },
            rname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[78..102].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            rname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[78..102]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.cname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.cname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.gname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.gname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.rname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.rname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.cname_raw.to_vec());
        wtr.append(&mut self.pname_raw.to_vec());
        wtr.append(&mut self.gname_raw.to_vec());
        wtr.append(&mut self.rname_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_cname(&mut self, value: [char; 24]) {
        self.cname = value;
    }
    pub fn set_cname_raw(&mut self, value: [u8; 24]) {
        self.cname_raw = value;
    }
    pub fn set_pname(&mut self, value: [char; 24]) {
        self.pname = value;
    }
    pub fn set_pname_raw(&mut self, value: [u8; 24]) {
        self.pname_raw = value;
    }
    pub fn set_gname(&mut self, value: [char; 24]) {
        self.gname = value;
    }
    pub fn set_gname_raw(&mut self, value: [u8; 24]) {
        self.gname_raw = value;
    }
    pub fn set_rname(&mut self, value: [char; 24]) {
        self.rname = value;
    }
    pub fn set_rname_raw(&mut self, value: [u8; 24]) {
        self.rname_raw = value;
    }
    pub fn new() -> PacketZcAckReqnameall {
        PacketZcAckReqnameall {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x19, 0x5]),
        packet_id_raw: [0x19, 0x5],
        aid: 0,
        aid_raw: [0; 4],
        cname: [0 as char; 24],
        cname_raw: [0; 24],
        pname: [0 as char; 24],
        pname_raw: [0; 24],
        gname: [0 as char; 24],
        gname_raw: [0; 24],
        rname: [0 as char; 24],
        rname_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcAckReqnameall {
    fn id(&self) -> &str {
       "0x0195"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMsgStateChange {
    pub fn from(buffer: &[u8]) -> PacketZcMsgStateChange {
        PacketZcMsgStateChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            state: buffer[8] == 1,
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state as u8).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_state(&mut self, value: bool) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn new() -> PacketZcMsgStateChange {
        PacketZcMsgStateChange {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x19, 0x6]),
        packet_id_raw: [0x19, 0x6],
        index: 0,
        index_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        state: false,
        state_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcMsgStateChange {
    fn id(&self) -> &str {
       "0x0196"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReset {
    pub fn from(buffer: &[u8]) -> PacketCzReset {
        PacketCzReset {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketCzReset {
        PacketCzReset {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x19, 0x7]),
        packet_id_raw: [0x19, 0x7],
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReset {
    fn id(&self) -> &str {
       "0x0197"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzChangeMaptype {
    pub fn from(buffer: &[u8]) -> PacketCzChangeMaptype {
        PacketCzChangeMaptype {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[2], buffer[3]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[4], buffer[5]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            atype: i16::from_le_bytes([buffer[6], buffer[7]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketCzChangeMaptype {
        PacketCzChangeMaptype {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x19, 0x8]),
        packet_id_raw: [0x19, 0x8],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzChangeMaptype {
    fn id(&self) -> &str {
       "0x0198"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyMapproperty {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMapproperty {
        PacketZcNotifyMapproperty {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketZcNotifyMapproperty {
        PacketZcNotifyMapproperty {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x19, 0x9]),
        packet_id_raw: [0x19, 0x9],
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyMapproperty {
    fn id(&self) -> &str {
       "0x0199"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyRanking {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyRanking {
        PacketZcNotifyRanking {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            ranking: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            ranking_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            total: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            total_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.ranking).unwrap();
        self.ranking_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.total).unwrap();
        self.total_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.ranking_raw.to_vec());
        wtr.append(&mut self.total_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_ranking(&mut self, value: i32) {
        self.ranking = value;
    }
    pub fn set_ranking_raw(&mut self, value: [u8; 4]) {
        self.ranking_raw = value;
    }
    pub fn set_total(&mut self, value: i32) {
        self.total = value;
    }
    pub fn set_total_raw(&mut self, value: [u8; 4]) {
        self.total_raw = value;
    }
    pub fn new() -> PacketZcNotifyRanking {
        PacketZcNotifyRanking {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x19, 0xa]),
        packet_id_raw: [0x19, 0xa],
        aid: 0,
        aid_raw: [0; 4],
        ranking: 0,
        ranking_raw: [0; 4],
        total: 0,
        total_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyRanking {
    fn id(&self) -> &str {
       "0x019a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyEffect {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyEffect {
        PacketZcNotifyEffect {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            effect_id: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            effect_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_id).unwrap();
        self.effect_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.effect_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_effect_id(&mut self, value: i32) {
        self.effect_id = value;
    }
    pub fn set_effect_id_raw(&mut self, value: [u8; 4]) {
        self.effect_id_raw = value;
    }
    pub fn new() -> PacketZcNotifyEffect {
        PacketZcNotifyEffect {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x19, 0xb]),
        packet_id_raw: [0x19, 0xb],
        aid: 0,
        aid_raw: [0; 4],
        effect_id: 0,
        effect_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyEffect {
    fn id(&self) -> &str {
       "0x019b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzChangeEffectstate {
    pub fn from(buffer: &[u8]) -> PacketCzChangeEffectstate {
        PacketCzChangeEffectstate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn new() -> PacketCzChangeEffectstate {
        PacketCzChangeEffectstate {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x19, 0xd]),
        packet_id_raw: [0x19, 0xd],
        effect_state: 0,
        effect_state_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzChangeEffectstate {
    fn id(&self) -> &str {
       "0x019d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcStartCapture {
    pub fn from(buffer: &[u8]) -> PacketZcStartCapture {
        PacketZcStartCapture {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketZcStartCapture {
        PacketZcStartCapture {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x19, 0xe]),
        packet_id_raw: [0x19, 0xe],
        }
    }
}

impl Packet for PacketZcStartCapture {
    fn id(&self) -> &str {
       "0x019e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzTrycaptureMonster {
    pub fn from(buffer: &[u8]) -> PacketCzTrycaptureMonster {
        PacketCzTrycaptureMonster {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            target_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            target_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_aid).unwrap();
        self.target_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.target_aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_target_aid(&mut self, value: u32) {
        self.target_aid = value;
    }
    pub fn set_target_aid_raw(&mut self, value: [u8; 4]) {
        self.target_aid_raw = value;
    }
    pub fn new() -> PacketCzTrycaptureMonster {
        PacketCzTrycaptureMonster {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x19, 0xf]),
        packet_id_raw: [0x19, 0xf],
        target_aid: 0,
        target_aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzTrycaptureMonster {
    fn id(&self) -> &str {
       "0x019f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcTrycaptureMonster {
    pub fn from(buffer: &[u8]) -> PacketZcTrycaptureMonster {
        PacketZcTrycaptureMonster {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcTrycaptureMonster {
        PacketZcTrycaptureMonster {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1a, 0x0]),
        packet_id_raw: [0x1a, 0x0],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcTrycaptureMonster {
    fn id(&self) -> &str {
       "0x01a0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzCommandPet {
    pub fn from(buffer: &[u8]) -> PacketCzCommandPet {
        PacketCzCommandPet {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            c_sub: i8::from_le_bytes([buffer[2]]),
            c_sub_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.c_sub).unwrap();
        self.c_sub_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.c_sub_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_c_sub(&mut self, value: i8) {
        self.c_sub = value;
    }
    pub fn set_c_sub_raw(&mut self, value: [u8; 1]) {
        self.c_sub_raw = value;
    }
    pub fn new() -> PacketCzCommandPet {
        PacketCzCommandPet {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1a, 0x1]),
        packet_id_raw: [0x1a, 0x1],
        c_sub: 0,
        c_sub_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzCommandPet {
    fn id(&self) -> &str {
       "0x01a1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPropertyPet {
    pub fn from(buffer: &[u8]) -> PacketZcPropertyPet {
        PacketZcPropertyPet {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            sz_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            sz_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            b_modified: u8::from_le_bytes([buffer[26]]),
            b_modified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[26..27]);
                dst
            },
            n_level: i16::from_le_bytes([buffer[27], buffer[28]]),
            n_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[27..29]);
                dst
            },
            n_fullness: i16::from_le_bytes([buffer[29], buffer[30]]),
            n_fullness_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[29..31]);
                dst
            },
            n_relationship: i16::from_le_bytes([buffer[31], buffer[32]]),
            n_relationship_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[31..33]);
                dst
            },
            itid: u16::from_le_bytes([buffer[33], buffer[34]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            job: i16::from_le_bytes([buffer[35], buffer[36]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[35..37]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.b_modified).unwrap();
        self.b_modified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.n_level).unwrap();
        self.n_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.n_fullness).unwrap();
        self.n_fullness_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.n_relationship).unwrap();
        self.n_relationship_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.sz_name_raw.to_vec());
        wtr.append(&mut self.b_modified_raw.to_vec());
        wtr.append(&mut self.n_level_raw.to_vec());
        wtr.append(&mut self.n_fullness_raw.to_vec());
        wtr.append(&mut self.n_relationship_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_sz_name(&mut self, value: [char; 24]) {
        self.sz_name = value;
    }
    pub fn set_sz_name_raw(&mut self, value: [u8; 24]) {
        self.sz_name_raw = value;
    }
    pub fn set_b_modified(&mut self, value: u8) {
        self.b_modified = value;
    }
    pub fn set_b_modified_raw(&mut self, value: [u8; 1]) {
        self.b_modified_raw = value;
    }
    pub fn set_n_level(&mut self, value: i16) {
        self.n_level = value;
    }
    pub fn set_n_level_raw(&mut self, value: [u8; 2]) {
        self.n_level_raw = value;
    }
    pub fn set_n_fullness(&mut self, value: i16) {
        self.n_fullness = value;
    }
    pub fn set_n_fullness_raw(&mut self, value: [u8; 2]) {
        self.n_fullness_raw = value;
    }
    pub fn set_n_relationship(&mut self, value: i16) {
        self.n_relationship = value;
    }
    pub fn set_n_relationship_raw(&mut self, value: [u8; 2]) {
        self.n_relationship_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn new() -> PacketZcPropertyPet {
        PacketZcPropertyPet {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1a, 0x2]),
        packet_id_raw: [0x1a, 0x2],
        sz_name: [0 as char; 24],
        sz_name_raw: [0; 24],
        b_modified: 0,
        b_modified_raw: [0; 1],
        n_level: 0,
        n_level_raw: [0; 2],
        n_fullness: 0,
        n_fullness_raw: [0; 2],
        n_relationship: 0,
        n_relationship_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcPropertyPet {
    fn id(&self) -> &str {
       "0x01a2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcFeedPet {
    pub fn from(buffer: &[u8]) -> PacketZcFeedPet {
        PacketZcFeedPet {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            c_ret: i8::from_le_bytes([buffer[2]]),
            c_ret_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            itid: u16::from_le_bytes([buffer[3], buffer[4]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[3..5]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.c_ret).unwrap();
        self.c_ret_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.c_ret_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_c_ret(&mut self, value: i8) {
        self.c_ret = value;
    }
    pub fn set_c_ret_raw(&mut self, value: [u8; 1]) {
        self.c_ret_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new() -> PacketZcFeedPet {
        PacketZcFeedPet {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1a, 0x3]),
        packet_id_raw: [0x1a, 0x3],
        c_ret: 0,
        c_ret_raw: [0; 1],
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcFeedPet {
    fn id(&self) -> &str {
       "0x01a3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcChangestatePet {
    pub fn from(buffer: &[u8]) -> PacketZcChangestatePet {
        PacketZcChangestatePet {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            gid: i32::from_le_bytes([buffer[3], buffer[4], buffer[5], buffer[6]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[3..7]);
                dst
            },
            data: i32::from_le_bytes([buffer[7], buffer[8], buffer[9], buffer[10]]),
            data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[7..11]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.data).unwrap();
        self.data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_gid(&mut self, value: i32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_data(&mut self, value: i32) {
        self.data = value;
    }
    pub fn set_data_raw(&mut self, value: [u8; 4]) {
        self.data_raw = value;
    }
    pub fn new() -> PacketZcChangestatePet {
        PacketZcChangestatePet {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1a, 0x4]),
        packet_id_raw: [0x1a, 0x4],
        atype: 0,
        atype_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        data: 0,
        data_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcChangestatePet {
    fn id(&self) -> &str {
       "0x01a4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRenamePet {
    pub fn from(buffer: &[u8]) -> PacketCzRenamePet {
        PacketCzRenamePet {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            sz_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            sz_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.sz_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_sz_name(&mut self, value: [char; 24]) {
        self.sz_name = value;
    }
    pub fn set_sz_name_raw(&mut self, value: [u8; 24]) {
        self.sz_name_raw = value;
    }
    pub fn new() -> PacketCzRenamePet {
        PacketCzRenamePet {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1a, 0x5]),
        packet_id_raw: [0x1a, 0x5],
        sz_name: [0 as char; 24],
        sz_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzRenamePet {
    fn id(&self) -> &str {
       "0x01a5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPeteggList {
    pub fn from(buffer: &[u8]) -> PacketZcPeteggList {
        let iter_count = (&buffer.len() - 4) / 2;
        let mut vec_field: Vec<PeteggitemInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (2 * (i - 1));
            let end_pos = 4 + 2 * i;
            vec_field.push(PeteggitemInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPeteggList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            egg_list: vec_field.clone(),
            egg_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.egg_list_raw = {
            self.egg_list.iter_mut().for_each(|item| item.fill_raw());
            self.egg_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.egg_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_egg_list(&mut self, value: Vec<PeteggitemInfo>) {
        self.egg_list = value;
    }
    pub fn set_egg_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.egg_list_raw = value;
    }
    pub fn new() -> PacketZcPeteggList {
        PacketZcPeteggList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1a, 0x6]),
        packet_id_raw: [0x1a, 0x6],
        packet_length: 0,
        packet_length_raw: [0; 2],
        egg_list: vec![],
        egg_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcPeteggList {
    fn id(&self) -> &str {
       "0x01a6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzSelectPetegg {
    pub fn from(buffer: &[u8]) -> PacketCzSelectPetegg {
        PacketCzSelectPetegg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn new() -> PacketCzSelectPetegg {
        PacketCzSelectPetegg {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1a, 0x7]),
        packet_id_raw: [0x1a, 0x7],
        index: 0,
        index_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzSelectPetegg {
    fn id(&self) -> &str {
       "0x01a7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzPeteggInfo {
    pub fn from(buffer: &[u8]) -> PacketCzPeteggInfo {
        PacketCzPeteggInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn new() -> PacketCzPeteggInfo {
        PacketCzPeteggInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1a, 0x8]),
        packet_id_raw: [0x1a, 0x8],
        index: 0,
        index_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzPeteggInfo {
    fn id(&self) -> &str {
       "0x01a8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzPetAct {
    pub fn from(buffer: &[u8]) -> PacketCzPetAct {
        PacketCzPetAct {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            data: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.data).unwrap();
        self.data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_data(&mut self, value: i32) {
        self.data = value;
    }
    pub fn set_data_raw(&mut self, value: [u8; 4]) {
        self.data_raw = value;
    }
    pub fn new() -> PacketCzPetAct {
        PacketCzPetAct {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1a, 0x9]),
        packet_id_raw: [0x1a, 0x9],
        data: 0,
        data_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzPetAct {
    fn id(&self) -> &str {
       "0x01a9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPetAct {
    pub fn from(buffer: &[u8]) -> PacketZcPetAct {
        PacketZcPetAct {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            data: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.data).unwrap();
        self.data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: i32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_data(&mut self, value: i32) {
        self.data = value;
    }
    pub fn set_data_raw(&mut self, value: [u8; 4]) {
        self.data_raw = value;
    }
    pub fn new() -> PacketZcPetAct {
        PacketZcPetAct {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1a, 0xa]),
        packet_id_raw: [0x1a, 0xa],
        gid: 0,
        gid_raw: [0; 4],
        data: 0,
        data_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcPetAct {
    fn id(&self) -> &str {
       "0x01aa"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcParChangeUser {
    pub fn from(buffer: &[u8]) -> PacketZcParChangeUser {
        PacketZcParChangeUser {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            var_id: u16::from_le_bytes([buffer[6], buffer[7]]),
            var_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            count: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var_id).unwrap();
        self.var_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.var_id_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_var_id(&mut self, value: u16) {
        self.var_id = value;
    }
    pub fn set_var_id_raw(&mut self, value: [u8; 2]) {
        self.var_id_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketZcParChangeUser {
        PacketZcParChangeUser {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1a, 0xb]),
        packet_id_raw: [0x1a, 0xb],
        aid: 0,
        aid_raw: [0; 4],
        var_id: 0,
        var_id_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcParChangeUser {
    fn id(&self) -> &str {
       "0x01ab"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSkillUpdate {
    pub fn from(buffer: &[u8]) -> PacketZcSkillUpdate {
        PacketZcSkillUpdate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketZcSkillUpdate {
        PacketZcSkillUpdate {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1a, 0xc]),
        packet_id_raw: [0x1a, 0xc],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcSkillUpdate {
    fn id(&self) -> &str {
       "0x01ac"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMakingarrowList {
    pub fn from(buffer: &[u8]) -> PacketZcMakingarrowList {
        let iter_count = (&buffer.len() - 4) / 2;
        let mut vec_field: Vec<ArrowitemInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (2 * (i - 1));
            let end_pos = 4 + 2 * i;
            vec_field.push(ArrowitemInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcMakingarrowList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            arrow_list: vec_field.clone(),
            arrow_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.arrow_list_raw = {
            self.arrow_list.iter_mut().for_each(|item| item.fill_raw());
            self.arrow_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.arrow_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_arrow_list(&mut self, value: Vec<ArrowitemInfo>) {
        self.arrow_list = value;
    }
    pub fn set_arrow_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.arrow_list_raw = value;
    }
    pub fn new() -> PacketZcMakingarrowList {
        PacketZcMakingarrowList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1a, 0xd]),
        packet_id_raw: [0x1a, 0xd],
        packet_length: 0,
        packet_length_raw: [0; 2],
        arrow_list: vec![],
        arrow_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcMakingarrowList {
    fn id(&self) -> &str {
       "0x01ad"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqMakingarrow {
    pub fn from(buffer: &[u8]) -> PacketCzReqMakingarrow {
        PacketCzReqMakingarrow {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            id: u16::from_le_bytes([buffer[2], buffer[3]]),
            id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.id).unwrap();
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_id(&mut self, value: u16) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 2]) {
        self.id_raw = value;
    }
    pub fn new() -> PacketCzReqMakingarrow {
        PacketCzReqMakingarrow {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1a, 0xe]),
        packet_id_raw: [0x1a, 0xe],
        id: 0,
        id_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqMakingarrow {
    fn id(&self) -> &str {
       "0x01ae"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqChangecart {
    pub fn from(buffer: &[u8]) -> PacketCzReqChangecart {
        PacketCzReqChangecart {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            num: i16::from_le_bytes([buffer[2], buffer[3]]),
            num_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.num).unwrap();
        self.num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.num_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_num(&mut self, value: i16) {
        self.num = value;
    }
    pub fn set_num_raw(&mut self, value: [u8; 2]) {
        self.num_raw = value;
    }
    pub fn new() -> PacketCzReqChangecart {
        PacketCzReqChangecart {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1a, 0xf]),
        packet_id_raw: [0x1a, 0xf],
        num: 0,
        num_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqChangecart {
    fn id(&self) -> &str {
       "0x01af"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNpcspriteChange {
    pub fn from(buffer: &[u8]) -> PacketZcNpcspriteChange {
        PacketZcNpcspriteChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            value: u32::from_le_bytes([buffer[7], buffer[8], buffer[9], buffer[10]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[7..11]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_value(&mut self, value: u32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new() -> PacketZcNpcspriteChange {
        PacketZcNpcspriteChange {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1b, 0x0]),
        packet_id_raw: [0x1b, 0x0],
        gid: 0,
        gid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNpcspriteChange {
    fn id(&self) -> &str {
       "0x01b0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcShowdigit {
    pub fn from(buffer: &[u8]) -> PacketZcShowdigit {
        PacketZcShowdigit {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: u8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            value: i32::from_le_bytes([buffer[3], buffer[4], buffer[5], buffer[6]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[3..7]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new() -> PacketZcShowdigit {
        PacketZcShowdigit {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1b, 0x1]),
        packet_id_raw: [0x1b, 0x1],
        atype: 0,
        atype_raw: [0; 1],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcShowdigit {
    fn id(&self) -> &str {
       "0x01b1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqOpenstore2 {
    pub fn from(buffer: &[u8]) -> PacketCzReqOpenstore2 {
        let iter_count = (&buffer.len() - 85) / 8;
        let mut vec_field: Vec<StoreItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 85 + (8 * (i - 1));
            let end_pos = 85 + 8 * i;
            vec_field.push(StoreItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzReqOpenstore2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            store_name:  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[4..84].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            store_name_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[4..84]);
                dst
            },
            result: buffer[84] == 1,
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[84..85]);
                dst
            },
            store_list: vec_field.clone(),
            store_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.store_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.store_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        self.store_list_raw = {
            self.store_list.iter_mut().for_each(|item| item.fill_raw());
            self.store_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.store_name_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.store_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_store_name(&mut self, value: [char; 80]) {
        self.store_name = value;
    }
    pub fn set_store_name_raw(&mut self, value: [u8; 80]) {
        self.store_name_raw = value;
    }
    pub fn set_result(&mut self, value: bool) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn set_store_list(&mut self, value: Vec<StoreItem>) {
        self.store_list = value;
    }
    pub fn set_store_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.store_list_raw = value;
    }
    pub fn new() -> PacketCzReqOpenstore2 {
        PacketCzReqOpenstore2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1b, 0x2]),
        packet_id_raw: [0x1b, 0x2],
        packet_length: 0,
        packet_length_raw: [0; 2],
        store_name: [0 as char; 80],
        store_name_raw: [0; 80],
        result: false,
        result_raw: [0; 1],
        store_list: vec![],
        store_list_raw: vec![],
        }
    }
}

impl Packet for PacketCzReqOpenstore2 {
    fn id(&self) -> &str {
       "0x01b2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcShowImage2 {
    pub fn from(buffer: &[u8]) -> PacketZcShowImage2 {
        PacketZcShowImage2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            image_name:  {
                let mut dst: [char; 64] = [0 as char; 64];
                for (index, byte) in buffer[2..66].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            image_name_raw: {
                let mut dst: [u8; 64] = [0u8; 64];
                dst.clone_from_slice(&buffer[2..66]);
                dst
            },
            atype: u8::from_le_bytes([buffer[66]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[66..67]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.image_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.image_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.image_name_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_image_name(&mut self, value: [char; 64]) {
        self.image_name = value;
    }
    pub fn set_image_name_raw(&mut self, value: [u8; 64]) {
        self.image_name_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketZcShowImage2 {
        PacketZcShowImage2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1b, 0x3]),
        packet_id_raw: [0x1b, 0x3],
        image_name: [0 as char; 64],
        image_name_raw: [0; 64],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcShowImage2 {
    fn id(&self) -> &str {
       "0x01b3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcChangeGuild {
    pub fn from(buffer: &[u8]) -> PacketZcChangeGuild {
        PacketZcChangeGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gdid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            emblem_version: i16::from_le_bytes([buffer[10], buffer[11]]),
            emblem_version_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.emblem_version).unwrap();
        self.emblem_version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.emblem_version_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gdid(&mut self, value: u32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_emblem_version(&mut self, value: i16) {
        self.emblem_version = value;
    }
    pub fn set_emblem_version_raw(&mut self, value: [u8; 2]) {
        self.emblem_version_raw = value;
    }
    pub fn new() -> PacketZcChangeGuild {
        PacketZcChangeGuild {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1b, 0x4]),
        packet_id_raw: [0x1b, 0x4],
        aid: 0,
        aid_raw: [0; 4],
        gdid: 0,
        gdid_raw: [0; 4],
        emblem_version: 0,
        emblem_version_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcChangeGuild {
    fn id(&self) -> &str {
       "0x01b4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketScBillingInfo {
    pub fn from(buffer: &[u8]) -> PacketScBillingInfo {
        PacketScBillingInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            dw_amount_remain: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            dw_amount_remain_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            dw_quantity_remain: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            dw_quantity_remain_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            dw_reserved1: u32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            dw_reserved1_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            dw_reserved2: u32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            dw_reserved2_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_amount_remain).unwrap();
        self.dw_amount_remain_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_quantity_remain).unwrap();
        self.dw_quantity_remain_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_reserved1).unwrap();
        self.dw_reserved1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_reserved2).unwrap();
        self.dw_reserved2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.dw_amount_remain_raw.to_vec());
        wtr.append(&mut self.dw_quantity_remain_raw.to_vec());
        wtr.append(&mut self.dw_reserved1_raw.to_vec());
        wtr.append(&mut self.dw_reserved2_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_dw_amount_remain(&mut self, value: u32) {
        self.dw_amount_remain = value;
    }
    pub fn set_dw_amount_remain_raw(&mut self, value: [u8; 4]) {
        self.dw_amount_remain_raw = value;
    }
    pub fn set_dw_quantity_remain(&mut self, value: u32) {
        self.dw_quantity_remain = value;
    }
    pub fn set_dw_quantity_remain_raw(&mut self, value: [u8; 4]) {
        self.dw_quantity_remain_raw = value;
    }
    pub fn set_dw_reserved1(&mut self, value: u32) {
        self.dw_reserved1 = value;
    }
    pub fn set_dw_reserved1_raw(&mut self, value: [u8; 4]) {
        self.dw_reserved1_raw = value;
    }
    pub fn set_dw_reserved2(&mut self, value: u32) {
        self.dw_reserved2 = value;
    }
    pub fn set_dw_reserved2_raw(&mut self, value: [u8; 4]) {
        self.dw_reserved2_raw = value;
    }
    pub fn new() -> PacketScBillingInfo {
        PacketScBillingInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1b, 0x5]),
        packet_id_raw: [0x1b, 0x5],
        dw_amount_remain: 0,
        dw_amount_remain_raw: [0; 4],
        dw_quantity_remain: 0,
        dw_quantity_remain_raw: [0; 4],
        dw_reserved1: 0,
        dw_reserved1_raw: [0; 4],
        dw_reserved2: 0,
        dw_reserved2_raw: [0; 4],
        }
    }
}

impl Packet for PacketScBillingInfo {
    fn id(&self) -> &str {
       "0x01b5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcGuildInfo2 {
    pub fn from(buffer: &[u8]) -> PacketZcGuildInfo2 {
        PacketZcGuildInfo2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            level: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            user_num: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            user_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            max_user_num: i32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            max_user_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
            user_average_level: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            user_average_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
            exp: i32::from_le_bytes([buffer[22], buffer[23], buffer[24], buffer[25]]),
            exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[22..26]);
                dst
            },
            max_exp: i32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            max_exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
            point: i32::from_le_bytes([buffer[30], buffer[31], buffer[32], buffer[33]]),
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[30..34]);
                dst
            },
            honor: i32::from_le_bytes([buffer[34], buffer[35], buffer[36], buffer[37]]),
            honor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[34..38]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[38], buffer[39], buffer[40], buffer[41]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[38..42]);
                dst
            },
            emblem_version: i32::from_le_bytes([buffer[42], buffer[43], buffer[44], buffer[45]]),
            emblem_version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[42..46]);
                dst
            },
            guildname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[46..70].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            guildname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[46..70]);
                dst
            },
            master_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[70..94].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            master_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[70..94]);
                dst
            },
            manage_land:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[94..110].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            manage_land_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[94..110]);
                dst
            },
            zeny: i32::from_le_bytes([buffer[110], buffer[111], buffer[112], buffer[113]]),
            zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[110..114]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.user_num).unwrap();
        self.user_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_user_num).unwrap();
        self.max_user_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.user_average_level).unwrap();
        self.user_average_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.exp).unwrap();
        self.exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_exp).unwrap();
        self.max_exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.emblem_version).unwrap();
        self.emblem_version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.guildname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guildname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.master_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.master_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.manage_land {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.manage_land_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.zeny).unwrap();
        self.zeny_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.user_num_raw.to_vec());
        wtr.append(&mut self.max_user_num_raw.to_vec());
        wtr.append(&mut self.user_average_level_raw.to_vec());
        wtr.append(&mut self.exp_raw.to_vec());
        wtr.append(&mut self.max_exp_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.emblem_version_raw.to_vec());
        wtr.append(&mut self.guildname_raw.to_vec());
        wtr.append(&mut self.master_name_raw.to_vec());
        wtr.append(&mut self.manage_land_raw.to_vec());
        wtr.append(&mut self.zeny_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: i32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_level(&mut self, value: i32) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 4]) {
        self.level_raw = value;
    }
    pub fn set_user_num(&mut self, value: i32) {
        self.user_num = value;
    }
    pub fn set_user_num_raw(&mut self, value: [u8; 4]) {
        self.user_num_raw = value;
    }
    pub fn set_max_user_num(&mut self, value: i32) {
        self.max_user_num = value;
    }
    pub fn set_max_user_num_raw(&mut self, value: [u8; 4]) {
        self.max_user_num_raw = value;
    }
    pub fn set_user_average_level(&mut self, value: i32) {
        self.user_average_level = value;
    }
    pub fn set_user_average_level_raw(&mut self, value: [u8; 4]) {
        self.user_average_level_raw = value;
    }
    pub fn set_exp(&mut self, value: i32) {
        self.exp = value;
    }
    pub fn set_exp_raw(&mut self, value: [u8; 4]) {
        self.exp_raw = value;
    }
    pub fn set_max_exp(&mut self, value: i32) {
        self.max_exp = value;
    }
    pub fn set_max_exp_raw(&mut self, value: [u8; 4]) {
        self.max_exp_raw = value;
    }
    pub fn set_point(&mut self, value: i32) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 4]) {
        self.point_raw = value;
    }
    pub fn set_honor(&mut self, value: i32) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 4]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_emblem_version(&mut self, value: i32) {
        self.emblem_version = value;
    }
    pub fn set_emblem_version_raw(&mut self, value: [u8; 4]) {
        self.emblem_version_raw = value;
    }
    pub fn set_guildname(&mut self, value: [char; 24]) {
        self.guildname = value;
    }
    pub fn set_guildname_raw(&mut self, value: [u8; 24]) {
        self.guildname_raw = value;
    }
    pub fn set_master_name(&mut self, value: [char; 24]) {
        self.master_name = value;
    }
    pub fn set_master_name_raw(&mut self, value: [u8; 24]) {
        self.master_name_raw = value;
    }
    pub fn set_manage_land(&mut self, value: [char; 16]) {
        self.manage_land = value;
    }
    pub fn set_manage_land_raw(&mut self, value: [u8; 16]) {
        self.manage_land_raw = value;
    }
    pub fn set_zeny(&mut self, value: i32) {
        self.zeny = value;
    }
    pub fn set_zeny_raw(&mut self, value: [u8; 4]) {
        self.zeny_raw = value;
    }
    pub fn new() -> PacketZcGuildInfo2 {
        PacketZcGuildInfo2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1b, 0x6]),
        packet_id_raw: [0x1b, 0x6],
        gdid: 0,
        gdid_raw: [0; 4],
        level: 0,
        level_raw: [0; 4],
        user_num: 0,
        user_num_raw: [0; 4],
        max_user_num: 0,
        max_user_num_raw: [0; 4],
        user_average_level: 0,
        user_average_level_raw: [0; 4],
        exp: 0,
        exp_raw: [0; 4],
        max_exp: 0,
        max_exp_raw: [0; 4],
        point: 0,
        point_raw: [0; 4],
        honor: 0,
        honor_raw: [0; 4],
        virtue: 0,
        virtue_raw: [0; 4],
        emblem_version: 0,
        emblem_version_raw: [0; 4],
        guildname: [0 as char; 24],
        guildname_raw: [0; 24],
        master_name: [0 as char; 24],
        master_name_raw: [0; 24],
        manage_land: [0 as char; 16],
        manage_land_raw: [0; 16],
        zeny: 0,
        zeny_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcGuildInfo2 {
    fn id(&self) -> &str {
       "0x01b6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzGuildZeny {
    pub fn from(buffer: &[u8]) -> PacketCzGuildZeny {
        PacketCzGuildZeny {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            zeny: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.zeny).unwrap();
        self.zeny_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.zeny_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_zeny(&mut self, value: i32) {
        self.zeny = value;
    }
    pub fn set_zeny_raw(&mut self, value: [u8; 4]) {
        self.zeny_raw = value;
    }
    pub fn new() -> PacketCzGuildZeny {
        PacketCzGuildZeny {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1b, 0x7]),
        packet_id_raw: [0x1b, 0x7],
        zeny: 0,
        zeny_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzGuildZeny {
    fn id(&self) -> &str {
       "0x01b7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcGuildZenyAck {
    pub fn from(buffer: &[u8]) -> PacketZcGuildZenyAck {
        PacketZcGuildZenyAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            ret: u8::from_le_bytes([buffer[2]]),
            ret_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.ret).unwrap();
        self.ret_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.ret_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_ret(&mut self, value: u8) {
        self.ret = value;
    }
    pub fn set_ret_raw(&mut self, value: [u8; 1]) {
        self.ret_raw = value;
    }
    pub fn new() -> PacketZcGuildZenyAck {
        PacketZcGuildZenyAck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1b, 0x8]),
        packet_id_raw: [0x1b, 0x8],
        ret: 0,
        ret_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcGuildZenyAck {
    fn id(&self) -> &str {
       "0x01b8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcDispel {
    pub fn from(buffer: &[u8]) -> PacketZcDispel {
        PacketZcDispel {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketZcDispel {
        PacketZcDispel {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1b, 0x9]),
        packet_id_raw: [0x1b, 0x9],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDispel {
    fn id(&self) -> &str {
       "0x01b9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRemoveAid {
    pub fn from(buffer: &[u8]) -> PacketCzRemoveAid {
        PacketCzRemoveAid {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            account_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            account_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.account_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.account_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.account_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_account_name(&mut self, value: [char; 24]) {
        self.account_name = value;
    }
    pub fn set_account_name_raw(&mut self, value: [u8; 24]) {
        self.account_name_raw = value;
    }
    pub fn new() -> PacketCzRemoveAid {
        PacketCzRemoveAid {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1b, 0xa]),
        packet_id_raw: [0x1b, 0xa],
        account_name: [0 as char; 24],
        account_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzRemoveAid {
    fn id(&self) -> &str {
       "0x01ba"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzShift {
    pub fn from(buffer: &[u8]) -> PacketCzShift {
        PacketCzShift {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn new() -> PacketCzShift {
        PacketCzShift {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1b, 0xb]),
        packet_id_raw: [0x1b, 0xb],
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzShift {
    fn id(&self) -> &str {
       "0x01bb"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRecall {
    pub fn from(buffer: &[u8]) -> PacketCzRecall {
        PacketCzRecall {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            account_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            account_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.account_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.account_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.account_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_account_name(&mut self, value: [char; 24]) {
        self.account_name = value;
    }
    pub fn set_account_name_raw(&mut self, value: [u8; 24]) {
        self.account_name_raw = value;
    }
    pub fn new() -> PacketCzRecall {
        PacketCzRecall {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1b, 0xc]),
        packet_id_raw: [0x1b, 0xc],
        account_name: [0 as char; 24],
        account_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzRecall {
    fn id(&self) -> &str {
       "0x01bc"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRecallGid {
    pub fn from(buffer: &[u8]) -> PacketCzRecallGid {
        PacketCzRecallGid {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn new() -> PacketCzRecallGid {
        PacketCzRecallGid {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1b, 0xd]),
        packet_id_raw: [0x1b, 0xd],
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzRecallGid {
    fn id(&self) -> &str {
       "0x01bd"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcAskPngameroom {
    pub fn from(buffer: &[u8]) -> PacketAcAskPngameroom {
        PacketAcAskPngameroom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketAcAskPngameroom {
        PacketAcAskPngameroom {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1b, 0xe]),
        packet_id_raw: [0x1b, 0xe],
        }
    }
}

impl Packet for PacketAcAskPngameroom {
    fn id(&self) -> &str {
       "0x01be"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCaReplyPngameroom {
    pub fn from(buffer: &[u8]) -> PacketCaReplyPngameroom {
        PacketCaReplyPngameroom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            permission: u8::from_le_bytes([buffer[2]]),
            permission_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.permission).unwrap();
        self.permission_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.permission_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_permission(&mut self, value: u8) {
        self.permission = value;
    }
    pub fn set_permission_raw(&mut self, value: [u8; 1]) {
        self.permission_raw = value;
    }
    pub fn new() -> PacketCaReplyPngameroom {
        PacketCaReplyPngameroom {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1b, 0xf]),
        packet_id_raw: [0x1b, 0xf],
        permission: 0,
        permission_raw: [0; 1],
        }
    }
}

impl Packet for PacketCaReplyPngameroom {
    fn id(&self) -> &str {
       "0x01bf"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqRemaintime {
    pub fn from(buffer: &[u8]) -> PacketCzReqRemaintime {
        PacketCzReqRemaintime {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzReqRemaintime {
        PacketCzReqRemaintime {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1c, 0x0]),
        packet_id_raw: [0x1c, 0x0],
        }
    }
}

impl Packet for PacketCzReqRemaintime {
    fn id(&self) -> &str {
       "0x01c0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcReplyRemaintime {
    pub fn from(buffer: &[u8]) -> PacketZcReplyRemaintime {
        PacketZcReplyRemaintime {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            expiration_date: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            expiration_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            remain_time: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            remain_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.expiration_date).unwrap();
        self.expiration_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.remain_time).unwrap();
        self.remain_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.expiration_date_raw.to_vec());
        wtr.append(&mut self.remain_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i32) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 4]) {
        self.result_raw = value;
    }
    pub fn set_expiration_date(&mut self, value: i32) {
        self.expiration_date = value;
    }
    pub fn set_expiration_date_raw(&mut self, value: [u8; 4]) {
        self.expiration_date_raw = value;
    }
    pub fn set_remain_time(&mut self, value: i32) {
        self.remain_time = value;
    }
    pub fn set_remain_time_raw(&mut self, value: [u8; 4]) {
        self.remain_time_raw = value;
    }
    pub fn new() -> PacketZcReplyRemaintime {
        PacketZcReplyRemaintime {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1c, 0x1]),
        packet_id_raw: [0x1c, 0x1],
        result: 0,
        result_raw: [0; 4],
        expiration_date: 0,
        expiration_date_raw: [0; 4],
        remain_time: 0,
        remain_time_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcReplyRemaintime {
    fn id(&self) -> &str {
       "0x01c1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcInfoRemaintime {
    pub fn from(buffer: &[u8]) -> PacketZcInfoRemaintime {
        PacketZcInfoRemaintime {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            remain_time: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            remain_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.remain_time).unwrap();
        self.remain_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.remain_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn set_remain_time(&mut self, value: i32) {
        self.remain_time = value;
    }
    pub fn set_remain_time_raw(&mut self, value: [u8; 4]) {
        self.remain_time_raw = value;
    }
    pub fn new() -> PacketZcInfoRemaintime {
        PacketZcInfoRemaintime {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1c, 0x2]),
        packet_id_raw: [0x1c, 0x2],
        atype: 0,
        atype_raw: [0; 4],
        remain_time: 0,
        remain_time_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcInfoRemaintime {
    fn id(&self) -> &str {
       "0x01c2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcBroadcast2 {
    pub fn from(buffer: &[u8]) -> PacketZcBroadcast2 {
        PacketZcBroadcast2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            font_color: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            font_color_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            font_type: i16::from_le_bytes([buffer[8], buffer[9]]),
            font_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            font_size: i16::from_le_bytes([buffer[10], buffer[11]]),
            font_size_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            font_align: i16::from_le_bytes([buffer[12], buffer[13]]),
            font_align_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            font_y: i16::from_le_bytes([buffer[14], buffer[15]]),
            font_y_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[16..buffer.len()]).to_string(),
            msg_raw: buffer[16..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.font_color).unwrap();
        self.font_color_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font_type).unwrap();
        self.font_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font_size).unwrap();
        self.font_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font_align).unwrap();
        self.font_align_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font_y).unwrap();
        self.font_y_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.font_color_raw.to_vec());
        wtr.append(&mut self.font_type_raw.to_vec());
        wtr.append(&mut self.font_size_raw.to_vec());
        wtr.append(&mut self.font_align_raw.to_vec());
        wtr.append(&mut self.font_y_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_font_color(&mut self, value: u32) {
        self.font_color = value;
    }
    pub fn set_font_color_raw(&mut self, value: [u8; 4]) {
        self.font_color_raw = value;
    }
    pub fn set_font_type(&mut self, value: i16) {
        self.font_type = value;
    }
    pub fn set_font_type_raw(&mut self, value: [u8; 2]) {
        self.font_type_raw = value;
    }
    pub fn set_font_size(&mut self, value: i16) {
        self.font_size = value;
    }
    pub fn set_font_size_raw(&mut self, value: [u8; 2]) {
        self.font_size_raw = value;
    }
    pub fn set_font_align(&mut self, value: i16) {
        self.font_align = value;
    }
    pub fn set_font_align_raw(&mut self, value: [u8; 2]) {
        self.font_align_raw = value;
    }
    pub fn set_font_y(&mut self, value: i16) {
        self.font_y = value;
    }
    pub fn set_font_y_raw(&mut self, value: [u8; 2]) {
        self.font_y_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketZcBroadcast2 {
        PacketZcBroadcast2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1c, 0x3]),
        packet_id_raw: [0x1c, 0x3],
        packet_length: 0,
        packet_length_raw: [0; 2],
        font_color: 0,
        font_color_raw: [0; 4],
        font_type: 0,
        font_type_raw: [0; 2],
        font_size: 0,
        font_size_raw: [0; 2],
        font_align: 0,
        font_align_raw: [0; 2],
        font_y: 0,
        font_y_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcBroadcast2 {
    fn id(&self) -> &str {
       "0x01c3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAddItemToStore2 {
    pub fn from(buffer: &[u8]) -> PacketZcAddItemToStore2 {
        PacketZcAddItemToStore2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            itid: u16::from_le_bytes([buffer[8], buffer[9]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            atype: u8::from_le_bytes([buffer[10]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            is_identified: buffer[11] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            is_damaged: buffer[12] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[13]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[13..14]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[14..22]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[14..22]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new() -> PacketZcAddItemToStore2 {
        PacketZcAddItemToStore2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1c, 0x4]),
        packet_id_raw: [0x1c, 0x4],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        }
    }
}

impl Packet for PacketZcAddItemToStore2 {
    fn id(&self) -> &str {
       "0x01c4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAddItemToCart2 {
    pub fn from(buffer: &[u8]) -> PacketZcAddItemToCart2 {
        PacketZcAddItemToCart2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            itid: u16::from_le_bytes([buffer[8], buffer[9]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            atype: u8::from_le_bytes([buffer[10]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            is_identified: buffer[11] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            is_damaged: buffer[12] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[13]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[13..14]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[14..22]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[14..22]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new() -> PacketZcAddItemToCart2 {
        PacketZcAddItemToCart2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1c, 0x5]),
        packet_id_raw: [0x1c, 0x5],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        }
    }
}

impl Packet for PacketZcAddItemToCart2 {
    fn id(&self) -> &str {
       "0x01c5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCsReqEncryption {
    pub fn from(buffer: &[u8]) -> PacketCsReqEncryption {
        PacketCsReqEncryption {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            enc_count: i8::from_le_bytes([buffer[2]]),
            enc_count_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            dec_count: i8::from_le_bytes([buffer[3]]),
            dec_count_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[3..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.enc_count).unwrap();
        self.enc_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.dec_count).unwrap();
        self.dec_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.enc_count_raw.to_vec());
        wtr.append(&mut self.dec_count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_enc_count(&mut self, value: i8) {
        self.enc_count = value;
    }
    pub fn set_enc_count_raw(&mut self, value: [u8; 1]) {
        self.enc_count_raw = value;
    }
    pub fn set_dec_count(&mut self, value: i8) {
        self.dec_count = value;
    }
    pub fn set_dec_count_raw(&mut self, value: [u8; 1]) {
        self.dec_count_raw = value;
    }
    pub fn new() -> PacketCsReqEncryption {
        PacketCsReqEncryption {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1c, 0x6]),
        packet_id_raw: [0x1c, 0x6],
        enc_count: 0,
        enc_count_raw: [0; 1],
        dec_count: 0,
        dec_count_raw: [0; 1],
        }
    }
}

impl Packet for PacketCsReqEncryption {
    fn id(&self) -> &str {
       "0x01c6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketScAckEncryption {
    pub fn from(buffer: &[u8]) -> PacketScAckEncryption {
        PacketScAckEncryption {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketScAckEncryption {
        PacketScAckEncryption {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1c, 0x7]),
        packet_id_raw: [0x1c, 0x7],
        }
    }
}

impl Packet for PacketScAckEncryption {
    fn id(&self) -> &str {
       "0x01c7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcUseItemAck2 {
    pub fn from(buffer: &[u8]) -> PacketZcUseItemAck2 {
        PacketZcUseItemAck2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            id: u16::from_le_bytes([buffer[4], buffer[5]]),
            id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            aid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            count: i16::from_le_bytes([buffer[10], buffer[11]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            result: buffer[12] == 1,
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.id).unwrap();
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_id(&mut self, value: u16) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 2]) {
        self.id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_result(&mut self, value: bool) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcUseItemAck2 {
        PacketZcUseItemAck2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1c, 0x8]),
        packet_id_raw: [0x1c, 0x8],
        index: 0,
        index_raw: [0; 2],
        id: 0,
        id_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        count: 0,
        count_raw: [0; 2],
        result: false,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcUseItemAck2 {
    fn id(&self) -> &str {
       "0x01c8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSkillEntry2 {
    pub fn from(buffer: &[u8]) -> PacketZcSkillEntry2 {
        PacketZcSkillEntry2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            creator_aid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            creator_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[10], buffer[11]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[12], buffer[13]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: u8::from_le_bytes([buffer[14]]),
            job_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
            is_visible: buffer[15] == 1,
            is_visible_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[15..16]);
                dst
            },
            is_contens: buffer[16] == 1,
            is_contens_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[16..17]);
                dst
            },
            msg:  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[17..97].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            msg_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[17..97]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.creator_aid).unwrap();
        self.creator_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_visible as u8).unwrap();
        self.is_visible_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_contens as u8).unwrap();
        self.is_contens_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.msg {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.msg_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.creator_aid_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.is_visible_raw.to_vec());
        wtr.append(&mut self.is_contens_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_creator_aid(&mut self, value: u32) {
        self.creator_aid = value;
    }
    pub fn set_creator_aid_raw(&mut self, value: [u8; 4]) {
        self.creator_aid_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_job(&mut self, value: u8) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 1]) {
        self.job_raw = value;
    }
    pub fn set_is_visible(&mut self, value: bool) {
        self.is_visible = value;
    }
    pub fn set_is_visible_raw(&mut self, value: [u8; 1]) {
        self.is_visible_raw = value;
    }
    pub fn set_is_contens(&mut self, value: bool) {
        self.is_contens = value;
    }
    pub fn set_is_contens_raw(&mut self, value: [u8; 1]) {
        self.is_contens_raw = value;
    }
    pub fn set_msg(&mut self, value: [char; 80]) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: [u8; 80]) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketZcSkillEntry2 {
        PacketZcSkillEntry2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1c, 0x9]),
        packet_id_raw: [0x1c, 0x9],
        aid: 0,
        aid_raw: [0; 4],
        creator_aid: 0,
        creator_aid_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        job: 0,
        job_raw: [0; 1],
        is_visible: false,
        is_visible_raw: [0; 1],
        is_contens: false,
        is_contens_raw: [0; 1],
        msg: [0 as char; 80],
        msg_raw: [0; 80],
        }
    }
}

impl Packet for PacketZcSkillEntry2 {
    fn id(&self) -> &str {
       "0x01c9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqmakinghomun {
    pub fn from(buffer: &[u8]) -> PacketCzReqmakinghomun {
        PacketCzReqmakinghomun {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: buffer[2] == 1,
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: bool) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketCzReqmakinghomun {
        PacketCzReqmakinghomun {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1c, 0xa]),
        packet_id_raw: [0x1c, 0xa],
        result: false,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzReqmakinghomun {
    fn id(&self) -> &str {
       "0x01ca"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzMonsterTalk {
    pub fn from(buffer: &[u8]) -> PacketCzMonsterTalk {
        PacketCzMonsterTalk {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            state_id: u8::from_le_bytes([buffer[6]]),
            state_id_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            skill_id: u8::from_le_bytes([buffer[7]]),
            skill_id_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[7..8]);
                dst
            },
            arg1: u8::from_le_bytes([buffer[8]]),
            arg1_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state_id).unwrap();
        self.state_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.skill_id).unwrap();
        self.skill_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.arg1).unwrap();
        self.arg1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.state_id_raw.to_vec());
        wtr.append(&mut self.skill_id_raw.to_vec());
        wtr.append(&mut self.arg1_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_state_id(&mut self, value: u8) {
        self.state_id = value;
    }
    pub fn set_state_id_raw(&mut self, value: [u8; 1]) {
        self.state_id_raw = value;
    }
    pub fn set_skill_id(&mut self, value: u8) {
        self.skill_id = value;
    }
    pub fn set_skill_id_raw(&mut self, value: [u8; 1]) {
        self.skill_id_raw = value;
    }
    pub fn set_arg1(&mut self, value: u8) {
        self.arg1 = value;
    }
    pub fn set_arg1_raw(&mut self, value: [u8; 1]) {
        self.arg1_raw = value;
    }
    pub fn new() -> PacketCzMonsterTalk {
        PacketCzMonsterTalk {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1c, 0xb]),
        packet_id_raw: [0x1c, 0xb],
        gid: 0,
        gid_raw: [0; 4],
        state_id: 0,
        state_id_raw: [0; 1],
        skill_id: 0,
        skill_id_raw: [0; 1],
        arg1: 0,
        arg1_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzMonsterTalk {
    fn id(&self) -> &str {
       "0x01cb"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMonsterTalk {
    pub fn from(buffer: &[u8]) -> PacketZcMonsterTalk {
        PacketZcMonsterTalk {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            state_id: u8::from_le_bytes([buffer[6]]),
            state_id_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            skill_id: u8::from_le_bytes([buffer[7]]),
            skill_id_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[7..8]);
                dst
            },
            arg1: u8::from_le_bytes([buffer[8]]),
            arg1_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state_id).unwrap();
        self.state_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.skill_id).unwrap();
        self.skill_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.arg1).unwrap();
        self.arg1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.state_id_raw.to_vec());
        wtr.append(&mut self.skill_id_raw.to_vec());
        wtr.append(&mut self.arg1_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_state_id(&mut self, value: u8) {
        self.state_id = value;
    }
    pub fn set_state_id_raw(&mut self, value: [u8; 1]) {
        self.state_id_raw = value;
    }
    pub fn set_skill_id(&mut self, value: u8) {
        self.skill_id = value;
    }
    pub fn set_skill_id_raw(&mut self, value: [u8; 1]) {
        self.skill_id_raw = value;
    }
    pub fn set_arg1(&mut self, value: u8) {
        self.arg1 = value;
    }
    pub fn set_arg1_raw(&mut self, value: [u8; 1]) {
        self.arg1_raw = value;
    }
    pub fn new() -> PacketZcMonsterTalk {
        PacketZcMonsterTalk {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1c, 0xc]),
        packet_id_raw: [0x1c, 0xc],
        gid: 0,
        gid_raw: [0; 4],
        state_id: 0,
        state_id_raw: [0; 1],
        skill_id: 0,
        skill_id_raw: [0; 1],
        arg1: 0,
        arg1_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcMonsterTalk {
    fn id(&self) -> &str {
       "0x01cc"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAutospelllist {
    pub fn from(buffer: &[u8]) -> PacketZcAutospelllist {
        PacketZcAutospelllist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid:  {
                let mut dst: [i32; 7] = [0 as i32; 7];
                for (index, byte) in buffer[2..9].iter().enumerate() {
                    dst[index] = *byte as i32;
                }
                dst
            },
            skid_raw: {
                let mut dst: [u8; 7] = [0u8; 7];
                dst.clone_from_slice(&buffer[2..9]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.skid {
            wtr.write_i32::<LittleEndian>(item).unwrap();
        }
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: [i32; 7]) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 7]) {
        self.skid_raw = value;
    }
    pub fn new() -> PacketZcAutospelllist {
        PacketZcAutospelllist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1c, 0xd]),
        packet_id_raw: [0x1c, 0xd],
        skid: [0; 7],
        skid_raw: [0; 7],
        }
    }
}

impl Packet for PacketZcAutospelllist {
    fn id(&self) -> &str {
       "0x01cd"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzSelectautospell {
    pub fn from(buffer: &[u8]) -> PacketCzSelectautospell {
        PacketCzSelectautospell {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            skid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: i32) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 4]) {
        self.skid_raw = value;
    }
    pub fn new() -> PacketCzSelectautospell {
        PacketCzSelectautospell {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1c, 0xe]),
        packet_id_raw: [0x1c, 0xe],
        skid: 0,
        skid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzSelectautospell {
    fn id(&self) -> &str {
       "0x01ce"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcDevotionlist {
    pub fn from(buffer: &[u8]) -> PacketZcDevotionlist {
        PacketZcDevotionlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            my_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            my_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            aid:  {
                let mut dst: [u32; 5] = [0 as u32; 5];
                for (index, byte) in buffer[6..11].iter().enumerate() {
                    dst[index] = *byte as u32;
                }
                dst
            },
            aid_raw: {
                let mut dst: [u8; 5] = [0u8; 5];
                dst.clone_from_slice(&buffer[6..11]);
                dst
            },
            range: i16::from_le_bytes([buffer[26], buffer[27]]),
            range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.my_aid).unwrap();
        self.my_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.aid {
            wtr.write_u32::<LittleEndian>(item).unwrap();
        }
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.range).unwrap();
        self.range_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.my_aid_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.range_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_my_aid(&mut self, value: u32) {
        self.my_aid = value;
    }
    pub fn set_my_aid_raw(&mut self, value: [u8; 4]) {
        self.my_aid_raw = value;
    }
    pub fn set_aid(&mut self, value: [u32; 5]) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 5]) {
        self.aid_raw = value;
    }
    pub fn set_range(&mut self, value: i16) {
        self.range = value;
    }
    pub fn set_range_raw(&mut self, value: [u8; 2]) {
        self.range_raw = value;
    }
    pub fn new() -> PacketZcDevotionlist {
        PacketZcDevotionlist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1c, 0xf]),
        packet_id_raw: [0x1c, 0xf],
        my_aid: 0,
        my_aid_raw: [0; 4],
        aid: [0; 5],
        aid_raw: [0; 5],
        range: 0,
        range_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcDevotionlist {
    fn id(&self) -> &str {
       "0x01cf"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSpirits {
    pub fn from(buffer: &[u8]) -> PacketZcSpirits {
        PacketZcSpirits {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            num: i16::from_le_bytes([buffer[6], buffer[7]]),
            num_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.num).unwrap();
        self.num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.num_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_num(&mut self, value: i16) {
        self.num = value;
    }
    pub fn set_num_raw(&mut self, value: [u8; 2]) {
        self.num_raw = value;
    }
    pub fn new() -> PacketZcSpirits {
        PacketZcSpirits {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1d, 0x0]),
        packet_id_raw: [0x1d, 0x0],
        aid: 0,
        aid_raw: [0; 4],
        num: 0,
        num_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcSpirits {
    fn id(&self) -> &str {
       "0x01d0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcBladestop {
    pub fn from(buffer: &[u8]) -> PacketZcBladestop {
        PacketZcBladestop {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            src_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            src_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            dest_aid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            dest_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            flag: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            flag_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.src_aid).unwrap();
        self.src_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dest_aid).unwrap();
        self.dest_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.flag).unwrap();
        self.flag_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.src_aid_raw.to_vec());
        wtr.append(&mut self.dest_aid_raw.to_vec());
        wtr.append(&mut self.flag_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_src_aid(&mut self, value: u32) {
        self.src_aid = value;
    }
    pub fn set_src_aid_raw(&mut self, value: [u8; 4]) {
        self.src_aid_raw = value;
    }
    pub fn set_dest_aid(&mut self, value: u32) {
        self.dest_aid = value;
    }
    pub fn set_dest_aid_raw(&mut self, value: [u8; 4]) {
        self.dest_aid_raw = value;
    }
    pub fn set_flag(&mut self, value: i32) {
        self.flag = value;
    }
    pub fn set_flag_raw(&mut self, value: [u8; 4]) {
        self.flag_raw = value;
    }
    pub fn new() -> PacketZcBladestop {
        PacketZcBladestop {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1d, 0x1]),
        packet_id_raw: [0x1d, 0x1],
        src_aid: 0,
        src_aid_raw: [0; 4],
        dest_aid: 0,
        dest_aid_raw: [0; 4],
        flag: 0,
        flag_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcBladestop {
    fn id(&self) -> &str {
       "0x01d1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcCombodelay {
    pub fn from(buffer: &[u8]) -> PacketZcCombodelay {
        PacketZcCombodelay {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            delay_time: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            delay_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.delay_time).unwrap();
        self.delay_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.delay_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_delay_time(&mut self, value: u32) {
        self.delay_time = value;
    }
    pub fn set_delay_time_raw(&mut self, value: [u8; 4]) {
        self.delay_time_raw = value;
    }
    pub fn new() -> PacketZcCombodelay {
        PacketZcCombodelay {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1d, 0x2]),
        packet_id_raw: [0x1d, 0x2],
        aid: 0,
        aid_raw: [0; 4],
        delay_time: 0,
        delay_time_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcCombodelay {
    fn id(&self) -> &str {
       "0x01d2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSound {
    pub fn from(buffer: &[u8]) -> PacketZcSound {
        PacketZcSound {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            file_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            file_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            act: u8::from_le_bytes([buffer[26]]),
            act_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[26..27]);
                dst
            },
            term: u32::from_le_bytes([buffer[27], buffer[28], buffer[29], buffer[30]]),
            term_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[27..31]);
                dst
            },
            naid: u32::from_le_bytes([buffer[31], buffer[32], buffer[33], buffer[34]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[31..35]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.file_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.file_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.act).unwrap();
        self.act_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.term).unwrap();
        self.term_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.file_name_raw.to_vec());
        wtr.append(&mut self.act_raw.to_vec());
        wtr.append(&mut self.term_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_file_name(&mut self, value: [char; 24]) {
        self.file_name = value;
    }
    pub fn set_file_name_raw(&mut self, value: [u8; 24]) {
        self.file_name_raw = value;
    }
    pub fn set_act(&mut self, value: u8) {
        self.act = value;
    }
    pub fn set_act_raw(&mut self, value: [u8; 1]) {
        self.act_raw = value;
    }
    pub fn set_term(&mut self, value: u32) {
        self.term = value;
    }
    pub fn set_term_raw(&mut self, value: [u8; 4]) {
        self.term_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn new() -> PacketZcSound {
        PacketZcSound {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1d, 0x3]),
        packet_id_raw: [0x1d, 0x3],
        file_name: [0 as char; 24],
        file_name_raw: [0; 24],
        act: 0,
        act_raw: [0; 1],
        term: 0,
        term_raw: [0; 4],
        naid: 0,
        naid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcSound {
    fn id(&self) -> &str {
       "0x01d3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcOpenEditdlgstr {
    pub fn from(buffer: &[u8]) -> PacketZcOpenEditdlgstr {
        PacketZcOpenEditdlgstr {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn new() -> PacketZcOpenEditdlgstr {
        PacketZcOpenEditdlgstr {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1d, 0x4]),
        packet_id_raw: [0x1d, 0x4],
        naid: 0,
        naid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcOpenEditdlgstr {
    fn id(&self) -> &str {
       "0x01d4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzInputEditdlgstr {
    pub fn from(buffer: &[u8]) -> PacketCzInputEditdlgstr {
        PacketCzInputEditdlgstr {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            naid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[8..buffer.len()]).to_string(),
            msg_raw: buffer[8..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketCzInputEditdlgstr {
        PacketCzInputEditdlgstr {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1d, 0x5]),
        packet_id_raw: [0x1d, 0x5],
        packet_length: 0,
        packet_length_raw: [0; 2],
        naid: 0,
        naid_raw: [0; 4],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketCzInputEditdlgstr {
    fn id(&self) -> &str {
       "0x01d5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyMapproperty2 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMapproperty2 {
        PacketZcNotifyMapproperty2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketZcNotifyMapproperty2 {
        PacketZcNotifyMapproperty2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1d, 0x6]),
        packet_id_raw: [0x1d, 0x6],
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyMapproperty2 {
    fn id(&self) -> &str {
       "0x01d6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSpriteChange2 {
    pub fn from(buffer: &[u8]) -> PacketZcSpriteChange2 {
        PacketZcSpriteChange2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            value: i32::from_le_bytes([buffer[7], buffer[8], buffer[9], buffer[10]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[7..11]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new() -> PacketZcSpriteChange2 {
        PacketZcSpriteChange2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1d, 0x7]),
        packet_id_raw: [0x1d, 0x7],
        gid: 0,
        gid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcSpriteChange2 {
    fn id(&self) -> &str {
       "0x01d7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyStandentry2 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyStandentry2 {
        PacketZcNotifyStandentry2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i16::from_le_bytes([buffer[12], buffer[13]]),
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: i16::from_le_bytes([buffer[14], buffer[15]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            head: i16::from_le_bytes([buffer[16], buffer[17]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[22], buffer[23]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[22..24]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[24], buffer[25]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[26], buffer[27]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[28], buffer[29]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[30], buffer[31]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[32], buffer[33]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            guid: u32::from_le_bytes([buffer[34], buffer[35], buffer[36], buffer[37]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[34..38]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[38], buffer[39]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[38..40]);
                dst
            },
            honor: i16::from_le_bytes([buffer[40], buffer[41]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            virtue: i16::from_le_bytes([buffer[42], buffer[43]]),
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            is_pkmode_on: buffer[44] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[44..45]);
                dst
            },
            sex: u8::from_le_bytes([buffer[45]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[45..46]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[46..49].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[46..49]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[49]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[50]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[50..51]);
                dst
            },
            state: u8::from_le_bytes([buffer[51]]),
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[51..52]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[52], buffer[53]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[52..54]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i16) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 2]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i16) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 2]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [char; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_state(&mut self, value: u8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new() -> PacketZcNotifyStandentry2 {
        PacketZcNotifyStandentry2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1d, 0x8]),
        packet_id_raw: [0x1d, 0x8],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 2],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0 as char; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        state: 0,
        state_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyStandentry2 {
    fn id(&self) -> &str {
       "0x01d8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyNewentry2 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyNewentry2 {
        PacketZcNotifyNewentry2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i16::from_le_bytes([buffer[12], buffer[13]]),
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: i16::from_le_bytes([buffer[14], buffer[15]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            head: i16::from_le_bytes([buffer[16], buffer[17]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[22], buffer[23]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[22..24]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[24], buffer[25]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[26], buffer[27]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[28], buffer[29]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[30], buffer[31]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[32], buffer[33]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            guid: u32::from_le_bytes([buffer[34], buffer[35], buffer[36], buffer[37]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[34..38]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[38], buffer[39]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[38..40]);
                dst
            },
            honor: i16::from_le_bytes([buffer[40], buffer[41]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            virtue: i16::from_le_bytes([buffer[42], buffer[43]]),
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            is_pkmode_on: buffer[44] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[44..45]);
                dst
            },
            sex: u8::from_le_bytes([buffer[45]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[45..46]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[46..49].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[46..49]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[49]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[50]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[50..51]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[51], buffer[52]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[51..53]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i16) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 2]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i16) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 2]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [char; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new() -> PacketZcNotifyNewentry2 {
        PacketZcNotifyNewentry2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1d, 0x9]),
        packet_id_raw: [0x1d, 0x9],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 2],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0 as char; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyNewentry2 {
    fn id(&self) -> &str {
       "0x01d9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyMoveentry2 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMoveentry2 {
        PacketZcNotifyMoveentry2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i16::from_le_bytes([buffer[12], buffer[13]]),
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: i16::from_le_bytes([buffer[14], buffer[15]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            head: i16::from_le_bytes([buffer[16], buffer[17]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[22], buffer[23]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[22..24]);
                dst
            },
            move_start_time: u32::from_le_bytes([buffer[24], buffer[25], buffer[26], buffer[27]]),
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[24..28]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[28], buffer[29]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[30], buffer[31]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[32], buffer[33]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[34], buffer[35]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[36], buffer[37]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[36..38]);
                dst
            },
            guid: u32::from_le_bytes([buffer[38], buffer[39], buffer[40], buffer[41]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[38..42]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[42], buffer[43]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            honor: i16::from_le_bytes([buffer[44], buffer[45]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[44..46]);
                dst
            },
            virtue: i16::from_le_bytes([buffer[46], buffer[47]]),
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[46..48]);
                dst
            },
            is_pkmode_on: buffer[48] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[48..49]);
                dst
            },
            sex: u8::from_le_bytes([buffer[49]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            move_data:  {
                let mut dst: [u16; 6] = [0 as u16; 6];
                for (index, byte) in buffer[50..56].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            },
            move_data_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[50..56]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[56]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[56..57]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[57]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[57..58]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[58], buffer[59]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[58..60]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.move_start_time_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.move_data_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i16) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 2]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_move_start_time(&mut self, value: u32) {
        self.move_start_time = value;
    }
    pub fn set_move_start_time_raw(&mut self, value: [u8; 4]) {
        self.move_start_time_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i16) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 2]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_move_data(&mut self, value: [u16; 6]) {
        self.move_data = value;
    }
    pub fn set_move_data_raw(&mut self, value: [u8; 6]) {
        self.move_data_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new() -> PacketZcNotifyMoveentry2 {
        PacketZcNotifyMoveentry2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1d, 0xa]),
        packet_id_raw: [0x1d, 0xa],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        move_start_time: 0,
        move_start_time_raw: [0; 4],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 2],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        move_data: [0; 6],
        move_data_raw: [0; 6],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyMoveentry2 {
    fn id(&self) -> &str {
       "0x01da"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCaReqHash {
    pub fn from(buffer: &[u8]) -> PacketCaReqHash {
        PacketCaReqHash {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCaReqHash {
        PacketCaReqHash {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1d, 0xb]),
        packet_id_raw: [0x1d, 0xb],
        }
    }
}

impl Packet for PacketCaReqHash {
    fn id(&self) -> &str {
       "0x01db"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcAckHash {
    pub fn from(buffer: &[u8]) -> PacketAcAckHash {
        PacketAcAckHash {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            secret: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            secret_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.secret_raw = self.secret.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.secret_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_secret(&mut self, value: String) {
        self.secret = value;
    }
    pub fn set_secret_raw(&mut self, value: Vec<u8>) {
        self.secret_raw = value;
    }
    pub fn new() -> PacketAcAckHash {
        PacketAcAckHash {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1d, 0xc]),
        packet_id_raw: [0x1d, 0xc],
        packet_length: 0,
        packet_length_raw: [0; 2],
        secret: String::new(),
        secret_raw: vec![],
        }
    }
}

impl Packet for PacketAcAckHash {
    fn id(&self) -> &str {
       "0x01dc"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCaLogin2 {
    pub fn from(buffer: &[u8]) -> PacketCaLogin2 {
        PacketCaLogin2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            version: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            id:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            passwd_md5:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[30..46].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_md5_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[30..46]);
                dst
            },
            clienttype: u8::from_le_bytes([buffer[46]]),
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[46..47]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd_md5 {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_md5_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.version_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.passwd_md5_raw.to_vec());
        wtr.append(&mut self.clienttype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_version(&mut self, value: u32) {
        self.version = value;
    }
    pub fn set_version_raw(&mut self, value: [u8; 4]) {
        self.version_raw = value;
    }
    pub fn set_id(&mut self, value: [char; 24]) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 24]) {
        self.id_raw = value;
    }
    pub fn set_passwd_md5(&mut self, value: [char; 16]) {
        self.passwd_md5 = value;
    }
    pub fn set_passwd_md5_raw(&mut self, value: [u8; 16]) {
        self.passwd_md5_raw = value;
    }
    pub fn set_clienttype(&mut self, value: u8) {
        self.clienttype = value;
    }
    pub fn set_clienttype_raw(&mut self, value: [u8; 1]) {
        self.clienttype_raw = value;
    }
    pub fn new() -> PacketCaLogin2 {
        PacketCaLogin2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1d, 0xd]),
        packet_id_raw: [0x1d, 0xd],
        version: 0,
        version_raw: [0; 4],
        id: [0 as char; 24],
        id_raw: [0; 24],
        passwd_md5: [0 as char; 16],
        passwd_md5_raw: [0; 16],
        clienttype: 0,
        clienttype_raw: [0; 1],
        }
    }
}

impl Packet for PacketCaLogin2 {
    fn id(&self) -> &str {
       "0x01dd"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifySkill2 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifySkill2 {
        PacketZcNotifySkill2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            target_id: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            start_time: u32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            attack_mt: i32::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19]]),
            attack_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[16..20]);
                dst
            },
            attacked_mt: i32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            attacked_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
            damage: i32::from_le_bytes([buffer[24], buffer[25], buffer[26], buffer[27]]),
            damage_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[24..28]);
                dst
            },
            level: i16::from_le_bytes([buffer[28], buffer[29]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            count: i16::from_le_bytes([buffer[30], buffer[31]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            action: u8::from_le_bytes([buffer[32]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[32..33]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attack_mt).unwrap();
        self.attack_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attacked_mt).unwrap();
        self.attacked_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.damage).unwrap();
        self.damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.target_id_raw.to_vec());
        wtr.append(&mut self.start_time_raw.to_vec());
        wtr.append(&mut self.attack_mt_raw.to_vec());
        wtr.append(&mut self.attacked_mt_raw.to_vec());
        wtr.append(&mut self.damage_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_target_id(&mut self, value: u32) {
        self.target_id = value;
    }
    pub fn set_target_id_raw(&mut self, value: [u8; 4]) {
        self.target_id_raw = value;
    }
    pub fn set_start_time(&mut self, value: u32) {
        self.start_time = value;
    }
    pub fn set_start_time_raw(&mut self, value: [u8; 4]) {
        self.start_time_raw = value;
    }
    pub fn set_attack_mt(&mut self, value: i32) {
        self.attack_mt = value;
    }
    pub fn set_attack_mt_raw(&mut self, value: [u8; 4]) {
        self.attack_mt_raw = value;
    }
    pub fn set_attacked_mt(&mut self, value: i32) {
        self.attacked_mt = value;
    }
    pub fn set_attacked_mt_raw(&mut self, value: [u8; 4]) {
        self.attacked_mt_raw = value;
    }
    pub fn set_damage(&mut self, value: i32) {
        self.damage = value;
    }
    pub fn set_damage_raw(&mut self, value: [u8; 4]) {
        self.damage_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn new() -> PacketZcNotifySkill2 {
        PacketZcNotifySkill2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1d, 0xe]),
        packet_id_raw: [0x1d, 0xe],
        skid: 0,
        skid_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        target_id: 0,
        target_id_raw: [0; 4],
        start_time: 0,
        start_time_raw: [0; 4],
        attack_mt: 0,
        attack_mt_raw: [0; 4],
        attacked_mt: 0,
        attacked_mt_raw: [0; 4],
        damage: 0,
        damage_raw: [0; 4],
        level: 0,
        level_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        action: 0,
        action_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcNotifySkill2 {
    fn id(&self) -> &str {
       "0x01de"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqAccountname {
    pub fn from(buffer: &[u8]) -> PacketCzReqAccountname {
        PacketCzReqAccountname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketCzReqAccountname {
        PacketCzReqAccountname {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1d, 0xf]),
        packet_id_raw: [0x1d, 0xf],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqAccountname {
    fn id(&self) -> &str {
       "0x01df"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckAccountname {
    pub fn from(buffer: &[u8]) -> PacketZcAckAccountname {
        PacketZcAckAccountname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new() -> PacketZcAckAccountname {
        PacketZcAckAccountname {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1e, 0x0]),
        packet_id_raw: [0x1e, 0x0],
        aid: 0,
        aid_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcAckAccountname {
    fn id(&self) -> &str {
       "0x01e0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSpirits2 {
    pub fn from(buffer: &[u8]) -> PacketZcSpirits2 {
        PacketZcSpirits2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            num: i16::from_le_bytes([buffer[6], buffer[7]]),
            num_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.num).unwrap();
        self.num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.num_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_num(&mut self, value: i16) {
        self.num = value;
    }
    pub fn set_num_raw(&mut self, value: [u8; 2]) {
        self.num_raw = value;
    }
    pub fn new() -> PacketZcSpirits2 {
        PacketZcSpirits2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1e, 0x1]),
        packet_id_raw: [0x1e, 0x1],
        aid: 0,
        aid_raw: [0; 4],
        num: 0,
        num_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcSpirits2 {
    fn id(&self) -> &str {
       "0x01e1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcReqCouple {
    pub fn from(buffer: &[u8]) -> PacketZcReqCouple {
        PacketZcReqCouple {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[10..34].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[10..34]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new() -> PacketZcReqCouple {
        PacketZcReqCouple {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1e, 0x2]),
        packet_id_raw: [0x1e, 0x2],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcReqCouple {
    fn id(&self) -> &str {
       "0x01e2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzJoinCouple {
    pub fn from(buffer: &[u8]) -> PacketCzJoinCouple {
        PacketCzJoinCouple {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            answer: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            answer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_answer(&mut self, value: i32) {
        self.answer = value;
    }
    pub fn set_answer_raw(&mut self, value: [u8; 4]) {
        self.answer_raw = value;
    }
    pub fn new() -> PacketCzJoinCouple {
        PacketCzJoinCouple {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1e, 0x3]),
        packet_id_raw: [0x1e, 0x3],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        answer: 0,
        answer_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzJoinCouple {
    fn id(&self) -> &str {
       "0x01e3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcStartCouple {
    pub fn from(buffer: &[u8]) -> PacketZcStartCouple {
        PacketZcStartCouple {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketZcStartCouple {
        PacketZcStartCouple {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1e, 0x4]),
        packet_id_raw: [0x1e, 0x4],
        }
    }
}

impl Packet for PacketZcStartCouple {
    fn id(&self) -> &str {
       "0x01e4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqJoinCouple {
    pub fn from(buffer: &[u8]) -> PacketCzReqJoinCouple {
        PacketCzReqJoinCouple {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketCzReqJoinCouple {
        PacketCzReqJoinCouple {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1e, 0x5]),
        packet_id_raw: [0x1e, 0x5],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqJoinCouple {
    fn id(&self) -> &str {
       "0x01e5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcCouplename {
    pub fn from(buffer: &[u8]) -> PacketZcCouplename {
        PacketZcCouplename {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            couple_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            couple_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.couple_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.couple_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.couple_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_couple_name(&mut self, value: [char; 24]) {
        self.couple_name = value;
    }
    pub fn set_couple_name_raw(&mut self, value: [u8; 24]) {
        self.couple_name_raw = value;
    }
    pub fn new() -> PacketZcCouplename {
        PacketZcCouplename {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1e, 0x6]),
        packet_id_raw: [0x1e, 0x6],
        couple_name: [0 as char; 24],
        couple_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcCouplename {
    fn id(&self) -> &str {
       "0x01e6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzDoridori {
    pub fn from(buffer: &[u8]) -> PacketCzDoridori {
        PacketCzDoridori {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzDoridori {
        PacketCzDoridori {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1e, 0x7]),
        packet_id_raw: [0x1e, 0x7],
        }
    }
}

impl Packet for PacketCzDoridori {
    fn id(&self) -> &str {
       "0x01e7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzMakeGroup2 {
    pub fn from(buffer: &[u8]) -> PacketCzMakeGroup2 {
        PacketCzMakeGroup2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            group_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            item_pickup_rule: u8::from_le_bytes([buffer[26]]),
            item_pickup_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[26..27]);
                dst
            },
            item_division_rule: u8::from_le_bytes([buffer[27]]),
            item_division_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[27..28]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_pickup_rule).unwrap();
        self.item_pickup_rule_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_division_rule).unwrap();
        self.item_division_rule_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.group_name_raw.to_vec());
        wtr.append(&mut self.item_pickup_rule_raw.to_vec());
        wtr.append(&mut self.item_division_rule_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_group_name(&mut self, value: [char; 24]) {
        self.group_name = value;
    }
    pub fn set_group_name_raw(&mut self, value: [u8; 24]) {
        self.group_name_raw = value;
    }
    pub fn set_item_pickup_rule(&mut self, value: u8) {
        self.item_pickup_rule = value;
    }
    pub fn set_item_pickup_rule_raw(&mut self, value: [u8; 1]) {
        self.item_pickup_rule_raw = value;
    }
    pub fn set_item_division_rule(&mut self, value: u8) {
        self.item_division_rule = value;
    }
    pub fn set_item_division_rule_raw(&mut self, value: [u8; 1]) {
        self.item_division_rule_raw = value;
    }
    pub fn new() -> PacketCzMakeGroup2 {
        PacketCzMakeGroup2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1e, 0x8]),
        packet_id_raw: [0x1e, 0x8],
        group_name: [0 as char; 24],
        group_name_raw: [0; 24],
        item_pickup_rule: 0,
        item_pickup_rule_raw: [0; 1],
        item_division_rule: 0,
        item_division_rule_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzMakeGroup2 {
    fn id(&self) -> &str {
       "0x01e8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAddMemberToGroup2 {
    pub fn from(buffer: &[u8]) -> PacketZcAddMemberToGroup2 {
        PacketZcAddMemberToGroup2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            role: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            role_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[10], buffer[11]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[12], buffer[13]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            state: u8::from_le_bytes([buffer[14]]),
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
            group_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[15..39].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[15..39]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[39..63].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[39..63]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[63..79].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[63..79]);
                dst
            },
            item_pickup_rule: u8::from_le_bytes([buffer[79]]),
            item_pickup_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[79..80]);
                dst
            },
            item_division_rule: u8::from_le_bytes([buffer[80]]),
            item_division_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[80..81]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.role).unwrap();
        self.role_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_pickup_rule).unwrap();
        self.item_pickup_rule_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_division_rule).unwrap();
        self.item_division_rule_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.role_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.group_name_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.item_pickup_rule_raw.to_vec());
        wtr.append(&mut self.item_division_rule_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_role(&mut self, value: u32) {
        self.role = value;
    }
    pub fn set_role_raw(&mut self, value: [u8; 4]) {
        self.role_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_state(&mut self, value: u8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_group_name(&mut self, value: [char; 24]) {
        self.group_name = value;
    }
    pub fn set_group_name_raw(&mut self, value: [u8; 24]) {
        self.group_name_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_item_pickup_rule(&mut self, value: u8) {
        self.item_pickup_rule = value;
    }
    pub fn set_item_pickup_rule_raw(&mut self, value: [u8; 1]) {
        self.item_pickup_rule_raw = value;
    }
    pub fn set_item_division_rule(&mut self, value: u8) {
        self.item_division_rule = value;
    }
    pub fn set_item_division_rule_raw(&mut self, value: [u8; 1]) {
        self.item_division_rule_raw = value;
    }
    pub fn new() -> PacketZcAddMemberToGroup2 {
        PacketZcAddMemberToGroup2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1e, 0x9]),
        packet_id_raw: [0x1e, 0x9],
        aid: 0,
        aid_raw: [0; 4],
        role: 0,
        role_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        state: 0,
        state_raw: [0; 1],
        group_name: [0 as char; 24],
        group_name_raw: [0; 24],
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        item_pickup_rule: 0,
        item_pickup_rule_raw: [0; 1],
        item_division_rule: 0,
        item_division_rule_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAddMemberToGroup2 {
    fn id(&self) -> &str {
       "0x01e9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcCongratulation {
    pub fn from(buffer: &[u8]) -> PacketZcCongratulation {
        PacketZcCongratulation {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketZcCongratulation {
        PacketZcCongratulation {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1e, 0xa]),
        packet_id_raw: [0x1e, 0xa],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcCongratulation {
    fn id(&self) -> &str {
       "0x01ea"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyPositionToGuildm {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyPositionToGuildm {
        PacketZcNotifyPositionToGuildm {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[6], buffer[7]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[8], buffer[9]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn new() -> PacketZcNotifyPositionToGuildm {
        PacketZcNotifyPositionToGuildm {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1e, 0xb]),
        packet_id_raw: [0x1e, 0xb],
        aid: 0,
        aid_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyPositionToGuildm {
    fn id(&self) -> &str {
       "0x01eb"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcGuildMemberMapChange {
    pub fn from(buffer: &[u8]) -> PacketZcGuildMemberMapChange {
        PacketZcGuildMemberMapChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            aid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[10..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[10..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: u32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn new() -> PacketZcGuildMemberMapChange {
        PacketZcGuildMemberMapChange {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1e, 0xc]),
        packet_id_raw: [0x1e, 0xc],
        gdid: 0,
        gdid_raw: [0; 4],
        aid: 0,
        aid_raw: [0; 4],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        }
    }
}

impl Packet for PacketZcGuildMemberMapChange {
    fn id(&self) -> &str {
       "0x01ec"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzChopokgi {
    pub fn from(buffer: &[u8]) -> PacketCzChopokgi {
        PacketCzChopokgi {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzChopokgi {
        PacketCzChopokgi {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1e, 0xd]),
        packet_id_raw: [0x1e, 0xd],
        }
    }
}

impl Packet for PacketCzChopokgi {
    fn id(&self) -> &str {
       "0x01ed"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNormalItemlist2 {
    pub fn from(buffer: &[u8]) -> PacketZcNormalItemlist2 {
        let iter_count = (&buffer.len() - 4) / 18;
        let mut vec_field: Vec<NormalitemExtrainfo2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (18 * (i - 1));
            let end_pos = 4 + 18 * i;
            vec_field.push(NormalitemExtrainfo2::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcNormalItemlist2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<NormalitemExtrainfo2>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new() -> PacketZcNormalItemlist2 {
        PacketZcNormalItemlist2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1e, 0xe]),
        packet_id_raw: [0x1e, 0xe],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcNormalItemlist2 {
    fn id(&self) -> &str {
       "0x01ee"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcCartNormalItemlist2 {
    pub fn from(buffer: &[u8]) -> PacketZcCartNormalItemlist2 {
        let iter_count = (&buffer.len() - 4) / 18;
        let mut vec_field: Vec<NormalitemExtrainfo2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (18 * (i - 1));
            let end_pos = 4 + 18 * i;
            vec_field.push(NormalitemExtrainfo2::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcCartNormalItemlist2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<NormalitemExtrainfo2>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new() -> PacketZcCartNormalItemlist2 {
        PacketZcCartNormalItemlist2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1e, 0xf]),
        packet_id_raw: [0x1e, 0xf],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcCartNormalItemlist2 {
    fn id(&self) -> &str {
       "0x01ef"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcStoreNormalItemlist2 {
    pub fn from(buffer: &[u8]) -> PacketZcStoreNormalItemlist2 {
        let iter_count = (&buffer.len() - 4) / 18;
        let mut vec_field: Vec<NormalitemExtrainfo2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (18 * (i - 1));
            let end_pos = 4 + 18 * i;
            vec_field.push(NormalitemExtrainfo2::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcStoreNormalItemlist2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<NormalitemExtrainfo2>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new() -> PacketZcStoreNormalItemlist2 {
        PacketZcStoreNormalItemlist2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1f, 0x0]),
        packet_id_raw: [0x1f, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcStoreNormalItemlist2 {
    fn id(&self) -> &str {
       "0x01f0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcNotifyError {
    pub fn from(buffer: &[u8]) -> PacketAcNotifyError {
        PacketAcNotifyError {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            msg_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketAcNotifyError {
        PacketAcNotifyError {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1f, 0x1]),
        packet_id_raw: [0x1f, 0x1],
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketAcNotifyError {
    fn id(&self) -> &str {
       "0x01f1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcUpdateCharstat2 {
    pub fn from(buffer: &[u8]) -> PacketZcUpdateCharstat2 {
        PacketZcUpdateCharstat2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            status: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            status_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            sex: i16::from_le_bytes([buffer[14], buffer[15]]),
            sex_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            head: i16::from_le_bytes([buffer[16], buffer[17]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            head_palette: i16::from_le_bytes([buffer[18], buffer[19]]),
            head_palette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.status).unwrap();
        self.status_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_palette).unwrap();
        self.head_palette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.status_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.head_palette_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_status(&mut self, value: i32) {
        self.status = value;
    }
    pub fn set_status_raw(&mut self, value: [u8; 4]) {
        self.status_raw = value;
    }
    pub fn set_sex(&mut self, value: i16) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 2]) {
        self.sex_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_head_palette(&mut self, value: i16) {
        self.head_palette = value;
    }
    pub fn set_head_palette_raw(&mut self, value: [u8; 2]) {
        self.head_palette_raw = value;
    }
    pub fn new() -> PacketZcUpdateCharstat2 {
        PacketZcUpdateCharstat2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1f, 0x2]),
        packet_id_raw: [0x1f, 0x2],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        status: 0,
        status_raw: [0; 4],
        sex: 0,
        sex_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        head_palette: 0,
        head_palette_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcUpdateCharstat2 {
    fn id(&self) -> &str {
       "0x01f2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyEffect2 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyEffect2 {
        PacketZcNotifyEffect2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            effect_id: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            effect_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_id).unwrap();
        self.effect_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.effect_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_effect_id(&mut self, value: i32) {
        self.effect_id = value;
    }
    pub fn set_effect_id_raw(&mut self, value: [u8; 4]) {
        self.effect_id_raw = value;
    }
    pub fn new() -> PacketZcNotifyEffect2 {
        PacketZcNotifyEffect2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1f, 0x3]),
        packet_id_raw: [0x1f, 0x3],
        aid: 0,
        aid_raw: [0; 4],
        effect_id: 0,
        effect_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyEffect2 {
    fn id(&self) -> &str {
       "0x01f3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcReqExchangeItem2 {
    pub fn from(buffer: &[u8]) -> PacketZcReqExchangeItem2 {
        PacketZcReqExchangeItem2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            gid: u32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
            level: i16::from_le_bytes([buffer[30], buffer[31]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn new() -> PacketZcReqExchangeItem2 {
        PacketZcReqExchangeItem2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1f, 0x4]),
        packet_id_raw: [0x1f, 0x4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        gid: 0,
        gid_raw: [0; 4],
        level: 0,
        level_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcReqExchangeItem2 {
    fn id(&self) -> &str {
       "0x01f4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckExchangeItem2 {
    pub fn from(buffer: &[u8]) -> PacketZcAckExchangeItem2 {
        PacketZcAckExchangeItem2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            gid: u32::from_le_bytes([buffer[3], buffer[4], buffer[5], buffer[6]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[3..7]);
                dst
            },
            level: i16::from_le_bytes([buffer[7], buffer[8]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[7..9]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn new() -> PacketZcAckExchangeItem2 {
        PacketZcAckExchangeItem2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1f, 0x5]),
        packet_id_raw: [0x1f, 0x5],
        result: 0,
        result_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        level: 0,
        level_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAckExchangeItem2 {
    fn id(&self) -> &str {
       "0x01f5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcReqBaby {
    pub fn from(buffer: &[u8]) -> PacketZcReqBaby {
        PacketZcReqBaby {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[10..34].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[10..34]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new() -> PacketZcReqBaby {
        PacketZcReqBaby {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1f, 0x6]),
        packet_id_raw: [0x1f, 0x6],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcReqBaby {
    fn id(&self) -> &str {
       "0x01f6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzJoinBaby {
    pub fn from(buffer: &[u8]) -> PacketCzJoinBaby {
        PacketCzJoinBaby {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            answer: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            answer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_answer(&mut self, value: i32) {
        self.answer = value;
    }
    pub fn set_answer_raw(&mut self, value: [u8; 4]) {
        self.answer_raw = value;
    }
    pub fn new() -> PacketCzJoinBaby {
        PacketCzJoinBaby {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1f, 0x7]),
        packet_id_raw: [0x1f, 0x7],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        answer: 0,
        answer_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzJoinBaby {
    fn id(&self) -> &str {
       "0x01f7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcStartBaby {
    pub fn from(buffer: &[u8]) -> PacketZcStartBaby {
        PacketZcStartBaby {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketZcStartBaby {
        PacketZcStartBaby {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1f, 0x8]),
        packet_id_raw: [0x1f, 0x8],
        }
    }
}

impl Packet for PacketZcStartBaby {
    fn id(&self) -> &str {
       "0x01f8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqJoinBaby {
    pub fn from(buffer: &[u8]) -> PacketCzReqJoinBaby {
        PacketCzReqJoinBaby {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketCzReqJoinBaby {
        PacketCzReqJoinBaby {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1f, 0x9]),
        packet_id_raw: [0x1f, 0x9],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqJoinBaby {
    fn id(&self) -> &str {
       "0x01f9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCaLogin3 {
    pub fn from(buffer: &[u8]) -> PacketCaLogin3 {
        PacketCaLogin3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            version: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            id:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            passwd_md5:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[30..46].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_md5_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[30..46]);
                dst
            },
            clienttype: u8::from_le_bytes([buffer[46]]),
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[46..47]);
                dst
            },
            client_info: u8::from_le_bytes([buffer[47]]),
            client_info_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[47..48]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd_md5 {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_md5_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.client_info).unwrap();
        self.client_info_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.version_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.passwd_md5_raw.to_vec());
        wtr.append(&mut self.clienttype_raw.to_vec());
        wtr.append(&mut self.client_info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_version(&mut self, value: u32) {
        self.version = value;
    }
    pub fn set_version_raw(&mut self, value: [u8; 4]) {
        self.version_raw = value;
    }
    pub fn set_id(&mut self, value: [char; 24]) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 24]) {
        self.id_raw = value;
    }
    pub fn set_passwd_md5(&mut self, value: [char; 16]) {
        self.passwd_md5 = value;
    }
    pub fn set_passwd_md5_raw(&mut self, value: [u8; 16]) {
        self.passwd_md5_raw = value;
    }
    pub fn set_clienttype(&mut self, value: u8) {
        self.clienttype = value;
    }
    pub fn set_clienttype_raw(&mut self, value: [u8; 1]) {
        self.clienttype_raw = value;
    }
    pub fn set_client_info(&mut self, value: u8) {
        self.client_info = value;
    }
    pub fn set_client_info_raw(&mut self, value: [u8; 1]) {
        self.client_info_raw = value;
    }
    pub fn new() -> PacketCaLogin3 {
        PacketCaLogin3 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1f, 0xa]),
        packet_id_raw: [0x1f, 0xa],
        version: 0,
        version_raw: [0; 4],
        id: [0 as char; 24],
        id_raw: [0; 24],
        passwd_md5: [0 as char; 16],
        passwd_md5_raw: [0; 16],
        clienttype: 0,
        clienttype_raw: [0; 1],
        client_info: 0,
        client_info_raw: [0; 1],
        }
    }
}

impl Packet for PacketCaLogin3 {
    fn id(&self) -> &str {
       "0x01fa"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketChDeleteChar2 {
    pub fn from(buffer: &[u8]) -> PacketChDeleteChar2 {
        PacketChDeleteChar2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            key:  {
                let mut dst: [char; 50] = [0 as char; 50];
                for (index, byte) in buffer[6..56].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            key_raw: {
                let mut dst: [u8; 50] = [0u8; 50];
                dst.clone_from_slice(&buffer[6..56]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.key {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.key_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.key_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_key(&mut self, value: [char; 50]) {
        self.key = value;
    }
    pub fn set_key_raw(&mut self, value: [u8; 50]) {
        self.key_raw = value;
    }
    pub fn new() -> PacketChDeleteChar2 {
        PacketChDeleteChar2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1f, 0xb]),
        packet_id_raw: [0x1f, 0xb],
        gid: 0,
        gid_raw: [0; 4],
        key: [0 as char; 50],
        key_raw: [0; 50],
        }
    }
}

impl Packet for PacketChDeleteChar2 {
    fn id(&self) -> &str {
       "0x01fb"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcRepairitemlist {
    pub fn from(buffer: &[u8]) -> PacketZcRepairitemlist {
        let iter_count = (&buffer.len() - 4) / 13;
        let mut vec_field: Vec<RepairitemInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (13 * (i - 1));
            let end_pos = 4 + 13 * i;
            vec_field.push(RepairitemInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcRepairitemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<RepairitemInfo>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new() -> PacketZcRepairitemlist {
        PacketZcRepairitemlist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1f, 0xc]),
        packet_id_raw: [0x1f, 0xc],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcRepairitemlist {
    fn id(&self) -> &str {
       "0x01fc"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqItemrepair {
    pub fn from(buffer: &[u8]) -> PacketCzReqItemrepair {
        PacketCzReqItemrepair {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            target_item_info: RepairitemInfo::from(&buffer[2..buffer.len()]),
            target_item_info_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.target_item_info.fill_raw();
        self.target_item_info_raw = self.target_item_info.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.target_item_info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_target_item_info(&mut self, value: RepairitemInfo) {
        self.target_item_info = value;
    }
    pub fn set_target_item_info_raw(&mut self, value: Vec<u8>) {
        self.target_item_info_raw = value;
    }
    pub fn new() -> PacketCzReqItemrepair {
        PacketCzReqItemrepair {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1f, 0xd]),
        packet_id_raw: [0x1f, 0xd],
        target_item_info: RepairitemInfo::new(),
        target_item_info_raw: vec![],
        }
    }
}

impl Packet for PacketCzReqItemrepair {
    fn id(&self) -> &str {
       "0x01fd"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckItemrepair {
    pub fn from(buffer: &[u8]) -> PacketZcAckItemrepair {
        PacketZcAckItemrepair {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            result: u8::from_le_bytes([buffer[4]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcAckItemrepair {
        PacketZcAckItemrepair {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1f, 0xe]),
        packet_id_raw: [0x1f, 0xe],
        index: 0,
        index_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckItemrepair {
    fn id(&self) -> &str {
       "0x01fe"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcHighjump {
    pub fn from(buffer: &[u8]) -> PacketZcHighjump {
        PacketZcHighjump {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[6], buffer[7]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[8], buffer[9]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn new() -> PacketZcHighjump {
        PacketZcHighjump {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x1f, 0xf]),
        packet_id_raw: [0x1f, 0xf],
        aid: 0,
        aid_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcHighjump {
    fn id(&self) -> &str {
       "0x01ff"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCaConnectInfoChanged {
    pub fn from(buffer: &[u8]) -> PacketCaConnectInfoChanged {
        PacketCaConnectInfoChanged {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            id:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_id(&mut self, value: [char; 24]) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 24]) {
        self.id_raw = value;
    }
    pub fn new() -> PacketCaConnectInfoChanged {
        PacketCaConnectInfoChanged {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x20, 0x0]),
        packet_id_raw: [0x20, 0x0],
        id: [0 as char; 24],
        id_raw: [0; 24],
        }
    }
}

impl Packet for PacketCaConnectInfoChanged {
    fn id(&self) -> &str {
       "0x0200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcFriendsList {
    pub fn from(buffer: &[u8]) -> PacketZcFriendsList {
        let iter_count = (&buffer.len() - 4) / 32;
        let mut vec_field: Vec<StructFriend> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (32 * (i - 1));
            let end_pos = 4 + 32 * i;
            vec_field.push(StructFriend::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcFriendsList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            friend_list: vec_field.clone(),
            friend_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.friend_list_raw = {
            self.friend_list.iter_mut().for_each(|item| item.fill_raw());
            self.friend_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.friend_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_friend_list(&mut self, value: Vec<StructFriend>) {
        self.friend_list = value;
    }
    pub fn set_friend_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.friend_list_raw = value;
    }
    pub fn new() -> PacketZcFriendsList {
        PacketZcFriendsList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x20, 0x1]),
        packet_id_raw: [0x20, 0x1],
        packet_length: 0,
        packet_length_raw: [0; 2],
        friend_list: vec![],
        friend_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcFriendsList {
    fn id(&self) -> &str {
       "0x0201"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzAddFriends {
    pub fn from(buffer: &[u8]) -> PacketCzAddFriends {
        PacketCzAddFriends {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new() -> PacketCzAddFriends {
        PacketCzAddFriends {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x20, 0x2]),
        packet_id_raw: [0x20, 0x2],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzAddFriends {
    fn id(&self) -> &str {
       "0x0202"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzDeleteFriends {
    pub fn from(buffer: &[u8]) -> PacketCzDeleteFriends {
        PacketCzDeleteFriends {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new() -> PacketCzDeleteFriends {
        PacketCzDeleteFriends {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x20, 0x3]),
        packet_id_raw: [0x20, 0x3],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzDeleteFriends {
    fn id(&self) -> &str {
       "0x0203"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCaExeHashcheck {
    pub fn from(buffer: &[u8]) -> PacketCaExeHashcheck {
        PacketCaExeHashcheck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            hash_value:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[2..18].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            hash_value_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[2..18]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.hash_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.hash_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.hash_value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_hash_value(&mut self, value: [char; 16]) {
        self.hash_value = value;
    }
    pub fn set_hash_value_raw(&mut self, value: [u8; 16]) {
        self.hash_value_raw = value;
    }
    pub fn new() -> PacketCaExeHashcheck {
        PacketCaExeHashcheck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x20, 0x4]),
        packet_id_raw: [0x20, 0x4],
        hash_value: [0 as char; 16],
        hash_value_raw: [0; 16],
        }
    }
}

impl Packet for PacketCaExeHashcheck {
    fn id(&self) -> &str {
       "0x0204"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcDivorce {
    pub fn from(buffer: &[u8]) -> PacketZcDivorce {
        PacketZcDivorce {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new() -> PacketZcDivorce {
        PacketZcDivorce {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x20, 0x5]),
        packet_id_raw: [0x20, 0x5],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcDivorce {
    fn id(&self) -> &str {
       "0x0205"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcFriendsState {
    pub fn from(buffer: &[u8]) -> PacketZcFriendsState {
        PacketZcFriendsState {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            state: buffer[10] == 1,
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state as u8).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_state(&mut self, value: bool) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn new() -> PacketZcFriendsState {
        PacketZcFriendsState {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x20, 0x6]),
        packet_id_raw: [0x20, 0x6],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        state: false,
        state_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcFriendsState {
    fn id(&self) -> &str {
       "0x0206"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcReqAddFriends {
    pub fn from(buffer: &[u8]) -> PacketZcReqAddFriends {
        PacketZcReqAddFriends {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            req_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            req_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            req_gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            req_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[10..34].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[10..34]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.req_aid).unwrap();
        self.req_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.req_gid).unwrap();
        self.req_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.req_aid_raw.to_vec());
        wtr.append(&mut self.req_gid_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_req_aid(&mut self, value: u32) {
        self.req_aid = value;
    }
    pub fn set_req_aid_raw(&mut self, value: [u8; 4]) {
        self.req_aid_raw = value;
    }
    pub fn set_req_gid(&mut self, value: u32) {
        self.req_gid = value;
    }
    pub fn set_req_gid_raw(&mut self, value: [u8; 4]) {
        self.req_gid_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new() -> PacketZcReqAddFriends {
        PacketZcReqAddFriends {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x20, 0x7]),
        packet_id_raw: [0x20, 0x7],
        req_aid: 0,
        req_aid_raw: [0; 4],
        req_gid: 0,
        req_gid_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcReqAddFriends {
    fn id(&self) -> &str {
       "0x0207"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzAckReqAddFriends {
    pub fn from(buffer: &[u8]) -> PacketCzAckReqAddFriends {
        PacketCzAckReqAddFriends {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            req_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            req_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            req_gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            req_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            result: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.req_aid).unwrap();
        self.req_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.req_gid).unwrap();
        self.req_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.req_aid_raw.to_vec());
        wtr.append(&mut self.req_gid_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_req_aid(&mut self, value: u32) {
        self.req_aid = value;
    }
    pub fn set_req_aid_raw(&mut self, value: [u8; 4]) {
        self.req_aid_raw = value;
    }
    pub fn set_req_gid(&mut self, value: u32) {
        self.req_gid = value;
    }
    pub fn set_req_gid_raw(&mut self, value: [u8; 4]) {
        self.req_gid_raw = value;
    }
    pub fn set_result(&mut self, value: i32) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 4]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketCzAckReqAddFriends {
        PacketCzAckReqAddFriends {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x20, 0x8]),
        packet_id_raw: [0x20, 0x8],
        req_aid: 0,
        req_aid_raw: [0; 4],
        req_gid: 0,
        req_gid_raw: [0; 4],
        result: 0,
        result_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzAckReqAddFriends {
    fn id(&self) -> &str {
       "0x0208"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAddFriendsList {
    pub fn from(buffer: &[u8]) -> PacketZcAddFriendsList {
        PacketZcAddFriendsList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            gid: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[12..36].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[12..36]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new() -> PacketZcAddFriendsList {
        PacketZcAddFriendsList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x20, 0x9]),
        packet_id_raw: [0x20, 0x9],
        result: 0,
        result_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcAddFriendsList {
    fn id(&self) -> &str {
       "0x0209"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcDeleteFriends {
    pub fn from(buffer: &[u8]) -> PacketZcDeleteFriends {
        PacketZcDeleteFriends {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new() -> PacketZcDeleteFriends {
        PacketZcDeleteFriends {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x20, 0xa]),
        packet_id_raw: [0x20, 0xa],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDeleteFriends {
    fn id(&self) -> &str {
       "0x020a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcRefuseLoginR3 {
    pub fn from(buffer: &[u8]) -> PacketAcRefuseLoginR3 {
        PacketAcRefuseLoginR3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            error_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            block_date:  {
                let mut dst: [char; 20] = [0 as char; 20];
                for (index, byte) in buffer[6..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            block_date_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[6..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.block_date {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.block_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        wtr.append(&mut self.block_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u32) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 4]) {
        self.error_code_raw = value;
    }
    pub fn set_block_date(&mut self, value: [char; 20]) {
        self.block_date = value;
    }
    pub fn set_block_date_raw(&mut self, value: [u8; 20]) {
        self.block_date_raw = value;
    }
    pub fn new() -> PacketAcRefuseLoginR3 {
        PacketAcRefuseLoginR3 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x02, 0x0b]),
        packet_id_raw: [0x02, 0x0b],
        error_code: 0,
        error_code_raw: [0; 4],
        block_date: [0 as char; 20],
        block_date_raw: [0; 20],
        }
    }
}

impl Packet for PacketAcRefuseLoginR3 {
    fn id(&self) -> &str {
       "0x020b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzExeHashcheck {
    pub fn from(buffer: &[u8]) -> PacketCzExeHashcheck {
        PacketCzExeHashcheck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            client_type: u8::from_le_bytes([buffer[2]]),
            client_type_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            hash_value:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[3..19].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            hash_value_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[3..19]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.client_type).unwrap();
        self.client_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.hash_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.hash_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.client_type_raw.to_vec());
        wtr.append(&mut self.hash_value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_client_type(&mut self, value: u8) {
        self.client_type = value;
    }
    pub fn set_client_type_raw(&mut self, value: [u8; 1]) {
        self.client_type_raw = value;
    }
    pub fn set_hash_value(&mut self, value: [char; 16]) {
        self.hash_value = value;
    }
    pub fn set_hash_value_raw(&mut self, value: [u8; 16]) {
        self.hash_value_raw = value;
    }
    pub fn new() -> PacketCzExeHashcheck {
        PacketCzExeHashcheck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x20, 0xc]),
        packet_id_raw: [0x20, 0xc],
        client_type: 0,
        client_type_raw: [0; 1],
        hash_value: [0 as char; 16],
        hash_value_raw: [0; 16],
        }
    }
}

impl Packet for PacketCzExeHashcheck {
    fn id(&self) -> &str {
       "0x020c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcBlockCharacter {
    pub fn from(buffer: &[u8]) -> PacketHcBlockCharacter {
        let iter_count = (&buffer.len() - 4) / 24;
        let mut vec_field: Vec<TagCharacterBlockInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (24 * (i - 1));
            let end_pos = 4 + 24 * i;
            vec_field.push(TagCharacterBlockInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketHcBlockCharacter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            character_list: vec_field.clone(),
            character_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.character_list_raw = {
            self.character_list.iter_mut().for_each(|item| item.fill_raw());
            self.character_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.character_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_character_list(&mut self, value: Vec<TagCharacterBlockInfo>) {
        self.character_list = value;
    }
    pub fn set_character_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.character_list_raw = value;
    }
    pub fn new() -> PacketHcBlockCharacter {
        PacketHcBlockCharacter {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x20, 0xd]),
        packet_id_raw: [0x20, 0xd],
        packet_length: 0,
        packet_length_raw: [0; 2],
        character_list: vec![],
        character_list_raw: vec![],
        }
    }
}

impl Packet for PacketHcBlockCharacter {
    fn id(&self) -> &str {
       "0x020d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcStarskill {
    pub fn from(buffer: &[u8]) -> PacketZcStarskill {
        PacketZcStarskill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            map_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            monster_id: i32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            monster_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
            star: u8::from_le_bytes([buffer[30]]),
            star_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[30..31]);
                dst
            },
            result: u8::from_le_bytes([buffer[31]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[31..32]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.monster_id).unwrap();
        self.monster_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.star).unwrap();
        self.star_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.monster_id_raw.to_vec());
        wtr.append(&mut self.star_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 24]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 24]) {
        self.map_name_raw = value;
    }
    pub fn set_monster_id(&mut self, value: i32) {
        self.monster_id = value;
    }
    pub fn set_monster_id_raw(&mut self, value: [u8; 4]) {
        self.monster_id_raw = value;
    }
    pub fn set_star(&mut self, value: u8) {
        self.star = value;
    }
    pub fn set_star_raw(&mut self, value: [u8; 1]) {
        self.star_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcStarskill {
        PacketZcStarskill {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x20, 0xe]),
        packet_id_raw: [0x20, 0xe],
        map_name: [0 as char; 24],
        map_name_raw: [0; 24],
        monster_id: 0,
        monster_id_raw: [0; 4],
        star: 0,
        star_raw: [0; 1],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcStarskill {
    fn id(&self) -> &str {
       "0x020e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqPvppoint {
    pub fn from(buffer: &[u8]) -> PacketCzReqPvppoint {
        PacketCzReqPvppoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new() -> PacketCzReqPvppoint {
        PacketCzReqPvppoint {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x20, 0xf]),
        packet_id_raw: [0x20, 0xf],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqPvppoint {
    fn id(&self) -> &str {
       "0x020f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckPvppoint {
    pub fn from(buffer: &[u8]) -> PacketZcAckPvppoint {
        PacketZcAckPvppoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            pvp: PVPINFO::from(&buffer[10..buffer.len()]),
            pvp_raw: buffer[10..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        self.pvp.fill_raw();
        self.pvp_raw = self.pvp.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.pvp_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_pvp(&mut self, value: PVPINFO) {
        self.pvp = value;
    }
    pub fn set_pvp_raw(&mut self, value: Vec<u8>) {
        self.pvp_raw = value;
    }
    pub fn new() -> PacketZcAckPvppoint {
        PacketZcAckPvppoint {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x21, 0x0]),
        packet_id_raw: [0x21, 0x0],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        pvp: PVPINFO::new(),
        pvp_raw: vec![],
        }
    }
}

impl Packet for PacketZcAckPvppoint {
    fn id(&self) -> &str {
       "0x0210"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZhMovePvpworld {
    pub fn from(buffer: &[u8]) -> PacketZhMovePvpworld {
        PacketZhMovePvpworld {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new() -> PacketZhMovePvpworld {
        PacketZhMovePvpworld {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x21, 0x1]),
        packet_id_raw: [0x21, 0x1],
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZhMovePvpworld {
    fn id(&self) -> &str {
       "0x0211"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqGiveMannerByname {
    pub fn from(buffer: &[u8]) -> PacketCzReqGiveMannerByname {
        PacketCzReqGiveMannerByname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            char_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.char_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_char_name(&mut self, value: [char; 24]) {
        self.char_name = value;
    }
    pub fn set_char_name_raw(&mut self, value: [u8; 24]) {
        self.char_name_raw = value;
    }
    pub fn new() -> PacketCzReqGiveMannerByname {
        PacketCzReqGiveMannerByname {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x21, 0x2]),
        packet_id_raw: [0x21, 0x2],
        char_name: [0 as char; 24],
        char_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzReqGiveMannerByname {
    fn id(&self) -> &str {
       "0x0212"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqStatusGm {
    pub fn from(buffer: &[u8]) -> PacketCzReqStatusGm {
        PacketCzReqStatusGm {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            char_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.char_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_char_name(&mut self, value: [char; 24]) {
        self.char_name = value;
    }
    pub fn set_char_name_raw(&mut self, value: [u8; 24]) {
        self.char_name_raw = value;
    }
    pub fn new() -> PacketCzReqStatusGm {
        PacketCzReqStatusGm {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x21, 0x3]),
        packet_id_raw: [0x21, 0x3],
        char_name: [0 as char; 24],
        char_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzReqStatusGm {
    fn id(&self) -> &str {
       "0x0213"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckStatusGm {
    pub fn from(buffer: &[u8]) -> PacketZcAckStatusGm {
        PacketZcAckStatusGm {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            str: u8::from_le_bytes([buffer[2]]),
            str_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            standard_str: u8::from_le_bytes([buffer[3]]),
            standard_str_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[3..4]);
                dst
            },
            agi: u8::from_le_bytes([buffer[4]]),
            agi_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            standard_agi: u8::from_le_bytes([buffer[5]]),
            standard_agi_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            vit: u8::from_le_bytes([buffer[6]]),
            vit_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            standard_vit: u8::from_le_bytes([buffer[7]]),
            standard_vit_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[7..8]);
                dst
            },
            int: u8::from_le_bytes([buffer[8]]),
            int_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            standard_int: u8::from_le_bytes([buffer[9]]),
            standard_int_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            dex: u8::from_le_bytes([buffer[10]]),
            dex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            standard_dex: u8::from_le_bytes([buffer[11]]),
            standard_dex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            luk: u8::from_le_bytes([buffer[12]]),
            luk_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
            standard_luk: u8::from_le_bytes([buffer[13]]),
            standard_luk_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[13..14]);
                dst
            },
            att_power: i16::from_le_bytes([buffer[14], buffer[15]]),
            att_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            refining_power: i16::from_le_bytes([buffer[16], buffer[17]]),
            refining_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            max_matt_power: i16::from_le_bytes([buffer[18], buffer[19]]),
            max_matt_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            min_matt_power: i16::from_le_bytes([buffer[20], buffer[21]]),
            min_matt_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
            itemdef_power: i16::from_le_bytes([buffer[22], buffer[23]]),
            itemdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[22..24]);
                dst
            },
            plusdef_power: i16::from_le_bytes([buffer[24], buffer[25]]),
            plusdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            mdef_power: i16::from_le_bytes([buffer[26], buffer[27]]),
            mdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            plusmdef_power: i16::from_le_bytes([buffer[28], buffer[29]]),
            plusmdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            hit_success_value: i16::from_le_bytes([buffer[30], buffer[31]]),
            hit_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            avoid_success_value: i16::from_le_bytes([buffer[32], buffer[33]]),
            avoid_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            plus_avoid_success_value: i16::from_le_bytes([buffer[34], buffer[35]]),
            plus_avoid_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            critical_success_value: i16::from_le_bytes([buffer[36], buffer[37]]),
            critical_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[36..38]);
                dst
            },
            aspd: i16::from_le_bytes([buffer[38], buffer[39]]),
            aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[38..40]);
                dst
            },
            plus_aspd: i16::from_le_bytes([buffer[40], buffer[41]]),
            plus_aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.str).unwrap();
        self.str_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_str).unwrap();
        self.standard_str_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.agi).unwrap();
        self.agi_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_agi).unwrap();
        self.standard_agi_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.vit).unwrap();
        self.vit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_vit).unwrap();
        self.standard_vit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.int).unwrap();
        self.int_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_int).unwrap();
        self.standard_int_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dex).unwrap();
        self.dex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_dex).unwrap();
        self.standard_dex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.luk).unwrap();
        self.luk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_luk).unwrap();
        self.standard_luk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.att_power).unwrap();
        self.att_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.refining_power).unwrap();
        self.refining_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_matt_power).unwrap();
        self.max_matt_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.min_matt_power).unwrap();
        self.min_matt_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.itemdef_power).unwrap();
        self.itemdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plusdef_power).unwrap();
        self.plusdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef_power).unwrap();
        self.mdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plusmdef_power).unwrap();
        self.plusmdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hit_success_value).unwrap();
        self.hit_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.avoid_success_value).unwrap();
        self.avoid_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plus_avoid_success_value).unwrap();
        self.plus_avoid_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.critical_success_value).unwrap();
        self.critical_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.aspd).unwrap();
        self.aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plus_aspd).unwrap();
        self.plus_aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.str_raw.to_vec());
        wtr.append(&mut self.standard_str_raw.to_vec());
        wtr.append(&mut self.agi_raw.to_vec());
        wtr.append(&mut self.standard_agi_raw.to_vec());
        wtr.append(&mut self.vit_raw.to_vec());
        wtr.append(&mut self.standard_vit_raw.to_vec());
        wtr.append(&mut self.int_raw.to_vec());
        wtr.append(&mut self.standard_int_raw.to_vec());
        wtr.append(&mut self.dex_raw.to_vec());
        wtr.append(&mut self.standard_dex_raw.to_vec());
        wtr.append(&mut self.luk_raw.to_vec());
        wtr.append(&mut self.standard_luk_raw.to_vec());
        wtr.append(&mut self.att_power_raw.to_vec());
        wtr.append(&mut self.refining_power_raw.to_vec());
        wtr.append(&mut self.max_matt_power_raw.to_vec());
        wtr.append(&mut self.min_matt_power_raw.to_vec());
        wtr.append(&mut self.itemdef_power_raw.to_vec());
        wtr.append(&mut self.plusdef_power_raw.to_vec());
        wtr.append(&mut self.mdef_power_raw.to_vec());
        wtr.append(&mut self.plusmdef_power_raw.to_vec());
        wtr.append(&mut self.hit_success_value_raw.to_vec());
        wtr.append(&mut self.avoid_success_value_raw.to_vec());
        wtr.append(&mut self.plus_avoid_success_value_raw.to_vec());
        wtr.append(&mut self.critical_success_value_raw.to_vec());
        wtr.append(&mut self.aspd_raw.to_vec());
        wtr.append(&mut self.plus_aspd_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_str(&mut self, value: u8) {
        self.str = value;
    }
    pub fn set_str_raw(&mut self, value: [u8; 1]) {
        self.str_raw = value;
    }
    pub fn set_standard_str(&mut self, value: u8) {
        self.standard_str = value;
    }
    pub fn set_standard_str_raw(&mut self, value: [u8; 1]) {
        self.standard_str_raw = value;
    }
    pub fn set_agi(&mut self, value: u8) {
        self.agi = value;
    }
    pub fn set_agi_raw(&mut self, value: [u8; 1]) {
        self.agi_raw = value;
    }
    pub fn set_standard_agi(&mut self, value: u8) {
        self.standard_agi = value;
    }
    pub fn set_standard_agi_raw(&mut self, value: [u8; 1]) {
        self.standard_agi_raw = value;
    }
    pub fn set_vit(&mut self, value: u8) {
        self.vit = value;
    }
    pub fn set_vit_raw(&mut self, value: [u8; 1]) {
        self.vit_raw = value;
    }
    pub fn set_standard_vit(&mut self, value: u8) {
        self.standard_vit = value;
    }
    pub fn set_standard_vit_raw(&mut self, value: [u8; 1]) {
        self.standard_vit_raw = value;
    }
    pub fn set_int(&mut self, value: u8) {
        self.int = value;
    }
    pub fn set_int_raw(&mut self, value: [u8; 1]) {
        self.int_raw = value;
    }
    pub fn set_standard_int(&mut self, value: u8) {
        self.standard_int = value;
    }
    pub fn set_standard_int_raw(&mut self, value: [u8; 1]) {
        self.standard_int_raw = value;
    }
    pub fn set_dex(&mut self, value: u8) {
        self.dex = value;
    }
    pub fn set_dex_raw(&mut self, value: [u8; 1]) {
        self.dex_raw = value;
    }
    pub fn set_standard_dex(&mut self, value: u8) {
        self.standard_dex = value;
    }
    pub fn set_standard_dex_raw(&mut self, value: [u8; 1]) {
        self.standard_dex_raw = value;
    }
    pub fn set_luk(&mut self, value: u8) {
        self.luk = value;
    }
    pub fn set_luk_raw(&mut self, value: [u8; 1]) {
        self.luk_raw = value;
    }
    pub fn set_standard_luk(&mut self, value: u8) {
        self.standard_luk = value;
    }
    pub fn set_standard_luk_raw(&mut self, value: [u8; 1]) {
        self.standard_luk_raw = value;
    }
    pub fn set_att_power(&mut self, value: i16) {
        self.att_power = value;
    }
    pub fn set_att_power_raw(&mut self, value: [u8; 2]) {
        self.att_power_raw = value;
    }
    pub fn set_refining_power(&mut self, value: i16) {
        self.refining_power = value;
    }
    pub fn set_refining_power_raw(&mut self, value: [u8; 2]) {
        self.refining_power_raw = value;
    }
    pub fn set_max_matt_power(&mut self, value: i16) {
        self.max_matt_power = value;
    }
    pub fn set_max_matt_power_raw(&mut self, value: [u8; 2]) {
        self.max_matt_power_raw = value;
    }
    pub fn set_min_matt_power(&mut self, value: i16) {
        self.min_matt_power = value;
    }
    pub fn set_min_matt_power_raw(&mut self, value: [u8; 2]) {
        self.min_matt_power_raw = value;
    }
    pub fn set_itemdef_power(&mut self, value: i16) {
        self.itemdef_power = value;
    }
    pub fn set_itemdef_power_raw(&mut self, value: [u8; 2]) {
        self.itemdef_power_raw = value;
    }
    pub fn set_plusdef_power(&mut self, value: i16) {
        self.plusdef_power = value;
    }
    pub fn set_plusdef_power_raw(&mut self, value: [u8; 2]) {
        self.plusdef_power_raw = value;
    }
    pub fn set_mdef_power(&mut self, value: i16) {
        self.mdef_power = value;
    }
    pub fn set_mdef_power_raw(&mut self, value: [u8; 2]) {
        self.mdef_power_raw = value;
    }
    pub fn set_plusmdef_power(&mut self, value: i16) {
        self.plusmdef_power = value;
    }
    pub fn set_plusmdef_power_raw(&mut self, value: [u8; 2]) {
        self.plusmdef_power_raw = value;
    }
    pub fn set_hit_success_value(&mut self, value: i16) {
        self.hit_success_value = value;
    }
    pub fn set_hit_success_value_raw(&mut self, value: [u8; 2]) {
        self.hit_success_value_raw = value;
    }
    pub fn set_avoid_success_value(&mut self, value: i16) {
        self.avoid_success_value = value;
    }
    pub fn set_avoid_success_value_raw(&mut self, value: [u8; 2]) {
        self.avoid_success_value_raw = value;
    }
    pub fn set_plus_avoid_success_value(&mut self, value: i16) {
        self.plus_avoid_success_value = value;
    }
    pub fn set_plus_avoid_success_value_raw(&mut self, value: [u8; 2]) {
        self.plus_avoid_success_value_raw = value;
    }
    pub fn set_critical_success_value(&mut self, value: i16) {
        self.critical_success_value = value;
    }
    pub fn set_critical_success_value_raw(&mut self, value: [u8; 2]) {
        self.critical_success_value_raw = value;
    }
    pub fn set_aspd(&mut self, value: i16) {
        self.aspd = value;
    }
    pub fn set_aspd_raw(&mut self, value: [u8; 2]) {
        self.aspd_raw = value;
    }
    pub fn set_plus_aspd(&mut self, value: i16) {
        self.plus_aspd = value;
    }
    pub fn set_plus_aspd_raw(&mut self, value: [u8; 2]) {
        self.plus_aspd_raw = value;
    }
    pub fn new() -> PacketZcAckStatusGm {
        PacketZcAckStatusGm {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x21, 0x4]),
        packet_id_raw: [0x21, 0x4],
        str: 0,
        str_raw: [0; 1],
        standard_str: 0,
        standard_str_raw: [0; 1],
        agi: 0,
        agi_raw: [0; 1],
        standard_agi: 0,
        standard_agi_raw: [0; 1],
        vit: 0,
        vit_raw: [0; 1],
        standard_vit: 0,
        standard_vit_raw: [0; 1],
        int: 0,
        int_raw: [0; 1],
        standard_int: 0,
        standard_int_raw: [0; 1],
        dex: 0,
        dex_raw: [0; 1],
        standard_dex: 0,
        standard_dex_raw: [0; 1],
        luk: 0,
        luk_raw: [0; 1],
        standard_luk: 0,
        standard_luk_raw: [0; 1],
        att_power: 0,
        att_power_raw: [0; 2],
        refining_power: 0,
        refining_power_raw: [0; 2],
        max_matt_power: 0,
        max_matt_power_raw: [0; 2],
        min_matt_power: 0,
        min_matt_power_raw: [0; 2],
        itemdef_power: 0,
        itemdef_power_raw: [0; 2],
        plusdef_power: 0,
        plusdef_power_raw: [0; 2],
        mdef_power: 0,
        mdef_power_raw: [0; 2],
        plusmdef_power: 0,
        plusmdef_power_raw: [0; 2],
        hit_success_value: 0,
        hit_success_value_raw: [0; 2],
        avoid_success_value: 0,
        avoid_success_value_raw: [0; 2],
        plus_avoid_success_value: 0,
        plus_avoid_success_value_raw: [0; 2],
        critical_success_value: 0,
        critical_success_value_raw: [0; 2],
        aspd: 0,
        aspd_raw: [0; 2],
        plus_aspd: 0,
        plus_aspd_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAckStatusGm {
    fn id(&self) -> &str {
       "0x0214"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSkillmsg {
    pub fn from(buffer: &[u8]) -> PacketZcSkillmsg {
        PacketZcSkillmsg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            msg_no: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            msg_no_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.msg_no).unwrap();
        self.msg_no_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.msg_no_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_msg_no(&mut self, value: i32) {
        self.msg_no = value;
    }
    pub fn set_msg_no_raw(&mut self, value: [u8; 4]) {
        self.msg_no_raw = value;
    }
    pub fn new() -> PacketZcSkillmsg {
        PacketZcSkillmsg {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x21, 0x5]),
        packet_id_raw: [0x21, 0x5],
        msg_no: 0,
        msg_no_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcSkillmsg {
    fn id(&self) -> &str {
       "0x0215"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcBabymsg {
    pub fn from(buffer: &[u8]) -> PacketZcBabymsg {
        PacketZcBabymsg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            msg_no: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            msg_no_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.msg_no).unwrap();
        self.msg_no_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.msg_no_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_msg_no(&mut self, value: i32) {
        self.msg_no = value;
    }
    pub fn set_msg_no_raw(&mut self, value: [u8; 4]) {
        self.msg_no_raw = value;
    }
    pub fn new() -> PacketZcBabymsg {
        PacketZcBabymsg {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x21, 0x6]),
        packet_id_raw: [0x21, 0x6],
        msg_no: 0,
        msg_no_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcBabymsg {
    fn id(&self) -> &str {
       "0x0216"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzBlacksmithRank {
    pub fn from(buffer: &[u8]) -> PacketCzBlacksmithRank {
        PacketCzBlacksmithRank {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzBlacksmithRank {
        PacketCzBlacksmithRank {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x21, 0x7]),
        packet_id_raw: [0x21, 0x7],
        }
    }
}

impl Packet for PacketCzBlacksmithRank {
    fn id(&self) -> &str {
       "0x0217"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzAlchemistRank {
    pub fn from(buffer: &[u8]) -> PacketCzAlchemistRank {
        PacketCzAlchemistRank {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzAlchemistRank {
        PacketCzAlchemistRank {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x21, 0x8]),
        packet_id_raw: [0x21, 0x8],
        }
    }
}

impl Packet for PacketCzAlchemistRank {
    fn id(&self) -> &str {
       "0x0218"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcBlacksmithRank {
    pub fn from(buffer: &[u8]) -> PacketZcBlacksmithRank {
        PacketZcBlacksmithRank {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 10] = [0 as char; 10];
                for (index, byte) in buffer[2..12].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[2..12]);
                dst
            },
            point:  {
                let mut dst: [i32; 10] = [0 as i32; 10];
                for (index, byte) in buffer[242..252].iter().enumerate() {
                    dst[index] = *byte as i32;
                }
                dst
            },
            point_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[242..252]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.point {
            wtr.write_i32::<LittleEndian>(item).unwrap();
        }
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 10]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 10]) {
        self.name_raw = value;
    }
    pub fn set_point(&mut self, value: [i32; 10]) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 10]) {
        self.point_raw = value;
    }
    pub fn new() -> PacketZcBlacksmithRank {
        PacketZcBlacksmithRank {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x21, 0x9]),
        packet_id_raw: [0x21, 0x9],
        name: [0 as char; 10],
        name_raw: [0; 10],
        point: [0; 10],
        point_raw: [0; 10],
        }
    }
}

impl Packet for PacketZcBlacksmithRank {
    fn id(&self) -> &str {
       "0x0219"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAlchemistRank {
    pub fn from(buffer: &[u8]) -> PacketZcAlchemistRank {
        PacketZcAlchemistRank {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 10] = [0 as char; 10];
                for (index, byte) in buffer[2..12].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[2..12]);
                dst
            },
            point:  {
                let mut dst: [i32; 10] = [0 as i32; 10];
                for (index, byte) in buffer[242..252].iter().enumerate() {
                    dst[index] = *byte as i32;
                }
                dst
            },
            point_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[242..252]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.point {
            wtr.write_i32::<LittleEndian>(item).unwrap();
        }
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 10]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 10]) {
        self.name_raw = value;
    }
    pub fn set_point(&mut self, value: [i32; 10]) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 10]) {
        self.point_raw = value;
    }
    pub fn new() -> PacketZcAlchemistRank {
        PacketZcAlchemistRank {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x21, 0xa]),
        packet_id_raw: [0x21, 0xa],
        name: [0 as char; 10],
        name_raw: [0; 10],
        point: [0; 10],
        point_raw: [0; 10],
        }
    }
}

impl Packet for PacketZcAlchemistRank {
    fn id(&self) -> &str {
       "0x021a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcBlacksmithPoint {
    pub fn from(buffer: &[u8]) -> PacketZcBlacksmithPoint {
        PacketZcBlacksmithPoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            point: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            total_point: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            total_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.total_point).unwrap();
        self.total_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        wtr.append(&mut self.total_point_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_point(&mut self, value: i32) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 4]) {
        self.point_raw = value;
    }
    pub fn set_total_point(&mut self, value: i32) {
        self.total_point = value;
    }
    pub fn set_total_point_raw(&mut self, value: [u8; 4]) {
        self.total_point_raw = value;
    }
    pub fn new() -> PacketZcBlacksmithPoint {
        PacketZcBlacksmithPoint {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x21, 0xb]),
        packet_id_raw: [0x21, 0xb],
        point: 0,
        point_raw: [0; 4],
        total_point: 0,
        total_point_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcBlacksmithPoint {
    fn id(&self) -> &str {
       "0x021b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAlchemistPoint {
    pub fn from(buffer: &[u8]) -> PacketZcAlchemistPoint {
        PacketZcAlchemistPoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            point: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            total_point: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            total_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.total_point).unwrap();
        self.total_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        wtr.append(&mut self.total_point_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_point(&mut self, value: i32) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 4]) {
        self.point_raw = value;
    }
    pub fn set_total_point(&mut self, value: i32) {
        self.total_point = value;
    }
    pub fn set_total_point_raw(&mut self, value: [u8; 4]) {
        self.total_point_raw = value;
    }
    pub fn new() -> PacketZcAlchemistPoint {
        PacketZcAlchemistPoint {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x21, 0xc]),
        packet_id_raw: [0x21, 0xc],
        point: 0,
        point_raw: [0; 4],
        total_point: 0,
        total_point_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcAlchemistPoint {
    fn id(&self) -> &str {
       "0x021c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzLesseffect {
    pub fn from(buffer: &[u8]) -> PacketCzLesseffect {
        PacketCzLesseffect {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            is_less: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            is_less_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.is_less).unwrap();
        self.is_less_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.is_less_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_is_less(&mut self, value: i32) {
        self.is_less = value;
    }
    pub fn set_is_less_raw(&mut self, value: [u8; 4]) {
        self.is_less_raw = value;
    }
    pub fn new() -> PacketCzLesseffect {
        PacketCzLesseffect {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x21, 0xd]),
        packet_id_raw: [0x21, 0xd],
        is_less: 0,
        is_less_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzLesseffect {
    fn id(&self) -> &str {
       "0x021d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcLesseffect {
    pub fn from(buffer: &[u8]) -> PacketZcLesseffect {
        PacketZcLesseffect {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            is_less: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            is_less_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.is_less).unwrap();
        self.is_less_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.is_less_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_is_less(&mut self, value: i32) {
        self.is_less = value;
    }
    pub fn set_is_less_raw(&mut self, value: [u8; 4]) {
        self.is_less_raw = value;
    }
    pub fn new() -> PacketZcLesseffect {
        PacketZcLesseffect {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x21, 0xe]),
        packet_id_raw: [0x21, 0xe],
        is_less: 0,
        is_less_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcLesseffect {
    fn id(&self) -> &str {
       "0x021e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyPkinfo {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyPkinfo {
        PacketZcNotifyPkinfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            win_point: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            win_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            lose_point: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            lose_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            kill_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[10..34].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            kill_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[10..34]);
                dst
            },
            killed_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[34..58].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            killed_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[34..58]);
                dst
            },
            expire_time: Filetime::from(&buffer[58..buffer.len()]),
            expire_time_raw: buffer[58..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.win_point).unwrap();
        self.win_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.lose_point).unwrap();
        self.lose_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.kill_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.kill_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.killed_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.killed_name_raw = wtr.try_into().unwrap();
        self.expire_time.fill_raw();
        self.expire_time_raw = self.expire_time.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.win_point_raw.to_vec());
        wtr.append(&mut self.lose_point_raw.to_vec());
        wtr.append(&mut self.kill_name_raw.to_vec());
        wtr.append(&mut self.killed_name_raw.to_vec());
        wtr.append(&mut self.expire_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_win_point(&mut self, value: i32) {
        self.win_point = value;
    }
    pub fn set_win_point_raw(&mut self, value: [u8; 4]) {
        self.win_point_raw = value;
    }
    pub fn set_lose_point(&mut self, value: i32) {
        self.lose_point = value;
    }
    pub fn set_lose_point_raw(&mut self, value: [u8; 4]) {
        self.lose_point_raw = value;
    }
    pub fn set_kill_name(&mut self, value: [char; 24]) {
        self.kill_name = value;
    }
    pub fn set_kill_name_raw(&mut self, value: [u8; 24]) {
        self.kill_name_raw = value;
    }
    pub fn set_killed_name(&mut self, value: [char; 24]) {
        self.killed_name = value;
    }
    pub fn set_killed_name_raw(&mut self, value: [u8; 24]) {
        self.killed_name_raw = value;
    }
    pub fn set_expire_time(&mut self, value: Filetime) {
        self.expire_time = value;
    }
    pub fn set_expire_time_raw(&mut self, value: Vec<u8>) {
        self.expire_time_raw = value;
    }
    pub fn new() -> PacketZcNotifyPkinfo {
        PacketZcNotifyPkinfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x21, 0xf]),
        packet_id_raw: [0x21, 0xf],
        win_point: 0,
        win_point_raw: [0; 4],
        lose_point: 0,
        lose_point_raw: [0; 4],
        kill_name: [0 as char; 24],
        kill_name_raw: [0; 24],
        killed_name: [0 as char; 24],
        killed_name_raw: [0; 24],
        expire_time: Filetime::new(),
        expire_time_raw: vec![],
        }
    }
}

impl Packet for PacketZcNotifyPkinfo {
    fn id(&self) -> &str {
       "0x021f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyCrazykiller {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyCrazykiller {
        PacketZcNotifyCrazykiller {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            is_crazy_killer: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            is_crazy_killer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.is_crazy_killer).unwrap();
        self.is_crazy_killer_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.is_crazy_killer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_is_crazy_killer(&mut self, value: i32) {
        self.is_crazy_killer = value;
    }
    pub fn set_is_crazy_killer_raw(&mut self, value: [u8; 4]) {
        self.is_crazy_killer_raw = value;
    }
    pub fn new() -> PacketZcNotifyCrazykiller {
        PacketZcNotifyCrazykiller {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x22, 0x0]),
        packet_id_raw: [0x22, 0x0],
        aid: 0,
        aid_raw: [0; 4],
        is_crazy_killer: 0,
        is_crazy_killer_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyCrazykiller {
    fn id(&self) -> &str {
       "0x0220"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyWeaponitemlist {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyWeaponitemlist {
        let iter_count = (&buffer.len() - 4) / 13;
        let mut vec_field: Vec<RepairitemInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (13 * (i - 1));
            let end_pos = 4 + 13 * i;
            vec_field.push(RepairitemInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcNotifyWeaponitemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<RepairitemInfo>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new() -> PacketZcNotifyWeaponitemlist {
        PacketZcNotifyWeaponitemlist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x22, 0x1]),
        packet_id_raw: [0x22, 0x1],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcNotifyWeaponitemlist {
    fn id(&self) -> &str {
       "0x0221"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqWeaponrefine {
    pub fn from(buffer: &[u8]) -> PacketCzReqWeaponrefine {
        PacketCzReqWeaponrefine {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            index_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i32) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 4]) {
        self.index_raw = value;
    }
    pub fn new() -> PacketCzReqWeaponrefine {
        PacketCzReqWeaponrefine {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x22, 0x2]),
        packet_id_raw: [0x22, 0x2],
        index: 0,
        index_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqWeaponrefine {
    fn id(&self) -> &str {
       "0x0222"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckWeaponrefine {
    pub fn from(buffer: &[u8]) -> PacketZcAckWeaponrefine {
        PacketZcAckWeaponrefine {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            msg: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            msg_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            itid: u16::from_le_bytes([buffer[6], buffer[7]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.msg).unwrap();
        self.msg_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_msg(&mut self, value: i32) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: [u8; 4]) {
        self.msg_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new() -> PacketZcAckWeaponrefine {
        PacketZcAckWeaponrefine {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x22, 0x3]),
        packet_id_raw: [0x22, 0x3],
        msg: 0,
        msg_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAckWeaponrefine {
    fn id(&self) -> &str {
       "0x0223"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcTaekwonPoint {
    pub fn from(buffer: &[u8]) -> PacketZcTaekwonPoint {
        PacketZcTaekwonPoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            point: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            total_point: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            total_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.total_point).unwrap();
        self.total_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        wtr.append(&mut self.total_point_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_point(&mut self, value: i32) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 4]) {
        self.point_raw = value;
    }
    pub fn set_total_point(&mut self, value: i32) {
        self.total_point = value;
    }
    pub fn set_total_point_raw(&mut self, value: [u8; 4]) {
        self.total_point_raw = value;
    }
    pub fn new() -> PacketZcTaekwonPoint {
        PacketZcTaekwonPoint {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x22, 0x4]),
        packet_id_raw: [0x22, 0x4],
        point: 0,
        point_raw: [0; 4],
        total_point: 0,
        total_point_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcTaekwonPoint {
    fn id(&self) -> &str {
       "0x0224"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzTaekwonRank {
    pub fn from(buffer: &[u8]) -> PacketCzTaekwonRank {
        PacketCzTaekwonRank {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzTaekwonRank {
        PacketCzTaekwonRank {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x22, 0x5]),
        packet_id_raw: [0x22, 0x5],
        }
    }
}

impl Packet for PacketCzTaekwonRank {
    fn id(&self) -> &str {
       "0x0225"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcTaekwonRank {
    pub fn from(buffer: &[u8]) -> PacketZcTaekwonRank {
        PacketZcTaekwonRank {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 10] = [0 as char; 10];
                for (index, byte) in buffer[2..12].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[2..12]);
                dst
            },
            point:  {
                let mut dst: [i32; 10] = [0 as i32; 10];
                for (index, byte) in buffer[242..252].iter().enumerate() {
                    dst[index] = *byte as i32;
                }
                dst
            },
            point_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[242..252]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.point {
            wtr.write_i32::<LittleEndian>(item).unwrap();
        }
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 10]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 10]) {
        self.name_raw = value;
    }
    pub fn set_point(&mut self, value: [i32; 10]) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 10]) {
        self.point_raw = value;
    }
    pub fn new() -> PacketZcTaekwonRank {
        PacketZcTaekwonRank {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x22, 0x6]),
        packet_id_raw: [0x22, 0x6],
        name: [0 as char; 10],
        name_raw: [0; 10],
        point: [0; 10],
        point_raw: [0; 10],
        }
    }
}

impl Packet for PacketZcTaekwonRank {
    fn id(&self) -> &str {
       "0x0226"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcGameGuard {
    pub fn from(buffer: &[u8]) -> PacketZcGameGuard {
        PacketZcGameGuard {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            auth_data:  {
                let mut dst: [u32; 4] = [0 as u32; 4];
                for (index, byte) in buffer[2..6].iter().enumerate() {
                    dst[index] = *byte as u32;
                }
                dst
            },
            auth_data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.auth_data {
            wtr.write_u32::<LittleEndian>(item).unwrap();
        }
        self.auth_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.auth_data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_auth_data(&mut self, value: [u32; 4]) {
        self.auth_data = value;
    }
    pub fn set_auth_data_raw(&mut self, value: [u8; 4]) {
        self.auth_data_raw = value;
    }
    pub fn new() -> PacketZcGameGuard {
        PacketZcGameGuard {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x22, 0x7]),
        packet_id_raw: [0x22, 0x7],
        auth_data: [0; 4],
        auth_data_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcGameGuard {
    fn id(&self) -> &str {
       "0x0227"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzAckGameGuard {
    pub fn from(buffer: &[u8]) -> PacketCzAckGameGuard {
        PacketCzAckGameGuard {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            auth_data:  {
                let mut dst: [u32; 4] = [0 as u32; 4];
                for (index, byte) in buffer[2..6].iter().enumerate() {
                    dst[index] = *byte as u32;
                }
                dst
            },
            auth_data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.auth_data {
            wtr.write_u32::<LittleEndian>(item).unwrap();
        }
        self.auth_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.auth_data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_auth_data(&mut self, value: [u32; 4]) {
        self.auth_data = value;
    }
    pub fn set_auth_data_raw(&mut self, value: [u8; 4]) {
        self.auth_data_raw = value;
    }
    pub fn new() -> PacketCzAckGameGuard {
        PacketCzAckGameGuard {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x22, 0x8]),
        packet_id_raw: [0x22, 0x8],
        auth_data: [0; 4],
        auth_data_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzAckGameGuard {
    fn id(&self) -> &str {
       "0x0228"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcStateChange3 {
    pub fn from(buffer: &[u8]) -> PacketZcStateChange3 {
        PacketZcStateChange3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[6], buffer[7]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            is_pkmode_on: buffer[14] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn new() -> PacketZcStateChange3 {
        PacketZcStateChange3 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x22, 0x9]),
        packet_id_raw: [0x22, 0x9],
        aid: 0,
        aid_raw: [0; 4],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcStateChange3 {
    fn id(&self) -> &str {
       "0x0229"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyStandentry3 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyStandentry3 {
        PacketZcNotifyStandentry3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            job: i16::from_le_bytes([buffer[16], buffer[17]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            head: i16::from_le_bytes([buffer[18], buffer[19]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[24], buffer[25]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[26], buffer[27]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[28], buffer[29]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[30], buffer[31]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[32], buffer[33]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[34], buffer[35]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            guid: u32::from_le_bytes([buffer[36], buffer[37], buffer[38], buffer[39]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[36..40]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[40], buffer[41]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            honor: i16::from_le_bytes([buffer[42], buffer[43]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[44], buffer[45], buffer[46], buffer[47]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[44..48]);
                dst
            },
            is_pkmode_on: buffer[48] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[48..49]);
                dst
            },
            sex: u8::from_le_bytes([buffer[49]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[50..53].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[50..53]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[53]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[53..54]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[54]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[54..55]);
                dst
            },
            state: u8::from_le_bytes([buffer[55]]),
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[55..56]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[56], buffer[57]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[56..58]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [char; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_state(&mut self, value: u8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new() -> PacketZcNotifyStandentry3 {
        PacketZcNotifyStandentry3 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x22, 0xa]),
        packet_id_raw: [0x22, 0xa],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0 as char; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        state: 0,
        state_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyStandentry3 {
    fn id(&self) -> &str {
       "0x022a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyNewentry3 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyNewentry3 {
        PacketZcNotifyNewentry3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            job: i16::from_le_bytes([buffer[16], buffer[17]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            head: i16::from_le_bytes([buffer[18], buffer[19]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[24], buffer[25]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[26], buffer[27]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[28], buffer[29]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[30], buffer[31]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[32], buffer[33]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[34], buffer[35]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            guid: u32::from_le_bytes([buffer[36], buffer[37], buffer[38], buffer[39]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[36..40]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[40], buffer[41]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            honor: i16::from_le_bytes([buffer[42], buffer[43]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[44], buffer[45], buffer[46], buffer[47]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[44..48]);
                dst
            },
            is_pkmode_on: buffer[48] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[48..49]);
                dst
            },
            sex: u8::from_le_bytes([buffer[49]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[50..53].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[50..53]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[53]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[53..54]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[54]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[54..55]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[55], buffer[56]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[55..57]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [char; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new() -> PacketZcNotifyNewentry3 {
        PacketZcNotifyNewentry3 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x22, 0xb]),
        packet_id_raw: [0x22, 0xb],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0 as char; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyNewentry3 {
    fn id(&self) -> &str {
       "0x022b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyMoveentry3 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMoveentry3 {
        PacketZcNotifyMoveentry3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            objecttype: u8::from_le_bytes([buffer[2]]),
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            gid: u32::from_le_bytes([buffer[3], buffer[4], buffer[5], buffer[6]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[3..7]);
                dst
            },
            speed: i16::from_le_bytes([buffer[7], buffer[8]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[7..9]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[9], buffer[10]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[11], buffer[12]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[13], buffer[14], buffer[15], buffer[16]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[13..17]);
                dst
            },
            job: i16::from_le_bytes([buffer[17], buffer[18]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[17..19]);
                dst
            },
            head: i16::from_le_bytes([buffer[19], buffer[20]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[21], buffer[22], buffer[23], buffer[24]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[21..25]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[25], buffer[26]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[25..27]);
                dst
            },
            move_start_time: u32::from_le_bytes([buffer[27], buffer[28], buffer[29], buffer[30]]),
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[27..31]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[31], buffer[32]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[31..33]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[33], buffer[34]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[35], buffer[36]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[35..37]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[37], buffer[38]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[37..39]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[39], buffer[40]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[39..41]);
                dst
            },
            guid: u32::from_le_bytes([buffer[41], buffer[42], buffer[43], buffer[44]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[41..45]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[45], buffer[46]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[45..47]);
                dst
            },
            honor: i16::from_le_bytes([buffer[47], buffer[48]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[47..49]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[49], buffer[50], buffer[51], buffer[52]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[49..53]);
                dst
            },
            is_pkmode_on: buffer[53] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[53..54]);
                dst
            },
            sex: u8::from_le_bytes([buffer[54]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[54..55]);
                dst
            },
            move_data:  {
                let mut dst: [u16; 6] = [0 as u16; 6];
                for (index, byte) in buffer[55..61].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            },
            move_data_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[55..61]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[61]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[61..62]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[62]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[62..63]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[63], buffer[64]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[63..65]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.objecttype_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.move_start_time_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.move_data_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_objecttype(&mut self, value: u8) {
        self.objecttype = value;
    }
    pub fn set_objecttype_raw(&mut self, value: [u8; 1]) {
        self.objecttype_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_move_start_time(&mut self, value: u32) {
        self.move_start_time = value;
    }
    pub fn set_move_start_time_raw(&mut self, value: [u8; 4]) {
        self.move_start_time_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_move_data(&mut self, value: [u16; 6]) {
        self.move_data = value;
    }
    pub fn set_move_data_raw(&mut self, value: [u8; 6]) {
        self.move_data_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new() -> PacketZcNotifyMoveentry3 {
        PacketZcNotifyMoveentry3 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x22, 0xc]),
        packet_id_raw: [0x22, 0xc],
        objecttype: 0,
        objecttype_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        move_start_time: 0,
        move_start_time_raw: [0; 4],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        move_data: [0; 6],
        move_data_raw: [0; 6],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyMoveentry3 {
    fn id(&self) -> &str {
       "0x022c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzCommandMer {
    pub fn from(buffer: &[u8]) -> PacketCzCommandMer {
        PacketCzCommandMer {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            command: i8::from_le_bytes([buffer[4]]),
            command_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.command).unwrap();
        self.command_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.command_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn set_command(&mut self, value: i8) {
        self.command = value;
    }
    pub fn set_command_raw(&mut self, value: [u8; 1]) {
        self.command_raw = value;
    }
    pub fn new() -> PacketCzCommandMer {
        PacketCzCommandMer {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x22, 0xd]),
        packet_id_raw: [0x22, 0xd],
        atype: 0,
        atype_raw: [0; 2],
        command: 0,
        command_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzCommandMer {
    fn id(&self) -> &str {
       "0x022d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPropertyHomun {
    pub fn from(buffer: &[u8]) -> PacketZcPropertyHomun {
        PacketZcPropertyHomun {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            sz_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            sz_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            b_modified: u8::from_le_bytes([buffer[26]]),
            b_modified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[26..27]);
                dst
            },
            n_level: i16::from_le_bytes([buffer[27], buffer[28]]),
            n_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[27..29]);
                dst
            },
            n_fullness: i16::from_le_bytes([buffer[29], buffer[30]]),
            n_fullness_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[29..31]);
                dst
            },
            n_relationship: i16::from_le_bytes([buffer[31], buffer[32]]),
            n_relationship_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[31..33]);
                dst
            },
            itid: u16::from_le_bytes([buffer[33], buffer[34]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            atk: i16::from_le_bytes([buffer[35], buffer[36]]),
            atk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[35..37]);
                dst
            },
            matk: i16::from_le_bytes([buffer[37], buffer[38]]),
            matk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[37..39]);
                dst
            },
            hit: i16::from_le_bytes([buffer[39], buffer[40]]),
            hit_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[39..41]);
                dst
            },
            critical: i16::from_le_bytes([buffer[41], buffer[42]]),
            critical_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[41..43]);
                dst
            },
            def: i16::from_le_bytes([buffer[43], buffer[44]]),
            def_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[43..45]);
                dst
            },
            mdef: i16::from_le_bytes([buffer[45], buffer[46]]),
            mdef_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[45..47]);
                dst
            },
            flee: i16::from_le_bytes([buffer[47], buffer[48]]),
            flee_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[47..49]);
                dst
            },
            aspd: i16::from_le_bytes([buffer[49], buffer[50]]),
            aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[49..51]);
                dst
            },
            hp: i16::from_le_bytes([buffer[51], buffer[52]]),
            hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[51..53]);
                dst
            },
            max_hp: i16::from_le_bytes([buffer[53], buffer[54]]),
            max_hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[53..55]);
                dst
            },
            sp: i16::from_le_bytes([buffer[55], buffer[56]]),
            sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[55..57]);
                dst
            },
            max_sp: i16::from_le_bytes([buffer[57], buffer[58]]),
            max_sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[57..59]);
                dst
            },
            exp: i32::from_le_bytes([buffer[59], buffer[60], buffer[61], buffer[62]]),
            exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[59..63]);
                dst
            },
            max_exp: i32::from_le_bytes([buffer[63], buffer[64], buffer[65], buffer[66]]),
            max_exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[63..67]);
                dst
            },
            skpoint: i16::from_le_bytes([buffer[67], buffer[68]]),
            skpoint_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[67..69]);
                dst
            },
            atkrange: i16::from_le_bytes([buffer[69], buffer[70]]),
            atkrange_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[69..71]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.b_modified).unwrap();
        self.b_modified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.n_level).unwrap();
        self.n_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.n_fullness).unwrap();
        self.n_fullness_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.n_relationship).unwrap();
        self.n_relationship_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atk).unwrap();
        self.atk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.matk).unwrap();
        self.matk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hit).unwrap();
        self.hit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.critical).unwrap();
        self.critical_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.def).unwrap();
        self.def_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef).unwrap();
        self.mdef_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.flee).unwrap();
        self.flee_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.aspd).unwrap();
        self.aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sp).unwrap();
        self.sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_sp).unwrap();
        self.max_sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.exp).unwrap();
        self.exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_exp).unwrap();
        self.max_exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.skpoint).unwrap();
        self.skpoint_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atkrange).unwrap();
        self.atkrange_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.sz_name_raw.to_vec());
        wtr.append(&mut self.b_modified_raw.to_vec());
        wtr.append(&mut self.n_level_raw.to_vec());
        wtr.append(&mut self.n_fullness_raw.to_vec());
        wtr.append(&mut self.n_relationship_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atk_raw.to_vec());
        wtr.append(&mut self.matk_raw.to_vec());
        wtr.append(&mut self.hit_raw.to_vec());
        wtr.append(&mut self.critical_raw.to_vec());
        wtr.append(&mut self.def_raw.to_vec());
        wtr.append(&mut self.mdef_raw.to_vec());
        wtr.append(&mut self.flee_raw.to_vec());
        wtr.append(&mut self.aspd_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.max_hp_raw.to_vec());
        wtr.append(&mut self.sp_raw.to_vec());
        wtr.append(&mut self.max_sp_raw.to_vec());
        wtr.append(&mut self.exp_raw.to_vec());
        wtr.append(&mut self.max_exp_raw.to_vec());
        wtr.append(&mut self.skpoint_raw.to_vec());
        wtr.append(&mut self.atkrange_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_sz_name(&mut self, value: [char; 24]) {
        self.sz_name = value;
    }
    pub fn set_sz_name_raw(&mut self, value: [u8; 24]) {
        self.sz_name_raw = value;
    }
    pub fn set_b_modified(&mut self, value: u8) {
        self.b_modified = value;
    }
    pub fn set_b_modified_raw(&mut self, value: [u8; 1]) {
        self.b_modified_raw = value;
    }
    pub fn set_n_level(&mut self, value: i16) {
        self.n_level = value;
    }
    pub fn set_n_level_raw(&mut self, value: [u8; 2]) {
        self.n_level_raw = value;
    }
    pub fn set_n_fullness(&mut self, value: i16) {
        self.n_fullness = value;
    }
    pub fn set_n_fullness_raw(&mut self, value: [u8; 2]) {
        self.n_fullness_raw = value;
    }
    pub fn set_n_relationship(&mut self, value: i16) {
        self.n_relationship = value;
    }
    pub fn set_n_relationship_raw(&mut self, value: [u8; 2]) {
        self.n_relationship_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atk(&mut self, value: i16) {
        self.atk = value;
    }
    pub fn set_atk_raw(&mut self, value: [u8; 2]) {
        self.atk_raw = value;
    }
    pub fn set_matk(&mut self, value: i16) {
        self.matk = value;
    }
    pub fn set_matk_raw(&mut self, value: [u8; 2]) {
        self.matk_raw = value;
    }
    pub fn set_hit(&mut self, value: i16) {
        self.hit = value;
    }
    pub fn set_hit_raw(&mut self, value: [u8; 2]) {
        self.hit_raw = value;
    }
    pub fn set_critical(&mut self, value: i16) {
        self.critical = value;
    }
    pub fn set_critical_raw(&mut self, value: [u8; 2]) {
        self.critical_raw = value;
    }
    pub fn set_def(&mut self, value: i16) {
        self.def = value;
    }
    pub fn set_def_raw(&mut self, value: [u8; 2]) {
        self.def_raw = value;
    }
    pub fn set_mdef(&mut self, value: i16) {
        self.mdef = value;
    }
    pub fn set_mdef_raw(&mut self, value: [u8; 2]) {
        self.mdef_raw = value;
    }
    pub fn set_flee(&mut self, value: i16) {
        self.flee = value;
    }
    pub fn set_flee_raw(&mut self, value: [u8; 2]) {
        self.flee_raw = value;
    }
    pub fn set_aspd(&mut self, value: i16) {
        self.aspd = value;
    }
    pub fn set_aspd_raw(&mut self, value: [u8; 2]) {
        self.aspd_raw = value;
    }
    pub fn set_hp(&mut self, value: i16) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 2]) {
        self.hp_raw = value;
    }
    pub fn set_max_hp(&mut self, value: i16) {
        self.max_hp = value;
    }
    pub fn set_max_hp_raw(&mut self, value: [u8; 2]) {
        self.max_hp_raw = value;
    }
    pub fn set_sp(&mut self, value: i16) {
        self.sp = value;
    }
    pub fn set_sp_raw(&mut self, value: [u8; 2]) {
        self.sp_raw = value;
    }
    pub fn set_max_sp(&mut self, value: i16) {
        self.max_sp = value;
    }
    pub fn set_max_sp_raw(&mut self, value: [u8; 2]) {
        self.max_sp_raw = value;
    }
    pub fn set_exp(&mut self, value: i32) {
        self.exp = value;
    }
    pub fn set_exp_raw(&mut self, value: [u8; 4]) {
        self.exp_raw = value;
    }
    pub fn set_max_exp(&mut self, value: i32) {
        self.max_exp = value;
    }
    pub fn set_max_exp_raw(&mut self, value: [u8; 4]) {
        self.max_exp_raw = value;
    }
    pub fn set_skpoint(&mut self, value: i16) {
        self.skpoint = value;
    }
    pub fn set_skpoint_raw(&mut self, value: [u8; 2]) {
        self.skpoint_raw = value;
    }
    pub fn set_atkrange(&mut self, value: i16) {
        self.atkrange = value;
    }
    pub fn set_atkrange_raw(&mut self, value: [u8; 2]) {
        self.atkrange_raw = value;
    }
    pub fn new() -> PacketZcPropertyHomun {
        PacketZcPropertyHomun {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x22, 0xe]),
        packet_id_raw: [0x22, 0xe],
        sz_name: [0 as char; 24],
        sz_name_raw: [0; 24],
        b_modified: 0,
        b_modified_raw: [0; 1],
        n_level: 0,
        n_level_raw: [0; 2],
        n_fullness: 0,
        n_fullness_raw: [0; 2],
        n_relationship: 0,
        n_relationship_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        atk: 0,
        atk_raw: [0; 2],
        matk: 0,
        matk_raw: [0; 2],
        hit: 0,
        hit_raw: [0; 2],
        critical: 0,
        critical_raw: [0; 2],
        def: 0,
        def_raw: [0; 2],
        mdef: 0,
        mdef_raw: [0; 2],
        flee: 0,
        flee_raw: [0; 2],
        aspd: 0,
        aspd_raw: [0; 2],
        hp: 0,
        hp_raw: [0; 2],
        max_hp: 0,
        max_hp_raw: [0; 2],
        sp: 0,
        sp_raw: [0; 2],
        max_sp: 0,
        max_sp_raw: [0; 2],
        exp: 0,
        exp_raw: [0; 4],
        max_exp: 0,
        max_exp_raw: [0; 4],
        skpoint: 0,
        skpoint_raw: [0; 2],
        atkrange: 0,
        atkrange_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcPropertyHomun {
    fn id(&self) -> &str {
       "0x022e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcChangestateMer {
    pub fn from(buffer: &[u8]) -> PacketZcChangestateMer {
        PacketZcChangestateMer {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            state: i8::from_le_bytes([buffer[3]]),
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[3..4]);
                dst
            },
            gid: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            data: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.data).unwrap();
        self.data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_state(&mut self, value: i8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_gid(&mut self, value: i32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_data(&mut self, value: i32) {
        self.data = value;
    }
    pub fn set_data_raw(&mut self, value: [u8; 4]) {
        self.data_raw = value;
    }
    pub fn new() -> PacketZcChangestateMer {
        PacketZcChangestateMer {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x23, 0x0]),
        packet_id_raw: [0x23, 0x0],
        atype: 0,
        atype_raw: [0; 1],
        state: 0,
        state_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        data: 0,
        data_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcChangestateMer {
    fn id(&self) -> &str {
       "0x0230"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRenameMer {
    pub fn from(buffer: &[u8]) -> PacketCzRenameMer {
        PacketCzRenameMer {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new() -> PacketCzRenameMer {
        PacketCzRenameMer {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x23, 0x1]),
        packet_id_raw: [0x23, 0x1],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzRenameMer {
    fn id(&self) -> &str {
       "0x0231"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRequestMovenpc {
    pub fn from(buffer: &[u8]) -> PacketCzRequestMovenpc {
        PacketCzRequestMovenpc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            dest:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[6..9].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            dest_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[6..9]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.dest {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.dest_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.dest_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_dest(&mut self, value: [char; 3]) {
        self.dest = value;
    }
    pub fn set_dest_raw(&mut self, value: [u8; 3]) {
        self.dest_raw = value;
    }
    pub fn new() -> PacketCzRequestMovenpc {
        PacketCzRequestMovenpc {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x23, 0x2]),
        packet_id_raw: [0x23, 0x2],
        gid: 0,
        gid_raw: [0; 4],
        dest: [0 as char; 3],
        dest_raw: [0; 3],
        }
    }
}

impl Packet for PacketCzRequestMovenpc {
    fn id(&self) -> &str {
       "0x0232"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRequestActnpc {
    pub fn from(buffer: &[u8]) -> PacketCzRequestActnpc {
        PacketCzRequestActnpc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            target_gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            action: u8::from_le_bytes([buffer[10]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_gid).unwrap();
        self.target_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.target_gid_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_target_gid(&mut self, value: u32) {
        self.target_gid = value;
    }
    pub fn set_target_gid_raw(&mut self, value: [u8; 4]) {
        self.target_gid_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn new() -> PacketCzRequestActnpc {
        PacketCzRequestActnpc {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x23, 0x3]),
        packet_id_raw: [0x23, 0x3],
        gid: 0,
        gid_raw: [0; 4],
        target_gid: 0,
        target_gid_raw: [0; 4],
        action: 0,
        action_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzRequestActnpc {
    fn id(&self) -> &str {
       "0x0233"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRequestMovetoowner {
    pub fn from(buffer: &[u8]) -> PacketCzRequestMovetoowner {
        PacketCzRequestMovetoowner {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new() -> PacketCzRequestMovetoowner {
        PacketCzRequestMovetoowner {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x23, 0x4]),
        packet_id_raw: [0x23, 0x4],
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzRequestMovetoowner {
    fn id(&self) -> &str {
       "0x0234"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcReqStorePassword {
    pub fn from(buffer: &[u8]) -> PacketZcReqStorePassword {
        PacketZcReqStorePassword {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            info: i16::from_le_bytes([buffer[2], buffer[3]]),
            info_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.info).unwrap();
        self.info_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_info(&mut self, value: i16) {
        self.info = value;
    }
    pub fn set_info_raw(&mut self, value: [u8; 2]) {
        self.info_raw = value;
    }
    pub fn new() -> PacketZcReqStorePassword {
        PacketZcReqStorePassword {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x23, 0xa]),
        packet_id_raw: [0x23, 0xa],
        info: 0,
        info_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcReqStorePassword {
    fn id(&self) -> &str {
       "0x023a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzAckStorePassword {
    pub fn from(buffer: &[u8]) -> PacketCzAckStorePassword {
        PacketCzAckStorePassword {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            password:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[4..20].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            password_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[4..20]);
                dst
            },
            new_password:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[20..36].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            new_password_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[20..36]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.password {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.password_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.new_password {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.new_password_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.password_raw.to_vec());
        wtr.append(&mut self.new_password_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn set_password(&mut self, value: [char; 16]) {
        self.password = value;
    }
    pub fn set_password_raw(&mut self, value: [u8; 16]) {
        self.password_raw = value;
    }
    pub fn set_new_password(&mut self, value: [char; 16]) {
        self.new_password = value;
    }
    pub fn set_new_password_raw(&mut self, value: [u8; 16]) {
        self.new_password_raw = value;
    }
    pub fn new() -> PacketCzAckStorePassword {
        PacketCzAckStorePassword {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x23, 0xb]),
        packet_id_raw: [0x23, 0xb],
        atype: 0,
        atype_raw: [0; 2],
        password: [0 as char; 16],
        password_raw: [0; 16],
        new_password: [0 as char; 16],
        new_password_raw: [0; 16],
        }
    }
}

impl Packet for PacketCzAckStorePassword {
    fn id(&self) -> &str {
       "0x023b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcResultStorePassword {
    pub fn from(buffer: &[u8]) -> PacketZcResultStorePassword {
        PacketZcResultStorePassword {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            error_count: i16::from_le_bytes([buffer[4], buffer[5]]),
            error_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_count).unwrap();
        self.error_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.error_count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn set_error_count(&mut self, value: i16) {
        self.error_count = value;
    }
    pub fn set_error_count_raw(&mut self, value: [u8; 2]) {
        self.error_count_raw = value;
    }
    pub fn new() -> PacketZcResultStorePassword {
        PacketZcResultStorePassword {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x23, 0xc]),
        packet_id_raw: [0x23, 0xc],
        result: 0,
        result_raw: [0; 2],
        error_count: 0,
        error_count_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcResultStorePassword {
    fn id(&self) -> &str {
       "0x023c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcEventResult {
    pub fn from(buffer: &[u8]) -> PacketAcEventResult {
        PacketAcEventResult {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            event_item_count: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            event_item_count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.event_item_count).unwrap();
        self.event_item_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.event_item_count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_event_item_count(&mut self, value: u32) {
        self.event_item_count = value;
    }
    pub fn set_event_item_count_raw(&mut self, value: [u8; 4]) {
        self.event_item_count_raw = value;
    }
    pub fn new() -> PacketAcEventResult {
        PacketAcEventResult {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x23, 0xd]),
        packet_id_raw: [0x23, 0xd],
        event_item_count: 0,
        event_item_count_raw: [0; 4],
        }
    }
}

impl Packet for PacketAcEventResult {
    fn id(&self) -> &str {
       "0x023d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcRequestCharacterPassword {
    pub fn from(buffer: &[u8]) -> PacketHcRequestCharacterPassword {
        PacketHcRequestCharacterPassword {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            dummy_value: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            dummy_value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dummy_value).unwrap();
        self.dummy_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.dummy_value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn set_dummy_value(&mut self, value: u32) {
        self.dummy_value = value;
    }
    pub fn set_dummy_value_raw(&mut self, value: [u8; 4]) {
        self.dummy_value_raw = value;
    }
    pub fn new() -> PacketHcRequestCharacterPassword {
        PacketHcRequestCharacterPassword {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x23, 0xe]),
        packet_id_raw: [0x23, 0xe],
        result: 0,
        result_raw: [0; 2],
        dummy_value: 0,
        dummy_value_raw: [0; 4],
        }
    }
}

impl Packet for PacketHcRequestCharacterPassword {
    fn id(&self) -> &str {
       "0x023e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzMailGetList {
    pub fn from(buffer: &[u8]) -> PacketCzMailGetList {
        PacketCzMailGetList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzMailGetList {
        PacketCzMailGetList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x23, 0xf]),
        packet_id_raw: [0x23, 0xf],
        }
    }
}

impl Packet for PacketCzMailGetList {
    fn id(&self) -> &str {
       "0x023f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMailReqGetList {
    pub fn from(buffer: &[u8]) -> PacketZcMailReqGetList {
        let iter_count = (&buffer.len() - 8) / 73;
        let mut vec_field: Vec<MailList> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (73 * (i - 1));
            let end_pos = 8 + 73 * i;
            vec_field.push(MailList::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcMailReqGetList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            mail_number: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            mail_number_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            mail_list: vec_field.clone(),
            mail_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_number).unwrap();
        self.mail_number_raw = wtr.try_into().unwrap();
        self.mail_list_raw = {
            self.mail_list.iter_mut().for_each(|item| item.fill_raw());
            self.mail_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.mail_number_raw.to_vec());
        self.mail_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_mail_number(&mut self, value: i32) {
        self.mail_number = value;
    }
    pub fn set_mail_number_raw(&mut self, value: [u8; 4]) {
        self.mail_number_raw = value;
    }
    pub fn set_mail_list(&mut self, value: Vec<MailList>) {
        self.mail_list = value;
    }
    pub fn set_mail_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.mail_list_raw = value;
    }
    pub fn new() -> PacketZcMailReqGetList {
        PacketZcMailReqGetList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x24, 0x0]),
        packet_id_raw: [0x24, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        mail_number: 0,
        mail_number_raw: [0; 4],
        mail_list: vec![],
        mail_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcMailReqGetList {
    fn id(&self) -> &str {
       "0x0240"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzMailOpen {
    pub fn from(buffer: &[u8]) -> PacketCzMailOpen {
        PacketCzMailOpen {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            mail_id: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.mail_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_mail_id(&mut self, value: i32) {
        self.mail_id = value;
    }
    pub fn set_mail_id_raw(&mut self, value: [u8; 4]) {
        self.mail_id_raw = value;
    }
    pub fn new() -> PacketCzMailOpen {
        PacketCzMailOpen {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x24, 0x1]),
        packet_id_raw: [0x24, 0x1],
        mail_id: 0,
        mail_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMailOpen {
    fn id(&self) -> &str {
       "0x0241"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMailReqOpen {
    pub fn from(buffer: &[u8]) -> PacketZcMailReqOpen {
        PacketZcMailReqOpen {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            mail_id: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            header:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[8..48].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            header_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[8..48]);
                dst
            },
            from_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[48..72].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            from_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[48..72]);
                dst
            },
            delete_time: i32::from_le_bytes([buffer[72], buffer[73], buffer[74], buffer[75]]),
            delete_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[72..76]);
                dst
            },
            money: u32::from_le_bytes([buffer[76], buffer[77], buffer[78], buffer[79]]),
            money_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[76..80]);
                dst
            },
            count: i32::from_le_bytes([buffer[80], buffer[81], buffer[82], buffer[83]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[80..84]);
                dst
            },
            itid: u16::from_le_bytes([buffer[84], buffer[85]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[84..86]);
                dst
            },
            atype: u16::from_le_bytes([buffer[86], buffer[87]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[86..88]);
                dst
            },
            is_identified: buffer[88] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[88..89]);
                dst
            },
            is_damaged: buffer[89] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[89..90]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[90]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[90..91]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[91..99]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[91..99]);
                dst
            },
            msg_len: u8::from_le_bytes([buffer[99]]),
            msg_len_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[99..100]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[100..buffer.len()]).to_string(),
            msg_raw: buffer[100..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.header {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.header_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.from_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.from_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.delete_time).unwrap();
        self.delete_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.money).unwrap();
        self.money_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.write_u8(self.msg_len).unwrap();
        self.msg_len_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.mail_id_raw.to_vec());
        wtr.append(&mut self.header_raw.to_vec());
        wtr.append(&mut self.from_name_raw.to_vec());
        wtr.append(&mut self.delete_time_raw.to_vec());
        wtr.append(&mut self.money_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        wtr.append(&mut self.msg_len_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_mail_id(&mut self, value: i32) {
        self.mail_id = value;
    }
    pub fn set_mail_id_raw(&mut self, value: [u8; 4]) {
        self.mail_id_raw = value;
    }
    pub fn set_header(&mut self, value: [char; 40]) {
        self.header = value;
    }
    pub fn set_header_raw(&mut self, value: [u8; 40]) {
        self.header_raw = value;
    }
    pub fn set_from_name(&mut self, value: [char; 24]) {
        self.from_name = value;
    }
    pub fn set_from_name_raw(&mut self, value: [u8; 24]) {
        self.from_name_raw = value;
    }
    pub fn set_delete_time(&mut self, value: i32) {
        self.delete_time = value;
    }
    pub fn set_delete_time_raw(&mut self, value: [u8; 4]) {
        self.delete_time_raw = value;
    }
    pub fn set_money(&mut self, value: u32) {
        self.money = value;
    }
    pub fn set_money_raw(&mut self, value: [u8; 4]) {
        self.money_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn set_msg_len(&mut self, value: u8) {
        self.msg_len = value;
    }
    pub fn set_msg_len_raw(&mut self, value: [u8; 1]) {
        self.msg_len_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketZcMailReqOpen {
        PacketZcMailReqOpen {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x24, 0x2]),
        packet_id_raw: [0x24, 0x2],
        packet_length: 0,
        packet_length_raw: [0; 2],
        mail_id: 0,
        mail_id_raw: [0; 4],
        header: [0 as char; 40],
        header_raw: [0; 40],
        from_name: [0 as char; 24],
        from_name_raw: [0; 24],
        delete_time: 0,
        delete_time_raw: [0; 4],
        money: 0,
        money_raw: [0; 4],
        count: 0,
        count_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        msg_len: 0,
        msg_len_raw: [0; 1],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcMailReqOpen {
    fn id(&self) -> &str {
       "0x0242"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzMailDelete {
    pub fn from(buffer: &[u8]) -> PacketCzMailDelete {
        PacketCzMailDelete {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            mail_id: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.mail_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_mail_id(&mut self, value: i32) {
        self.mail_id = value;
    }
    pub fn set_mail_id_raw(&mut self, value: [u8; 4]) {
        self.mail_id_raw = value;
    }
    pub fn new() -> PacketCzMailDelete {
        PacketCzMailDelete {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x24, 0x3]),
        packet_id_raw: [0x24, 0x3],
        mail_id: 0,
        mail_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMailDelete {
    fn id(&self) -> &str {
       "0x0243"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzMailGetItem {
    pub fn from(buffer: &[u8]) -> PacketCzMailGetItem {
        PacketCzMailGetItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            mail_id: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.mail_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_mail_id(&mut self, value: i32) {
        self.mail_id = value;
    }
    pub fn set_mail_id_raw(&mut self, value: [u8; 4]) {
        self.mail_id_raw = value;
    }
    pub fn new() -> PacketCzMailGetItem {
        PacketCzMailGetItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x24, 0x4]),
        packet_id_raw: [0x24, 0x4],
        mail_id: 0,
        mail_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMailGetItem {
    fn id(&self) -> &str {
       "0x0244"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMailReqGetItem {
    pub fn from(buffer: &[u8]) -> PacketZcMailReqGetItem {
        PacketZcMailReqGetItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcMailReqGetItem {
        PacketZcMailReqGetItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x24, 0x5]),
        packet_id_raw: [0x24, 0x5],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcMailReqGetItem {
    fn id(&self) -> &str {
       "0x0245"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzMailResetItem {
    pub fn from(buffer: &[u8]) -> PacketCzMailResetItem {
        PacketCzMailResetItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketCzMailResetItem {
        PacketCzMailResetItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x24, 0x6]),
        packet_id_raw: [0x24, 0x6],
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzMailResetItem {
    fn id(&self) -> &str {
       "0x0246"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzMailAddItem {
    pub fn from(buffer: &[u8]) -> PacketCzMailAddItem {
        PacketCzMailAddItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketCzMailAddItem {
        PacketCzMailAddItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x24, 0x7]),
        packet_id_raw: [0x24, 0x7],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMailAddItem {
    fn id(&self) -> &str {
       "0x0247"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzMailSend {
    pub fn from(buffer: &[u8]) -> PacketCzMailSend {
        PacketCzMailSend {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            receive_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            receive_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
            header:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[28..68].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            header_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[28..68]);
                dst
            },
            msg_len: u32::from_le_bytes([buffer[68], buffer[69], buffer[70], buffer[71]]),
            msg_len_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[68..72]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[72..buffer.len()]).to_string(),
            msg_raw: buffer[72..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.receive_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.receive_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.header {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.header_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.msg_len).unwrap();
        self.msg_len_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.receive_name_raw.to_vec());
        wtr.append(&mut self.header_raw.to_vec());
        wtr.append(&mut self.msg_len_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_receive_name(&mut self, value: [char; 24]) {
        self.receive_name = value;
    }
    pub fn set_receive_name_raw(&mut self, value: [u8; 24]) {
        self.receive_name_raw = value;
    }
    pub fn set_header(&mut self, value: [char; 40]) {
        self.header = value;
    }
    pub fn set_header_raw(&mut self, value: [u8; 40]) {
        self.header_raw = value;
    }
    pub fn set_msg_len(&mut self, value: u32) {
        self.msg_len = value;
    }
    pub fn set_msg_len_raw(&mut self, value: [u8; 4]) {
        self.msg_len_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketCzMailSend {
        PacketCzMailSend {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x24, 0x8]),
        packet_id_raw: [0x24, 0x8],
        packet_length: 0,
        packet_length_raw: [0; 2],
        receive_name: [0 as char; 24],
        receive_name_raw: [0; 24],
        header: [0 as char; 40],
        header_raw: [0; 40],
        msg_len: 0,
        msg_len_raw: [0; 4],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketCzMailSend {
    fn id(&self) -> &str {
       "0x0248"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMailReqSend {
    pub fn from(buffer: &[u8]) -> PacketZcMailReqSend {
        PacketZcMailReqSend {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcMailReqSend {
        PacketZcMailReqSend {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x24, 0x9]),
        packet_id_raw: [0x24, 0x9],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcMailReqSend {
    fn id(&self) -> &str {
       "0x0249"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMailReceive {
    pub fn from(buffer: &[u8]) -> PacketZcMailReceive {
        PacketZcMailReceive {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            mail_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            header:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[6..46].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            header_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[6..46]);
                dst
            },
            from_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[46..70].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            from_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[46..70]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.header {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.header_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.from_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.from_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.mail_id_raw.to_vec());
        wtr.append(&mut self.header_raw.to_vec());
        wtr.append(&mut self.from_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_mail_id(&mut self, value: u32) {
        self.mail_id = value;
    }
    pub fn set_mail_id_raw(&mut self, value: [u8; 4]) {
        self.mail_id_raw = value;
    }
    pub fn set_header(&mut self, value: [char; 40]) {
        self.header = value;
    }
    pub fn set_header_raw(&mut self, value: [u8; 40]) {
        self.header_raw = value;
    }
    pub fn set_from_name(&mut self, value: [char; 24]) {
        self.from_name = value;
    }
    pub fn set_from_name_raw(&mut self, value: [u8; 24]) {
        self.from_name_raw = value;
    }
    pub fn new() -> PacketZcMailReceive {
        PacketZcMailReceive {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x24, 0xa]),
        packet_id_raw: [0x24, 0xa],
        mail_id: 0,
        mail_id_raw: [0; 4],
        header: [0 as char; 40],
        header_raw: [0; 40],
        from_name: [0 as char; 24],
        from_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcMailReceive {
    fn id(&self) -> &str {
       "0x024a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzAuctionCreate {
    pub fn from(buffer: &[u8]) -> PacketCzAuctionCreate {
        PacketCzAuctionCreate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketCzAuctionCreate {
        PacketCzAuctionCreate {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x24, 0xb]),
        packet_id_raw: [0x24, 0xb],
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzAuctionCreate {
    fn id(&self) -> &str {
       "0x024b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzAuctionAddItem {
    pub fn from(buffer: &[u8]) -> PacketCzAuctionAddItem {
        PacketCzAuctionAddItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketCzAuctionAddItem {
        PacketCzAuctionAddItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x24, 0xc]),
        packet_id_raw: [0x24, 0xc],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzAuctionAddItem {
    fn id(&self) -> &str {
       "0x024c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzAuctionAdd {
    pub fn from(buffer: &[u8]) -> PacketCzAuctionAdd {
        PacketCzAuctionAdd {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            now_money: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            now_money_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            max_money: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            max_money_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            delete_hour: i16::from_le_bytes([buffer[10], buffer[11]]),
            delete_hour_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.now_money).unwrap();
        self.now_money_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.max_money).unwrap();
        self.max_money_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.delete_hour).unwrap();
        self.delete_hour_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.now_money_raw.to_vec());
        wtr.append(&mut self.max_money_raw.to_vec());
        wtr.append(&mut self.delete_hour_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_now_money(&mut self, value: u32) {
        self.now_money = value;
    }
    pub fn set_now_money_raw(&mut self, value: [u8; 4]) {
        self.now_money_raw = value;
    }
    pub fn set_max_money(&mut self, value: u32) {
        self.max_money = value;
    }
    pub fn set_max_money_raw(&mut self, value: [u8; 4]) {
        self.max_money_raw = value;
    }
    pub fn set_delete_hour(&mut self, value: i16) {
        self.delete_hour = value;
    }
    pub fn set_delete_hour_raw(&mut self, value: [u8; 2]) {
        self.delete_hour_raw = value;
    }
    pub fn new() -> PacketCzAuctionAdd {
        PacketCzAuctionAdd {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x24, 0xd]),
        packet_id_raw: [0x24, 0xd],
        now_money: 0,
        now_money_raw: [0; 4],
        max_money: 0,
        max_money_raw: [0; 4],
        delete_hour: 0,
        delete_hour_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzAuctionAdd {
    fn id(&self) -> &str {
       "0x024d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzAuctionAddCancel {
    pub fn from(buffer: &[u8]) -> PacketCzAuctionAddCancel {
        PacketCzAuctionAddCancel {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            auction_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            auction_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.auction_id).unwrap();
        self.auction_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.auction_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_auction_id(&mut self, value: u32) {
        self.auction_id = value;
    }
    pub fn set_auction_id_raw(&mut self, value: [u8; 4]) {
        self.auction_id_raw = value;
    }
    pub fn new() -> PacketCzAuctionAddCancel {
        PacketCzAuctionAddCancel {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x24, 0xe]),
        packet_id_raw: [0x24, 0xe],
        auction_id: 0,
        auction_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzAuctionAddCancel {
    fn id(&self) -> &str {
       "0x024e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzAuctionBuy {
    pub fn from(buffer: &[u8]) -> PacketCzAuctionBuy {
        PacketCzAuctionBuy {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            auction_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            auction_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            money: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            money_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.auction_id).unwrap();
        self.auction_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.money).unwrap();
        self.money_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.auction_id_raw.to_vec());
        wtr.append(&mut self.money_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_auction_id(&mut self, value: u32) {
        self.auction_id = value;
    }
    pub fn set_auction_id_raw(&mut self, value: [u8; 4]) {
        self.auction_id_raw = value;
    }
    pub fn set_money(&mut self, value: u32) {
        self.money = value;
    }
    pub fn set_money_raw(&mut self, value: [u8; 4]) {
        self.money_raw = value;
    }
    pub fn new() -> PacketCzAuctionBuy {
        PacketCzAuctionBuy {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x24, 0xf]),
        packet_id_raw: [0x24, 0xf],
        auction_id: 0,
        auction_id_raw: [0; 4],
        money: 0,
        money_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzAuctionBuy {
    fn id(&self) -> &str {
       "0x024f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAuctionResult {
    pub fn from(buffer: &[u8]) -> PacketZcAuctionResult {
        PacketZcAuctionResult {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcAuctionResult {
        PacketZcAuctionResult {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x25, 0x0]),
        packet_id_raw: [0x25, 0x0],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAuctionResult {
    fn id(&self) -> &str {
       "0x0250"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzAuctionItemSearch {
    pub fn from(buffer: &[u8]) -> PacketCzAuctionItemSearch {
        PacketCzAuctionItemSearch {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            auction_id: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            auction_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[8..32].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[8..32]);
                dst
            },
            page: u16::from_le_bytes([buffer[32], buffer[33]]),
            page_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.auction_id).unwrap();
        self.auction_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.page).unwrap();
        self.page_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.auction_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.page_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn set_auction_id(&mut self, value: u32) {
        self.auction_id = value;
    }
    pub fn set_auction_id_raw(&mut self, value: [u8; 4]) {
        self.auction_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_page(&mut self, value: u16) {
        self.page = value;
    }
    pub fn set_page_raw(&mut self, value: [u8; 2]) {
        self.page_raw = value;
    }
    pub fn new() -> PacketCzAuctionItemSearch {
        PacketCzAuctionItemSearch {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x25, 0x1]),
        packet_id_raw: [0x25, 0x1],
        atype: 0,
        atype_raw: [0; 2],
        auction_id: 0,
        auction_id_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        page: 0,
        page_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzAuctionItemSearch {
    fn id(&self) -> &str {
       "0x0251"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAuctionItemReqSearch {
    pub fn from(buffer: &[u8]) -> PacketZcAuctionItemReqSearch {
        let iter_count = (&buffer.len() - 12) / 83;
        let mut vec_field: Vec<AuctionItemSearchInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 12 + (83 * (i - 1));
            let end_pos = 12 + 83 * i;
            vec_field.push(AuctionItemSearchInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcAuctionItemReqSearch {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            max_page: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            max_page_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            number: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            number_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            auction_item_list: vec_field.clone(),
            auction_item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_page).unwrap();
        self.max_page_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.number).unwrap();
        self.number_raw = wtr.try_into().unwrap();
        self.auction_item_list_raw = {
            self.auction_item_list.iter_mut().for_each(|item| item.fill_raw());
            self.auction_item_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.max_page_raw.to_vec());
        wtr.append(&mut self.number_raw.to_vec());
        self.auction_item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_max_page(&mut self, value: i32) {
        self.max_page = value;
    }
    pub fn set_max_page_raw(&mut self, value: [u8; 4]) {
        self.max_page_raw = value;
    }
    pub fn set_number(&mut self, value: i32) {
        self.number = value;
    }
    pub fn set_number_raw(&mut self, value: [u8; 4]) {
        self.number_raw = value;
    }
    pub fn set_auction_item_list(&mut self, value: Vec<AuctionItemSearchInfo>) {
        self.auction_item_list = value;
    }
    pub fn set_auction_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.auction_item_list_raw = value;
    }
    pub fn new() -> PacketZcAuctionItemReqSearch {
        PacketZcAuctionItemReqSearch {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x25, 0x2]),
        packet_id_raw: [0x25, 0x2],
        packet_length: 0,
        packet_length_raw: [0; 2],
        max_page: 0,
        max_page_raw: [0; 4],
        number: 0,
        number_raw: [0; 4],
        auction_item_list: vec![],
        auction_item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcAuctionItemReqSearch {
    fn id(&self) -> &str {
       "0x0252"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcStarplace {
    pub fn from(buffer: &[u8]) -> PacketZcStarplace {
        PacketZcStarplace {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            which: i8::from_le_bytes([buffer[2]]),
            which_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.which).unwrap();
        self.which_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.which_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_which(&mut self, value: i8) {
        self.which = value;
    }
    pub fn set_which_raw(&mut self, value: [u8; 1]) {
        self.which_raw = value;
    }
    pub fn new() -> PacketZcStarplace {
        PacketZcStarplace {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x25, 0x3]),
        packet_id_raw: [0x25, 0x3],
        which: 0,
        which_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcStarplace {
    fn id(&self) -> &str {
       "0x0253"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzAgreeStarplace {
    pub fn from(buffer: &[u8]) -> PacketCzAgreeStarplace {
        PacketCzAgreeStarplace {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            which: i8::from_le_bytes([buffer[2]]),
            which_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.which).unwrap();
        self.which_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.which_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_which(&mut self, value: i8) {
        self.which = value;
    }
    pub fn set_which_raw(&mut self, value: [u8; 1]) {
        self.which_raw = value;
    }
    pub fn new() -> PacketCzAgreeStarplace {
        PacketCzAgreeStarplace {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x25, 0x4]),
        packet_id_raw: [0x25, 0x4],
        which: 0,
        which_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzAgreeStarplace {
    fn id(&self) -> &str {
       "0x0254"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckMailAddItem {
    pub fn from(buffer: &[u8]) -> PacketZcAckMailAddItem {
        PacketZcAckMailAddItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            result: u8::from_le_bytes([buffer[4]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcAckMailAddItem {
        PacketZcAckMailAddItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x25, 0x5]),
        packet_id_raw: [0x25, 0x5],
        index: 0,
        index_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckMailAddItem {
    fn id(&self) -> &str {
       "0x0255"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckAuctionAddItem {
    pub fn from(buffer: &[u8]) -> PacketZcAckAuctionAddItem {
        PacketZcAckAuctionAddItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            result: u8::from_le_bytes([buffer[4]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcAckAuctionAddItem {
        PacketZcAckAuctionAddItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x25, 0x6]),
        packet_id_raw: [0x25, 0x6],
        index: 0,
        index_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckAuctionAddItem {
    fn id(&self) -> &str {
       "0x0256"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckMailDelete {
    pub fn from(buffer: &[u8]) -> PacketZcAckMailDelete {
        PacketZcAckMailDelete {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            mail_id: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            result: u16::from_le_bytes([buffer[6], buffer[7]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.mail_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_mail_id(&mut self, value: i32) {
        self.mail_id = value;
    }
    pub fn set_mail_id_raw(&mut self, value: [u8; 4]) {
        self.mail_id_raw = value;
    }
    pub fn set_result(&mut self, value: u16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcAckMailDelete {
        PacketZcAckMailDelete {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x25, 0x7]),
        packet_id_raw: [0x25, 0x7],
        mail_id: 0,
        mail_id_raw: [0; 4],
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAckMailDelete {
    fn id(&self) -> &str {
       "0x0257"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCaReqGameGuardCheck {
    pub fn from(buffer: &[u8]) -> PacketCaReqGameGuardCheck {
        PacketCaReqGameGuardCheck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCaReqGameGuardCheck {
        PacketCaReqGameGuardCheck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x25, 0x8]),
        packet_id_raw: [0x25, 0x8],
        }
    }
}

impl Packet for PacketCaReqGameGuardCheck {
    fn id(&self) -> &str {
       "0x0258"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcAckGameGuard {
    pub fn from(buffer: &[u8]) -> PacketAcAckGameGuard {
        PacketAcAckGameGuard {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            uc_answer: u8::from_le_bytes([buffer[2]]),
            uc_answer_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.uc_answer).unwrap();
        self.uc_answer_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.uc_answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_uc_answer(&mut self, value: u8) {
        self.uc_answer = value;
    }
    pub fn set_uc_answer_raw(&mut self, value: [u8; 1]) {
        self.uc_answer_raw = value;
    }
    pub fn new() -> PacketAcAckGameGuard {
        PacketAcAckGameGuard {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x25, 0x9]),
        packet_id_raw: [0x25, 0x9],
        uc_answer: 0,
        uc_answer_raw: [0; 1],
        }
    }
}

impl Packet for PacketAcAckGameGuard {
    fn id(&self) -> &str {
       "0x0259"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMakingitemList {
    pub fn from(buffer: &[u8]) -> PacketZcMakingitemList {
        PacketZcMakingitemList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            id_list:  {
                let dst: Vec<u8> = buffer[4..buffer.len()].to_vec();
                dst
            },
            id_list_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.id_list_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_id_list(&mut self, value: Vec<u8>) {
        self.id_list = value;
    }
    pub fn set_id_list_raw(&mut self, value: Vec<u8>) {
        self.id_list_raw = value;
    }
    pub fn new() -> PacketZcMakingitemList {
        PacketZcMakingitemList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x25, 0xa]),
        packet_id_raw: [0x25, 0xa],
        packet_length: 0,
        packet_length_raw: [0; 2],
        id_list: vec![],
        id_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcMakingitemList {
    fn id(&self) -> &str {
       "0x025a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqMakingitem {
    pub fn from(buffer: &[u8]) -> PacketCzReqMakingitem {
        PacketCzReqMakingitem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            mk_type: i16::from_le_bytes([buffer[2], buffer[3]]),
            mk_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            id: u16::from_le_bytes([buffer[4], buffer[5]]),
            id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mk_type).unwrap();
        self.mk_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.id).unwrap();
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.mk_type_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_mk_type(&mut self, value: i16) {
        self.mk_type = value;
    }
    pub fn set_mk_type_raw(&mut self, value: [u8; 2]) {
        self.mk_type_raw = value;
    }
    pub fn set_id(&mut self, value: u16) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 2]) {
        self.id_raw = value;
    }
    pub fn new() -> PacketCzReqMakingitem {
        PacketCzReqMakingitem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x25, 0xb]),
        packet_id_raw: [0x25, 0xb],
        mk_type: 0,
        mk_type_raw: [0; 2],
        id: 0,
        id_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqMakingitem {
    fn id(&self) -> &str {
       "0x025b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzAuctionReqMyInfo {
    pub fn from(buffer: &[u8]) -> PacketCzAuctionReqMyInfo {
        PacketCzAuctionReqMyInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketCzAuctionReqMyInfo {
        PacketCzAuctionReqMyInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x25, 0xc]),
        packet_id_raw: [0x25, 0xc],
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzAuctionReqMyInfo {
    fn id(&self) -> &str {
       "0x025c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzAuctionReqMySellStop {
    pub fn from(buffer: &[u8]) -> PacketCzAuctionReqMySellStop {
        PacketCzAuctionReqMySellStop {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            auction_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            auction_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.auction_id).unwrap();
        self.auction_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.auction_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_auction_id(&mut self, value: u32) {
        self.auction_id = value;
    }
    pub fn set_auction_id_raw(&mut self, value: [u8; 4]) {
        self.auction_id_raw = value;
    }
    pub fn new() -> PacketCzAuctionReqMySellStop {
        PacketCzAuctionReqMySellStop {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x25, 0xd]),
        packet_id_raw: [0x25, 0xd],
        auction_id: 0,
        auction_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzAuctionReqMySellStop {
    fn id(&self) -> &str {
       "0x025d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAuctionAckMySellStop {
    pub fn from(buffer: &[u8]) -> PacketZcAuctionAckMySellStop {
        PacketZcAuctionAckMySellStop {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcAuctionAckMySellStop {
        PacketZcAuctionAckMySellStop {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x25, 0xe]),
        packet_id_raw: [0x25, 0xe],
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAuctionAckMySellStop {
    fn id(&self) -> &str {
       "0x025e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAuctionWindows {
    pub fn from(buffer: &[u8]) -> PacketZcAuctionWindows {
        PacketZcAuctionWindows {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketZcAuctionWindows {
        PacketZcAuctionWindows {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x25, 0xf]),
        packet_id_raw: [0x25, 0xf],
        atype: 0,
        atype_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcAuctionWindows {
    fn id(&self) -> &str {
       "0x025f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMailWindows {
    pub fn from(buffer: &[u8]) -> PacketZcMailWindows {
        PacketZcMailWindows {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketZcMailWindows {
        PacketZcMailWindows {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x26, 0x0]),
        packet_id_raw: [0x26, 0x0],
        atype: 0,
        atype_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcMailWindows {
    fn id(&self) -> &str {
       "0x0260"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcReqLoginOldekey {
    pub fn from(buffer: &[u8]) -> PacketAcReqLoginOldekey {
        PacketAcReqLoginOldekey {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            m_seed_value:  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[2..11].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            m_seed_value_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[2..11]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_seed_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_seed_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.m_seed_value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_m_seed_value(&mut self, value: [char; 9]) {
        self.m_seed_value = value;
    }
    pub fn set_m_seed_value_raw(&mut self, value: [u8; 9]) {
        self.m_seed_value_raw = value;
    }
    pub fn new() -> PacketAcReqLoginOldekey {
        PacketAcReqLoginOldekey {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x26, 0x1]),
        packet_id_raw: [0x26, 0x1],
        m_seed_value: [0 as char; 9],
        m_seed_value_raw: [0; 9],
        }
    }
}

impl Packet for PacketAcReqLoginOldekey {
    fn id(&self) -> &str {
       "0x0261"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcReqLoginNewekey {
    pub fn from(buffer: &[u8]) -> PacketAcReqLoginNewekey {
        PacketAcReqLoginNewekey {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            m_seed_value:  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[2..11].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            m_seed_value_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[2..11]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_seed_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_seed_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.m_seed_value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_m_seed_value(&mut self, value: [char; 9]) {
        self.m_seed_value = value;
    }
    pub fn set_m_seed_value_raw(&mut self, value: [u8; 9]) {
        self.m_seed_value_raw = value;
    }
    pub fn new() -> PacketAcReqLoginNewekey {
        PacketAcReqLoginNewekey {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x26, 0x2]),
        packet_id_raw: [0x26, 0x2],
        m_seed_value: [0 as char; 9],
        m_seed_value_raw: [0; 9],
        }
    }
}

impl Packet for PacketAcReqLoginNewekey {
    fn id(&self) -> &str {
       "0x0262"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcReqLoginCardpass {
    pub fn from(buffer: &[u8]) -> PacketAcReqLoginCardpass {
        PacketAcReqLoginCardpass {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            m_seed_value:  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[2..11].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            m_seed_value_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[2..11]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_seed_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_seed_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.m_seed_value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_m_seed_value(&mut self, value: [char; 9]) {
        self.m_seed_value = value;
    }
    pub fn set_m_seed_value_raw(&mut self, value: [u8; 9]) {
        self.m_seed_value_raw = value;
    }
    pub fn new() -> PacketAcReqLoginCardpass {
        PacketAcReqLoginCardpass {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x26, 0x3]),
        packet_id_raw: [0x26, 0x3],
        m_seed_value: [0 as char; 9],
        m_seed_value_raw: [0; 9],
        }
    }
}

impl Packet for PacketAcReqLoginCardpass {
    fn id(&self) -> &str {
       "0x0263"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCaAckLoginOldekey {
    pub fn from(buffer: &[u8]) -> PacketCaAckLoginOldekey {
        PacketCaAckLoginOldekey {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            m_seed_value:  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[2..11].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            m_seed_value_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[2..11]);
                dst
            },
            m_ekey:  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[11..20].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            m_ekey_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[11..20]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_seed_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_seed_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_ekey {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_ekey_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.m_seed_value_raw.to_vec());
        wtr.append(&mut self.m_ekey_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_m_seed_value(&mut self, value: [char; 9]) {
        self.m_seed_value = value;
    }
    pub fn set_m_seed_value_raw(&mut self, value: [u8; 9]) {
        self.m_seed_value_raw = value;
    }
    pub fn set_m_ekey(&mut self, value: [char; 9]) {
        self.m_ekey = value;
    }
    pub fn set_m_ekey_raw(&mut self, value: [u8; 9]) {
        self.m_ekey_raw = value;
    }
    pub fn new() -> PacketCaAckLoginOldekey {
        PacketCaAckLoginOldekey {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x26, 0x4]),
        packet_id_raw: [0x26, 0x4],
        m_seed_value: [0 as char; 9],
        m_seed_value_raw: [0; 9],
        m_ekey: [0 as char; 9],
        m_ekey_raw: [0; 9],
        }
    }
}

impl Packet for PacketCaAckLoginOldekey {
    fn id(&self) -> &str {
       "0x0264"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCaAckLoginNewekey {
    pub fn from(buffer: &[u8]) -> PacketCaAckLoginNewekey {
        PacketCaAckLoginNewekey {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            m_seed_value:  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[2..11].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            m_seed_value_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[2..11]);
                dst
            },
            m_ekey:  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[11..20].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            m_ekey_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[11..20]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_seed_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_seed_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_ekey {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_ekey_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.m_seed_value_raw.to_vec());
        wtr.append(&mut self.m_ekey_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_m_seed_value(&mut self, value: [char; 9]) {
        self.m_seed_value = value;
    }
    pub fn set_m_seed_value_raw(&mut self, value: [u8; 9]) {
        self.m_seed_value_raw = value;
    }
    pub fn set_m_ekey(&mut self, value: [char; 9]) {
        self.m_ekey = value;
    }
    pub fn set_m_ekey_raw(&mut self, value: [u8; 9]) {
        self.m_ekey_raw = value;
    }
    pub fn new() -> PacketCaAckLoginNewekey {
        PacketCaAckLoginNewekey {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x26, 0x5]),
        packet_id_raw: [0x26, 0x5],
        m_seed_value: [0 as char; 9],
        m_seed_value_raw: [0; 9],
        m_ekey: [0 as char; 9],
        m_ekey_raw: [0; 9],
        }
    }
}

impl Packet for PacketCaAckLoginNewekey {
    fn id(&self) -> &str {
       "0x0265"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCaAckLoginCardpass {
    pub fn from(buffer: &[u8]) -> PacketCaAckLoginCardpass {
        PacketCaAckLoginCardpass {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            mcard_pass:  {
                let mut dst: [char; 28] = [0 as char; 28];
                for (index, byte) in buffer[2..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            mcard_pass_raw: {
                let mut dst: [u8; 28] = [0u8; 28];
                dst.clone_from_slice(&buffer[2..30]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mcard_pass {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mcard_pass_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.mcard_pass_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_mcard_pass(&mut self, value: [char; 28]) {
        self.mcard_pass = value;
    }
    pub fn set_mcard_pass_raw(&mut self, value: [u8; 28]) {
        self.mcard_pass_raw = value;
    }
    pub fn new() -> PacketCaAckLoginCardpass {
        PacketCaAckLoginCardpass {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x26, 0x6]),
        packet_id_raw: [0x26, 0x6],
        mcard_pass: [0 as char; 28],
        mcard_pass_raw: [0; 28],
        }
    }
}

impl Packet for PacketCaAckLoginCardpass {
    fn id(&self) -> &str {
       "0x0266"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcAckEkeyFailNotexist {
    pub fn from(buffer: &[u8]) -> PacketAcAckEkeyFailNotexist {
        PacketAcAckEkeyFailNotexist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: i16) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 2]) {
        self.error_code_raw = value;
    }
    pub fn new() -> PacketAcAckEkeyFailNotexist {
        PacketAcAckEkeyFailNotexist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x26, 0x7]),
        packet_id_raw: [0x26, 0x7],
        error_code: 0,
        error_code_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcAckEkeyFailNotexist {
    fn id(&self) -> &str {
       "0x0267"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcAckEkeyFailNotusesekey {
    pub fn from(buffer: &[u8]) -> PacketAcAckEkeyFailNotusesekey {
        PacketAcAckEkeyFailNotusesekey {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: i16) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 2]) {
        self.error_code_raw = value;
    }
    pub fn new() -> PacketAcAckEkeyFailNotusesekey {
        PacketAcAckEkeyFailNotusesekey {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x26, 0x8]),
        packet_id_raw: [0x26, 0x8],
        error_code: 0,
        error_code_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcAckEkeyFailNotusesekey {
    fn id(&self) -> &str {
       "0x0268"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcAckEkeyFailNotusedekey {
    pub fn from(buffer: &[u8]) -> PacketAcAckEkeyFailNotusedekey {
        PacketAcAckEkeyFailNotusedekey {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: i16) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 2]) {
        self.error_code_raw = value;
    }
    pub fn new() -> PacketAcAckEkeyFailNotusedekey {
        PacketAcAckEkeyFailNotusedekey {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x26, 0x9]),
        packet_id_raw: [0x26, 0x9],
        error_code: 0,
        error_code_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcAckEkeyFailNotusedekey {
    fn id(&self) -> &str {
       "0x0269"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcAckEkeyFailAuthrefuse {
    pub fn from(buffer: &[u8]) -> PacketAcAckEkeyFailAuthrefuse {
        PacketAcAckEkeyFailAuthrefuse {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: i16) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 2]) {
        self.error_code_raw = value;
    }
    pub fn new() -> PacketAcAckEkeyFailAuthrefuse {
        PacketAcAckEkeyFailAuthrefuse {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x26, 0xa]),
        packet_id_raw: [0x26, 0xa],
        error_code: 0,
        error_code_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcAckEkeyFailAuthrefuse {
    fn id(&self) -> &str {
       "0x026a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcAckEkeyFailInputekey {
    pub fn from(buffer: &[u8]) -> PacketAcAckEkeyFailInputekey {
        PacketAcAckEkeyFailInputekey {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: i16) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 2]) {
        self.error_code_raw = value;
    }
    pub fn new() -> PacketAcAckEkeyFailInputekey {
        PacketAcAckEkeyFailInputekey {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x26, 0xb]),
        packet_id_raw: [0x26, 0xb],
        error_code: 0,
        error_code_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcAckEkeyFailInputekey {
    fn id(&self) -> &str {
       "0x026b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcAckEkeyFailNotice {
    pub fn from(buffer: &[u8]) -> PacketAcAckEkeyFailNotice {
        PacketAcAckEkeyFailNotice {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: i16) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 2]) {
        self.error_code_raw = value;
    }
    pub fn new() -> PacketAcAckEkeyFailNotice {
        PacketAcAckEkeyFailNotice {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x26, 0xc]),
        packet_id_raw: [0x26, 0xc],
        error_code: 0,
        error_code_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcAckEkeyFailNotice {
    fn id(&self) -> &str {
       "0x026c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcAckEkeyFailNeedcardpass {
    pub fn from(buffer: &[u8]) -> PacketAcAckEkeyFailNeedcardpass {
        PacketAcAckEkeyFailNeedcardpass {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: i16) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 2]) {
        self.error_code_raw = value;
    }
    pub fn new() -> PacketAcAckEkeyFailNeedcardpass {
        PacketAcAckEkeyFailNeedcardpass {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x26, 0xd]),
        packet_id_raw: [0x26, 0xd],
        error_code: 0,
        error_code_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcAckEkeyFailNeedcardpass {
    fn id(&self) -> &str {
       "0x026d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcAckAuthekeyFailNotmatchcardpass {
    pub fn from(buffer: &[u8]) -> PacketAcAckAuthekeyFailNotmatchcardpass {
        PacketAcAckAuthekeyFailNotmatchcardpass {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: i16) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 2]) {
        self.error_code_raw = value;
    }
    pub fn new() -> PacketAcAckAuthekeyFailNotmatchcardpass {
        PacketAcAckAuthekeyFailNotmatchcardpass {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x26, 0xe]),
        packet_id_raw: [0x26, 0xe],
        error_code: 0,
        error_code_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcAckAuthekeyFailNotmatchcardpass {
    fn id(&self) -> &str {
       "0x026e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcAckFirstLogin {
    pub fn from(buffer: &[u8]) -> PacketAcAckFirstLogin {
        PacketAcAckFirstLogin {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketAcAckFirstLogin {
        PacketAcAckFirstLogin {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x26, 0xf]),
        packet_id_raw: [0x26, 0xf],
        }
    }
}

impl Packet for PacketAcAckFirstLogin {
    fn id(&self) -> &str {
       "0x026f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcReqLoginAccountInfo {
    pub fn from(buffer: &[u8]) -> PacketAcReqLoginAccountInfo {
        PacketAcReqLoginAccountInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketAcReqLoginAccountInfo {
        PacketAcReqLoginAccountInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x27, 0x0]),
        packet_id_raw: [0x27, 0x0],
        }
    }
}

impl Packet for PacketAcReqLoginAccountInfo {
    fn id(&self) -> &str {
       "0x0270"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCaAckLoginAccountInfo {
    pub fn from(buffer: &[u8]) -> PacketCaAckLoginAccountInfo {
        PacketCaAckLoginAccountInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            sex: i16::from_le_bytes([buffer[2], buffer[3]]),
            sex_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            b_point: i16::from_le_bytes([buffer[4], buffer[5]]),
            b_point_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            email:  {
                let mut dst: [char; 34] = [0 as char; 34];
                for (index, byte) in buffer[6..40].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            email_raw: {
                let mut dst: [u8; 34] = [0u8; 34];
                dst.clone_from_slice(&buffer[6..40]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.b_point).unwrap();
        self.b_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.email {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.email_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.b_point_raw.to_vec());
        wtr.append(&mut self.email_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_sex(&mut self, value: i16) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 2]) {
        self.sex_raw = value;
    }
    pub fn set_b_point(&mut self, value: i16) {
        self.b_point = value;
    }
    pub fn set_b_point_raw(&mut self, value: [u8; 2]) {
        self.b_point_raw = value;
    }
    pub fn set_email(&mut self, value: [char; 34]) {
        self.email = value;
    }
    pub fn set_email_raw(&mut self, value: [u8; 34]) {
        self.email_raw = value;
    }
    pub fn new() -> PacketCaAckLoginAccountInfo {
        PacketCaAckLoginAccountInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x27, 0x1]),
        packet_id_raw: [0x27, 0x1],
        sex: 0,
        sex_raw: [0; 2],
        b_point: 0,
        b_point_raw: [0; 2],
        email: [0 as char; 34],
        email_raw: [0; 34],
        }
    }
}

impl Packet for PacketCaAckLoginAccountInfo {
    fn id(&self) -> &str {
       "0x0271"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcAckPtIdInfo {
    pub fn from(buffer: &[u8]) -> PacketAcAckPtIdInfo {
        PacketAcAckPtIdInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            sz_ptid:  {
                let mut dst: [char; 21] = [0 as char; 21];
                for (index, byte) in buffer[2..23].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            sz_ptid_raw: {
                let mut dst: [u8; 21] = [0u8; 21];
                dst.clone_from_slice(&buffer[2..23]);
                dst
            },
            sz_ptnum_id:  {
                let mut dst: [char; 21] = [0 as char; 21];
                for (index, byte) in buffer[23..44].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            sz_ptnum_id_raw: {
                let mut dst: [u8; 21] = [0u8; 21];
                dst.clone_from_slice(&buffer[23..44]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_ptid {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_ptid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_ptnum_id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_ptnum_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.sz_ptid_raw.to_vec());
        wtr.append(&mut self.sz_ptnum_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_sz_ptid(&mut self, value: [char; 21]) {
        self.sz_ptid = value;
    }
    pub fn set_sz_ptid_raw(&mut self, value: [u8; 21]) {
        self.sz_ptid_raw = value;
    }
    pub fn set_sz_ptnum_id(&mut self, value: [char; 21]) {
        self.sz_ptnum_id = value;
    }
    pub fn set_sz_ptnum_id_raw(&mut self, value: [u8; 21]) {
        self.sz_ptnum_id_raw = value;
    }
    pub fn new() -> PacketAcAckPtIdInfo {
        PacketAcAckPtIdInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x27, 0x2]),
        packet_id_raw: [0x27, 0x2],
        sz_ptid: [0 as char; 21],
        sz_ptid_raw: [0; 21],
        sz_ptnum_id: [0 as char; 21],
        sz_ptnum_id_raw: [0; 21],
        }
    }
}

impl Packet for PacketAcAckPtIdInfo {
    fn id(&self) -> &str {
       "0x0272"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqMailReturn {
    pub fn from(buffer: &[u8]) -> PacketCzReqMailReturn {
        PacketCzReqMailReturn {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            mail_id: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            receive_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            receive_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.receive_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.receive_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.mail_id_raw.to_vec());
        wtr.append(&mut self.receive_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_mail_id(&mut self, value: i32) {
        self.mail_id = value;
    }
    pub fn set_mail_id_raw(&mut self, value: [u8; 4]) {
        self.mail_id_raw = value;
    }
    pub fn set_receive_name(&mut self, value: [char; 24]) {
        self.receive_name = value;
    }
    pub fn set_receive_name_raw(&mut self, value: [u8; 24]) {
        self.receive_name_raw = value;
    }
    pub fn new() -> PacketCzReqMailReturn {
        PacketCzReqMailReturn {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x27, 0x3]),
        packet_id_raw: [0x27, 0x3],
        mail_id: 0,
        mail_id_raw: [0; 4],
        receive_name: [0 as char; 24],
        receive_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzReqMailReturn {
    fn id(&self) -> &str {
       "0x0273"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckMailReturn {
    pub fn from(buffer: &[u8]) -> PacketZcAckMailReturn {
        PacketZcAckMailReturn {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            mail_id: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            result: i16::from_le_bytes([buffer[6], buffer[7]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.mail_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_mail_id(&mut self, value: i32) {
        self.mail_id = value;
    }
    pub fn set_mail_id_raw(&mut self, value: [u8; 4]) {
        self.mail_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcAckMailReturn {
        PacketZcAckMailReturn {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x27, 0x4]),
        packet_id_raw: [0x27, 0x4],
        mail_id: 0,
        mail_id_raw: [0; 4],
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAckMailReturn {
    fn id(&self) -> &str {
       "0x0274"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketChEnter2 {
    pub fn from(buffer: &[u8]) -> PacketChEnter2 {
        PacketChEnter2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            auth_code: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            user_level: u32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            user_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            client_type: u16::from_le_bytes([buffer[14], buffer[15]]),
            client_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            sex: u8::from_le_bytes([buffer[16]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[16..17]);
                dst
            },
            mac_data:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[17..33].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            mac_data_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[17..33]);
                dst
            },
            i_account_sid: i32::from_le_bytes([buffer[33], buffer[34], buffer[35], buffer[36]]),
            i_account_sid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[33..37]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.user_level).unwrap();
        self.user_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.client_type).unwrap();
        self.client_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mac_data {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mac_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.i_account_sid).unwrap();
        self.i_account_sid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.auth_code_raw.to_vec());
        wtr.append(&mut self.user_level_raw.to_vec());
        wtr.append(&mut self.client_type_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.mac_data_raw.to_vec());
        wtr.append(&mut self.i_account_sid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_auth_code(&mut self, value: i32) {
        self.auth_code = value;
    }
    pub fn set_auth_code_raw(&mut self, value: [u8; 4]) {
        self.auth_code_raw = value;
    }
    pub fn set_user_level(&mut self, value: u32) {
        self.user_level = value;
    }
    pub fn set_user_level_raw(&mut self, value: [u8; 4]) {
        self.user_level_raw = value;
    }
    pub fn set_client_type(&mut self, value: u16) {
        self.client_type = value;
    }
    pub fn set_client_type_raw(&mut self, value: [u8; 2]) {
        self.client_type_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_mac_data(&mut self, value: [char; 16]) {
        self.mac_data = value;
    }
    pub fn set_mac_data_raw(&mut self, value: [u8; 16]) {
        self.mac_data_raw = value;
    }
    pub fn set_i_account_sid(&mut self, value: i32) {
        self.i_account_sid = value;
    }
    pub fn set_i_account_sid_raw(&mut self, value: [u8; 4]) {
        self.i_account_sid_raw = value;
    }
    pub fn new() -> PacketChEnter2 {
        PacketChEnter2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x27, 0x5]),
        packet_id_raw: [0x27, 0x5],
        aid: 0,
        aid_raw: [0; 4],
        auth_code: 0,
        auth_code_raw: [0; 4],
        user_level: 0,
        user_level_raw: [0; 4],
        client_type: 0,
        client_type_raw: [0; 2],
        sex: 0,
        sex_raw: [0; 1],
        mac_data: [0 as char; 16],
        mac_data_raw: [0; 16],
        i_account_sid: 0,
        i_account_sid_raw: [0; 4],
        }
    }
}

impl Packet for PacketChEnter2 {
    fn id(&self) -> &str {
       "0x0275"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCaAcceptLogin2 {
    pub fn from(buffer: &[u8]) -> PacketCaAcceptLogin2 {
        PacketCaAcceptLogin2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            auth_code: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            aid: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            user_level: u32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            user_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            last_login_ip: u32::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19]]),
            last_login_ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[16..20]);
                dst
            },
            last_login_time:  {
                let mut dst: [char; 26] = [0 as char; 26];
                for (index, byte) in buffer[20..46].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            last_login_time_raw: {
                let mut dst: [u8; 26] = [0u8; 26];
                dst.clone_from_slice(&buffer[20..46]);
                dst
            },
            sex: u8::from_le_bytes([buffer[46]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[46..47]);
                dst
            },
            i_account_sid: i32::from_le_bytes([buffer[47], buffer[48], buffer[49], buffer[50]]),
            i_account_sid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[47..51]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.user_level).unwrap();
        self.user_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.last_login_ip).unwrap();
        self.last_login_ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.last_login_time {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.last_login_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.i_account_sid).unwrap();
        self.i_account_sid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.auth_code_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.user_level_raw.to_vec());
        wtr.append(&mut self.last_login_ip_raw.to_vec());
        wtr.append(&mut self.last_login_time_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.i_account_sid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_auth_code(&mut self, value: i32) {
        self.auth_code = value;
    }
    pub fn set_auth_code_raw(&mut self, value: [u8; 4]) {
        self.auth_code_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_user_level(&mut self, value: u32) {
        self.user_level = value;
    }
    pub fn set_user_level_raw(&mut self, value: [u8; 4]) {
        self.user_level_raw = value;
    }
    pub fn set_last_login_ip(&mut self, value: u32) {
        self.last_login_ip = value;
    }
    pub fn set_last_login_ip_raw(&mut self, value: [u8; 4]) {
        self.last_login_ip_raw = value;
    }
    pub fn set_last_login_time(&mut self, value: [char; 26]) {
        self.last_login_time = value;
    }
    pub fn set_last_login_time_raw(&mut self, value: [u8; 26]) {
        self.last_login_time_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_i_account_sid(&mut self, value: i32) {
        self.i_account_sid = value;
    }
    pub fn set_i_account_sid_raw(&mut self, value: [u8; 4]) {
        self.i_account_sid_raw = value;
    }
    pub fn new() -> PacketCaAcceptLogin2 {
        PacketCaAcceptLogin2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x27, 0x6]),
        packet_id_raw: [0x27, 0x6],
        packet_length: 0,
        packet_length_raw: [0; 2],
        auth_code: 0,
        auth_code_raw: [0; 4],
        aid: 0,
        aid_raw: [0; 4],
        user_level: 0,
        user_level_raw: [0; 4],
        last_login_ip: 0,
        last_login_ip_raw: [0; 4],
        last_login_time: [0 as char; 26],
        last_login_time_raw: [0; 26],
        sex: 0,
        sex_raw: [0; 1],
        i_account_sid: 0,
        i_account_sid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCaAcceptLogin2 {
    fn id(&self) -> &str {
       "0x0276"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCaLoginPcbang {
    pub fn from(buffer: &[u8]) -> PacketCaLoginPcbang {
        PacketCaLoginPcbang {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            version: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            id:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            passwd:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[30..54].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[30..54]);
                dst
            },
            clienttype: u8::from_le_bytes([buffer[54]]),
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[54..55]);
                dst
            },
            ip:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[55..71].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            ip_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[55..71]);
                dst
            },
            mac_adress:  {
                let mut dst: [char; 13] = [0 as char; 13];
                for (index, byte) in buffer[71..84].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            mac_adress_raw: {
                let mut dst: [u8; 13] = [0u8; 13];
                dst.clone_from_slice(&buffer[71..84]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.ip {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mac_adress {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mac_adress_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.version_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.passwd_raw.to_vec());
        wtr.append(&mut self.clienttype_raw.to_vec());
        wtr.append(&mut self.ip_raw.to_vec());
        wtr.append(&mut self.mac_adress_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_version(&mut self, value: u32) {
        self.version = value;
    }
    pub fn set_version_raw(&mut self, value: [u8; 4]) {
        self.version_raw = value;
    }
    pub fn set_id(&mut self, value: [char; 24]) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 24]) {
        self.id_raw = value;
    }
    pub fn set_passwd(&mut self, value: [char; 24]) {
        self.passwd = value;
    }
    pub fn set_passwd_raw(&mut self, value: [u8; 24]) {
        self.passwd_raw = value;
    }
    pub fn set_clienttype(&mut self, value: u8) {
        self.clienttype = value;
    }
    pub fn set_clienttype_raw(&mut self, value: [u8; 1]) {
        self.clienttype_raw = value;
    }
    pub fn set_ip(&mut self, value: [char; 16]) {
        self.ip = value;
    }
    pub fn set_ip_raw(&mut self, value: [u8; 16]) {
        self.ip_raw = value;
    }
    pub fn set_mac_adress(&mut self, value: [char; 13]) {
        self.mac_adress = value;
    }
    pub fn set_mac_adress_raw(&mut self, value: [u8; 13]) {
        self.mac_adress_raw = value;
    }
    pub fn new() -> PacketCaLoginPcbang {
        PacketCaLoginPcbang {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x27, 0x7]),
        packet_id_raw: [0x27, 0x7],
        version: 0,
        version_raw: [0; 4],
        id: [0 as char; 24],
        id_raw: [0; 24],
        passwd: [0 as char; 24],
        passwd_raw: [0; 24],
        clienttype: 0,
        clienttype_raw: [0; 1],
        ip: [0 as char; 16],
        ip_raw: [0; 16],
        mac_adress: [0 as char; 13],
        mac_adress_raw: [0; 13],
        }
    }
}

impl Packet for PacketCaLoginPcbang {
    fn id(&self) -> &str {
       "0x0277"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyPcbang {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyPcbang {
        PacketZcNotifyPcbang {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketZcNotifyPcbang {
        PacketZcNotifyPcbang {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x27, 0x8]),
        packet_id_raw: [0x27, 0x8],
        }
    }
}

impl Packet for PacketZcNotifyPcbang {
    fn id(&self) -> &str {
       "0x0278"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzHuntinglist {
    pub fn from(buffer: &[u8]) -> PacketCzHuntinglist {
        PacketCzHuntinglist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzHuntinglist {
        PacketCzHuntinglist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x27, 0x9]),
        packet_id_raw: [0x27, 0x9],
        }
    }
}

impl Packet for PacketCzHuntinglist {
    fn id(&self) -> &str {
       "0x0279"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcHuntinglist {
    pub fn from(buffer: &[u8]) -> PacketZcHuntinglist {
        let iter_count = (&buffer.len() - 4) / 12;
        let mut vec_field: Vec<PacketMobHunting> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (12 * (i - 1));
            let end_pos = 4 + 12 * i;
            vec_field.push(PacketMobHunting::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcHuntinglist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            hunting_list: vec_field.clone(),
            hunting_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.hunting_list_raw = {
            self.hunting_list.iter_mut().for_each(|item| item.fill_raw());
            self.hunting_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.hunting_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_hunting_list(&mut self, value: Vec<PacketMobHunting>) {
        self.hunting_list = value;
    }
    pub fn set_hunting_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.hunting_list_raw = value;
    }
    pub fn new() -> PacketZcHuntinglist {
        PacketZcHuntinglist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x27, 0xa]),
        packet_id_raw: [0x27, 0xa],
        packet_length: 0,
        packet_length_raw: [0; 2],
        hunting_list: vec![],
        hunting_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcHuntinglist {
    fn id(&self) -> &str {
       "0x027a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPcbangEffect {
    pub fn from(buffer: &[u8]) -> PacketZcPcbangEffect {
        PacketZcPcbangEffect {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            exp_factor: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            exp_factor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            exp_factor2: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            exp_factor2_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            drop_factor: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            drop_factor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.exp_factor).unwrap();
        self.exp_factor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.exp_factor2).unwrap();
        self.exp_factor2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.drop_factor).unwrap();
        self.drop_factor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.exp_factor_raw.to_vec());
        wtr.append(&mut self.exp_factor2_raw.to_vec());
        wtr.append(&mut self.drop_factor_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_exp_factor(&mut self, value: i32) {
        self.exp_factor = value;
    }
    pub fn set_exp_factor_raw(&mut self, value: [u8; 4]) {
        self.exp_factor_raw = value;
    }
    pub fn set_exp_factor2(&mut self, value: i32) {
        self.exp_factor2 = value;
    }
    pub fn set_exp_factor2_raw(&mut self, value: [u8; 4]) {
        self.exp_factor2_raw = value;
    }
    pub fn set_drop_factor(&mut self, value: i32) {
        self.drop_factor = value;
    }
    pub fn set_drop_factor_raw(&mut self, value: [u8; 4]) {
        self.drop_factor_raw = value;
    }
    pub fn new() -> PacketZcPcbangEffect {
        PacketZcPcbangEffect {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x27, 0xb]),
        packet_id_raw: [0x27, 0xb],
        exp_factor: 0,
        exp_factor_raw: [0; 4],
        exp_factor2: 0,
        exp_factor2_raw: [0; 4],
        drop_factor: 0,
        drop_factor_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcPcbangEffect {
    fn id(&self) -> &str {
       "0x027b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCaLogin4 {
    pub fn from(buffer: &[u8]) -> PacketCaLogin4 {
        PacketCaLogin4 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            version: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            id:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            passwd_md5:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[30..46].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_md5_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[30..46]);
                dst
            },
            clienttype: u8::from_le_bytes([buffer[46]]),
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[46..47]);
                dst
            },
            mac_data:  {
                let mut dst: [char; 13] = [0 as char; 13];
                for (index, byte) in buffer[47..60].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            mac_data_raw: {
                let mut dst: [u8; 13] = [0u8; 13];
                dst.clone_from_slice(&buffer[47..60]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd_md5 {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_md5_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mac_data {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mac_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.version_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.passwd_md5_raw.to_vec());
        wtr.append(&mut self.clienttype_raw.to_vec());
        wtr.append(&mut self.mac_data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_version(&mut self, value: u32) {
        self.version = value;
    }
    pub fn set_version_raw(&mut self, value: [u8; 4]) {
        self.version_raw = value;
    }
    pub fn set_id(&mut self, value: [char; 24]) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 24]) {
        self.id_raw = value;
    }
    pub fn set_passwd_md5(&mut self, value: [char; 16]) {
        self.passwd_md5 = value;
    }
    pub fn set_passwd_md5_raw(&mut self, value: [u8; 16]) {
        self.passwd_md5_raw = value;
    }
    pub fn set_clienttype(&mut self, value: u8) {
        self.clienttype = value;
    }
    pub fn set_clienttype_raw(&mut self, value: [u8; 1]) {
        self.clienttype_raw = value;
    }
    pub fn set_mac_data(&mut self, value: [char; 13]) {
        self.mac_data = value;
    }
    pub fn set_mac_data_raw(&mut self, value: [u8; 13]) {
        self.mac_data_raw = value;
    }
    pub fn new() -> PacketCaLogin4 {
        PacketCaLogin4 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x27, 0xc]),
        packet_id_raw: [0x27, 0xc],
        version: 0,
        version_raw: [0; 4],
        id: [0 as char; 24],
        id_raw: [0; 24],
        passwd_md5: [0 as char; 16],
        passwd_md5_raw: [0; 16],
        clienttype: 0,
        clienttype_raw: [0; 1],
        mac_data: [0 as char; 13],
        mac_data_raw: [0; 13],
        }
    }
}

impl Packet for PacketCaLogin4 {
    fn id(&self) -> &str {
       "0x027c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPropertyMerce {
    pub fn from(buffer: &[u8]) -> PacketZcPropertyMerce {
        PacketZcPropertyMerce {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            level: i16::from_le_bytes([buffer[26], buffer[27]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            faith: i16::from_le_bytes([buffer[28], buffer[29]]),
            faith_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            summon_count: i16::from_le_bytes([buffer[30], buffer[31]]),
            summon_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            atk: i16::from_le_bytes([buffer[32], buffer[33]]),
            atk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            matk: i16::from_le_bytes([buffer[34], buffer[35]]),
            matk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            hit: i16::from_le_bytes([buffer[36], buffer[37]]),
            hit_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[36..38]);
                dst
            },
            critical: i16::from_le_bytes([buffer[38], buffer[39]]),
            critical_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[38..40]);
                dst
            },
            def: i16::from_le_bytes([buffer[40], buffer[41]]),
            def_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            mdef: i16::from_le_bytes([buffer[42], buffer[43]]),
            mdef_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            flee: i16::from_le_bytes([buffer[44], buffer[45]]),
            flee_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[44..46]);
                dst
            },
            aspd: i16::from_le_bytes([buffer[46], buffer[47]]),
            aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[46..48]);
                dst
            },
            hp: i16::from_le_bytes([buffer[48], buffer[49]]),
            hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[48..50]);
                dst
            },
            max_hp: i16::from_le_bytes([buffer[50], buffer[51]]),
            max_hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[50..52]);
                dst
            },
            sp: i16::from_le_bytes([buffer[52], buffer[53]]),
            sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[52..54]);
                dst
            },
            max_sp: i16::from_le_bytes([buffer[54], buffer[55]]),
            max_sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[54..56]);
                dst
            },
            atkrange: i16::from_le_bytes([buffer[56], buffer[57]]),
            atkrange_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[56..58]);
                dst
            },
            exp: i32::from_le_bytes([buffer[58], buffer[59], buffer[60], buffer[61]]),
            exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[58..62]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.faith).unwrap();
        self.faith_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.summon_count).unwrap();
        self.summon_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atk).unwrap();
        self.atk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.matk).unwrap();
        self.matk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hit).unwrap();
        self.hit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.critical).unwrap();
        self.critical_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.def).unwrap();
        self.def_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef).unwrap();
        self.mdef_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.flee).unwrap();
        self.flee_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.aspd).unwrap();
        self.aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sp).unwrap();
        self.sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_sp).unwrap();
        self.max_sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atkrange).unwrap();
        self.atkrange_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.exp).unwrap();
        self.exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.faith_raw.to_vec());
        wtr.append(&mut self.summon_count_raw.to_vec());
        wtr.append(&mut self.atk_raw.to_vec());
        wtr.append(&mut self.matk_raw.to_vec());
        wtr.append(&mut self.hit_raw.to_vec());
        wtr.append(&mut self.critical_raw.to_vec());
        wtr.append(&mut self.def_raw.to_vec());
        wtr.append(&mut self.mdef_raw.to_vec());
        wtr.append(&mut self.flee_raw.to_vec());
        wtr.append(&mut self.aspd_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.max_hp_raw.to_vec());
        wtr.append(&mut self.sp_raw.to_vec());
        wtr.append(&mut self.max_sp_raw.to_vec());
        wtr.append(&mut self.atkrange_raw.to_vec());
        wtr.append(&mut self.exp_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_faith(&mut self, value: i16) {
        self.faith = value;
    }
    pub fn set_faith_raw(&mut self, value: [u8; 2]) {
        self.faith_raw = value;
    }
    pub fn set_summon_count(&mut self, value: i16) {
        self.summon_count = value;
    }
    pub fn set_summon_count_raw(&mut self, value: [u8; 2]) {
        self.summon_count_raw = value;
    }
    pub fn set_atk(&mut self, value: i16) {
        self.atk = value;
    }
    pub fn set_atk_raw(&mut self, value: [u8; 2]) {
        self.atk_raw = value;
    }
    pub fn set_matk(&mut self, value: i16) {
        self.matk = value;
    }
    pub fn set_matk_raw(&mut self, value: [u8; 2]) {
        self.matk_raw = value;
    }
    pub fn set_hit(&mut self, value: i16) {
        self.hit = value;
    }
    pub fn set_hit_raw(&mut self, value: [u8; 2]) {
        self.hit_raw = value;
    }
    pub fn set_critical(&mut self, value: i16) {
        self.critical = value;
    }
    pub fn set_critical_raw(&mut self, value: [u8; 2]) {
        self.critical_raw = value;
    }
    pub fn set_def(&mut self, value: i16) {
        self.def = value;
    }
    pub fn set_def_raw(&mut self, value: [u8; 2]) {
        self.def_raw = value;
    }
    pub fn set_mdef(&mut self, value: i16) {
        self.mdef = value;
    }
    pub fn set_mdef_raw(&mut self, value: [u8; 2]) {
        self.mdef_raw = value;
    }
    pub fn set_flee(&mut self, value: i16) {
        self.flee = value;
    }
    pub fn set_flee_raw(&mut self, value: [u8; 2]) {
        self.flee_raw = value;
    }
    pub fn set_aspd(&mut self, value: i16) {
        self.aspd = value;
    }
    pub fn set_aspd_raw(&mut self, value: [u8; 2]) {
        self.aspd_raw = value;
    }
    pub fn set_hp(&mut self, value: i16) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 2]) {
        self.hp_raw = value;
    }
    pub fn set_max_hp(&mut self, value: i16) {
        self.max_hp = value;
    }
    pub fn set_max_hp_raw(&mut self, value: [u8; 2]) {
        self.max_hp_raw = value;
    }
    pub fn set_sp(&mut self, value: i16) {
        self.sp = value;
    }
    pub fn set_sp_raw(&mut self, value: [u8; 2]) {
        self.sp_raw = value;
    }
    pub fn set_max_sp(&mut self, value: i16) {
        self.max_sp = value;
    }
    pub fn set_max_sp_raw(&mut self, value: [u8; 2]) {
        self.max_sp_raw = value;
    }
    pub fn set_atkrange(&mut self, value: i16) {
        self.atkrange = value;
    }
    pub fn set_atkrange_raw(&mut self, value: [u8; 2]) {
        self.atkrange_raw = value;
    }
    pub fn set_exp(&mut self, value: i32) {
        self.exp = value;
    }
    pub fn set_exp_raw(&mut self, value: [u8; 4]) {
        self.exp_raw = value;
    }
    pub fn new() -> PacketZcPropertyMerce {
        PacketZcPropertyMerce {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x27, 0xd]),
        packet_id_raw: [0x27, 0xd],
        name: [0 as char; 24],
        name_raw: [0; 24],
        level: 0,
        level_raw: [0; 2],
        faith: 0,
        faith_raw: [0; 2],
        summon_count: 0,
        summon_count_raw: [0; 2],
        atk: 0,
        atk_raw: [0; 2],
        matk: 0,
        matk_raw: [0; 2],
        hit: 0,
        hit_raw: [0; 2],
        critical: 0,
        critical_raw: [0; 2],
        def: 0,
        def_raw: [0; 2],
        mdef: 0,
        mdef_raw: [0; 2],
        flee: 0,
        flee_raw: [0; 2],
        aspd: 0,
        aspd_raw: [0; 2],
        hp: 0,
        hp_raw: [0; 2],
        max_hp: 0,
        max_hp_raw: [0; 2],
        sp: 0,
        sp_raw: [0; 2],
        max_sp: 0,
        max_sp_raw: [0; 2],
        atkrange: 0,
        atkrange_raw: [0; 2],
        exp: 0,
        exp_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcPropertyMerce {
    fn id(&self) -> &str {
       "0x027d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcShandaProtect {
    pub fn from(buffer: &[u8]) -> PacketZcShandaProtect {
        PacketZcShandaProtect {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            code_len: i16::from_le_bytes([buffer[4], buffer[5]]),
            code_len_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            code: String::from_utf8_lossy(&buffer[6..buffer.len()]).to_string(),
            code_raw: buffer[6..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.code_len).unwrap();
        self.code_len_raw = wtr.try_into().unwrap();
        self.code_raw = self.code.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.code_len_raw.to_vec());
        wtr.append(&mut self.code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_code_len(&mut self, value: i16) {
        self.code_len = value;
    }
    pub fn set_code_len_raw(&mut self, value: [u8; 2]) {
        self.code_len_raw = value;
    }
    pub fn set_code(&mut self, value: String) {
        self.code = value;
    }
    pub fn set_code_raw(&mut self, value: Vec<u8>) {
        self.code_raw = value;
    }
    pub fn new() -> PacketZcShandaProtect {
        PacketZcShandaProtect {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x27, 0xe]),
        packet_id_raw: [0x27, 0xe],
        packet_length: 0,
        packet_length_raw: [0; 2],
        code_len: 0,
        code_len_raw: [0; 2],
        code: String::new(),
        code_raw: vec![],
        }
    }
}

impl Packet for PacketZcShandaProtect {
    fn id(&self) -> &str {
       "0x027e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCaClientType {
    pub fn from(buffer: &[u8]) -> PacketCaClientType {
        PacketCaClientType {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            client_type: i16::from_le_bytes([buffer[2], buffer[3]]),
            client_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            n_ver: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            n_ver_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.client_type).unwrap();
        self.client_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.n_ver).unwrap();
        self.n_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.client_type_raw.to_vec());
        wtr.append(&mut self.n_ver_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_client_type(&mut self, value: i16) {
        self.client_type = value;
    }
    pub fn set_client_type_raw(&mut self, value: [u8; 2]) {
        self.client_type_raw = value;
    }
    pub fn set_n_ver(&mut self, value: i32) {
        self.n_ver = value;
    }
    pub fn set_n_ver_raw(&mut self, value: [u8; 4]) {
        self.n_ver_raw = value;
    }
    pub fn new() -> PacketCaClientType {
        PacketCaClientType {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x27, 0xf]),
        packet_id_raw: [0x27, 0xf],
        client_type: 0,
        client_type_raw: [0; 2],
        n_ver: 0,
        n_ver_raw: [0; 4],
        }
    }
}

impl Packet for PacketCaClientType {
    fn id(&self) -> &str {
       "0x027f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcGangsiPoint {
    pub fn from(buffer: &[u8]) -> PacketZcGangsiPoint {
        PacketZcGangsiPoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            point: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            total_point: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            total_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            packet_switch: i16::from_le_bytes([buffer[10], buffer[11]]),
            packet_switch_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.total_point).unwrap();
        self.total_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_switch).unwrap();
        self.packet_switch_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        wtr.append(&mut self.total_point_raw.to_vec());
        wtr.append(&mut self.packet_switch_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_point(&mut self, value: i32) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 4]) {
        self.point_raw = value;
    }
    pub fn set_total_point(&mut self, value: i32) {
        self.total_point = value;
    }
    pub fn set_total_point_raw(&mut self, value: [u8; 4]) {
        self.total_point_raw = value;
    }
    pub fn set_packet_switch(&mut self, value: i16) {
        self.packet_switch = value;
    }
    pub fn set_packet_switch_raw(&mut self, value: [u8; 2]) {
        self.packet_switch_raw = value;
    }
    pub fn new() -> PacketZcGangsiPoint {
        PacketZcGangsiPoint {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x28, 0x0]),
        packet_id_raw: [0x28, 0x0],
        point: 0,
        point_raw: [0; 4],
        total_point: 0,
        total_point_raw: [0; 4],
        packet_switch: 0,
        packet_switch_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcGangsiPoint {
    fn id(&self) -> &str {
       "0x0280"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzGangsiRank {
    pub fn from(buffer: &[u8]) -> PacketCzGangsiRank {
        PacketCzGangsiRank {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_switch: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_switch_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_switch).unwrap();
        self.packet_switch_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_switch_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_switch(&mut self, value: i16) {
        self.packet_switch = value;
    }
    pub fn set_packet_switch_raw(&mut self, value: [u8; 2]) {
        self.packet_switch_raw = value;
    }
    pub fn new() -> PacketCzGangsiRank {
        PacketCzGangsiRank {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x28, 0x1]),
        packet_id_raw: [0x28, 0x1],
        packet_switch: 0,
        packet_switch_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzGangsiRank {
    fn id(&self) -> &str {
       "0x0281"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcGangsiRank {
    pub fn from(buffer: &[u8]) -> PacketZcGangsiRank {
        PacketZcGangsiRank {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 10] = [0 as char; 10];
                for (index, byte) in buffer[2..12].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[2..12]);
                dst
            },
            point:  {
                let mut dst: [i32; 10] = [0 as i32; 10];
                for (index, byte) in buffer[242..252].iter().enumerate() {
                    dst[index] = *byte as i32;
                }
                dst
            },
            point_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[242..252]);
                dst
            },
            packet_switch: i16::from_le_bytes([buffer[282], buffer[283]]),
            packet_switch_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[282..284]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.point {
            wtr.write_i32::<LittleEndian>(item).unwrap();
        }
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_switch).unwrap();
        self.packet_switch_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        wtr.append(&mut self.packet_switch_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 10]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 10]) {
        self.name_raw = value;
    }
    pub fn set_point(&mut self, value: [i32; 10]) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 10]) {
        self.point_raw = value;
    }
    pub fn set_packet_switch(&mut self, value: i16) {
        self.packet_switch = value;
    }
    pub fn set_packet_switch_raw(&mut self, value: [u8; 2]) {
        self.packet_switch_raw = value;
    }
    pub fn new() -> PacketZcGangsiRank {
        PacketZcGangsiRank {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x28, 0x2]),
        packet_id_raw: [0x28, 0x2],
        name: [0 as char; 10],
        name_raw: [0; 10],
        point: [0; 10],
        point_raw: [0; 10],
        packet_switch: 0,
        packet_switch_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcGangsiRank {
    fn id(&self) -> &str {
       "0x0282"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAid {
    pub fn from(buffer: &[u8]) -> PacketZcAid {
        PacketZcAid {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketZcAid {
        PacketZcAid {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x28, 0x3]),
        packet_id_raw: [0x28, 0x3],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcAid {
    fn id(&self) -> &str {
       "0x0283"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyEffect3 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyEffect3 {
        PacketZcNotifyEffect3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            effect_id: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            effect_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            numdata: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            numdata_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_id).unwrap();
        self.effect_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.numdata).unwrap();
        self.numdata_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.effect_id_raw.to_vec());
        wtr.append(&mut self.numdata_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_effect_id(&mut self, value: i32) {
        self.effect_id = value;
    }
    pub fn set_effect_id_raw(&mut self, value: [u8; 4]) {
        self.effect_id_raw = value;
    }
    pub fn set_numdata(&mut self, value: i32) {
        self.numdata = value;
    }
    pub fn set_numdata_raw(&mut self, value: [u8; 4]) {
        self.numdata_raw = value;
    }
    pub fn new() -> PacketZcNotifyEffect3 {
        PacketZcNotifyEffect3 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x28, 0x4]),
        packet_id_raw: [0x28, 0x4],
        aid: 0,
        aid_raw: [0; 4],
        effect_id: 0,
        effect_id_raw: [0; 4],
        numdata: 0,
        numdata_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyEffect3 {
    fn id(&self) -> &str {
       "0x0284"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcDeathQuestion {
    pub fn from(buffer: &[u8]) -> PacketZcDeathQuestion {
        PacketZcDeathQuestion {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            qcategory: i16::from_le_bytes([buffer[2], buffer[3]]),
            qcategory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            qnum: i16::from_le_bytes([buffer[4], buffer[5]]),
            qnum_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.qcategory).unwrap();
        self.qcategory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.qnum).unwrap();
        self.qnum_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.qcategory_raw.to_vec());
        wtr.append(&mut self.qnum_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_qcategory(&mut self, value: i16) {
        self.qcategory = value;
    }
    pub fn set_qcategory_raw(&mut self, value: [u8; 2]) {
        self.qcategory_raw = value;
    }
    pub fn set_qnum(&mut self, value: i16) {
        self.qnum = value;
    }
    pub fn set_qnum_raw(&mut self, value: [u8; 2]) {
        self.qnum_raw = value;
    }
    pub fn new() -> PacketZcDeathQuestion {
        PacketZcDeathQuestion {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x28, 0x5]),
        packet_id_raw: [0x28, 0x5],
        qcategory: 0,
        qcategory_raw: [0; 2],
        qnum: 0,
        qnum_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcDeathQuestion {
    fn id(&self) -> &str {
       "0x0285"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzDeathQuestion {
    pub fn from(buffer: &[u8]) -> PacketCzDeathQuestion {
        PacketCzDeathQuestion {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            qanswer: i16::from_le_bytes([buffer[2], buffer[3]]),
            qanswer_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.qanswer).unwrap();
        self.qanswer_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.qanswer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_qanswer(&mut self, value: i16) {
        self.qanswer = value;
    }
    pub fn set_qanswer_raw(&mut self, value: [u8; 2]) {
        self.qanswer_raw = value;
    }
    pub fn new() -> PacketCzDeathQuestion {
        PacketCzDeathQuestion {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x28, 0x6]),
        packet_id_raw: [0x28, 0x6],
        qanswer: 0,
        qanswer_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzDeathQuestion {
    fn id(&self) -> &str {
       "0x0286"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPcCashPointItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcPcCashPointItemlist {
        let iter_count = (&buffer.len() - 8) / 11;
        let mut vec_field: Vec<PurchaseItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (11 * (i - 1));
            let end_pos = 8 + 11 * i;
            vec_field.push(PurchaseItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPcCashPointItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            cash_point: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            cash_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.cash_point).unwrap();
        self.cash_point_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.cash_point_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_cash_point(&mut self, value: u32) {
        self.cash_point = value;
    }
    pub fn set_cash_point_raw(&mut self, value: [u8; 4]) {
        self.cash_point_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<PurchaseItem>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new() -> PacketZcPcCashPointItemlist {
        PacketZcPcCashPointItemlist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x28, 0x7]),
        packet_id_raw: [0x28, 0x7],
        packet_length: 0,
        packet_length_raw: [0; 2],
        cash_point: 0,
        cash_point_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcPcCashPointItemlist {
    fn id(&self) -> &str {
       "0x0287"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzPcBuyCashPointItem {
    pub fn from(buffer: &[u8]) -> PacketCzPcBuyCashPointItem {
        PacketCzPcBuyCashPointItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketCzPcBuyCashPointItem {
        PacketCzPcBuyCashPointItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x28, 0x8]),
        packet_id_raw: [0x28, 0x8],
        itid: 0,
        itid_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzPcBuyCashPointItem {
    fn id(&self) -> &str {
       "0x0288"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPcCashPointUpdate {
    pub fn from(buffer: &[u8]) -> PacketZcPcCashPointUpdate {
        PacketZcPcCashPointUpdate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            cash_point: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            cash_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            error: i16::from_le_bytes([buffer[6], buffer[7]]),
            error_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.cash_point).unwrap();
        self.cash_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error).unwrap();
        self.error_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.cash_point_raw.to_vec());
        wtr.append(&mut self.error_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_cash_point(&mut self, value: u32) {
        self.cash_point = value;
    }
    pub fn set_cash_point_raw(&mut self, value: [u8; 4]) {
        self.cash_point_raw = value;
    }
    pub fn set_error(&mut self, value: i16) {
        self.error = value;
    }
    pub fn set_error_raw(&mut self, value: [u8; 2]) {
        self.error_raw = value;
    }
    pub fn new() -> PacketZcPcCashPointUpdate {
        PacketZcPcCashPointUpdate {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x28, 0x9]),
        packet_id_raw: [0x28, 0x9],
        cash_point: 0,
        cash_point_raw: [0; 4],
        error: 0,
        error_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcPcCashPointUpdate {
    fn id(&self) -> &str {
       "0x0289"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNpcShowefstUpdate {
    pub fn from(buffer: &[u8]) -> PacketZcNpcShowefstUpdate {
        PacketZcNpcShowefstUpdate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            clevel: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            clevel_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            show_efst: i32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            show_efst_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.show_efst).unwrap();
        self.show_efst_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        wtr.append(&mut self.show_efst_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_clevel(&mut self, value: i32) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 4]) {
        self.clevel_raw = value;
    }
    pub fn set_show_efst(&mut self, value: i32) {
        self.show_efst = value;
    }
    pub fn set_show_efst_raw(&mut self, value: [u8; 4]) {
        self.show_efst_raw = value;
    }
    pub fn new() -> PacketZcNpcShowefstUpdate {
        PacketZcNpcShowefstUpdate {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x28, 0xa]),
        packet_id_raw: [0x28, 0xa],
        aid: 0,
        aid_raw: [0; 4],
        effect_state: 0,
        effect_state_raw: [0; 4],
        clevel: 0,
        clevel_raw: [0; 4],
        show_efst: 0,
        show_efst_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNpcShowefstUpdate {
    fn id(&self) -> &str {
       "0x028a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketChSelectCharGoingtobeused {
    pub fn from(buffer: &[u8]) -> PacketChSelectCharGoingtobeused {
        PacketChSelectCharGoingtobeused {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            dw_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            dw_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            n_count_selected_char: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            n_count_selected_char_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            ardw_selected_gid:  {
                let mut dst: [u32; 9] = [0 as u32; 9];
                for (index, byte) in buffer[10..19].iter().enumerate() {
                    dst[index] = *byte as u32;
                }
                dst
            },
            ardw_selected_gid_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[10..19]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_aid).unwrap();
        self.dw_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.n_count_selected_char).unwrap();
        self.n_count_selected_char_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.ardw_selected_gid {
            wtr.write_u32::<LittleEndian>(item).unwrap();
        }
        self.ardw_selected_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.dw_aid_raw.to_vec());
        wtr.append(&mut self.n_count_selected_char_raw.to_vec());
        wtr.append(&mut self.ardw_selected_gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_dw_aid(&mut self, value: u32) {
        self.dw_aid = value;
    }
    pub fn set_dw_aid_raw(&mut self, value: [u8; 4]) {
        self.dw_aid_raw = value;
    }
    pub fn set_n_count_selected_char(&mut self, value: i32) {
        self.n_count_selected_char = value;
    }
    pub fn set_n_count_selected_char_raw(&mut self, value: [u8; 4]) {
        self.n_count_selected_char_raw = value;
    }
    pub fn set_ardw_selected_gid(&mut self, value: [u32; 9]) {
        self.ardw_selected_gid = value;
    }
    pub fn set_ardw_selected_gid_raw(&mut self, value: [u8; 9]) {
        self.ardw_selected_gid_raw = value;
    }
    pub fn new() -> PacketChSelectCharGoingtobeused {
        PacketChSelectCharGoingtobeused {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x28, 0xc]),
        packet_id_raw: [0x28, 0xc],
        dw_aid: 0,
        dw_aid_raw: [0; 4],
        n_count_selected_char: 0,
        n_count_selected_char_raw: [0; 4],
        ardw_selected_gid: [0; 9],
        ardw_selected_gid_raw: [0; 9],
        }
    }
}

impl Packet for PacketChSelectCharGoingtobeused {
    fn id(&self) -> &str {
       "0x028c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketChReqIsValidCharname {
    pub fn from(buffer: &[u8]) -> PacketChReqIsValidCharname {
        PacketChReqIsValidCharname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            dw_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            dw_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            dw_gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            dw_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            sz_char_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[10..34].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            sz_char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[10..34]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_aid).unwrap();
        self.dw_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_gid).unwrap();
        self.dw_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.dw_aid_raw.to_vec());
        wtr.append(&mut self.dw_gid_raw.to_vec());
        wtr.append(&mut self.sz_char_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_dw_aid(&mut self, value: u32) {
        self.dw_aid = value;
    }
    pub fn set_dw_aid_raw(&mut self, value: [u8; 4]) {
        self.dw_aid_raw = value;
    }
    pub fn set_dw_gid(&mut self, value: u32) {
        self.dw_gid = value;
    }
    pub fn set_dw_gid_raw(&mut self, value: [u8; 4]) {
        self.dw_gid_raw = value;
    }
    pub fn set_sz_char_name(&mut self, value: [char; 24]) {
        self.sz_char_name = value;
    }
    pub fn set_sz_char_name_raw(&mut self, value: [u8; 24]) {
        self.sz_char_name_raw = value;
    }
    pub fn new() -> PacketChReqIsValidCharname {
        PacketChReqIsValidCharname {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x28, 0xd]),
        packet_id_raw: [0x28, 0xd],
        dw_aid: 0,
        dw_aid_raw: [0; 4],
        dw_gid: 0,
        dw_gid_raw: [0; 4],
        sz_char_name: [0 as char; 24],
        sz_char_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketChReqIsValidCharname {
    fn id(&self) -> &str {
       "0x028d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcAckIsValidCharname {
    pub fn from(buffer: &[u8]) -> PacketHcAckIsValidCharname {
        PacketHcAckIsValidCharname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            s_result: i16::from_le_bytes([buffer[2], buffer[3]]),
            s_result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.s_result).unwrap();
        self.s_result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.s_result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_s_result(&mut self, value: i16) {
        self.s_result = value;
    }
    pub fn set_s_result_raw(&mut self, value: [u8; 2]) {
        self.s_result_raw = value;
    }
    pub fn new() -> PacketHcAckIsValidCharname {
        PacketHcAckIsValidCharname {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x28, 0xe]),
        packet_id_raw: [0x28, 0xe],
        s_result: 0,
        s_result_raw: [0; 2],
        }
    }
}

impl Packet for PacketHcAckIsValidCharname {
    fn id(&self) -> &str {
       "0x028e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketChReqChangeCharname {
    pub fn from(buffer: &[u8]) -> PacketChReqChangeCharname {
        PacketChReqChangeCharname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            dw_gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            dw_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_gid).unwrap();
        self.dw_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.dw_gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_dw_gid(&mut self, value: u32) {
        self.dw_gid = value;
    }
    pub fn set_dw_gid_raw(&mut self, value: [u8; 4]) {
        self.dw_gid_raw = value;
    }
    pub fn new() -> PacketChReqChangeCharname {
        PacketChReqChangeCharname {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x28, 0xf]),
        packet_id_raw: [0x28, 0xf],
        dw_gid: 0,
        dw_gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketChReqChangeCharname {
    fn id(&self) -> &str {
       "0x028f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcAckChangeCharname {
    pub fn from(buffer: &[u8]) -> PacketHcAckChangeCharname {
        PacketHcAckChangeCharname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            s_result: i16::from_le_bytes([buffer[2], buffer[3]]),
            s_result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.s_result).unwrap();
        self.s_result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.s_result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_s_result(&mut self, value: i16) {
        self.s_result = value;
    }
    pub fn set_s_result_raw(&mut self, value: [u8; 2]) {
        self.s_result_raw = value;
    }
    pub fn new() -> PacketHcAckChangeCharname {
        PacketHcAckChangeCharname {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x29, 0x0]),
        packet_id_raw: [0x29, 0x0],
        s_result: 0,
        s_result_raw: [0; 2],
        }
    }
}

impl Packet for PacketHcAckChangeCharname {
    fn id(&self) -> &str {
       "0x0290"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMsg {
    pub fn from(buffer: &[u8]) -> PacketZcMsg {
        PacketZcMsg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            msg: u16::from_le_bytes([buffer[2], buffer[3]]),
            msg_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.msg).unwrap();
        self.msg_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_msg(&mut self, value: u16) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: [u8; 2]) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketZcMsg {
        PacketZcMsg {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x29, 0x1]),
        packet_id_raw: [0x29, 0x1],
        msg: 0,
        msg_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcMsg {
    fn id(&self) -> &str {
       "0x0291"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzStandingResurrection {
    pub fn from(buffer: &[u8]) -> PacketCzStandingResurrection {
        PacketCzStandingResurrection {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzStandingResurrection {
        PacketCzStandingResurrection {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x29, 0x2]),
        packet_id_raw: [0x29, 0x2],
        }
    }
}

impl Packet for PacketCzStandingResurrection {
    fn id(&self) -> &str {
       "0x0292"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcBossInfo {
    pub fn from(buffer: &[u8]) -> PacketZcBossInfo {
        PacketZcBossInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            info_type: u8::from_le_bytes([buffer[2]]),
            info_type_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            x_pos: i32::from_le_bytes([buffer[3], buffer[4], buffer[5], buffer[6]]),
            x_pos_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[3..7]);
                dst
            },
            y_pos: i32::from_le_bytes([buffer[7], buffer[8], buffer[9], buffer[10]]),
            y_pos_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[7..11]);
                dst
            },
            min_hour: u16::from_le_bytes([buffer[11], buffer[12]]),
            min_hour_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            min_minute: u16::from_le_bytes([buffer[13], buffer[14]]),
            min_minute_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[13..15]);
                dst
            },
            max_hour: u16::from_le_bytes([buffer[15], buffer[16]]),
            max_hour_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[15..17]);
                dst
            },
            max_minute: u16::from_le_bytes([buffer[17], buffer[18]]),
            max_minute_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[17..19]);
                dst
            },
            name:  {
                let mut dst: [char; 51] = [0 as char; 51];
                for (index, byte) in buffer[19..70].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 51] = [0u8; 51];
                dst.clone_from_slice(&buffer[19..70]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.info_type).unwrap();
        self.info_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.min_hour).unwrap();
        self.min_hour_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.min_minute).unwrap();
        self.min_minute_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.max_hour).unwrap();
        self.max_hour_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.max_minute).unwrap();
        self.max_minute_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.info_type_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.min_hour_raw.to_vec());
        wtr.append(&mut self.min_minute_raw.to_vec());
        wtr.append(&mut self.max_hour_raw.to_vec());
        wtr.append(&mut self.max_minute_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_info_type(&mut self, value: u8) {
        self.info_type = value;
    }
    pub fn set_info_type_raw(&mut self, value: [u8; 1]) {
        self.info_type_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i32) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 4]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i32) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 4]) {
        self.y_pos_raw = value;
    }
    pub fn set_min_hour(&mut self, value: u16) {
        self.min_hour = value;
    }
    pub fn set_min_hour_raw(&mut self, value: [u8; 2]) {
        self.min_hour_raw = value;
    }
    pub fn set_min_minute(&mut self, value: u16) {
        self.min_minute = value;
    }
    pub fn set_min_minute_raw(&mut self, value: [u8; 2]) {
        self.min_minute_raw = value;
    }
    pub fn set_max_hour(&mut self, value: u16) {
        self.max_hour = value;
    }
    pub fn set_max_hour_raw(&mut self, value: [u8; 2]) {
        self.max_hour_raw = value;
    }
    pub fn set_max_minute(&mut self, value: u16) {
        self.max_minute = value;
    }
    pub fn set_max_minute_raw(&mut self, value: [u8; 2]) {
        self.max_minute_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 51]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 51]) {
        self.name_raw = value;
    }
    pub fn new() -> PacketZcBossInfo {
        PacketZcBossInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x29, 0x3]),
        packet_id_raw: [0x29, 0x3],
        info_type: 0,
        info_type_raw: [0; 1],
        x_pos: 0,
        x_pos_raw: [0; 4],
        y_pos: 0,
        y_pos_raw: [0; 4],
        min_hour: 0,
        min_hour_raw: [0; 2],
        min_minute: 0,
        min_minute_raw: [0; 2],
        max_hour: 0,
        max_hour_raw: [0; 2],
        max_minute: 0,
        max_minute_raw: [0; 2],
        name: [0 as char; 51],
        name_raw: [0; 51],
        }
    }
}

impl Packet for PacketZcBossInfo {
    fn id(&self) -> &str {
       "0x0293"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcReadBook {
    pub fn from(buffer: &[u8]) -> PacketZcReadBook {
        PacketZcReadBook {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            book_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            book_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            page: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            page_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.book_id).unwrap();
        self.book_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.page).unwrap();
        self.page_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.book_id_raw.to_vec());
        wtr.append(&mut self.page_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_book_id(&mut self, value: u32) {
        self.book_id = value;
    }
    pub fn set_book_id_raw(&mut self, value: [u8; 4]) {
        self.book_id_raw = value;
    }
    pub fn set_page(&mut self, value: u32) {
        self.page = value;
    }
    pub fn set_page_raw(&mut self, value: [u8; 4]) {
        self.page_raw = value;
    }
    pub fn new() -> PacketZcReadBook {
        PacketZcReadBook {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x29, 0x4]),
        packet_id_raw: [0x29, 0x4],
        book_id: 0,
        book_id_raw: [0; 4],
        page: 0,
        page_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcReadBook {
    fn id(&self) -> &str {
       "0x0294"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcEquipmentItemlist2 {
    pub fn from(buffer: &[u8]) -> PacketZcEquipmentItemlist2 {
        let iter_count = (&buffer.len() - 4) / 24;
        let mut vec_field: Vec<EquipmentitemExtrainfo2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (24 * (i - 1));
            let end_pos = 4 + 24 * i;
            vec_field.push(EquipmentitemExtrainfo2::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcEquipmentItemlist2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo2>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new() -> PacketZcEquipmentItemlist2 {
        PacketZcEquipmentItemlist2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x29, 0x5]),
        packet_id_raw: [0x29, 0x5],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcEquipmentItemlist2 {
    fn id(&self) -> &str {
       "0x0295"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcStoreEquipmentItemlist2 {
    pub fn from(buffer: &[u8]) -> PacketZcStoreEquipmentItemlist2 {
        let iter_count = (&buffer.len() - 4) / 24;
        let mut vec_field: Vec<EquipmentitemExtrainfo2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (24 * (i - 1));
            let end_pos = 4 + 24 * i;
            vec_field.push(EquipmentitemExtrainfo2::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcStoreEquipmentItemlist2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo2>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new() -> PacketZcStoreEquipmentItemlist2 {
        PacketZcStoreEquipmentItemlist2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x29, 0x6]),
        packet_id_raw: [0x29, 0x6],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcStoreEquipmentItemlist2 {
    fn id(&self) -> &str {
       "0x0296"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcCartEquipmentItemlist2 {
    pub fn from(buffer: &[u8]) -> PacketZcCartEquipmentItemlist2 {
        let iter_count = (&buffer.len() - 4) / 24;
        let mut vec_field: Vec<EquipmentitemExtrainfo2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (24 * (i - 1));
            let end_pos = 4 + 24 * i;
            vec_field.push(EquipmentitemExtrainfo2::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcCartEquipmentItemlist2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo2>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new() -> PacketZcCartEquipmentItemlist2 {
        PacketZcCartEquipmentItemlist2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x29, 0x7]),
        packet_id_raw: [0x29, 0x7],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcCartEquipmentItemlist2 {
    fn id(&self) -> &str {
       "0x0297"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcCashTimeCounter {
    pub fn from(buffer: &[u8]) -> PacketZcCashTimeCounter {
        PacketZcCashTimeCounter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            remain_second: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            remain_second_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.remain_second).unwrap();
        self.remain_second_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.remain_second_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_remain_second(&mut self, value: u32) {
        self.remain_second = value;
    }
    pub fn set_remain_second_raw(&mut self, value: [u8; 4]) {
        self.remain_second_raw = value;
    }
    pub fn new() -> PacketZcCashTimeCounter {
        PacketZcCashTimeCounter {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x29, 0x8]),
        packet_id_raw: [0x29, 0x8],
        itid: 0,
        itid_raw: [0; 2],
        remain_second: 0,
        remain_second_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcCashTimeCounter {
    fn id(&self) -> &str {
       "0x0298"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcCashItemDelete {
    pub fn from(buffer: &[u8]) -> PacketZcCashItemDelete {
        PacketZcCashItemDelete {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            itid: u16::from_le_bytes([buffer[4], buffer[5]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new() -> PacketZcCashItemDelete {
        PacketZcCashItemDelete {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x29, 0x9]),
        packet_id_raw: [0x29, 0x9],
        index: 0,
        index_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcCashItemDelete {
    fn id(&self) -> &str {
       "0x0299"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcItemPickupAck2 {
    pub fn from(buffer: &[u8]) -> PacketZcItemPickupAck2 {
        PacketZcItemPickupAck2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: u16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            itid: u16::from_le_bytes([buffer[6], buffer[7]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            is_identified: buffer[8] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            is_damaged: buffer[9] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[10]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[11..19]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[11..19]);
                dst
            },
            location: u16::from_le_bytes([buffer[19], buffer[20]]),
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            atype: u8::from_le_bytes([buffer[21]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[21..22]);
                dst
            },
            result: u8::from_le_bytes([buffer[22]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[22..23]);
                dst
            },
            hire_expire_date: i32::from_le_bytes([buffer[23], buffer[24], buffer[25], buffer[26]]),
            hire_expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[23..27]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hire_expire_date).unwrap();
        self.hire_expire_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        wtr.append(&mut self.location_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.hire_expire_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: u16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn set_location(&mut self, value: u16) {
        self.location = value;
    }
    pub fn set_location_raw(&mut self, value: [u8; 2]) {
        self.location_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn set_hire_expire_date(&mut self, value: i32) {
        self.hire_expire_date = value;
    }
    pub fn set_hire_expire_date_raw(&mut self, value: [u8; 4]) {
        self.hire_expire_date_raw = value;
    }
    pub fn new() -> PacketZcItemPickupAck2 {
        PacketZcItemPickupAck2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x29, 0xa]),
        packet_id_raw: [0x29, 0xa],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        location: 0,
        location_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        result: 0,
        result_raw: [0; 1],
        hire_expire_date: 0,
        hire_expire_date_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcItemPickupAck2 {
    fn id(&self) -> &str {
       "0x029a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMerInit {
    pub fn from(buffer: &[u8]) -> PacketZcMerInit {
        PacketZcMerInit {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atk: i16::from_le_bytes([buffer[6], buffer[7]]),
            atk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            matk: i16::from_le_bytes([buffer[8], buffer[9]]),
            matk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            hit: i16::from_le_bytes([buffer[10], buffer[11]]),
            hit_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            critical: i16::from_le_bytes([buffer[12], buffer[13]]),
            critical_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            def: i16::from_le_bytes([buffer[14], buffer[15]]),
            def_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            mdef: i16::from_le_bytes([buffer[16], buffer[17]]),
            mdef_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            flee: i16::from_le_bytes([buffer[18], buffer[19]]),
            flee_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            aspd: i16::from_le_bytes([buffer[20], buffer[21]]),
            aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[22..46].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[22..46]);
                dst
            },
            level: i16::from_le_bytes([buffer[46], buffer[47]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[46..48]);
                dst
            },
            hp: i32::from_le_bytes([buffer[48], buffer[49], buffer[50], buffer[51]]),
            hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[48..52]);
                dst
            },
            max_hp: i32::from_le_bytes([buffer[52], buffer[53], buffer[54], buffer[55]]),
            max_hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[52..56]);
                dst
            },
            sp: i32::from_le_bytes([buffer[56], buffer[57], buffer[58], buffer[59]]),
            sp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[56..60]);
                dst
            },
            max_sp: i32::from_le_bytes([buffer[60], buffer[61], buffer[62], buffer[63]]),
            max_sp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[60..64]);
                dst
            },
            expire_date: i32::from_le_bytes([buffer[64], buffer[65], buffer[66], buffer[67]]),
            expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[64..68]);
                dst
            },
            faith: i16::from_le_bytes([buffer[68], buffer[69]]),
            faith_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[68..70]);
                dst
            },
            toal_call_num: i32::from_le_bytes([buffer[70], buffer[71], buffer[72], buffer[73]]),
            toal_call_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[70..74]);
                dst
            },
            approval_monster_kill_counter: i32::from_le_bytes([buffer[74], buffer[75], buffer[76], buffer[77]]),
            approval_monster_kill_counter_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[74..78]);
                dst
            },
            atkrange: i16::from_le_bytes([buffer[78], buffer[79]]),
            atkrange_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[78..80]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atk).unwrap();
        self.atk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.matk).unwrap();
        self.matk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hit).unwrap();
        self.hit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.critical).unwrap();
        self.critical_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.def).unwrap();
        self.def_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef).unwrap();
        self.mdef_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.flee).unwrap();
        self.flee_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.aspd).unwrap();
        self.aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.sp).unwrap();
        self.sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_sp).unwrap();
        self.max_sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.expire_date).unwrap();
        self.expire_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.faith).unwrap();
        self.faith_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.toal_call_num).unwrap();
        self.toal_call_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.approval_monster_kill_counter).unwrap();
        self.approval_monster_kill_counter_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atkrange).unwrap();
        self.atkrange_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.atk_raw.to_vec());
        wtr.append(&mut self.matk_raw.to_vec());
        wtr.append(&mut self.hit_raw.to_vec());
        wtr.append(&mut self.critical_raw.to_vec());
        wtr.append(&mut self.def_raw.to_vec());
        wtr.append(&mut self.mdef_raw.to_vec());
        wtr.append(&mut self.flee_raw.to_vec());
        wtr.append(&mut self.aspd_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.max_hp_raw.to_vec());
        wtr.append(&mut self.sp_raw.to_vec());
        wtr.append(&mut self.max_sp_raw.to_vec());
        wtr.append(&mut self.expire_date_raw.to_vec());
        wtr.append(&mut self.faith_raw.to_vec());
        wtr.append(&mut self.toal_call_num_raw.to_vec());
        wtr.append(&mut self.approval_monster_kill_counter_raw.to_vec());
        wtr.append(&mut self.atkrange_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: i32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_atk(&mut self, value: i16) {
        self.atk = value;
    }
    pub fn set_atk_raw(&mut self, value: [u8; 2]) {
        self.atk_raw = value;
    }
    pub fn set_matk(&mut self, value: i16) {
        self.matk = value;
    }
    pub fn set_matk_raw(&mut self, value: [u8; 2]) {
        self.matk_raw = value;
    }
    pub fn set_hit(&mut self, value: i16) {
        self.hit = value;
    }
    pub fn set_hit_raw(&mut self, value: [u8; 2]) {
        self.hit_raw = value;
    }
    pub fn set_critical(&mut self, value: i16) {
        self.critical = value;
    }
    pub fn set_critical_raw(&mut self, value: [u8; 2]) {
        self.critical_raw = value;
    }
    pub fn set_def(&mut self, value: i16) {
        self.def = value;
    }
    pub fn set_def_raw(&mut self, value: [u8; 2]) {
        self.def_raw = value;
    }
    pub fn set_mdef(&mut self, value: i16) {
        self.mdef = value;
    }
    pub fn set_mdef_raw(&mut self, value: [u8; 2]) {
        self.mdef_raw = value;
    }
    pub fn set_flee(&mut self, value: i16) {
        self.flee = value;
    }
    pub fn set_flee_raw(&mut self, value: [u8; 2]) {
        self.flee_raw = value;
    }
    pub fn set_aspd(&mut self, value: i16) {
        self.aspd = value;
    }
    pub fn set_aspd_raw(&mut self, value: [u8; 2]) {
        self.aspd_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_hp(&mut self, value: i32) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 4]) {
        self.hp_raw = value;
    }
    pub fn set_max_hp(&mut self, value: i32) {
        self.max_hp = value;
    }
    pub fn set_max_hp_raw(&mut self, value: [u8; 4]) {
        self.max_hp_raw = value;
    }
    pub fn set_sp(&mut self, value: i32) {
        self.sp = value;
    }
    pub fn set_sp_raw(&mut self, value: [u8; 4]) {
        self.sp_raw = value;
    }
    pub fn set_max_sp(&mut self, value: i32) {
        self.max_sp = value;
    }
    pub fn set_max_sp_raw(&mut self, value: [u8; 4]) {
        self.max_sp_raw = value;
    }
    pub fn set_expire_date(&mut self, value: i32) {
        self.expire_date = value;
    }
    pub fn set_expire_date_raw(&mut self, value: [u8; 4]) {
        self.expire_date_raw = value;
    }
    pub fn set_faith(&mut self, value: i16) {
        self.faith = value;
    }
    pub fn set_faith_raw(&mut self, value: [u8; 2]) {
        self.faith_raw = value;
    }
    pub fn set_toal_call_num(&mut self, value: i32) {
        self.toal_call_num = value;
    }
    pub fn set_toal_call_num_raw(&mut self, value: [u8; 4]) {
        self.toal_call_num_raw = value;
    }
    pub fn set_approval_monster_kill_counter(&mut self, value: i32) {
        self.approval_monster_kill_counter = value;
    }
    pub fn set_approval_monster_kill_counter_raw(&mut self, value: [u8; 4]) {
        self.approval_monster_kill_counter_raw = value;
    }
    pub fn set_atkrange(&mut self, value: i16) {
        self.atkrange = value;
    }
    pub fn set_atkrange_raw(&mut self, value: [u8; 2]) {
        self.atkrange_raw = value;
    }
    pub fn new() -> PacketZcMerInit {
        PacketZcMerInit {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x29, 0xb]),
        packet_id_raw: [0x29, 0xb],
        aid: 0,
        aid_raw: [0; 4],
        atk: 0,
        atk_raw: [0; 2],
        matk: 0,
        matk_raw: [0; 2],
        hit: 0,
        hit_raw: [0; 2],
        critical: 0,
        critical_raw: [0; 2],
        def: 0,
        def_raw: [0; 2],
        mdef: 0,
        mdef_raw: [0; 2],
        flee: 0,
        flee_raw: [0; 2],
        aspd: 0,
        aspd_raw: [0; 2],
        name: [0 as char; 24],
        name_raw: [0; 24],
        level: 0,
        level_raw: [0; 2],
        hp: 0,
        hp_raw: [0; 4],
        max_hp: 0,
        max_hp_raw: [0; 4],
        sp: 0,
        sp_raw: [0; 4],
        max_sp: 0,
        max_sp_raw: [0; 4],
        expire_date: 0,
        expire_date_raw: [0; 4],
        faith: 0,
        faith_raw: [0; 2],
        toal_call_num: 0,
        toal_call_num_raw: [0; 4],
        approval_monster_kill_counter: 0,
        approval_monster_kill_counter_raw: [0; 4],
        atkrange: 0,
        atkrange_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcMerInit {
    fn id(&self) -> &str {
       "0x029b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMerProperty {
    pub fn from(buffer: &[u8]) -> PacketZcMerProperty {
        PacketZcMerProperty {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atk: i16::from_le_bytes([buffer[2], buffer[3]]),
            atk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            matk: i16::from_le_bytes([buffer[4], buffer[5]]),
            matk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            hit: i16::from_le_bytes([buffer[6], buffer[7]]),
            hit_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            critical: i16::from_le_bytes([buffer[8], buffer[9]]),
            critical_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            def: i16::from_le_bytes([buffer[10], buffer[11]]),
            def_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            mdef: i16::from_le_bytes([buffer[12], buffer[13]]),
            mdef_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            flee: i16::from_le_bytes([buffer[14], buffer[15]]),
            flee_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            aspd: i16::from_le_bytes([buffer[16], buffer[17]]),
            aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[18..42].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[18..42]);
                dst
            },
            level: i16::from_le_bytes([buffer[42], buffer[43]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            hp: i16::from_le_bytes([buffer[44], buffer[45]]),
            hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[44..46]);
                dst
            },
            max_hp: i16::from_le_bytes([buffer[46], buffer[47]]),
            max_hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[46..48]);
                dst
            },
            sp: i16::from_le_bytes([buffer[48], buffer[49]]),
            sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[48..50]);
                dst
            },
            max_sp: i16::from_le_bytes([buffer[50], buffer[51]]),
            max_sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[50..52]);
                dst
            },
            expire_date: i32::from_le_bytes([buffer[52], buffer[53], buffer[54], buffer[55]]),
            expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[52..56]);
                dst
            },
            faith: i16::from_le_bytes([buffer[56], buffer[57]]),
            faith_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[56..58]);
                dst
            },
            toal_call_num: i32::from_le_bytes([buffer[58], buffer[59], buffer[60], buffer[61]]),
            toal_call_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[58..62]);
                dst
            },
            approval_monster_kill_counter: i32::from_le_bytes([buffer[62], buffer[63], buffer[64], buffer[65]]),
            approval_monster_kill_counter_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[62..66]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atk).unwrap();
        self.atk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.matk).unwrap();
        self.matk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hit).unwrap();
        self.hit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.critical).unwrap();
        self.critical_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.def).unwrap();
        self.def_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef).unwrap();
        self.mdef_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.flee).unwrap();
        self.flee_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.aspd).unwrap();
        self.aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sp).unwrap();
        self.sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_sp).unwrap();
        self.max_sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.expire_date).unwrap();
        self.expire_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.faith).unwrap();
        self.faith_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.toal_call_num).unwrap();
        self.toal_call_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.approval_monster_kill_counter).unwrap();
        self.approval_monster_kill_counter_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atk_raw.to_vec());
        wtr.append(&mut self.matk_raw.to_vec());
        wtr.append(&mut self.hit_raw.to_vec());
        wtr.append(&mut self.critical_raw.to_vec());
        wtr.append(&mut self.def_raw.to_vec());
        wtr.append(&mut self.mdef_raw.to_vec());
        wtr.append(&mut self.flee_raw.to_vec());
        wtr.append(&mut self.aspd_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.max_hp_raw.to_vec());
        wtr.append(&mut self.sp_raw.to_vec());
        wtr.append(&mut self.max_sp_raw.to_vec());
        wtr.append(&mut self.expire_date_raw.to_vec());
        wtr.append(&mut self.faith_raw.to_vec());
        wtr.append(&mut self.toal_call_num_raw.to_vec());
        wtr.append(&mut self.approval_monster_kill_counter_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atk(&mut self, value: i16) {
        self.atk = value;
    }
    pub fn set_atk_raw(&mut self, value: [u8; 2]) {
        self.atk_raw = value;
    }
    pub fn set_matk(&mut self, value: i16) {
        self.matk = value;
    }
    pub fn set_matk_raw(&mut self, value: [u8; 2]) {
        self.matk_raw = value;
    }
    pub fn set_hit(&mut self, value: i16) {
        self.hit = value;
    }
    pub fn set_hit_raw(&mut self, value: [u8; 2]) {
        self.hit_raw = value;
    }
    pub fn set_critical(&mut self, value: i16) {
        self.critical = value;
    }
    pub fn set_critical_raw(&mut self, value: [u8; 2]) {
        self.critical_raw = value;
    }
    pub fn set_def(&mut self, value: i16) {
        self.def = value;
    }
    pub fn set_def_raw(&mut self, value: [u8; 2]) {
        self.def_raw = value;
    }
    pub fn set_mdef(&mut self, value: i16) {
        self.mdef = value;
    }
    pub fn set_mdef_raw(&mut self, value: [u8; 2]) {
        self.mdef_raw = value;
    }
    pub fn set_flee(&mut self, value: i16) {
        self.flee = value;
    }
    pub fn set_flee_raw(&mut self, value: [u8; 2]) {
        self.flee_raw = value;
    }
    pub fn set_aspd(&mut self, value: i16) {
        self.aspd = value;
    }
    pub fn set_aspd_raw(&mut self, value: [u8; 2]) {
        self.aspd_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_hp(&mut self, value: i16) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 2]) {
        self.hp_raw = value;
    }
    pub fn set_max_hp(&mut self, value: i16) {
        self.max_hp = value;
    }
    pub fn set_max_hp_raw(&mut self, value: [u8; 2]) {
        self.max_hp_raw = value;
    }
    pub fn set_sp(&mut self, value: i16) {
        self.sp = value;
    }
    pub fn set_sp_raw(&mut self, value: [u8; 2]) {
        self.sp_raw = value;
    }
    pub fn set_max_sp(&mut self, value: i16) {
        self.max_sp = value;
    }
    pub fn set_max_sp_raw(&mut self, value: [u8; 2]) {
        self.max_sp_raw = value;
    }
    pub fn set_expire_date(&mut self, value: i32) {
        self.expire_date = value;
    }
    pub fn set_expire_date_raw(&mut self, value: [u8; 4]) {
        self.expire_date_raw = value;
    }
    pub fn set_faith(&mut self, value: i16) {
        self.faith = value;
    }
    pub fn set_faith_raw(&mut self, value: [u8; 2]) {
        self.faith_raw = value;
    }
    pub fn set_toal_call_num(&mut self, value: i32) {
        self.toal_call_num = value;
    }
    pub fn set_toal_call_num_raw(&mut self, value: [u8; 4]) {
        self.toal_call_num_raw = value;
    }
    pub fn set_approval_monster_kill_counter(&mut self, value: i32) {
        self.approval_monster_kill_counter = value;
    }
    pub fn set_approval_monster_kill_counter_raw(&mut self, value: [u8; 4]) {
        self.approval_monster_kill_counter_raw = value;
    }
    pub fn new() -> PacketZcMerProperty {
        PacketZcMerProperty {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x29, 0xc]),
        packet_id_raw: [0x29, 0xc],
        atk: 0,
        atk_raw: [0; 2],
        matk: 0,
        matk_raw: [0; 2],
        hit: 0,
        hit_raw: [0; 2],
        critical: 0,
        critical_raw: [0; 2],
        def: 0,
        def_raw: [0; 2],
        mdef: 0,
        mdef_raw: [0; 2],
        flee: 0,
        flee_raw: [0; 2],
        aspd: 0,
        aspd_raw: [0; 2],
        name: [0 as char; 24],
        name_raw: [0; 24],
        level: 0,
        level_raw: [0; 2],
        hp: 0,
        hp_raw: [0; 2],
        max_hp: 0,
        max_hp_raw: [0; 2],
        sp: 0,
        sp_raw: [0; 2],
        max_sp: 0,
        max_sp_raw: [0; 2],
        expire_date: 0,
        expire_date_raw: [0; 4],
        faith: 0,
        faith_raw: [0; 2],
        toal_call_num: 0,
        toal_call_num_raw: [0; 4],
        approval_monster_kill_counter: 0,
        approval_monster_kill_counter_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcMerProperty {
    fn id(&self) -> &str {
       "0x029c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMerSkillinfoList {
    pub fn from(buffer: &[u8]) -> PacketZcMerSkillinfoList {
        let iter_count = (&buffer.len() - 4) / 37;
        let mut vec_field: Vec<SKILLINFO> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (37 * (i - 1));
            let end_pos = 4 + 37 * i;
            vec_field.push(SKILLINFO::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcMerSkillinfoList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            skill_list: vec_field.clone(),
            skill_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.skill_list_raw = {
            self.skill_list.iter_mut().for_each(|item| item.fill_raw());
            self.skill_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.skill_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_skill_list(&mut self, value: Vec<SKILLINFO>) {
        self.skill_list = value;
    }
    pub fn set_skill_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.skill_list_raw = value;
    }
    pub fn new() -> PacketZcMerSkillinfoList {
        PacketZcMerSkillinfoList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x29, 0xd]),
        packet_id_raw: [0x29, 0xd],
        packet_length: 0,
        packet_length_raw: [0; 2],
        skill_list: vec![],
        skill_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcMerSkillinfoList {
    fn id(&self) -> &str {
       "0x029d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMerSkillinfoUpdate {
    pub fn from(buffer: &[u8]) -> PacketZcMerSkillinfoUpdate {
        PacketZcMerSkillinfoUpdate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            level: i16::from_le_bytes([buffer[4], buffer[5]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            spcost: i16::from_le_bytes([buffer[6], buffer[7]]),
            spcost_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            attack_range: i16::from_le_bytes([buffer[8], buffer[9]]),
            attack_range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            upgradable: buffer[10] == 1,
            upgradable_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.spcost).unwrap();
        self.spcost_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.attack_range).unwrap();
        self.attack_range_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.upgradable as u8).unwrap();
        self.upgradable_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.spcost_raw.to_vec());
        wtr.append(&mut self.attack_range_raw.to_vec());
        wtr.append(&mut self.upgradable_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_spcost(&mut self, value: i16) {
        self.spcost = value;
    }
    pub fn set_spcost_raw(&mut self, value: [u8; 2]) {
        self.spcost_raw = value;
    }
    pub fn set_attack_range(&mut self, value: i16) {
        self.attack_range = value;
    }
    pub fn set_attack_range_raw(&mut self, value: [u8; 2]) {
        self.attack_range_raw = value;
    }
    pub fn set_upgradable(&mut self, value: bool) {
        self.upgradable = value;
    }
    pub fn set_upgradable_raw(&mut self, value: [u8; 1]) {
        self.upgradable_raw = value;
    }
    pub fn new() -> PacketZcMerSkillinfoUpdate {
        PacketZcMerSkillinfoUpdate {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x29, 0xe]),
        packet_id_raw: [0x29, 0xe],
        skid: 0,
        skid_raw: [0; 2],
        level: 0,
        level_raw: [0; 2],
        spcost: 0,
        spcost_raw: [0; 2],
        attack_range: 0,
        attack_range_raw: [0; 2],
        upgradable: false,
        upgradable_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcMerSkillinfoUpdate {
    fn id(&self) -> &str {
       "0x029e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzMerCommand {
    pub fn from(buffer: &[u8]) -> PacketCzMerCommand {
        PacketCzMerCommand {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            command: i8::from_le_bytes([buffer[2]]),
            command_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.command).unwrap();
        self.command_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.command_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_command(&mut self, value: i8) {
        self.command = value;
    }
    pub fn set_command_raw(&mut self, value: [u8; 1]) {
        self.command_raw = value;
    }
    pub fn new() -> PacketCzMerCommand {
        PacketCzMerCommand {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x29, 0xf]),
        packet_id_raw: [0x29, 0xf],
        command: 0,
        command_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzMerCommand {
    fn id(&self) -> &str {
       "0x029f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl UnusedPacketCzMerUseSkill {
    pub fn from(buffer: &[u8]) -> UnusedPacketCzMerUseSkill {
        UnusedPacketCzMerUseSkill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            selected_level: i16::from_le_bytes([buffer[2], buffer[3]]),
            selected_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            skid: u16::from_le_bytes([buffer[4], buffer[5]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            target_id: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.selected_level).unwrap();
        self.selected_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.selected_level_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.target_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_selected_level(&mut self, value: i16) {
        self.selected_level = value;
    }
    pub fn set_selected_level_raw(&mut self, value: [u8; 2]) {
        self.selected_level_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_target_id(&mut self, value: u32) {
        self.target_id = value;
    }
    pub fn set_target_id_raw(&mut self, value: [u8; 4]) {
        self.target_id_raw = value;
    }
    pub fn new() -> UnusedPacketCzMerUseSkill {
        UnusedPacketCzMerUseSkill {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2a, 0x0]),
        packet_id_raw: [0x2a, 0x0],
        selected_level: 0,
        selected_level_raw: [0; 2],
        skid: 0,
        skid_raw: [0; 2],
        target_id: 0,
        target_id_raw: [0; 4],
        }
    }
}

impl Packet for UnusedPacketCzMerUseSkill {
    fn id(&self) -> &str {
       "0x02a0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl UnusedPacketCzMerUpgradeSkilllevel {
    pub fn from(buffer: &[u8]) -> UnusedPacketCzMerUpgradeSkilllevel {
        UnusedPacketCzMerUpgradeSkilllevel {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn new() -> UnusedPacketCzMerUpgradeSkilllevel {
        UnusedPacketCzMerUpgradeSkilllevel {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2a, 0x1]),
        packet_id_raw: [0x2a, 0x1],
        skid: 0,
        skid_raw: [0; 2],
        }
    }
}

impl Packet for UnusedPacketCzMerUpgradeSkilllevel {
    fn id(&self) -> &str {
       "0x02a1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMerParChange {
    pub fn from(buffer: &[u8]) -> PacketZcMerParChange {
        PacketZcMerParChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            var: u16::from_le_bytes([buffer[2], buffer[3]]),
            var_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            value: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var).unwrap();
        self.var_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.var_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_var(&mut self, value: u16) {
        self.var = value;
    }
    pub fn set_var_raw(&mut self, value: [u8; 2]) {
        self.var_raw = value;
    }
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new() -> PacketZcMerParChange {
        PacketZcMerParChange {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2a, 0x2]),
        packet_id_raw: [0x2a, 0x2],
        var: 0,
        var_raw: [0; 2],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcMerParChange {
    fn id(&self) -> &str {
       "0x02a2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcGameguardLingoKey {
    pub fn from(buffer: &[u8]) -> PacketZcGameguardLingoKey {
        PacketZcGameguardLingoKey {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            lingo_key: PggLingoKeyTemp::from(&buffer[2..buffer.len()]),
            lingo_key_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.lingo_key.fill_raw();
        self.lingo_key_raw = self.lingo_key.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.lingo_key_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_lingo_key(&mut self, value: PggLingoKeyTemp) {
        self.lingo_key = value;
    }
    pub fn set_lingo_key_raw(&mut self, value: Vec<u8>) {
        self.lingo_key_raw = value;
    }
    pub fn new() -> PacketZcGameguardLingoKey {
        PacketZcGameguardLingoKey {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2a, 0x3]),
        packet_id_raw: [0x2a, 0x3],
        lingo_key: PggLingoKeyTemp::new(),
        lingo_key_raw: vec![],
        }
    }
}

impl Packet for PacketZcGameguardLingoKey {
    fn id(&self) -> &str {
       "0x02a3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzKsyEvent {
    pub fn from(buffer: &[u8]) -> PacketCzKsyEvent {
        PacketCzKsyEvent {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketCzKsyEvent {
        PacketCzKsyEvent {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2a, 0x5]),
        packet_id_raw: [0x2a, 0x5],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzKsyEvent {
    fn id(&self) -> &str {
       "0x02a5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcReqCashPassword {
    pub fn from(buffer: &[u8]) -> PacketZcReqCashPassword {
        PacketZcReqCashPassword {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            info: i16::from_le_bytes([buffer[2], buffer[3]]),
            info_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.info).unwrap();
        self.info_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_info(&mut self, value: i16) {
        self.info = value;
    }
    pub fn set_info_raw(&mut self, value: [u8; 2]) {
        self.info_raw = value;
    }
    pub fn new() -> PacketZcReqCashPassword {
        PacketZcReqCashPassword {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2a, 0xa]),
        packet_id_raw: [0x2a, 0xa],
        info: 0,
        info_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcReqCashPassword {
    fn id(&self) -> &str {
       "0x02aa"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzAckCashPassword {
    pub fn from(buffer: &[u8]) -> PacketCzAckCashPassword {
        PacketCzAckCashPassword {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            password:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[4..20].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            password_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[4..20]);
                dst
            },
            new_password:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[20..36].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            new_password_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[20..36]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.password {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.password_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.new_password {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.new_password_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.password_raw.to_vec());
        wtr.append(&mut self.new_password_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn set_password(&mut self, value: [char; 16]) {
        self.password = value;
    }
    pub fn set_password_raw(&mut self, value: [u8; 16]) {
        self.password_raw = value;
    }
    pub fn set_new_password(&mut self, value: [char; 16]) {
        self.new_password = value;
    }
    pub fn set_new_password_raw(&mut self, value: [u8; 16]) {
        self.new_password_raw = value;
    }
    pub fn new() -> PacketCzAckCashPassword {
        PacketCzAckCashPassword {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2a, 0xb]),
        packet_id_raw: [0x2a, 0xb],
        atype: 0,
        atype_raw: [0; 2],
        password: [0 as char; 16],
        password_raw: [0; 16],
        new_password: [0 as char; 16],
        new_password_raw: [0; 16],
        }
    }
}

impl Packet for PacketCzAckCashPassword {
    fn id(&self) -> &str {
       "0x02ab"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcResultCashPassword {
    pub fn from(buffer: &[u8]) -> PacketZcResultCashPassword {
        PacketZcResultCashPassword {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            error_count: i16::from_le_bytes([buffer[4], buffer[5]]),
            error_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_count).unwrap();
        self.error_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.error_count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn set_error_count(&mut self, value: i16) {
        self.error_count = value;
    }
    pub fn set_error_count_raw(&mut self, value: [u8; 2]) {
        self.error_count_raw = value;
    }
    pub fn new() -> PacketZcResultCashPassword {
        PacketZcResultCashPassword {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2a, 0xc]),
        packet_id_raw: [0x2a, 0xc],
        result: 0,
        result_raw: [0; 2],
        error_count: 0,
        error_count_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcResultCashPassword {
    fn id(&self) -> &str {
       "0x02ac"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcRequestSecondPassword {
    pub fn from(buffer: &[u8]) -> PacketAcRequestSecondPassword {
        PacketAcRequestSecondPassword {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            dw_seed: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            dw_seed_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_seed).unwrap();
        self.dw_seed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.dw_seed_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn set_dw_seed(&mut self, value: u32) {
        self.dw_seed = value;
    }
    pub fn set_dw_seed_raw(&mut self, value: [u8; 4]) {
        self.dw_seed_raw = value;
    }
    pub fn new() -> PacketAcRequestSecondPassword {
        PacketAcRequestSecondPassword {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2a, 0xd]),
        packet_id_raw: [0x2a, 0xd],
        result: 0,
        result_raw: [0; 2],
        dw_seed: 0,
        dw_seed_raw: [0; 4],
        }
    }
}

impl Packet for PacketAcRequestSecondPassword {
    fn id(&self) -> &str {
       "0x02ad"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCaLoginHan {
    pub fn from(buffer: &[u8]) -> PacketCaLoginHan {
        PacketCaLoginHan {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            version: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            id:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            passwd:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[30..54].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[30..54]);
                dst
            },
            clienttype: u8::from_le_bytes([buffer[54]]),
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[54..55]);
                dst
            },
            m_sz_ip:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[55..71].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            m_sz_ip_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[55..71]);
                dst
            },
            m_sz_mac_addr:  {
                let mut dst: [char; 13] = [0 as char; 13];
                for (index, byte) in buffer[71..84].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            m_sz_mac_addr_raw: {
                let mut dst: [u8; 13] = [0u8; 13];
                dst.clone_from_slice(&buffer[71..84]);
                dst
            },
            is_han_game_user: u8::from_le_bytes([buffer[84]]),
            is_han_game_user_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[84..85]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_sz_ip {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_sz_ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_sz_mac_addr {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_sz_mac_addr_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_han_game_user).unwrap();
        self.is_han_game_user_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.version_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.passwd_raw.to_vec());
        wtr.append(&mut self.clienttype_raw.to_vec());
        wtr.append(&mut self.m_sz_ip_raw.to_vec());
        wtr.append(&mut self.m_sz_mac_addr_raw.to_vec());
        wtr.append(&mut self.is_han_game_user_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_version(&mut self, value: u32) {
        self.version = value;
    }
    pub fn set_version_raw(&mut self, value: [u8; 4]) {
        self.version_raw = value;
    }
    pub fn set_id(&mut self, value: [char; 24]) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 24]) {
        self.id_raw = value;
    }
    pub fn set_passwd(&mut self, value: [char; 24]) {
        self.passwd = value;
    }
    pub fn set_passwd_raw(&mut self, value: [u8; 24]) {
        self.passwd_raw = value;
    }
    pub fn set_clienttype(&mut self, value: u8) {
        self.clienttype = value;
    }
    pub fn set_clienttype_raw(&mut self, value: [u8; 1]) {
        self.clienttype_raw = value;
    }
    pub fn set_m_sz_ip(&mut self, value: [char; 16]) {
        self.m_sz_ip = value;
    }
    pub fn set_m_sz_ip_raw(&mut self, value: [u8; 16]) {
        self.m_sz_ip_raw = value;
    }
    pub fn set_m_sz_mac_addr(&mut self, value: [char; 13]) {
        self.m_sz_mac_addr = value;
    }
    pub fn set_m_sz_mac_addr_raw(&mut self, value: [u8; 13]) {
        self.m_sz_mac_addr_raw = value;
    }
    pub fn set_is_han_game_user(&mut self, value: u8) {
        self.is_han_game_user = value;
    }
    pub fn set_is_han_game_user_raw(&mut self, value: [u8; 1]) {
        self.is_han_game_user_raw = value;
    }
    pub fn new() -> PacketCaLoginHan {
        PacketCaLoginHan {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2b, 0x0]),
        packet_id_raw: [0x2b, 0x0],
        version: 0,
        version_raw: [0; 4],
        id: [0 as char; 24],
        id_raw: [0; 24],
        passwd: [0 as char; 24],
        passwd_raw: [0; 24],
        clienttype: 0,
        clienttype_raw: [0; 1],
        m_sz_ip: [0 as char; 16],
        m_sz_ip_raw: [0; 16],
        m_sz_mac_addr: [0 as char; 13],
        m_sz_mac_addr_raw: [0; 13],
        is_han_game_user: 0,
        is_han_game_user_raw: [0; 1],
        }
    }
}

impl Packet for PacketCaLoginHan {
    fn id(&self) -> &str {
       "0x02b0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAllQuestList {
    pub fn from(buffer: &[u8]) -> PacketZcAllQuestList {
        let iter_count = (&buffer.len() - 8) / 5;
        let mut vec_field: Vec<PacketZcQuestInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (5 * (i - 1));
            let end_pos = 8 + 5 * i;
            vec_field.push(PacketZcQuestInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcAllQuestList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            quest_count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            quest_count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            quest_list: vec_field.clone(),
            quest_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.quest_count).unwrap();
        self.quest_count_raw = wtr.try_into().unwrap();
        self.quest_list_raw = {
            self.quest_list.iter_mut().for_each(|item| item.fill_raw());
            self.quest_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.quest_count_raw.to_vec());
        self.quest_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_quest_count(&mut self, value: i32) {
        self.quest_count = value;
    }
    pub fn set_quest_count_raw(&mut self, value: [u8; 4]) {
        self.quest_count_raw = value;
    }
    pub fn set_quest_list(&mut self, value: Vec<PacketZcQuestInfo>) {
        self.quest_list = value;
    }
    pub fn set_quest_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.quest_list_raw = value;
    }
    pub fn new() -> PacketZcAllQuestList {
        PacketZcAllQuestList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2b, 0x1]),
        packet_id_raw: [0x2b, 0x1],
        packet_length: 0,
        packet_length_raw: [0; 2],
        quest_count: 0,
        quest_count_raw: [0; 4],
        quest_list: vec![],
        quest_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcAllQuestList {
    fn id(&self) -> &str {
       "0x02b1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAllQuestMission {
    pub fn from(buffer: &[u8]) -> PacketZcAllQuestMission {
        let iter_count = (&buffer.len() - 8) / 104;
        let mut vec_field: Vec<PacketZcQuestMissionInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (104 * (i - 1));
            let end_pos = 8 + 104 * i;
            vec_field.push(PacketZcQuestMissionInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcAllQuestMission {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            quest_mission_list: vec_field.clone(),
            quest_mission_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        self.quest_mission_list_raw = {
            self.quest_mission_list.iter_mut().for_each(|item| item.fill_raw());
            self.quest_mission_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.quest_mission_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn set_quest_mission_list(&mut self, value: Vec<PacketZcQuestMissionInfo>) {
        self.quest_mission_list = value;
    }
    pub fn set_quest_mission_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.quest_mission_list_raw = value;
    }
    pub fn new() -> PacketZcAllQuestMission {
        PacketZcAllQuestMission {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2b, 0x2]),
        packet_id_raw: [0x2b, 0x2],
        packet_length: 0,
        packet_length_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        quest_mission_list: vec![],
        quest_mission_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcAllQuestMission {
    fn id(&self) -> &str {
       "0x02b2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAddQuest {
    pub fn from(buffer: &[u8]) -> PacketZcAddQuest {
        let iter_count = (&buffer.len() - 17) / 30;
        let mut vec_field: Vec<PacketZcMissionHunt> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 17 + (30 * (i - 1));
            let end_pos = 17 + 30 * i;
            vec_field.push(PacketZcMissionHunt::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcAddQuest {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            quest_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            active: buffer[6] == 1,
            active_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            quest_svr_time: i32::from_le_bytes([buffer[7], buffer[8], buffer[9], buffer[10]]),
            quest_svr_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[7..11]);
                dst
            },
            quest_end_time: i32::from_le_bytes([buffer[11], buffer[12], buffer[13], buffer[14]]),
            quest_end_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[11..15]);
                dst
            },
            count: i16::from_le_bytes([buffer[15], buffer[16]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[15..17]);
                dst
            },
            hunt: vec_field.clone(),
            hunt_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.active as u8).unwrap();
        self.active_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.quest_svr_time).unwrap();
        self.quest_svr_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.quest_end_time).unwrap();
        self.quest_end_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        self.hunt_raw = {
            self.hunt.iter_mut().for_each(|item| item.fill_raw());
            self.hunt.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.quest_id_raw.to_vec());
        wtr.append(&mut self.active_raw.to_vec());
        wtr.append(&mut self.quest_svr_time_raw.to_vec());
        wtr.append(&mut self.quest_end_time_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.hunt.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_quest_id(&mut self, value: u32) {
        self.quest_id = value;
    }
    pub fn set_quest_id_raw(&mut self, value: [u8; 4]) {
        self.quest_id_raw = value;
    }
    pub fn set_active(&mut self, value: bool) {
        self.active = value;
    }
    pub fn set_active_raw(&mut self, value: [u8; 1]) {
        self.active_raw = value;
    }
    pub fn set_quest_svr_time(&mut self, value: i32) {
        self.quest_svr_time = value;
    }
    pub fn set_quest_svr_time_raw(&mut self, value: [u8; 4]) {
        self.quest_svr_time_raw = value;
    }
    pub fn set_quest_end_time(&mut self, value: i32) {
        self.quest_end_time = value;
    }
    pub fn set_quest_end_time_raw(&mut self, value: [u8; 4]) {
        self.quest_end_time_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_hunt(&mut self, value: Vec<PacketZcMissionHunt>) {
        self.hunt = value;
    }
    pub fn set_hunt_raw(&mut self, value: Vec<Vec<u8>>) {
        self.hunt_raw = value;
    }
    pub fn new() -> PacketZcAddQuest {
        PacketZcAddQuest {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2b, 0x3]),
        packet_id_raw: [0x2b, 0x3],
        quest_id: 0,
        quest_id_raw: [0; 4],
        active: false,
        active_raw: [0; 1],
        quest_svr_time: 0,
        quest_svr_time_raw: [0; 4],
        quest_end_time: 0,
        quest_end_time_raw: [0; 4],
        count: 0,
        count_raw: [0; 2],
        hunt: vec![],
        hunt_raw: vec![],
        }
    }
}

impl Packet for PacketZcAddQuest {
    fn id(&self) -> &str {
       "0x02b3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcDelQuest {
    pub fn from(buffer: &[u8]) -> PacketZcDelQuest {
        PacketZcDelQuest {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            quest_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.quest_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_quest_id(&mut self, value: u32) {
        self.quest_id = value;
    }
    pub fn set_quest_id_raw(&mut self, value: [u8; 4]) {
        self.quest_id_raw = value;
    }
    pub fn new() -> PacketZcDelQuest {
        PacketZcDelQuest {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2b, 0x4]),
        packet_id_raw: [0x2b, 0x4],
        quest_id: 0,
        quest_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDelQuest {
    fn id(&self) -> &str {
       "0x02b4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcUpdateMissionHunt {
    pub fn from(buffer: &[u8]) -> PacketZcUpdateMissionHunt {
        let iter_count = (&buffer.len() - 6) / 12;
        let mut vec_field: Vec<PacketMobHunting> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 6 + (12 * (i - 1));
            let end_pos = 6 + 12 * i;
            vec_field.push(PacketMobHunting::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcUpdateMissionHunt {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            mob_hunt_list: vec_field.clone(),
            mob_hunt_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        self.mob_hunt_list_raw = {
            self.mob_hunt_list.iter_mut().for_each(|item| item.fill_raw());
            self.mob_hunt_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.mob_hunt_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_mob_hunt_list(&mut self, value: Vec<PacketMobHunting>) {
        self.mob_hunt_list = value;
    }
    pub fn set_mob_hunt_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.mob_hunt_list_raw = value;
    }
    pub fn new() -> PacketZcUpdateMissionHunt {
        PacketZcUpdateMissionHunt {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2b, 0x5]),
        packet_id_raw: [0x2b, 0x5],
        packet_length: 0,
        packet_length_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        mob_hunt_list: vec![],
        mob_hunt_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcUpdateMissionHunt {
    fn id(&self) -> &str {
       "0x02b5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzActiveQuest {
    pub fn from(buffer: &[u8]) -> PacketCzActiveQuest {
        PacketCzActiveQuest {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            quest_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            active: buffer[6] == 1,
            active_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.active as u8).unwrap();
        self.active_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.quest_id_raw.to_vec());
        wtr.append(&mut self.active_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_quest_id(&mut self, value: u32) {
        self.quest_id = value;
    }
    pub fn set_quest_id_raw(&mut self, value: [u8; 4]) {
        self.quest_id_raw = value;
    }
    pub fn set_active(&mut self, value: bool) {
        self.active = value;
    }
    pub fn set_active_raw(&mut self, value: [u8; 1]) {
        self.active_raw = value;
    }
    pub fn new() -> PacketCzActiveQuest {
        PacketCzActiveQuest {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2b, 0x6]),
        packet_id_raw: [0x2b, 0x6],
        quest_id: 0,
        quest_id_raw: [0; 4],
        active: false,
        active_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzActiveQuest {
    fn id(&self) -> &str {
       "0x02b6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcActiveQuest {
    pub fn from(buffer: &[u8]) -> PacketZcActiveQuest {
        PacketZcActiveQuest {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            quest_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            active: buffer[6] == 1,
            active_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.active as u8).unwrap();
        self.active_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.quest_id_raw.to_vec());
        wtr.append(&mut self.active_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_quest_id(&mut self, value: u32) {
        self.quest_id = value;
    }
    pub fn set_quest_id_raw(&mut self, value: [u8; 4]) {
        self.quest_id_raw = value;
    }
    pub fn set_active(&mut self, value: bool) {
        self.active = value;
    }
    pub fn set_active_raw(&mut self, value: [u8; 1]) {
        self.active_raw = value;
    }
    pub fn new() -> PacketZcActiveQuest {
        PacketZcActiveQuest {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2b, 0x7]),
        packet_id_raw: [0x2b, 0x7],
        quest_id: 0,
        quest_id_raw: [0; 4],
        active: false,
        active_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcActiveQuest {
    fn id(&self) -> &str {
       "0x02b7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcItemPickupParty {
    pub fn from(buffer: &[u8]) -> PacketZcItemPickupParty {
        PacketZcItemPickupParty {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            account_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            itid: u16::from_le_bytes([buffer[6], buffer[7]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            is_identified: buffer[8] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            is_damaged: buffer[9] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[10]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[11..19]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[11..19]);
                dst
            },
            location: u16::from_le_bytes([buffer[19], buffer[20]]),
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            atype: u8::from_le_bytes([buffer[21]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[21..22]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.account_id_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        wtr.append(&mut self.location_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_account_id(&mut self, value: u32) {
        self.account_id = value;
    }
    pub fn set_account_id_raw(&mut self, value: [u8; 4]) {
        self.account_id_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn set_location(&mut self, value: u16) {
        self.location = value;
    }
    pub fn set_location_raw(&mut self, value: [u8; 2]) {
        self.location_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketZcItemPickupParty {
        PacketZcItemPickupParty {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2b, 0x8]),
        packet_id_raw: [0x2b, 0x8],
        account_id: 0,
        account_id_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        location: 0,
        location_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcItemPickupParty {
    fn id(&self) -> &str {
       "0x02b8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcShortcutKeyList {
    pub fn from(buffer: &[u8]) -> PacketZcShortcutKeyList {
        let iter_count = (&buffer.len() - 2) / 7;
        let mut vec_field: Vec<ShortCutKey> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 2 + (7 * (i - 1));
            let end_pos = 2 + 7 * i;
            vec_field.push(ShortCutKey::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcShortcutKeyList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            short_cut_key: vec_field.clone(),
            short_cut_key_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.short_cut_key_raw = {
            self.short_cut_key.iter_mut().for_each(|item| item.fill_raw());
            self.short_cut_key.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.short_cut_key.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_short_cut_key(&mut self, value: Vec<ShortCutKey>) {
        self.short_cut_key = value;
    }
    pub fn set_short_cut_key_raw(&mut self, value: Vec<Vec<u8>>) {
        self.short_cut_key_raw = value;
    }
    pub fn new() -> PacketZcShortcutKeyList {
        PacketZcShortcutKeyList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2b, 0x9]),
        packet_id_raw: [0x2b, 0x9],
        short_cut_key: vec![],
        short_cut_key_raw: vec![],
        }
    }
}

impl Packet for PacketZcShortcutKeyList {
    fn id(&self) -> &str {
       "0x02b9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzShortcutKeyChange {
    pub fn from(buffer: &[u8]) -> PacketCzShortcutKeyChange {
        PacketCzShortcutKeyChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            short_cut_key: ShortCutKey::from(&buffer[4..buffer.len()]),
            short_cut_key_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        self.short_cut_key.fill_raw();
        self.short_cut_key_raw = self.short_cut_key.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.short_cut_key_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_short_cut_key(&mut self, value: ShortCutKey) {
        self.short_cut_key = value;
    }
    pub fn set_short_cut_key_raw(&mut self, value: Vec<u8>) {
        self.short_cut_key_raw = value;
    }
    pub fn new() -> PacketCzShortcutKeyChange {
        PacketCzShortcutKeyChange {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2b, 0xa]),
        packet_id_raw: [0x2b, 0xa],
        index: 0,
        index_raw: [0; 2],
        short_cut_key: ShortCutKey::new(),
        short_cut_key_raw: vec![],
        }
    }
}

impl Packet for PacketCzShortcutKeyChange {
    fn id(&self) -> &str {
       "0x02ba"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcEquipitemDamaged {
    pub fn from(buffer: &[u8]) -> PacketZcEquipitemDamaged {
        PacketZcEquipitemDamaged {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            wear_location: u16::from_le_bytes([buffer[2], buffer[3]]),
            wear_location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            account_id: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_location).unwrap();
        self.wear_location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.wear_location_raw.to_vec());
        wtr.append(&mut self.account_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_wear_location(&mut self, value: u16) {
        self.wear_location = value;
    }
    pub fn set_wear_location_raw(&mut self, value: [u8; 2]) {
        self.wear_location_raw = value;
    }
    pub fn set_account_id(&mut self, value: u32) {
        self.account_id = value;
    }
    pub fn set_account_id_raw(&mut self, value: [u8; 4]) {
        self.account_id_raw = value;
    }
    pub fn new() -> PacketZcEquipitemDamaged {
        PacketZcEquipitemDamaged {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2b, 0xb]),
        packet_id_raw: [0x2b, 0xb],
        wear_location: 0,
        wear_location_raw: [0; 2],
        account_id: 0,
        account_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcEquipitemDamaged {
    fn id(&self) -> &str {
       "0x02bb"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyPcbangPlayingTime {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyPcbangPlayingTime {
        PacketZcNotifyPcbangPlayingTime {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            time_minute: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            time_minute_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.time_minute).unwrap();
        self.time_minute_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.time_minute_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_time_minute(&mut self, value: i32) {
        self.time_minute = value;
    }
    pub fn set_time_minute_raw(&mut self, value: [u8; 4]) {
        self.time_minute_raw = value;
    }
    pub fn new() -> PacketZcNotifyPcbangPlayingTime {
        PacketZcNotifyPcbangPlayingTime {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2b, 0xc]),
        packet_id_raw: [0x2b, 0xc],
        time_minute: 0,
        time_minute_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyPcbangPlayingTime {
    fn id(&self) -> &str {
       "0x02bc"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSrpacketr2Init {
    pub fn from(buffer: &[u8]) -> PacketZcSrpacketr2Init {
        PacketZcSrpacketr2Init {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            protect_factor: u16::from_le_bytes([buffer[2], buffer[3]]),
            protect_factor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            deform_seed_factor: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            deform_seed_factor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            deform_add_factor: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            deform_add_factor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.protect_factor).unwrap();
        self.protect_factor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.deform_seed_factor).unwrap();
        self.deform_seed_factor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.deform_add_factor).unwrap();
        self.deform_add_factor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.protect_factor_raw.to_vec());
        wtr.append(&mut self.deform_seed_factor_raw.to_vec());
        wtr.append(&mut self.deform_add_factor_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_protect_factor(&mut self, value: u16) {
        self.protect_factor = value;
    }
    pub fn set_protect_factor_raw(&mut self, value: [u8; 2]) {
        self.protect_factor_raw = value;
    }
    pub fn set_deform_seed_factor(&mut self, value: u32) {
        self.deform_seed_factor = value;
    }
    pub fn set_deform_seed_factor_raw(&mut self, value: [u8; 4]) {
        self.deform_seed_factor_raw = value;
    }
    pub fn set_deform_add_factor(&mut self, value: u32) {
        self.deform_add_factor = value;
    }
    pub fn set_deform_add_factor_raw(&mut self, value: [u8; 4]) {
        self.deform_add_factor_raw = value;
    }
    pub fn new() -> PacketZcSrpacketr2Init {
        PacketZcSrpacketr2Init {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2b, 0xf]),
        packet_id_raw: [0x2b, 0xf],
        protect_factor: 0,
        protect_factor_raw: [0; 2],
        deform_seed_factor: 0,
        deform_seed_factor_raw: [0; 4],
        deform_add_factor: 0,
        deform_add_factor_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcSrpacketr2Init {
    fn id(&self) -> &str {
       "0x02bf"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzSrpacketr2Start {
    pub fn from(buffer: &[u8]) -> PacketCzSrpacketr2Start {
        PacketCzSrpacketr2Start {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            protect_factor: u16::from_le_bytes([buffer[2], buffer[3]]),
            protect_factor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.protect_factor).unwrap();
        self.protect_factor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.protect_factor_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_protect_factor(&mut self, value: u16) {
        self.protect_factor = value;
    }
    pub fn set_protect_factor_raw(&mut self, value: [u8; 2]) {
        self.protect_factor_raw = value;
    }
    pub fn new() -> PacketCzSrpacketr2Start {
        PacketCzSrpacketr2Start {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2c, 0x0]),
        packet_id_raw: [0x2c, 0x0],
        protect_factor: 0,
        protect_factor_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzSrpacketr2Start {
    fn id(&self) -> &str {
       "0x02c0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNpcChat {
    pub fn from(buffer: &[u8]) -> PacketZcNpcChat {
        PacketZcNpcChat {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            account_id: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            color: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            color_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[12..buffer.len()]).to_string(),
            msg_raw: buffer[12..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.color).unwrap();
        self.color_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.account_id_raw.to_vec());
        wtr.append(&mut self.color_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_account_id(&mut self, value: u32) {
        self.account_id = value;
    }
    pub fn set_account_id_raw(&mut self, value: [u8; 4]) {
        self.account_id_raw = value;
    }
    pub fn set_color(&mut self, value: u32) {
        self.color = value;
    }
    pub fn set_color_raw(&mut self, value: [u8; 4]) {
        self.color_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketZcNpcChat {
        PacketZcNpcChat {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2c, 0x1]),
        packet_id_raw: [0x2c, 0x1],
        packet_length: 0,
        packet_length_raw: [0; 2],
        account_id: 0,
        account_id_raw: [0; 4],
        color: 0,
        color_raw: [0; 4],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcNpcChat {
    fn id(&self) -> &str {
       "0x02c1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcFormatstringMsg {
    pub fn from(buffer: &[u8]) -> PacketZcFormatstringMsg {
        PacketZcFormatstringMsg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: u16::from_le_bytes([buffer[4], buffer[5]]),
            msg_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            value: String::from_utf8_lossy(&buffer[6..buffer.len()]).to_string(),
            value_raw: buffer[6..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.msg).unwrap();
        self.msg_raw = wtr.try_into().unwrap();
        self.value_raw = self.value.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: u16) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: [u8; 2]) {
        self.msg_raw = value;
    }
    pub fn set_value(&mut self, value: String) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: Vec<u8>) {
        self.value_raw = value;
    }
    pub fn new() -> PacketZcFormatstringMsg {
        PacketZcFormatstringMsg {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2c, 0x2]),
        packet_id_raw: [0x2c, 0x2],
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: 0,
        msg_raw: [0; 2],
        value: String::new(),
        value_raw: vec![],
        }
    }
}

impl Packet for PacketZcFormatstringMsg {
    fn id(&self) -> &str {
       "0x02c2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzPartyJoinReq {
    pub fn from(buffer: &[u8]) -> PacketCzPartyJoinReq {
        PacketCzPartyJoinReq {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn new() -> PacketCzPartyJoinReq {
        PacketCzPartyJoinReq {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2c, 0x4]),
        packet_id_raw: [0x2c, 0x4],
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzPartyJoinReq {
    fn id(&self) -> &str {
       "0x02c4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPartyJoinReqAck {
    pub fn from(buffer: &[u8]) -> PacketZcPartyJoinReqAck {
        PacketZcPartyJoinReqAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            answer: i32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            answer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        wtr.append(&mut self.answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn set_answer(&mut self, value: i32) {
        self.answer = value;
    }
    pub fn set_answer_raw(&mut self, value: [u8; 4]) {
        self.answer_raw = value;
    }
    pub fn new() -> PacketZcPartyJoinReqAck {
        PacketZcPartyJoinReqAck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2c, 0x5]),
        packet_id_raw: [0x2c, 0x5],
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        answer: 0,
        answer_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcPartyJoinReqAck {
    fn id(&self) -> &str {
       "0x02c5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPartyJoinReq {
    pub fn from(buffer: &[u8]) -> PacketZcPartyJoinReq {
        PacketZcPartyJoinReq {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            grid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            grid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            group_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.grid).unwrap();
        self.grid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.grid_raw.to_vec());
        wtr.append(&mut self.group_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_grid(&mut self, value: u32) {
        self.grid = value;
    }
    pub fn set_grid_raw(&mut self, value: [u8; 4]) {
        self.grid_raw = value;
    }
    pub fn set_group_name(&mut self, value: [char; 24]) {
        self.group_name = value;
    }
    pub fn set_group_name_raw(&mut self, value: [u8; 24]) {
        self.group_name_raw = value;
    }
    pub fn new() -> PacketZcPartyJoinReq {
        PacketZcPartyJoinReq {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2c, 0x6]),
        packet_id_raw: [0x2c, 0x6],
        grid: 0,
        grid_raw: [0; 4],
        group_name: [0 as char; 24],
        group_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcPartyJoinReq {
    fn id(&self) -> &str {
       "0x02c6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzPartyJoinReqAck {
    pub fn from(buffer: &[u8]) -> PacketCzPartyJoinReqAck {
        PacketCzPartyJoinReqAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            grid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            grid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            b_accept: buffer[6] == 1,
            b_accept_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.grid).unwrap();
        self.grid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.b_accept as u8).unwrap();
        self.b_accept_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.grid_raw.to_vec());
        wtr.append(&mut self.b_accept_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_grid(&mut self, value: u32) {
        self.grid = value;
    }
    pub fn set_grid_raw(&mut self, value: [u8; 4]) {
        self.grid_raw = value;
    }
    pub fn set_b_accept(&mut self, value: bool) {
        self.b_accept = value;
    }
    pub fn set_b_accept_raw(&mut self, value: [u8; 1]) {
        self.b_accept_raw = value;
    }
    pub fn new() -> PacketCzPartyJoinReqAck {
        PacketCzPartyJoinReqAck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2c, 0x7]),
        packet_id_raw: [0x2c, 0x7],
        grid: 0,
        grid_raw: [0; 4],
        b_accept: false,
        b_accept_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzPartyJoinReqAck {
    fn id(&self) -> &str {
       "0x02c7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzPartyConfig {
    pub fn from(buffer: &[u8]) -> PacketCzPartyConfig {
        PacketCzPartyConfig {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            b_refuse_join_msg: buffer[2] == 1,
            b_refuse_join_msg_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.b_refuse_join_msg as u8).unwrap();
        self.b_refuse_join_msg_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.b_refuse_join_msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_b_refuse_join_msg(&mut self, value: bool) {
        self.b_refuse_join_msg = value;
    }
    pub fn set_b_refuse_join_msg_raw(&mut self, value: [u8; 1]) {
        self.b_refuse_join_msg_raw = value;
    }
    pub fn new() -> PacketCzPartyConfig {
        PacketCzPartyConfig {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2c, 0x8]),
        packet_id_raw: [0x2c, 0x8],
        b_refuse_join_msg: false,
        b_refuse_join_msg_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzPartyConfig {
    fn id(&self) -> &str {
       "0x02c8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPartyConfig {
    pub fn from(buffer: &[u8]) -> PacketZcPartyConfig {
        PacketZcPartyConfig {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            b_refuse_join_msg: buffer[2] == 1,
            b_refuse_join_msg_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.b_refuse_join_msg as u8).unwrap();
        self.b_refuse_join_msg_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.b_refuse_join_msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_b_refuse_join_msg(&mut self, value: bool) {
        self.b_refuse_join_msg = value;
    }
    pub fn set_b_refuse_join_msg_raw(&mut self, value: [u8; 1]) {
        self.b_refuse_join_msg_raw = value;
    }
    pub fn new() -> PacketZcPartyConfig {
        PacketZcPartyConfig {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2c, 0x9]),
        packet_id_raw: [0x2c, 0x9],
        b_refuse_join_msg: false,
        b_refuse_join_msg_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcPartyConfig {
    fn id(&self) -> &str {
       "0x02c9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcRefuseSelectchar {
    pub fn from(buffer: &[u8]) -> PacketHcRefuseSelectchar {
        PacketHcRefuseSelectchar {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: u8::from_le_bytes([buffer[2]]),
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u8) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 1]) {
        self.error_code_raw = value;
    }
    pub fn new() -> PacketHcRefuseSelectchar {
        PacketHcRefuseSelectchar {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2c, 0xa]),
        packet_id_raw: [0x2c, 0xa],
        error_code: 0,
        error_code_raw: [0; 1],
        }
    }
}

impl Packet for PacketHcRefuseSelectchar {
    fn id(&self) -> &str {
       "0x02ca"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMemorialdungeonSubscriptionInfo {
    pub fn from(buffer: &[u8]) -> PacketZcMemorialdungeonSubscriptionInfo {
        PacketZcMemorialdungeonSubscriptionInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            memorial_dungeon_name:  {
                let mut dst: [char; 61] = [0 as char; 61];
                for (index, byte) in buffer[2..63].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            memorial_dungeon_name_raw: {
                let mut dst: [u8; 61] = [0u8; 61];
                dst.clone_from_slice(&buffer[2..63]);
                dst
            },
            priority_order_num: i16::from_le_bytes([buffer[63], buffer[64]]),
            priority_order_num_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[63..65]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.memorial_dungeon_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.memorial_dungeon_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.priority_order_num).unwrap();
        self.priority_order_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.memorial_dungeon_name_raw.to_vec());
        wtr.append(&mut self.priority_order_num_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_memorial_dungeon_name(&mut self, value: [char; 61]) {
        self.memorial_dungeon_name = value;
    }
    pub fn set_memorial_dungeon_name_raw(&mut self, value: [u8; 61]) {
        self.memorial_dungeon_name_raw = value;
    }
    pub fn set_priority_order_num(&mut self, value: i16) {
        self.priority_order_num = value;
    }
    pub fn set_priority_order_num_raw(&mut self, value: [u8; 2]) {
        self.priority_order_num_raw = value;
    }
    pub fn new() -> PacketZcMemorialdungeonSubscriptionInfo {
        PacketZcMemorialdungeonSubscriptionInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2c, 0xb]),
        packet_id_raw: [0x2c, 0xb],
        memorial_dungeon_name: [0 as char; 61],
        memorial_dungeon_name_raw: [0; 61],
        priority_order_num: 0,
        priority_order_num_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcMemorialdungeonSubscriptionInfo {
    fn id(&self) -> &str {
       "0x02cb"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMemorialdungeonSubscriptionNotify {
    pub fn from(buffer: &[u8]) -> PacketZcMemorialdungeonSubscriptionNotify {
        PacketZcMemorialdungeonSubscriptionNotify {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            priority_order_num: i16::from_le_bytes([buffer[2], buffer[3]]),
            priority_order_num_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.priority_order_num).unwrap();
        self.priority_order_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.priority_order_num_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_priority_order_num(&mut self, value: i16) {
        self.priority_order_num = value;
    }
    pub fn set_priority_order_num_raw(&mut self, value: [u8; 2]) {
        self.priority_order_num_raw = value;
    }
    pub fn new() -> PacketZcMemorialdungeonSubscriptionNotify {
        PacketZcMemorialdungeonSubscriptionNotify {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2c, 0xc]),
        packet_id_raw: [0x2c, 0xc],
        priority_order_num: 0,
        priority_order_num_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcMemorialdungeonSubscriptionNotify {
    fn id(&self) -> &str {
       "0x02cc"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMemorialdungeonInfo {
    pub fn from(buffer: &[u8]) -> PacketZcMemorialdungeonInfo {
        PacketZcMemorialdungeonInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            memorial_dungeon_name:  {
                let mut dst: [char; 61] = [0 as char; 61];
                for (index, byte) in buffer[2..63].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            memorial_dungeon_name_raw: {
                let mut dst: [u8; 61] = [0u8; 61];
                dst.clone_from_slice(&buffer[2..63]);
                dst
            },
            destroy_date: u32::from_le_bytes([buffer[63], buffer[64], buffer[65], buffer[66]]),
            destroy_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[63..67]);
                dst
            },
            enter_time_out_date: u32::from_le_bytes([buffer[67], buffer[68], buffer[69], buffer[70]]),
            enter_time_out_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[67..71]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.memorial_dungeon_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.memorial_dungeon_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.destroy_date).unwrap();
        self.destroy_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.enter_time_out_date).unwrap();
        self.enter_time_out_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.memorial_dungeon_name_raw.to_vec());
        wtr.append(&mut self.destroy_date_raw.to_vec());
        wtr.append(&mut self.enter_time_out_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_memorial_dungeon_name(&mut self, value: [char; 61]) {
        self.memorial_dungeon_name = value;
    }
    pub fn set_memorial_dungeon_name_raw(&mut self, value: [u8; 61]) {
        self.memorial_dungeon_name_raw = value;
    }
    pub fn set_destroy_date(&mut self, value: u32) {
        self.destroy_date = value;
    }
    pub fn set_destroy_date_raw(&mut self, value: [u8; 4]) {
        self.destroy_date_raw = value;
    }
    pub fn set_enter_time_out_date(&mut self, value: u32) {
        self.enter_time_out_date = value;
    }
    pub fn set_enter_time_out_date_raw(&mut self, value: [u8; 4]) {
        self.enter_time_out_date_raw = value;
    }
    pub fn new() -> PacketZcMemorialdungeonInfo {
        PacketZcMemorialdungeonInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2c, 0xd]),
        packet_id_raw: [0x2c, 0xd],
        memorial_dungeon_name: [0 as char; 61],
        memorial_dungeon_name_raw: [0; 61],
        destroy_date: 0,
        destroy_date_raw: [0; 4],
        enter_time_out_date: 0,
        enter_time_out_date_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcMemorialdungeonInfo {
    fn id(&self) -> &str {
       "0x02cd"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMemorialdungeonNotify {
    pub fn from(buffer: &[u8]) -> PacketZcMemorialdungeonNotify {
        PacketZcMemorialdungeonNotify {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            enter_limit_date: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            enter_limit_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.enter_limit_date).unwrap();
        self.enter_limit_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.enter_limit_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn set_enter_limit_date(&mut self, value: u32) {
        self.enter_limit_date = value;
    }
    pub fn set_enter_limit_date_raw(&mut self, value: [u8; 4]) {
        self.enter_limit_date_raw = value;
    }
    pub fn new() -> PacketZcMemorialdungeonNotify {
        PacketZcMemorialdungeonNotify {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2c, 0xe]),
        packet_id_raw: [0x2c, 0xe],
        atype: 0,
        atype_raw: [0; 4],
        enter_limit_date: 0,
        enter_limit_date_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcMemorialdungeonNotify {
    fn id(&self) -> &str {
       "0x02ce"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzMemorialdungeonCommand {
    pub fn from(buffer: &[u8]) -> PacketCzMemorialdungeonCommand {
        PacketCzMemorialdungeonCommand {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            command: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            command_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.command).unwrap();
        self.command_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.command_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_command(&mut self, value: i32) {
        self.command = value;
    }
    pub fn set_command_raw(&mut self, value: [u8; 4]) {
        self.command_raw = value;
    }
    pub fn new() -> PacketCzMemorialdungeonCommand {
        PacketCzMemorialdungeonCommand {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2c, 0xf]),
        packet_id_raw: [0x2c, 0xf],
        command: 0,
        command_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMemorialdungeonCommand {
    fn id(&self) -> &str {
       "0x02cf"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcEquipmentItemlist3 {
    pub fn from(buffer: &[u8]) -> PacketZcEquipmentItemlist3 {
        let iter_count = (&buffer.len() - 4) / 28;
        let mut vec_field: Vec<EquipmentitemExtrainfo301> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (28 * (i - 1));
            let end_pos = 4 + 28 * i;
            vec_field.push(EquipmentitemExtrainfo301::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcEquipmentItemlist3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo301>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new() -> PacketZcEquipmentItemlist3 {
        PacketZcEquipmentItemlist3 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2d, 0x0]),
        packet_id_raw: [0x2d, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcEquipmentItemlist3 {
    fn id(&self) -> &str {
       "0x02d0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcStoreEquipmentItemlist3 {
    pub fn from(buffer: &[u8]) -> PacketZcStoreEquipmentItemlist3 {
        let iter_count = (&buffer.len() - 4) / 28;
        let mut vec_field: Vec<EquipmentitemExtrainfo301> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (28 * (i - 1));
            let end_pos = 4 + 28 * i;
            vec_field.push(EquipmentitemExtrainfo301::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcStoreEquipmentItemlist3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo301>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new() -> PacketZcStoreEquipmentItemlist3 {
        PacketZcStoreEquipmentItemlist3 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2d, 0x1]),
        packet_id_raw: [0x2d, 0x1],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcStoreEquipmentItemlist3 {
    fn id(&self) -> &str {
       "0x02d1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcCartEquipmentItemlist3 {
    pub fn from(buffer: &[u8]) -> PacketZcCartEquipmentItemlist3 {
        let iter_count = (&buffer.len() - 4) / 28;
        let mut vec_field: Vec<EquipmentitemExtrainfo301> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (28 * (i - 1));
            let end_pos = 4 + 28 * i;
            vec_field.push(EquipmentitemExtrainfo301::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcCartEquipmentItemlist3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo301>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new() -> PacketZcCartEquipmentItemlist3 {
        PacketZcCartEquipmentItemlist3 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2d, 0x2]),
        packet_id_raw: [0x2d, 0x2],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcCartEquipmentItemlist3 {
    fn id(&self) -> &str {
       "0x02d2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyBindOnEquip {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyBindOnEquip {
        PacketZcNotifyBindOnEquip {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn new() -> PacketZcNotifyBindOnEquip {
        PacketZcNotifyBindOnEquip {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2d, 0x3]),
        packet_id_raw: [0x2d, 0x3],
        index: 0,
        index_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyBindOnEquip {
    fn id(&self) -> &str {
       "0x02d3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcItemPickupAck3 {
    pub fn from(buffer: &[u8]) -> PacketZcItemPickupAck3 {
        PacketZcItemPickupAck3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: u16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            itid: u16::from_le_bytes([buffer[6], buffer[7]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            is_identified: buffer[8] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            is_damaged: buffer[9] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[10]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[11..19]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[11..19]);
                dst
            },
            location: u16::from_le_bytes([buffer[19], buffer[20]]),
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            atype: u8::from_le_bytes([buffer[21]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[21..22]);
                dst
            },
            result: u8::from_le_bytes([buffer[22]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[22..23]);
                dst
            },
            hire_expire_date: i32::from_le_bytes([buffer[23], buffer[24], buffer[25], buffer[26]]),
            hire_expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[23..27]);
                dst
            },
            bind_on_equip_type: u16::from_le_bytes([buffer[27], buffer[28]]),
            bind_on_equip_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[27..29]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hire_expire_date).unwrap();
        self.hire_expire_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.bind_on_equip_type).unwrap();
        self.bind_on_equip_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        wtr.append(&mut self.location_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.hire_expire_date_raw.to_vec());
        wtr.append(&mut self.bind_on_equip_type_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: u16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn set_location(&mut self, value: u16) {
        self.location = value;
    }
    pub fn set_location_raw(&mut self, value: [u8; 2]) {
        self.location_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn set_hire_expire_date(&mut self, value: i32) {
        self.hire_expire_date = value;
    }
    pub fn set_hire_expire_date_raw(&mut self, value: [u8; 4]) {
        self.hire_expire_date_raw = value;
    }
    pub fn set_bind_on_equip_type(&mut self, value: u16) {
        self.bind_on_equip_type = value;
    }
    pub fn set_bind_on_equip_type_raw(&mut self, value: [u8; 2]) {
        self.bind_on_equip_type_raw = value;
    }
    pub fn new() -> PacketZcItemPickupAck3 {
        PacketZcItemPickupAck3 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2d, 0x4]),
        packet_id_raw: [0x2d, 0x4],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        location: 0,
        location_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        result: 0,
        result_raw: [0; 1],
        hire_expire_date: 0,
        hire_expire_date_raw: [0; 4],
        bind_on_equip_type: 0,
        bind_on_equip_type_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcItemPickupAck3 {
    fn id(&self) -> &str {
       "0x02d4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcIsvrDisconnect {
    pub fn from(buffer: &[u8]) -> PacketZcIsvrDisconnect {
        PacketZcIsvrDisconnect {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketZcIsvrDisconnect {
        PacketZcIsvrDisconnect {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2d, 0x5]),
        packet_id_raw: [0x2d, 0x5],
        }
    }
}

impl Packet for PacketZcIsvrDisconnect {
    fn id(&self) -> &str {
       "0x02d5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzEquipwinMicroscope {
    pub fn from(buffer: &[u8]) -> PacketCzEquipwinMicroscope {
        PacketCzEquipwinMicroscope {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketCzEquipwinMicroscope {
        PacketCzEquipwinMicroscope {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2d, 0x6]),
        packet_id_raw: [0x2d, 0x6],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzEquipwinMicroscope {
    fn id(&self) -> &str {
       "0x02d6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcEquipwinMicroscope {
    pub fn from(buffer: &[u8]) -> PacketZcEquipwinMicroscope {
        let iter_count = (&buffer.len() - 43) / 28;
        let mut vec_field: Vec<EquipmentitemExtrainfo301> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 43 + (28 * (i - 1));
            let end_pos = 43 + 28 * i;
            vec_field.push(EquipmentitemExtrainfo301::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcEquipwinMicroscope {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
            job: i16::from_le_bytes([buffer[28], buffer[29]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            head: i16::from_le_bytes([buffer[30], buffer[31]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[32], buffer[33]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[34], buffer[35]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[36], buffer[37]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[36..38]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[38], buffer[39]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[38..40]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[40], buffer[41]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            sex: u8::from_le_bytes([buffer[42]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[42..43]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo301>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new() -> PacketZcEquipwinMicroscope {
        PacketZcEquipwinMicroscope {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2d, 0x7]),
        packet_id_raw: [0x2d, 0x7],
        packet_length: 0,
        packet_length_raw: [0; 2],
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        accessory: 0,
        accessory_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        sex: 0,
        sex_raw: [0; 1],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcEquipwinMicroscope {
    fn id(&self) -> &str {
       "0x02d7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzConfig {
    pub fn from(buffer: &[u8]) -> PacketCzConfig {
        PacketCzConfig {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            config: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            config_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            value: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.config).unwrap();
        self.config_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.config_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_config(&mut self, value: i32) {
        self.config = value;
    }
    pub fn set_config_raw(&mut self, value: [u8; 4]) {
        self.config_raw = value;
    }
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new() -> PacketCzConfig {
        PacketCzConfig {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2d, 0x8]),
        packet_id_raw: [0x2d, 0x8],
        config: 0,
        config_raw: [0; 4],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzConfig {
    fn id(&self) -> &str {
       "0x02d8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcConfig {
    pub fn from(buffer: &[u8]) -> PacketZcConfig {
        PacketZcConfig {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            config: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            config_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            value: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.config).unwrap();
        self.config_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.config_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_config(&mut self, value: i32) {
        self.config = value;
    }
    pub fn set_config_raw(&mut self, value: [u8; 4]) {
        self.config_raw = value;
    }
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new() -> PacketZcConfig {
        PacketZcConfig {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2d, 0x9]),
        packet_id_raw: [0x2d, 0x9],
        config: 0,
        config_raw: [0; 4],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcConfig {
    fn id(&self) -> &str {
       "0x02d9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcConfigNotify {
    pub fn from(buffer: &[u8]) -> PacketZcConfigNotify {
        PacketZcConfigNotify {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            b_open_equipment_win: buffer[2] == 1,
            b_open_equipment_win_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.b_open_equipment_win as u8).unwrap();
        self.b_open_equipment_win_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.b_open_equipment_win_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_b_open_equipment_win(&mut self, value: bool) {
        self.b_open_equipment_win = value;
    }
    pub fn set_b_open_equipment_win_raw(&mut self, value: [u8; 1]) {
        self.b_open_equipment_win_raw = value;
    }
    pub fn new() -> PacketZcConfigNotify {
        PacketZcConfigNotify {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2d, 0xa]),
        packet_id_raw: [0x2d, 0xa],
        b_open_equipment_win: false,
        b_open_equipment_win_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcConfigNotify {
    fn id(&self) -> &str {
       "0x02da"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzBattlefieldChat {
    pub fn from(buffer: &[u8]) -> PacketCzBattlefieldChat {
        PacketCzBattlefieldChat {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            msg_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketCzBattlefieldChat {
        PacketCzBattlefieldChat {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2d, 0xb]),
        packet_id_raw: [0x2d, 0xb],
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketCzBattlefieldChat {
    fn id(&self) -> &str {
       "0x02db"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcBattlefieldChat {
    pub fn from(buffer: &[u8]) -> PacketZcBattlefieldChat {
        PacketZcBattlefieldChat {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            account_id: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[8..32].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[8..32]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[32..buffer.len()]).to_string(),
            msg_raw: buffer[32..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.account_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_account_id(&mut self, value: u32) {
        self.account_id = value;
    }
    pub fn set_account_id_raw(&mut self, value: [u8; 4]) {
        self.account_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketZcBattlefieldChat {
        PacketZcBattlefieldChat {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2d, 0xc]),
        packet_id_raw: [0x2d, 0xc],
        packet_length: 0,
        packet_length_raw: [0; 2],
        account_id: 0,
        account_id_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcBattlefieldChat {
    fn id(&self) -> &str {
       "0x02dc"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcBattlefieldNotifyCampinfo {
    pub fn from(buffer: &[u8]) -> PacketZcBattlefieldNotifyCampinfo {
        PacketZcBattlefieldNotifyCampinfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            account_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            camp: i16::from_le_bytes([buffer[30], buffer[31]]),
            camp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.camp).unwrap();
        self.camp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.account_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.camp_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_account_id(&mut self, value: u32) {
        self.account_id = value;
    }
    pub fn set_account_id_raw(&mut self, value: [u8; 4]) {
        self.account_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_camp(&mut self, value: i16) {
        self.camp = value;
    }
    pub fn set_camp_raw(&mut self, value: [u8; 2]) {
        self.camp_raw = value;
    }
    pub fn new() -> PacketZcBattlefieldNotifyCampinfo {
        PacketZcBattlefieldNotifyCampinfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2d, 0xd]),
        packet_id_raw: [0x2d, 0xd],
        account_id: 0,
        account_id_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        camp: 0,
        camp_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcBattlefieldNotifyCampinfo {
    fn id(&self) -> &str {
       "0x02dd"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcBattlefieldNotifyPoint {
    pub fn from(buffer: &[u8]) -> PacketZcBattlefieldNotifyPoint {
        PacketZcBattlefieldNotifyPoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            point_camp_a: i16::from_le_bytes([buffer[2], buffer[3]]),
            point_camp_a_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            point_camp_b: i16::from_le_bytes([buffer[4], buffer[5]]),
            point_camp_b_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.point_camp_a).unwrap();
        self.point_camp_a_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.point_camp_b).unwrap();
        self.point_camp_b_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.point_camp_a_raw.to_vec());
        wtr.append(&mut self.point_camp_b_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_point_camp_a(&mut self, value: i16) {
        self.point_camp_a = value;
    }
    pub fn set_point_camp_a_raw(&mut self, value: [u8; 2]) {
        self.point_camp_a_raw = value;
    }
    pub fn set_point_camp_b(&mut self, value: i16) {
        self.point_camp_b = value;
    }
    pub fn set_point_camp_b_raw(&mut self, value: [u8; 2]) {
        self.point_camp_b_raw = value;
    }
    pub fn new() -> PacketZcBattlefieldNotifyPoint {
        PacketZcBattlefieldNotifyPoint {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2d, 0xe]),
        packet_id_raw: [0x2d, 0xe],
        point_camp_a: 0,
        point_camp_a_raw: [0; 2],
        point_camp_b: 0,
        point_camp_b_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcBattlefieldNotifyPoint {
    fn id(&self) -> &str {
       "0x02de"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcBattlefieldNotifyPosition {
    pub fn from(buffer: &[u8]) -> PacketZcBattlefieldNotifyPosition {
        PacketZcBattlefieldNotifyPosition {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            account_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            job: u16::from_le_bytes([buffer[30], buffer[31]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            x: i16::from_le_bytes([buffer[32], buffer[33]]),
            x_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            y: i16::from_le_bytes([buffer[34], buffer[35]]),
            y_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x).unwrap();
        self.x_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y).unwrap();
        self.y_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.account_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.x_raw.to_vec());
        wtr.append(&mut self.y_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_account_id(&mut self, value: u32) {
        self.account_id = value;
    }
    pub fn set_account_id_raw(&mut self, value: [u8; 4]) {
        self.account_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_job(&mut self, value: u16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_x(&mut self, value: i16) {
        self.x = value;
    }
    pub fn set_x_raw(&mut self, value: [u8; 2]) {
        self.x_raw = value;
    }
    pub fn set_y(&mut self, value: i16) {
        self.y = value;
    }
    pub fn set_y_raw(&mut self, value: [u8; 2]) {
        self.y_raw = value;
    }
    pub fn new() -> PacketZcBattlefieldNotifyPosition {
        PacketZcBattlefieldNotifyPosition {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2d, 0xf]),
        packet_id_raw: [0x2d, 0xf],
        account_id: 0,
        account_id_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        job: 0,
        job_raw: [0; 2],
        x: 0,
        x_raw: [0; 2],
        y: 0,
        y_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcBattlefieldNotifyPosition {
    fn id(&self) -> &str {
       "0x02df"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcBattlefieldNotifyHp {
    pub fn from(buffer: &[u8]) -> PacketZcBattlefieldNotifyHp {
        PacketZcBattlefieldNotifyHp {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            account_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            hp: i16::from_le_bytes([buffer[30], buffer[31]]),
            hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            max_hp: i16::from_le_bytes([buffer[32], buffer[33]]),
            max_hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.account_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.max_hp_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_account_id(&mut self, value: u32) {
        self.account_id = value;
    }
    pub fn set_account_id_raw(&mut self, value: [u8; 4]) {
        self.account_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_hp(&mut self, value: i16) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 2]) {
        self.hp_raw = value;
    }
    pub fn set_max_hp(&mut self, value: i16) {
        self.max_hp = value;
    }
    pub fn set_max_hp_raw(&mut self, value: [u8; 2]) {
        self.max_hp_raw = value;
    }
    pub fn new() -> PacketZcBattlefieldNotifyHp {
        PacketZcBattlefieldNotifyHp {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2e, 0x0]),
        packet_id_raw: [0x2e, 0x0],
        account_id: 0,
        account_id_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        hp: 0,
        hp_raw: [0; 2],
        max_hp: 0,
        max_hp_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcBattlefieldNotifyHp {
    fn id(&self) -> &str {
       "0x02e0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyAct2 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyAct2 {
        PacketZcNotifyAct2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            target_gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            start_time: u32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            attack_mt: i32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            attack_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
            attacked_mt: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            attacked_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
            damage: i32::from_le_bytes([buffer[22], buffer[23], buffer[24], buffer[25]]),
            damage_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[22..26]);
                dst
            },
            count: i16::from_le_bytes([buffer[26], buffer[27]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            action: u8::from_le_bytes([buffer[28]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[28..29]);
                dst
            },
            left_damage: i32::from_le_bytes([buffer[29], buffer[30], buffer[31], buffer[32]]),
            left_damage_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[29..33]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_gid).unwrap();
        self.target_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attack_mt).unwrap();
        self.attack_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attacked_mt).unwrap();
        self.attacked_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.damage).unwrap();
        self.damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.left_damage).unwrap();
        self.left_damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.target_gid_raw.to_vec());
        wtr.append(&mut self.start_time_raw.to_vec());
        wtr.append(&mut self.attack_mt_raw.to_vec());
        wtr.append(&mut self.attacked_mt_raw.to_vec());
        wtr.append(&mut self.damage_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        wtr.append(&mut self.left_damage_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_target_gid(&mut self, value: u32) {
        self.target_gid = value;
    }
    pub fn set_target_gid_raw(&mut self, value: [u8; 4]) {
        self.target_gid_raw = value;
    }
    pub fn set_start_time(&mut self, value: u32) {
        self.start_time = value;
    }
    pub fn set_start_time_raw(&mut self, value: [u8; 4]) {
        self.start_time_raw = value;
    }
    pub fn set_attack_mt(&mut self, value: i32) {
        self.attack_mt = value;
    }
    pub fn set_attack_mt_raw(&mut self, value: [u8; 4]) {
        self.attack_mt_raw = value;
    }
    pub fn set_attacked_mt(&mut self, value: i32) {
        self.attacked_mt = value;
    }
    pub fn set_attacked_mt_raw(&mut self, value: [u8; 4]) {
        self.attacked_mt_raw = value;
    }
    pub fn set_damage(&mut self, value: i32) {
        self.damage = value;
    }
    pub fn set_damage_raw(&mut self, value: [u8; 4]) {
        self.damage_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn set_left_damage(&mut self, value: i32) {
        self.left_damage = value;
    }
    pub fn set_left_damage_raw(&mut self, value: [u8; 4]) {
        self.left_damage_raw = value;
    }
    pub fn new() -> PacketZcNotifyAct2 {
        PacketZcNotifyAct2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2e, 0x1]),
        packet_id_raw: [0x2e, 0x1],
        gid: 0,
        gid_raw: [0; 4],
        target_gid: 0,
        target_gid_raw: [0; 4],
        start_time: 0,
        start_time_raw: [0; 4],
        attack_mt: 0,
        attack_mt_raw: [0; 4],
        attacked_mt: 0,
        attacked_mt_raw: [0; 4],
        damage: 0,
        damage_raw: [0; 4],
        count: 0,
        count_raw: [0; 2],
        action: 0,
        action_raw: [0; 1],
        left_damage: 0,
        left_damage_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyAct2 {
    fn id(&self) -> &str {
       "0x02e1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzBotCheck {
    pub fn from(buffer: &[u8]) -> PacketCzBotCheck {
        PacketCzBotCheck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            is_bot: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            is_bot_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.is_bot).unwrap();
        self.is_bot_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.is_bot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_is_bot(&mut self, value: i32) {
        self.is_bot = value;
    }
    pub fn set_is_bot_raw(&mut self, value: [u8; 4]) {
        self.is_bot_raw = value;
    }
    pub fn new() -> PacketCzBotCheck {
        PacketCzBotCheck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2e, 0x6]),
        packet_id_raw: [0x2e, 0x6],
        is_bot: 0,
        is_bot_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzBotCheck {
    fn id(&self) -> &str {
       "0x02e6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMapproperty {
    pub fn from(buffer: &[u8]) -> PacketZcMapproperty {
        PacketZcMapproperty {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: i16::from_le_bytes([buffer[4], buffer[5]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            map_info_table:  {
                let dst: Vec<u8> = buffer[6..buffer.len()].to_vec();
                dst
            },
            map_info_table_raw: buffer[6..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.map_info_table_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn set_map_info_table(&mut self, value: Vec<u8>) {
        self.map_info_table = value;
    }
    pub fn set_map_info_table_raw(&mut self, value: Vec<u8>) {
        self.map_info_table_raw = value;
    }
    pub fn new() -> PacketZcMapproperty {
        PacketZcMapproperty {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2e, 0x7]),
        packet_id_raw: [0x2e, 0x7],
        packet_length: 0,
        packet_length_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 2],
        map_info_table: vec![],
        map_info_table_raw: vec![],
        }
    }
}

impl Packet for PacketZcMapproperty {
    fn id(&self) -> &str {
       "0x02e7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNormalItemlist3 {
    pub fn from(buffer: &[u8]) -> PacketZcNormalItemlist3 {
        let iter_count = (&buffer.len() - 4) / 22;
        let mut vec_field: Vec<NormalitemExtrainfo3> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (22 * (i - 1));
            let end_pos = 4 + 22 * i;
            vec_field.push(NormalitemExtrainfo3::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcNormalItemlist3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<NormalitemExtrainfo3>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new() -> PacketZcNormalItemlist3 {
        PacketZcNormalItemlist3 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2e, 0x8]),
        packet_id_raw: [0x2e, 0x8],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcNormalItemlist3 {
    fn id(&self) -> &str {
       "0x02e8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcCartNormalItemlist3 {
    pub fn from(buffer: &[u8]) -> PacketZcCartNormalItemlist3 {
        let iter_count = (&buffer.len() - 4) / 22;
        let mut vec_field: Vec<NormalitemExtrainfo3> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (22 * (i - 1));
            let end_pos = 4 + 22 * i;
            vec_field.push(NormalitemExtrainfo3::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcCartNormalItemlist3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<NormalitemExtrainfo3>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new() -> PacketZcCartNormalItemlist3 {
        PacketZcCartNormalItemlist3 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2e, 0x9]),
        packet_id_raw: [0x2e, 0x9],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcCartNormalItemlist3 {
    fn id(&self) -> &str {
       "0x02e9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcStoreNormalItemlist3 {
    pub fn from(buffer: &[u8]) -> PacketZcStoreNormalItemlist3 {
        let iter_count = (&buffer.len() - 4) / 22;
        let mut vec_field: Vec<NormalitemExtrainfo3> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (22 * (i - 1));
            let end_pos = 4 + 22 * i;
            vec_field.push(NormalitemExtrainfo3::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcStoreNormalItemlist3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<NormalitemExtrainfo3>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new() -> PacketZcStoreNormalItemlist3 {
        PacketZcStoreNormalItemlist3 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2e, 0xa]),
        packet_id_raw: [0x2e, 0xa],
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcStoreNormalItemlist3 {
    fn id(&self) -> &str {
       "0x02ea"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAcceptEnter2 {
    pub fn from(buffer: &[u8]) -> PacketZcAcceptEnter2 {
        PacketZcAcceptEnter2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            start_time: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[6..9].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[6..9]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[9]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[10]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            font: i16::from_le_bytes([buffer[11], buffer[12]]),
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.start_time_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.font_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_start_time(&mut self, value: u32) {
        self.start_time = value;
    }
    pub fn set_start_time_raw(&mut self, value: [u8; 4]) {
        self.start_time_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [char; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_font(&mut self, value: i16) {
        self.font = value;
    }
    pub fn set_font_raw(&mut self, value: [u8; 2]) {
        self.font_raw = value;
    }
    pub fn new() -> PacketZcAcceptEnter2 {
        PacketZcAcceptEnter2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2e, 0xb]),
        packet_id_raw: [0x2e, 0xb],
        start_time: 0,
        start_time_raw: [0; 4],
        pos_dir: [0 as char; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        font: 0,
        font_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAcceptEnter2 {
    fn id(&self) -> &str {
       "0x02eb"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyMoveentry4 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMoveentry4 {
        PacketZcNotifyMoveentry4 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            objecttype: u8::from_le_bytes([buffer[2]]),
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            gid: u32::from_le_bytes([buffer[3], buffer[4], buffer[5], buffer[6]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[3..7]);
                dst
            },
            speed: i16::from_le_bytes([buffer[7], buffer[8]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[7..9]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[9], buffer[10]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[11], buffer[12]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[13], buffer[14], buffer[15], buffer[16]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[13..17]);
                dst
            },
            job: i16::from_le_bytes([buffer[17], buffer[18]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[17..19]);
                dst
            },
            head: i16::from_le_bytes([buffer[19], buffer[20]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[21], buffer[22], buffer[23], buffer[24]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[21..25]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[25], buffer[26]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[25..27]);
                dst
            },
            move_start_time: u32::from_le_bytes([buffer[27], buffer[28], buffer[29], buffer[30]]),
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[27..31]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[31], buffer[32]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[31..33]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[33], buffer[34]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[35], buffer[36]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[35..37]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[37], buffer[38]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[37..39]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[39], buffer[40]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[39..41]);
                dst
            },
            guid: u32::from_le_bytes([buffer[41], buffer[42], buffer[43], buffer[44]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[41..45]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[45], buffer[46]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[45..47]);
                dst
            },
            honor: i16::from_le_bytes([buffer[47], buffer[48]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[47..49]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[49], buffer[50], buffer[51], buffer[52]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[49..53]);
                dst
            },
            is_pkmode_on: buffer[53] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[53..54]);
                dst
            },
            sex: u8::from_le_bytes([buffer[54]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[54..55]);
                dst
            },
            move_data:  {
                let mut dst: [u16; 6] = [0 as u16; 6];
                for (index, byte) in buffer[55..61].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            },
            move_data_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[55..61]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[61]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[61..62]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[62]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[62..63]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[63], buffer[64]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[63..65]);
                dst
            },
            font: i16::from_le_bytes([buffer[65], buffer[66]]),
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[65..67]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.objecttype_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.move_start_time_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.move_data_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        wtr.append(&mut self.font_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_objecttype(&mut self, value: u8) {
        self.objecttype = value;
    }
    pub fn set_objecttype_raw(&mut self, value: [u8; 1]) {
        self.objecttype_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_move_start_time(&mut self, value: u32) {
        self.move_start_time = value;
    }
    pub fn set_move_start_time_raw(&mut self, value: [u8; 4]) {
        self.move_start_time_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_move_data(&mut self, value: [u16; 6]) {
        self.move_data = value;
    }
    pub fn set_move_data_raw(&mut self, value: [u8; 6]) {
        self.move_data_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn set_font(&mut self, value: i16) {
        self.font = value;
    }
    pub fn set_font_raw(&mut self, value: [u8; 2]) {
        self.font_raw = value;
    }
    pub fn new() -> PacketZcNotifyMoveentry4 {
        PacketZcNotifyMoveentry4 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2e, 0xc]),
        packet_id_raw: [0x2e, 0xc],
        objecttype: 0,
        objecttype_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        move_start_time: 0,
        move_start_time_raw: [0; 4],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        move_data: [0; 6],
        move_data_raw: [0; 6],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        font: 0,
        font_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyMoveentry4 {
    fn id(&self) -> &str {
       "0x02ec"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyNewentry4 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyNewentry4 {
        PacketZcNotifyNewentry4 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            job: i16::from_le_bytes([buffer[16], buffer[17]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            head: i16::from_le_bytes([buffer[18], buffer[19]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[24], buffer[25]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[26], buffer[27]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[28], buffer[29]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[30], buffer[31]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[32], buffer[33]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[34], buffer[35]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            guid: u32::from_le_bytes([buffer[36], buffer[37], buffer[38], buffer[39]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[36..40]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[40], buffer[41]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            honor: i16::from_le_bytes([buffer[42], buffer[43]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[44], buffer[45], buffer[46], buffer[47]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[44..48]);
                dst
            },
            is_pkmode_on: buffer[48] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[48..49]);
                dst
            },
            sex: u8::from_le_bytes([buffer[49]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[50..53].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[50..53]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[53]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[53..54]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[54]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[54..55]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[55], buffer[56]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[55..57]);
                dst
            },
            font: i16::from_le_bytes([buffer[57], buffer[58]]),
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[57..59]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        wtr.append(&mut self.font_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [char; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn set_font(&mut self, value: i16) {
        self.font = value;
    }
    pub fn set_font_raw(&mut self, value: [u8; 2]) {
        self.font_raw = value;
    }
    pub fn new() -> PacketZcNotifyNewentry4 {
        PacketZcNotifyNewentry4 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2e, 0xd]),
        packet_id_raw: [0x2e, 0xd],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0 as char; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        font: 0,
        font_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyNewentry4 {
    fn id(&self) -> &str {
       "0x02ed"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyStandentry4 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyStandentry4 {
        PacketZcNotifyStandentry4 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            job: i16::from_le_bytes([buffer[16], buffer[17]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            head: i16::from_le_bytes([buffer[18], buffer[19]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[24], buffer[25]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[26], buffer[27]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[28], buffer[29]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[30], buffer[31]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[32], buffer[33]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[34], buffer[35]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            guid: u32::from_le_bytes([buffer[36], buffer[37], buffer[38], buffer[39]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[36..40]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[40], buffer[41]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            honor: i16::from_le_bytes([buffer[42], buffer[43]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[44], buffer[45], buffer[46], buffer[47]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[44..48]);
                dst
            },
            is_pkmode_on: buffer[48] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[48..49]);
                dst
            },
            sex: u8::from_le_bytes([buffer[49]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[50..53].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[50..53]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[53]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[53..54]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[54]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[54..55]);
                dst
            },
            state: u8::from_le_bytes([buffer[55]]),
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[55..56]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[56], buffer[57]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[56..58]);
                dst
            },
            font: i16::from_le_bytes([buffer[58], buffer[59]]),
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[58..60]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        wtr.append(&mut self.font_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [char; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_state(&mut self, value: u8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn set_font(&mut self, value: i16) {
        self.font = value;
    }
    pub fn set_font_raw(&mut self, value: [u8; 2]) {
        self.font_raw = value;
    }
    pub fn new() -> PacketZcNotifyStandentry4 {
        PacketZcNotifyStandentry4 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2e, 0xe]),
        packet_id_raw: [0x2e, 0xe],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0 as char; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        state: 0,
        state_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        font: 0,
        font_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyStandentry4 {
    fn id(&self) -> &str {
       "0x02ee"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyFont {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyFont {
        PacketZcNotifyFont {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            font: i16::from_le_bytes([buffer[6], buffer[7]]),
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.font_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_font(&mut self, value: i16) {
        self.font = value;
    }
    pub fn set_font_raw(&mut self, value: [u8; 2]) {
        self.font_raw = value;
    }
    pub fn new() -> PacketZcNotifyFont {
        PacketZcNotifyFont {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2e, 0xf]),
        packet_id_raw: [0x2e, 0xf],
        aid: 0,
        aid_raw: [0; 4],
        font: 0,
        font_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyFont {
    fn id(&self) -> &str {
       "0x02ef"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcProgress {
    pub fn from(buffer: &[u8]) -> PacketZcProgress {
        PacketZcProgress {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            color: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            color_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            time: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.color).unwrap();
        self.color_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.time).unwrap();
        self.time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.color_raw.to_vec());
        wtr.append(&mut self.time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_color(&mut self, value: u32) {
        self.color = value;
    }
    pub fn set_color_raw(&mut self, value: [u8; 4]) {
        self.color_raw = value;
    }
    pub fn set_time(&mut self, value: u32) {
        self.time = value;
    }
    pub fn set_time_raw(&mut self, value: [u8; 4]) {
        self.time_raw = value;
    }
    pub fn new() -> PacketZcProgress {
        PacketZcProgress {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2f, 0x0]),
        packet_id_raw: [0x2f, 0x0],
        color: 0,
        color_raw: [0; 4],
        time: 0,
        time_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcProgress {
    fn id(&self) -> &str {
       "0x02f0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzProgress {
    pub fn from(buffer: &[u8]) -> PacketCzProgress {
        PacketCzProgress {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzProgress {
        PacketCzProgress {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2f, 0x1]),
        packet_id_raw: [0x2f, 0x1],
        }
    }
}

impl Packet for PacketCzProgress {
    fn id(&self) -> &str {
       "0x02f1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcProgressCancel {
    pub fn from(buffer: &[u8]) -> PacketZcProgressCancel {
        PacketZcProgressCancel {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketZcProgressCancel {
        PacketZcProgressCancel {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2f, 0x2]),
        packet_id_raw: [0x2f, 0x2],
        }
    }
}

impl Packet for PacketZcProgressCancel {
    fn id(&self) -> &str {
       "0x02f2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzOpenSimpleCashshopItemlist {
    pub fn from(buffer: &[u8]) -> PacketCzOpenSimpleCashshopItemlist {
        PacketCzOpenSimpleCashshopItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzOpenSimpleCashshopItemlist {
        PacketCzOpenSimpleCashshopItemlist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x35, 0xc]),
        packet_id_raw: [0x35, 0xc],
        }
    }
}

impl Packet for PacketCzOpenSimpleCashshopItemlist {
    fn id(&self) -> &str {
       "0x035c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSimpleCashshopPointItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcSimpleCashshopPointItemlist {
        let iter_count = (&buffer.len() - 16) / 11;
        let mut vec_field: Vec<PurchaseItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 16 + (11 * (i - 1));
            let end_pos = 16 + 11 * i;
            vec_field.push(PurchaseItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcSimpleCashshopPointItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            cash_point: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            cash_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            md_itemcount: i16::from_le_bytes([buffer[8], buffer[9]]),
            md_itemcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            md_item_size: i16::from_le_bytes([buffer[10], buffer[11]]),
            md_item_size_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            best_itemcount: i16::from_le_bytes([buffer[12], buffer[13]]),
            best_itemcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            best_itemsize: i16::from_le_bytes([buffer[14], buffer[15]]),
            best_itemsize_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.cash_point).unwrap();
        self.cash_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.md_itemcount).unwrap();
        self.md_itemcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.md_item_size).unwrap();
        self.md_item_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.best_itemcount).unwrap();
        self.best_itemcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.best_itemsize).unwrap();
        self.best_itemsize_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.cash_point_raw.to_vec());
        wtr.append(&mut self.md_itemcount_raw.to_vec());
        wtr.append(&mut self.md_item_size_raw.to_vec());
        wtr.append(&mut self.best_itemcount_raw.to_vec());
        wtr.append(&mut self.best_itemsize_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_cash_point(&mut self, value: u32) {
        self.cash_point = value;
    }
    pub fn set_cash_point_raw(&mut self, value: [u8; 4]) {
        self.cash_point_raw = value;
    }
    pub fn set_md_itemcount(&mut self, value: i16) {
        self.md_itemcount = value;
    }
    pub fn set_md_itemcount_raw(&mut self, value: [u8; 2]) {
        self.md_itemcount_raw = value;
    }
    pub fn set_md_item_size(&mut self, value: i16) {
        self.md_item_size = value;
    }
    pub fn set_md_item_size_raw(&mut self, value: [u8; 2]) {
        self.md_item_size_raw = value;
    }
    pub fn set_best_itemcount(&mut self, value: i16) {
        self.best_itemcount = value;
    }
    pub fn set_best_itemcount_raw(&mut self, value: [u8; 2]) {
        self.best_itemcount_raw = value;
    }
    pub fn set_best_itemsize(&mut self, value: i16) {
        self.best_itemsize = value;
    }
    pub fn set_best_itemsize_raw(&mut self, value: [u8; 2]) {
        self.best_itemsize_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<PurchaseItem>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new() -> PacketZcSimpleCashshopPointItemlist {
        PacketZcSimpleCashshopPointItemlist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x35, 0xd]),
        packet_id_raw: [0x35, 0xd],
        packet_length: 0,
        packet_length_raw: [0; 2],
        cash_point: 0,
        cash_point_raw: [0; 4],
        md_itemcount: 0,
        md_itemcount_raw: [0; 2],
        md_item_size: 0,
        md_item_size_raw: [0; 2],
        best_itemcount: 0,
        best_itemcount_raw: [0; 2],
        best_itemsize: 0,
        best_itemsize_raw: [0; 2],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcSimpleCashshopPointItemlist {
    fn id(&self) -> &str {
       "0x035d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzCloseWindow {
    pub fn from(buffer: &[u8]) -> PacketCzCloseWindow {
        PacketCzCloseWindow {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzCloseWindow {
        PacketCzCloseWindow {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x35, 0xe]),
        packet_id_raw: [0x35, 0xe],
        }
    }
}

impl Packet for PacketCzCloseWindow {
    fn id(&self) -> &str {
       "0x035e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAhcGameGuard {
    pub fn from(buffer: &[u8]) -> PacketAhcGameGuard {
        PacketAhcGameGuard {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            auth_data:  {
                let mut dst: [u32; 4] = [0 as u32; 4];
                for (index, byte) in buffer[2..6].iter().enumerate() {
                    dst[index] = *byte as u32;
                }
                dst
            },
            auth_data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.auth_data {
            wtr.write_u32::<LittleEndian>(item).unwrap();
        }
        self.auth_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.auth_data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_auth_data(&mut self, value: [u32; 4]) {
        self.auth_data = value;
    }
    pub fn set_auth_data_raw(&mut self, value: [u8; 4]) {
        self.auth_data_raw = value;
    }
    pub fn new() -> PacketAhcGameGuard {
        PacketAhcGameGuard {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x3d, 0xd]),
        packet_id_raw: [0x3d, 0xd],
        auth_data: [0; 4],
        auth_data_raw: [0; 4],
        }
    }
}

impl Packet for PacketAhcGameGuard {
    fn id(&self) -> &str {
       "0x03dd"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCahAckGameGuard {
    pub fn from(buffer: &[u8]) -> PacketCahAckGameGuard {
        PacketCahAckGameGuard {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            auth_data:  {
                let mut dst: [u32; 4] = [0 as u32; 4];
                for (index, byte) in buffer[2..6].iter().enumerate() {
                    dst[index] = *byte as u32;
                }
                dst
            },
            auth_data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.auth_data {
            wtr.write_u32::<LittleEndian>(item).unwrap();
        }
        self.auth_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.auth_data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_auth_data(&mut self, value: [u32; 4]) {
        self.auth_data = value;
    }
    pub fn set_auth_data_raw(&mut self, value: [u8; 4]) {
        self.auth_data_raw = value;
    }
    pub fn new() -> PacketCahAckGameGuard {
        PacketCahAckGameGuard {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x3d, 0xe]),
        packet_id_raw: [0x3d, 0xe],
        auth_data: [0; 4],
        auth_data_raw: [0; 4],
        }
    }
}

impl Packet for PacketCahAckGameGuard {
    fn id(&self) -> &str {
       "0x03de"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzEnter2 {
    pub fn from(buffer: &[u8]) -> PacketCzEnter2 {
        PacketCzEnter2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            auth_code: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            client_time: u32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            client_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
            sex: u8::from_le_bytes([buffer[18]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[18..19]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.client_time).unwrap();
        self.client_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.auth_code_raw.to_vec());
        wtr.append(&mut self.client_time_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_auth_code(&mut self, value: i32) {
        self.auth_code = value;
    }
    pub fn set_auth_code_raw(&mut self, value: [u8; 4]) {
        self.auth_code_raw = value;
    }
    pub fn set_client_time(&mut self, value: u32) {
        self.client_time = value;
    }
    pub fn set_client_time_raw(&mut self, value: [u8; 4]) {
        self.client_time_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn new() -> PacketCzEnter2 {
        PacketCzEnter2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x36, 0x04]),
        packet_id_raw: [0x36, 0x04],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        auth_code: 0,
        auth_code_raw: [0; 4],
        client_time: 0,
        client_time_raw: [0; 4],
        sex: 0,
        sex_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzEnter2 {
    fn id(&self) -> &str {
       "0x3604"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRequestAct2 {
    pub fn from(buffer: &[u8]) -> PacketCzRequestAct2 {
        PacketCzRequestAct2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            target_gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            target_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            action: u8::from_le_bytes([buffer[6]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_gid).unwrap();
        self.target_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.target_gid_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_target_gid(&mut self, value: u32) {
        self.target_gid = value;
    }
    pub fn set_target_gid_raw(&mut self, value: [u8; 4]) {
        self.target_gid_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn new() -> PacketCzRequestAct2 {
        PacketCzRequestAct2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x43, 0x7]),
        packet_id_raw: [0x43, 0x7],
        target_gid: 0,
        target_gid_raw: [0; 4],
        action: 0,
        action_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzRequestAct2 {
    fn id(&self) -> &str {
       "0x0437"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzUseSkill2 {
    pub fn from(buffer: &[u8]) -> PacketCzUseSkill2 {
        PacketCzUseSkill2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            selected_level: i16::from_le_bytes([buffer[2], buffer[3]]),
            selected_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            skid: u16::from_le_bytes([buffer[4], buffer[5]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            target_id: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.selected_level).unwrap();
        self.selected_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.selected_level_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.target_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_selected_level(&mut self, value: i16) {
        self.selected_level = value;
    }
    pub fn set_selected_level_raw(&mut self, value: [u8; 2]) {
        self.selected_level_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_target_id(&mut self, value: u32) {
        self.target_id = value;
    }
    pub fn set_target_id_raw(&mut self, value: [u8; 4]) {
        self.target_id_raw = value;
    }
    pub fn new() -> PacketCzUseSkill2 {
        PacketCzUseSkill2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x43, 0x8]),
        packet_id_raw: [0x43, 0x8],
        selected_level: 0,
        selected_level_raw: [0; 2],
        skid: 0,
        skid_raw: [0; 2],
        target_id: 0,
        target_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzUseSkill2 {
    fn id(&self) -> &str {
       "0x0438"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzUseItem2 {
    pub fn from(buffer: &[u8]) -> PacketCzUseItem2 {
        PacketCzUseItem2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketCzUseItem2 {
        PacketCzUseItem2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x43, 0x9]),
        packet_id_raw: [0x43, 0x9],
        index: 0,
        index_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzUseItem2 {
    fn id(&self) -> &str {
       "0x0439"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSkillPostdelay {
    pub fn from(buffer: &[u8]) -> PacketZcSkillPostdelay {
        PacketZcSkillPostdelay {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            delay_tm: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            delay_tm_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.delay_tm).unwrap();
        self.delay_tm_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.delay_tm_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_delay_tm(&mut self, value: u32) {
        self.delay_tm = value;
    }
    pub fn set_delay_tm_raw(&mut self, value: [u8; 4]) {
        self.delay_tm_raw = value;
    }
    pub fn new() -> PacketZcSkillPostdelay {
        PacketZcSkillPostdelay {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x43, 0xd]),
        packet_id_raw: [0x43, 0xd],
        skid: 0,
        skid_raw: [0; 2],
        delay_tm: 0,
        delay_tm_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcSkillPostdelay {
    fn id(&self) -> &str {
       "0x043d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSkillPostdelayList {
    pub fn from(buffer: &[u8]) -> PacketZcSkillPostdelayList {
        let iter_count = (&buffer.len() - 4) / 6;
        let mut vec_field: Vec<SkillPostdelay> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (6 * (i - 1));
            let end_pos = 4 + 6 * i;
            vec_field.push(SkillPostdelay::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcSkillPostdelayList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            delay_list: vec_field.clone(),
            delay_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.delay_list_raw = {
            self.delay_list.iter_mut().for_each(|item| item.fill_raw());
            self.delay_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.delay_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_delay_list(&mut self, value: Vec<SkillPostdelay>) {
        self.delay_list = value;
    }
    pub fn set_delay_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.delay_list_raw = value;
    }
    pub fn new() -> PacketZcSkillPostdelayList {
        PacketZcSkillPostdelayList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x43, 0xe]),
        packet_id_raw: [0x43, 0xe],
        packet_length: 0,
        packet_length_raw: [0; 2],
        delay_list: vec![],
        delay_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcSkillPostdelayList {
    fn id(&self) -> &str {
       "0x043e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMsgStateChange2 {
    pub fn from(buffer: &[u8]) -> PacketZcMsgStateChange2 {
        PacketZcMsgStateChange2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            state: buffer[8] == 1,
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            remain_ms: u32::from_le_bytes([buffer[9], buffer[10], buffer[11], buffer[12]]),
            remain_ms_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[9..13]);
                dst
            },
            val:  {
                let mut dst: [i32; 3] = [0 as i32; 3];
                for (index, byte) in buffer[13..16].iter().enumerate() {
                    dst[index] = *byte as i32;
                }
                dst
            },
            val_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[13..16]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state as u8).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.remain_ms).unwrap();
        self.remain_ms_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.val {
            wtr.write_i32::<LittleEndian>(item).unwrap();
        }
        self.val_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.remain_ms_raw.to_vec());
        wtr.append(&mut self.val_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_state(&mut self, value: bool) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_remain_ms(&mut self, value: u32) {
        self.remain_ms = value;
    }
    pub fn set_remain_ms_raw(&mut self, value: [u8; 4]) {
        self.remain_ms_raw = value;
    }
    pub fn set_val(&mut self, value: [i32; 3]) {
        self.val = value;
    }
    pub fn set_val_raw(&mut self, value: [u8; 3]) {
        self.val_raw = value;
    }
    pub fn new() -> PacketZcMsgStateChange2 {
        PacketZcMsgStateChange2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x43, 0xf]),
        packet_id_raw: [0x43, 0xf],
        index: 0,
        index_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        state: false,
        state_raw: [0; 1],
        remain_ms: 0,
        remain_ms_raw: [0; 4],
        val: [0; 3],
        val_raw: [0; 3],
        }
    }
}

impl Packet for PacketZcMsgStateChange2 {
    fn id(&self) -> &str {
       "0x043f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMillenniumshield {
    pub fn from(buffer: &[u8]) -> PacketZcMillenniumshield {
        PacketZcMillenniumshield {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            num: i16::from_le_bytes([buffer[6], buffer[7]]),
            num_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            state: i16::from_le_bytes([buffer[8], buffer[9]]),
            state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.num).unwrap();
        self.num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.num_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_num(&mut self, value: i16) {
        self.num = value;
    }
    pub fn set_num_raw(&mut self, value: [u8; 2]) {
        self.num_raw = value;
    }
    pub fn set_state(&mut self, value: i16) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 2]) {
        self.state_raw = value;
    }
    pub fn new() -> PacketZcMillenniumshield {
        PacketZcMillenniumshield {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x44, 0x0]),
        packet_id_raw: [0x44, 0x0],
        aid: 0,
        aid_raw: [0; 4],
        num: 0,
        num_raw: [0; 2],
        state: 0,
        state_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcMillenniumshield {
    fn id(&self) -> &str {
       "0x0440"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSkillinfoDelete {
    pub fn from(buffer: &[u8]) -> PacketZcSkillinfoDelete {
        PacketZcSkillinfoDelete {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn new() -> PacketZcSkillinfoDelete {
        PacketZcSkillinfoDelete {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x44, 0x1]),
        packet_id_raw: [0x44, 0x1],
        skid: 0,
        skid_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcSkillinfoDelete {
    fn id(&self) -> &str {
       "0x0441"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSkillSelectRequest {
    pub fn from(buffer: &[u8]) -> PacketZcSkillSelectRequest {
        PacketZcSkillSelectRequest {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            why: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            why_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            skidlist:  {
                let dst: Vec<u8> = buffer[8..buffer.len()].to_vec();
                dst
            },
            skidlist_raw: buffer[8..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.why).unwrap();
        self.why_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.why_raw.to_vec());
        wtr.append(&mut self.skidlist_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_why(&mut self, value: i32) {
        self.why = value;
    }
    pub fn set_why_raw(&mut self, value: [u8; 4]) {
        self.why_raw = value;
    }
    pub fn set_skidlist(&mut self, value: Vec<u8>) {
        self.skidlist = value;
    }
    pub fn set_skidlist_raw(&mut self, value: Vec<u8>) {
        self.skidlist_raw = value;
    }
    pub fn new() -> PacketZcSkillSelectRequest {
        PacketZcSkillSelectRequest {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x44, 0x2]),
        packet_id_raw: [0x44, 0x2],
        packet_length: 0,
        packet_length_raw: [0; 2],
        why: 0,
        why_raw: [0; 4],
        skidlist: vec![],
        skidlist_raw: vec![],
        }
    }
}

impl Packet for PacketZcSkillSelectRequest {
    fn id(&self) -> &str {
       "0x0442"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzSkillSelectResponse {
    pub fn from(buffer: &[u8]) -> PacketCzSkillSelectResponse {
        PacketCzSkillSelectResponse {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            why: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            why_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            skid: u16::from_le_bytes([buffer[6], buffer[7]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.why).unwrap();
        self.why_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.why_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_why(&mut self, value: i32) {
        self.why = value;
    }
    pub fn set_why_raw(&mut self, value: [u8; 4]) {
        self.why_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn new() -> PacketCzSkillSelectResponse {
        PacketCzSkillSelectResponse {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x44, 0x3]),
        packet_id_raw: [0x44, 0x3],
        why: 0,
        why_raw: [0; 4],
        skid: 0,
        skid_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzSkillSelectResponse {
    fn id(&self) -> &str {
       "0x0443"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSimpleCashPointItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcSimpleCashPointItemlist {
        let iter_count = (&buffer.len() - 8) / 11;
        let mut vec_field: Vec<PurchaseItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (11 * (i - 1));
            let end_pos = 8 + 11 * i;
            vec_field.push(PurchaseItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcSimpleCashPointItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            cash_point: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            cash_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.cash_point).unwrap();
        self.cash_point_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.cash_point_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_cash_point(&mut self, value: u32) {
        self.cash_point = value;
    }
    pub fn set_cash_point_raw(&mut self, value: [u8; 4]) {
        self.cash_point_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<PurchaseItem>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new() -> PacketZcSimpleCashPointItemlist {
        PacketZcSimpleCashPointItemlist {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x44, 0x4]),
        packet_id_raw: [0x44, 0x4],
        packet_length: 0,
        packet_length_raw: [0; 2],
        cash_point: 0,
        cash_point_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcSimpleCashPointItemlist {
    fn id(&self) -> &str {
       "0x0444"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzSimpleBuyCashPointItem {
    pub fn from(buffer: &[u8]) -> PacketCzSimpleBuyCashPointItem {
        PacketCzSimpleBuyCashPointItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketCzSimpleBuyCashPointItem {
        PacketCzSimpleBuyCashPointItem {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x44, 0x5]),
        packet_id_raw: [0x44, 0x5],
        itid: 0,
        itid_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzSimpleBuyCashPointItem {
    fn id(&self) -> &str {
       "0x0445"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcQuestNotifyEffect {
    pub fn from(buffer: &[u8]) -> PacketZcQuestNotifyEffect {
        PacketZcQuestNotifyEffect {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            npc_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            npc_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[6], buffer[7]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[8], buffer[9]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            effect: i16::from_le_bytes([buffer[10], buffer[11]]),
            effect_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            atype: i16::from_le_bytes([buffer[12], buffer[13]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.npc_id).unwrap();
        self.npc_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect).unwrap();
        self.effect_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.npc_id_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.effect_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_npc_id(&mut self, value: u32) {
        self.npc_id = value;
    }
    pub fn set_npc_id_raw(&mut self, value: [u8; 4]) {
        self.npc_id_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_effect(&mut self, value: i16) {
        self.effect = value;
    }
    pub fn set_effect_raw(&mut self, value: [u8; 2]) {
        self.effect_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketZcQuestNotifyEffect {
        PacketZcQuestNotifyEffect {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x44, 0x6]),
        packet_id_raw: [0x44, 0x6],
        npc_id: 0,
        npc_id_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        effect: 0,
        effect_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcQuestNotifyEffect {
    fn id(&self) -> &str {
       "0x0446"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzBlockingPlayCancel {
    pub fn from(buffer: &[u8]) -> PacketCzBlockingPlayCancel {
        PacketCzBlockingPlayCancel {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzBlockingPlayCancel {
        PacketCzBlockingPlayCancel {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x44, 0x7]),
        packet_id_raw: [0x44, 0x7],
        }
    }
}

impl Packet for PacketCzBlockingPlayCancel {
    fn id(&self) -> &str {
       "0x0447"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcCharacterList {
    pub fn from(buffer: &[u8]) -> PacketHcCharacterList {
        let iter_count = (&buffer.len() - 4) / 5;
        let mut vec_field: Vec<CharacterList> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (5 * (i - 1));
            let end_pos = 4 + 5 * i;
            vec_field.push(CharacterList::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketHcCharacterList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            character_list: vec_field.clone(),
            character_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.character_list_raw = {
            self.character_list.iter_mut().for_each(|item| item.fill_raw());
            self.character_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.character_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_character_list(&mut self, value: Vec<CharacterList>) {
        self.character_list = value;
    }
    pub fn set_character_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.character_list_raw = value;
    }
    pub fn new() -> PacketHcCharacterList {
        PacketHcCharacterList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x44, 0x8]),
        packet_id_raw: [0x44, 0x8],
        packet_length: 0,
        packet_length_raw: [0; 2],
        character_list: vec![],
        character_list_raw: vec![],
        }
    }
}

impl Packet for PacketHcCharacterList {
    fn id(&self) -> &str {
       "0x0448"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcHackshErrorMsg {
    pub fn from(buffer: &[u8]) -> PacketZcHackshErrorMsg {
        PacketZcHackshErrorMsg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_id: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_id).unwrap();
        self.error_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_id(&mut self, value: i16) {
        self.error_id = value;
    }
    pub fn set_error_id_raw(&mut self, value: [u8; 2]) {
        self.error_id_raw = value;
    }
    pub fn new() -> PacketZcHackshErrorMsg {
        PacketZcHackshErrorMsg {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x44, 0x9]),
        packet_id_raw: [0x44, 0x9],
        error_id: 0,
        error_id_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcHackshErrorMsg {
    fn id(&self) -> &str {
       "0x0449"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzClientVersion {
    pub fn from(buffer: &[u8]) -> PacketCzClientVersion {
        PacketCzClientVersion {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            client_ver: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            client_ver_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.client_ver).unwrap();
        self.client_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.client_ver_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_client_ver(&mut self, value: i32) {
        self.client_ver = value;
    }
    pub fn set_client_ver_raw(&mut self, value: [u8; 4]) {
        self.client_ver_raw = value;
    }
    pub fn new() -> PacketCzClientVersion {
        PacketCzClientVersion {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x44, 0xa]),
        packet_id_raw: [0x44, 0xa],
        client_ver: 0,
        client_ver_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzClientVersion {
    fn id(&self) -> &str {
       "0x044a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzCloseSimplecashShop {
    pub fn from(buffer: &[u8]) -> PacketCzCloseSimplecashShop {
        PacketCzCloseSimplecashShop {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzCloseSimplecashShop {
        PacketCzCloseSimplecashShop {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x44, 0xb]),
        packet_id_raw: [0x44, 0xb],
        }
    }
}

impl Packet for PacketCzCloseSimplecashShop {
    fn id(&self) -> &str {
       "0x044b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcEsResult {
    pub fn from(buffer: &[u8]) -> PacketZcEsResult {
        PacketZcEsResult {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            es_no: i16::from_le_bytes([buffer[2], buffer[3]]),
            es_no_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            es_msg: i16::from_le_bytes([buffer[4], buffer[5]]),
            es_msg_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_no).unwrap();
        self.es_no_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_msg).unwrap();
        self.es_msg_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.es_no_raw.to_vec());
        wtr.append(&mut self.es_msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_es_no(&mut self, value: i16) {
        self.es_no = value;
    }
    pub fn set_es_no_raw(&mut self, value: [u8; 2]) {
        self.es_no_raw = value;
    }
    pub fn set_es_msg(&mut self, value: i16) {
        self.es_msg = value;
    }
    pub fn set_es_msg_raw(&mut self, value: [u8; 2]) {
        self.es_msg_raw = value;
    }
    pub fn new() -> PacketZcEsResult {
        PacketZcEsResult {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7d, 0x0]),
        packet_id_raw: [0x7d, 0x0],
        es_no: 0,
        es_no_raw: [0; 2],
        es_msg: 0,
        es_msg_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcEsResult {
    fn id(&self) -> &str {
       "0x07d0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzEsGetList {
    pub fn from(buffer: &[u8]) -> PacketCzEsGetList {
        PacketCzEsGetList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzEsGetList {
        PacketCzEsGetList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7d, 0x1]),
        packet_id_raw: [0x7d, 0x1],
        }
    }
}

impl Packet for PacketCzEsGetList {
    fn id(&self) -> &str {
       "0x07d1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcEsList {
    pub fn from(buffer: &[u8]) -> PacketZcEsList {
        PacketZcEsList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketZcEsList {
        PacketZcEsList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7d, 0x2]),
        packet_id_raw: [0x7d, 0x2],
        packet_length: 0,
        packet_length_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcEsList {
    fn id(&self) -> &str {
       "0x07d2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzEsChoose {
    pub fn from(buffer: &[u8]) -> PacketCzEsChoose {
        PacketCzEsChoose {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            es_no: i16::from_le_bytes([buffer[2], buffer[3]]),
            es_no_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_no).unwrap();
        self.es_no_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.es_no_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_es_no(&mut self, value: i16) {
        self.es_no = value;
    }
    pub fn set_es_no_raw(&mut self, value: [u8; 2]) {
        self.es_no_raw = value;
    }
    pub fn new() -> PacketCzEsChoose {
        PacketCzEsChoose {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7d, 0x3]),
        packet_id_raw: [0x7d, 0x3],
        es_no: 0,
        es_no_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzEsChoose {
    fn id(&self) -> &str {
       "0x07d3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzEsCancel {
    pub fn from(buffer: &[u8]) -> PacketCzEsCancel {
        PacketCzEsCancel {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            es_no: i16::from_le_bytes([buffer[2], buffer[3]]),
            es_no_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_no).unwrap();
        self.es_no_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.es_no_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_es_no(&mut self, value: i16) {
        self.es_no = value;
    }
    pub fn set_es_no_raw(&mut self, value: [u8; 2]) {
        self.es_no_raw = value;
    }
    pub fn new() -> PacketCzEsCancel {
        PacketCzEsCancel {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7d, 0x4]),
        packet_id_raw: [0x7d, 0x4],
        es_no: 0,
        es_no_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzEsCancel {
    fn id(&self) -> &str {
       "0x07d4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcEsReady {
    pub fn from(buffer: &[u8]) -> PacketZcEsReady {
        PacketZcEsReady {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            es_no: i16::from_le_bytes([buffer[2], buffer[3]]),
            es_no_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_no).unwrap();
        self.es_no_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.es_no_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_es_no(&mut self, value: i16) {
        self.es_no = value;
    }
    pub fn set_es_no_raw(&mut self, value: [u8; 2]) {
        self.es_no_raw = value;
    }
    pub fn new() -> PacketZcEsReady {
        PacketZcEsReady {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7d, 0x5]),
        packet_id_raw: [0x7d, 0x5],
        es_no: 0,
        es_no_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcEsReady {
    fn id(&self) -> &str {
       "0x07d5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcEsGoto {
    pub fn from(buffer: &[u8]) -> PacketZcEsGoto {
        PacketZcEsGoto {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            es_no: i16::from_le_bytes([buffer[2], buffer[3]]),
            es_no_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_no).unwrap();
        self.es_no_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.es_no_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_es_no(&mut self, value: i16) {
        self.es_no = value;
    }
    pub fn set_es_no_raw(&mut self, value: [u8; 2]) {
        self.es_no_raw = value;
    }
    pub fn new() -> PacketZcEsGoto {
        PacketZcEsGoto {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7d, 0x6]),
        packet_id_raw: [0x7d, 0x6],
        es_no: 0,
        es_no_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcEsGoto {
    fn id(&self) -> &str {
       "0x07d6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzGroupinfoChangeV2 {
    pub fn from(buffer: &[u8]) -> PacketCzGroupinfoChangeV2 {
        PacketCzGroupinfoChangeV2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            exp_option: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            exp_option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            item_pickup_rule: u8::from_le_bytes([buffer[6]]),
            item_pickup_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            item_division_rule: u8::from_le_bytes([buffer[7]]),
            item_division_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[7..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.exp_option).unwrap();
        self.exp_option_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_pickup_rule).unwrap();
        self.item_pickup_rule_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_division_rule).unwrap();
        self.item_division_rule_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.exp_option_raw.to_vec());
        wtr.append(&mut self.item_pickup_rule_raw.to_vec());
        wtr.append(&mut self.item_division_rule_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_exp_option(&mut self, value: u32) {
        self.exp_option = value;
    }
    pub fn set_exp_option_raw(&mut self, value: [u8; 4]) {
        self.exp_option_raw = value;
    }
    pub fn set_item_pickup_rule(&mut self, value: u8) {
        self.item_pickup_rule = value;
    }
    pub fn set_item_pickup_rule_raw(&mut self, value: [u8; 1]) {
        self.item_pickup_rule_raw = value;
    }
    pub fn set_item_division_rule(&mut self, value: u8) {
        self.item_division_rule = value;
    }
    pub fn set_item_division_rule_raw(&mut self, value: [u8; 1]) {
        self.item_division_rule_raw = value;
    }
    pub fn new() -> PacketCzGroupinfoChangeV2 {
        PacketCzGroupinfoChangeV2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7d, 0x7]),
        packet_id_raw: [0x7d, 0x7],
        exp_option: 0,
        exp_option_raw: [0; 4],
        item_pickup_rule: 0,
        item_pickup_rule_raw: [0; 1],
        item_division_rule: 0,
        item_division_rule_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzGroupinfoChangeV2 {
    fn id(&self) -> &str {
       "0x07d7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcReqGroupinfoChangeV2 {
    pub fn from(buffer: &[u8]) -> PacketZcReqGroupinfoChangeV2 {
        PacketZcReqGroupinfoChangeV2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            exp_option: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            exp_option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            item_pickup_rule: u8::from_le_bytes([buffer[6]]),
            item_pickup_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            item_division_rule: u8::from_le_bytes([buffer[7]]),
            item_division_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[7..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.exp_option).unwrap();
        self.exp_option_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_pickup_rule).unwrap();
        self.item_pickup_rule_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_division_rule).unwrap();
        self.item_division_rule_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.exp_option_raw.to_vec());
        wtr.append(&mut self.item_pickup_rule_raw.to_vec());
        wtr.append(&mut self.item_division_rule_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_exp_option(&mut self, value: u32) {
        self.exp_option = value;
    }
    pub fn set_exp_option_raw(&mut self, value: [u8; 4]) {
        self.exp_option_raw = value;
    }
    pub fn set_item_pickup_rule(&mut self, value: u8) {
        self.item_pickup_rule = value;
    }
    pub fn set_item_pickup_rule_raw(&mut self, value: [u8; 1]) {
        self.item_pickup_rule_raw = value;
    }
    pub fn set_item_division_rule(&mut self, value: u8) {
        self.item_division_rule = value;
    }
    pub fn set_item_division_rule_raw(&mut self, value: [u8; 1]) {
        self.item_division_rule_raw = value;
    }
    pub fn new() -> PacketZcReqGroupinfoChangeV2 {
        PacketZcReqGroupinfoChangeV2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7d, 0x8]),
        packet_id_raw: [0x7d, 0x8],
        exp_option: 0,
        exp_option_raw: [0; 4],
        item_pickup_rule: 0,
        item_pickup_rule_raw: [0; 1],
        item_division_rule: 0,
        item_division_rule_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcReqGroupinfoChangeV2 {
    fn id(&self) -> &str {
       "0x07d8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcShortcutKeyListV2 {
    pub fn from(buffer: &[u8]) -> PacketZcShortcutKeyListV2 {
        let iter_count = (&buffer.len() - 2) / 7;
        let mut vec_field: Vec<ShortCutKey> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 2 + (7 * (i - 1));
            let end_pos = 2 + 7 * i;
            vec_field.push(ShortCutKey::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcShortcutKeyListV2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            short_cut_key: vec_field.clone(),
            short_cut_key_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.short_cut_key_raw = {
            self.short_cut_key.iter_mut().for_each(|item| item.fill_raw());
            self.short_cut_key.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.short_cut_key.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_short_cut_key(&mut self, value: Vec<ShortCutKey>) {
        self.short_cut_key = value;
    }
    pub fn set_short_cut_key_raw(&mut self, value: Vec<Vec<u8>>) {
        self.short_cut_key_raw = value;
    }
    pub fn new() -> PacketZcShortcutKeyListV2 {
        PacketZcShortcutKeyListV2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7d, 0x9]),
        packet_id_raw: [0x7d, 0x9],
        short_cut_key: vec![],
        short_cut_key_raw: vec![],
        }
    }
}

impl Packet for PacketZcShortcutKeyListV2 {
    fn id(&self) -> &str {
       "0x07d9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzChangeGroupMaster {
    pub fn from(buffer: &[u8]) -> PacketCzChangeGroupMaster {
        PacketCzChangeGroupMaster {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketCzChangeGroupMaster {
        PacketCzChangeGroupMaster {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7d, 0xa]),
        packet_id_raw: [0x7d, 0xa],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzChangeGroupMaster {
    fn id(&self) -> &str {
       "0x07da"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcHoParChange {
    pub fn from(buffer: &[u8]) -> PacketZcHoParChange {
        PacketZcHoParChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            var: u16::from_le_bytes([buffer[2], buffer[3]]),
            var_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            value: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var).unwrap();
        self.var_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.var_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_var(&mut self, value: u16) {
        self.var = value;
    }
    pub fn set_var_raw(&mut self, value: [u8; 2]) {
        self.var_raw = value;
    }
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new() -> PacketZcHoParChange {
        PacketZcHoParChange {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7d, 0xb]),
        packet_id_raw: [0x7d, 0xb],
        var: 0,
        var_raw: [0; 2],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcHoParChange {
    fn id(&self) -> &str {
       "0x07db"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzSeekParty {
    pub fn from(buffer: &[u8]) -> PacketCzSeekParty {
        PacketCzSeekParty {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            option: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.option).unwrap();
        self.option_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.option_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_option(&mut self, value: u32) {
        self.option = value;
    }
    pub fn set_option_raw(&mut self, value: [u8; 4]) {
        self.option_raw = value;
    }
    pub fn new() -> PacketCzSeekParty {
        PacketCzSeekParty {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7d, 0xc]),
        packet_id_raw: [0x7d, 0xc],
        option: 0,
        option_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzSeekParty {
    fn id(&self) -> &str {
       "0x07dc"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSeekParty {
    pub fn from(buffer: &[u8]) -> PacketZcSeekParty {
        PacketZcSeekParty {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            job: u32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            job_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
            level: u32::from_le_bytes([buffer[30], buffer[31], buffer[32], buffer[33]]),
            level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[30..34]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[34..50].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[34..50]);
                dst
            },
            option: u32::from_le_bytes([buffer[50], buffer[51], buffer[52], buffer[53]]),
            option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[50..54]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.option).unwrap();
        self.option_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.option_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_job(&mut self, value: u32) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 4]) {
        self.job_raw = value;
    }
    pub fn set_level(&mut self, value: u32) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 4]) {
        self.level_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_option(&mut self, value: u32) {
        self.option = value;
    }
    pub fn set_option_raw(&mut self, value: [u8; 4]) {
        self.option_raw = value;
    }
    pub fn new() -> PacketZcSeekParty {
        PacketZcSeekParty {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7d, 0xd]),
        packet_id_raw: [0x7d, 0xd],
        name: [0 as char; 24],
        name_raw: [0; 24],
        job: 0,
        job_raw: [0; 4],
        level: 0,
        level_raw: [0; 4],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        option: 0,
        option_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcSeekParty {
    fn id(&self) -> &str {
       "0x07dd"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzSeekPartyMember {
    pub fn from(buffer: &[u8]) -> PacketCzSeekPartyMember {
        PacketCzSeekPartyMember {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            job: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            job_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            level: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[10..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[10..26]);
                dst
            },
            option: u32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.option).unwrap();
        self.option_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.option_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_job(&mut self, value: u32) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 4]) {
        self.job_raw = value;
    }
    pub fn set_level(&mut self, value: u32) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 4]) {
        self.level_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_option(&mut self, value: u32) {
        self.option = value;
    }
    pub fn set_option_raw(&mut self, value: [u8; 4]) {
        self.option_raw = value;
    }
    pub fn new() -> PacketCzSeekPartyMember {
        PacketCzSeekPartyMember {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7d, 0xe]),
        packet_id_raw: [0x7d, 0xe],
        job: 0,
        job_raw: [0; 4],
        level: 0,
        level_raw: [0; 4],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        option: 0,
        option_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzSeekPartyMember {
    fn id(&self) -> &str {
       "0x07de"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSeekPartyMember {
    pub fn from(buffer: &[u8]) -> PacketZcSeekPartyMember {
        PacketZcSeekPartyMember {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            job: u32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            job_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
            level: u32::from_le_bytes([buffer[30], buffer[31], buffer[32], buffer[33]]),
            level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[30..34]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[34..50].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[34..50]);
                dst
            },
            option: u32::from_le_bytes([buffer[50], buffer[51], buffer[52], buffer[53]]),
            option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[50..54]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.option).unwrap();
        self.option_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.option_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_job(&mut self, value: u32) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 4]) {
        self.job_raw = value;
    }
    pub fn set_level(&mut self, value: u32) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 4]) {
        self.level_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_option(&mut self, value: u32) {
        self.option = value;
    }
    pub fn set_option_raw(&mut self, value: [u8; 4]) {
        self.option_raw = value;
    }
    pub fn new() -> PacketZcSeekPartyMember {
        PacketZcSeekPartyMember {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7d, 0xf]),
        packet_id_raw: [0x7d, 0xf],
        name: [0 as char; 24],
        name_raw: [0; 24],
        job: 0,
        job_raw: [0; 4],
        level: 0,
        level_raw: [0; 4],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        option: 0,
        option_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcSeekPartyMember {
    fn id(&self) -> &str {
       "0x07df"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcEsNotiMyinfo {
    pub fn from(buffer: &[u8]) -> PacketZcEsNotiMyinfo {
        PacketZcEsNotiMyinfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            es_no: i16::from_le_bytes([buffer[2], buffer[3]]),
            es_no_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            esname:  {
                let mut dst: [char; 54] = [0 as char; 54];
                for (index, byte) in buffer[4..58].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            esname_raw: {
                let mut dst: [u8; 54] = [0u8; 54];
                dst.clone_from_slice(&buffer[4..58]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_no).unwrap();
        self.es_no_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.esname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.esname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.es_no_raw.to_vec());
        wtr.append(&mut self.esname_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_es_no(&mut self, value: i16) {
        self.es_no = value;
    }
    pub fn set_es_no_raw(&mut self, value: [u8; 2]) {
        self.es_no_raw = value;
    }
    pub fn set_esname(&mut self, value: [char; 54]) {
        self.esname = value;
    }
    pub fn set_esname_raw(&mut self, value: [u8; 54]) {
        self.esname_raw = value;
    }
    pub fn new() -> PacketZcEsNotiMyinfo {
        PacketZcEsNotiMyinfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7e, 0x0]),
        packet_id_raw: [0x7e, 0x0],
        es_no: 0,
        es_no_raw: [0; 2],
        esname: [0 as char; 54],
        esname_raw: [0; 54],
        }
    }
}

impl Packet for PacketZcEsNotiMyinfo {
    fn id(&self) -> &str {
       "0x07e0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSkillinfoUpdate2 {
    pub fn from(buffer: &[u8]) -> PacketZcSkillinfoUpdate2 {
        PacketZcSkillinfoUpdate2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            level: i16::from_le_bytes([buffer[8], buffer[9]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            spcost: i16::from_le_bytes([buffer[10], buffer[11]]),
            spcost_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            attack_range: i16::from_le_bytes([buffer[12], buffer[13]]),
            attack_range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            upgradable: buffer[14] == 1,
            upgradable_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.spcost).unwrap();
        self.spcost_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.attack_range).unwrap();
        self.attack_range_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.upgradable as u8).unwrap();
        self.upgradable_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.spcost_raw.to_vec());
        wtr.append(&mut self.attack_range_raw.to_vec());
        wtr.append(&mut self.upgradable_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_spcost(&mut self, value: i16) {
        self.spcost = value;
    }
    pub fn set_spcost_raw(&mut self, value: [u8; 2]) {
        self.spcost_raw = value;
    }
    pub fn set_attack_range(&mut self, value: i16) {
        self.attack_range = value;
    }
    pub fn set_attack_range_raw(&mut self, value: [u8; 2]) {
        self.attack_range_raw = value;
    }
    pub fn set_upgradable(&mut self, value: bool) {
        self.upgradable = value;
    }
    pub fn set_upgradable_raw(&mut self, value: [u8; 1]) {
        self.upgradable_raw = value;
    }
    pub fn new() -> PacketZcSkillinfoUpdate2 {
        PacketZcSkillinfoUpdate2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7e, 0x1]),
        packet_id_raw: [0x7e, 0x1],
        skid: 0,
        skid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 4],
        level: 0,
        level_raw: [0; 2],
        spcost: 0,
        spcost_raw: [0; 2],
        attack_range: 0,
        attack_range_raw: [0; 2],
        upgradable: false,
        upgradable_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcSkillinfoUpdate2 {
    fn id(&self) -> &str {
       "0x07e1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMsgValue {
    pub fn from(buffer: &[u8]) -> PacketZcMsgValue {
        PacketZcMsgValue {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            msg: u16::from_le_bytes([buffer[2], buffer[3]]),
            msg_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            value: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.msg).unwrap();
        self.msg_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_msg(&mut self, value: u16) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: [u8; 2]) {
        self.msg_raw = value;
    }
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new() -> PacketZcMsgValue {
        PacketZcMsgValue {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7e, 0x2]),
        packet_id_raw: [0x7e, 0x2],
        msg: 0,
        msg_raw: [0; 2],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcMsgValue {
    fn id(&self) -> &str {
       "0x07e2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcItemlistwinOpen {
    pub fn from(buffer: &[u8]) -> PacketZcItemlistwinOpen {
        PacketZcItemlistwinOpen {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn new() -> PacketZcItemlistwinOpen {
        PacketZcItemlistwinOpen {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7e, 0x3]),
        packet_id_raw: [0x7e, 0x3],
        atype: 0,
        atype_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcItemlistwinOpen {
    fn id(&self) -> &str {
       "0x07e3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzItemlistwinRes {
    pub fn from(buffer: &[u8]) -> PacketCzItemlistwinRes {
        PacketCzItemlistwinRes {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            action: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            action_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            material_list: u16::from_le_bytes([buffer[12], buffer[13]]),
            material_list_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.material_list).unwrap();
        self.material_list_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        wtr.append(&mut self.material_list_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn set_action(&mut self, value: i32) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 4]) {
        self.action_raw = value;
    }
    pub fn set_material_list(&mut self, value: u16) {
        self.material_list = value;
    }
    pub fn set_material_list_raw(&mut self, value: [u8; 2]) {
        self.material_list_raw = value;
    }
    pub fn new() -> PacketCzItemlistwinRes {
        PacketCzItemlistwinRes {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7e, 0x4]),
        packet_id_raw: [0x7e, 0x4],
        packet_length: 0,
        packet_length_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 4],
        action: 0,
        action_raw: [0; 4],
        material_list: 0,
        material_list_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzItemlistwinRes {
    fn id(&self) -> &str {
       "0x07e4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketChEnterCheckbot {
    pub fn from(buffer: &[u8]) -> PacketChEnterCheckbot {
        PacketChEnterCheckbot {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            dw_aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            dw_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            sz_string_info: String::from_utf8_lossy(&buffer[8..buffer.len()]).to_string(),
            sz_string_info_raw: buffer[8..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_aid).unwrap();
        self.dw_aid_raw = wtr.try_into().unwrap();
        self.sz_string_info_raw = self.sz_string_info.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.dw_aid_raw.to_vec());
        wtr.append(&mut self.sz_string_info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_dw_aid(&mut self, value: u32) {
        self.dw_aid = value;
    }
    pub fn set_dw_aid_raw(&mut self, value: [u8; 4]) {
        self.dw_aid_raw = value;
    }
    pub fn set_sz_string_info(&mut self, value: String) {
        self.sz_string_info = value;
    }
    pub fn set_sz_string_info_raw(&mut self, value: Vec<u8>) {
        self.sz_string_info_raw = value;
    }
    pub fn new() -> PacketChEnterCheckbot {
        PacketChEnterCheckbot {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7e, 0x5]),
        packet_id_raw: [0x7e, 0x5],
        packet_length: 0,
        packet_length_raw: [0; 2],
        dw_aid: 0,
        dw_aid_raw: [0; 4],
        sz_string_info: String::new(),
        sz_string_info_raw: vec![],
        }
    }
}

impl Packet for PacketChEnterCheckbot {
    fn id(&self) -> &str {
       "0x07e5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMsgSkill {
    pub fn from(buffer: &[u8]) -> PacketZcMsgSkill {
        PacketZcMsgSkill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msgid: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            msgid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.msgid).unwrap();
        self.msgid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.msgid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_msgid(&mut self, value: i32) {
        self.msgid = value;
    }
    pub fn set_msgid_raw(&mut self, value: [u8; 4]) {
        self.msgid_raw = value;
    }
    pub fn new() -> PacketZcMsgSkill {
        PacketZcMsgSkill {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7e, 0x6]),
        packet_id_raw: [0x7e, 0x6],
        skid: 0,
        skid_raw: [0; 2],
        msgid: 0,
        msgid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcMsgSkill {
    fn id(&self) -> &str {
       "0x07e6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketChCheckbot {
    pub fn from(buffer: &[u8]) -> PacketChCheckbot {
        PacketChCheckbot {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            dw_aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            dw_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            sz_string_info:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[8..32].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            sz_string_info_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[8..32]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_aid).unwrap();
        self.dw_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_string_info {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_string_info_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.dw_aid_raw.to_vec());
        wtr.append(&mut self.sz_string_info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_dw_aid(&mut self, value: u32) {
        self.dw_aid = value;
    }
    pub fn set_dw_aid_raw(&mut self, value: [u8; 4]) {
        self.dw_aid_raw = value;
    }
    pub fn set_sz_string_info(&mut self, value: [char; 24]) {
        self.sz_string_info = value;
    }
    pub fn set_sz_string_info_raw(&mut self, value: [u8; 24]) {
        self.sz_string_info_raw = value;
    }
    pub fn new() -> PacketChCheckbot {
        PacketChCheckbot {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7e, 0x7]),
        packet_id_raw: [0x7e, 0x7],
        packet_length: 0,
        packet_length_raw: [0; 2],
        dw_aid: 0,
        dw_aid_raw: [0; 4],
        sz_string_info: [0 as char; 24],
        sz_string_info_raw: [0; 24],
        }
    }
}

impl Packet for PacketChCheckbot {
    fn id(&self) -> &str {
       "0x07e7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcCheckbot {
    pub fn from(buffer: &[u8]) -> PacketHcCheckbot {
        PacketHcCheckbot {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            img: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            img_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.img_raw = self.img.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.img_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_img(&mut self, value: String) {
        self.img = value;
    }
    pub fn set_img_raw(&mut self, value: Vec<u8>) {
        self.img_raw = value;
    }
    pub fn new() -> PacketHcCheckbot {
        PacketHcCheckbot {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7e, 0x8]),
        packet_id_raw: [0x7e, 0x8],
        packet_length: 0,
        packet_length_raw: [0; 2],
        img: String::new(),
        img_raw: vec![],
        }
    }
}

impl Packet for PacketHcCheckbot {
    fn id(&self) -> &str {
       "0x07e8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcCheckbotResult {
    pub fn from(buffer: &[u8]) -> PacketHcCheckbotResult {
        PacketHcCheckbotResult {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            result: u8::from_le_bytes([buffer[4]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketHcCheckbotResult {
        PacketHcCheckbotResult {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7e, 0x9]),
        packet_id_raw: [0x7e, 0x9],
        packet_length: 0,
        packet_length_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketHcCheckbotResult {
    fn id(&self) -> &str {
       "0x07e9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzBattleFieldList {
    pub fn from(buffer: &[u8]) -> PacketCzBattleFieldList {
        PacketCzBattleFieldList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzBattleFieldList {
        PacketCzBattleFieldList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7e, 0xa]),
        packet_id_raw: [0x7e, 0xa],
        }
    }
}

impl Packet for PacketCzBattleFieldList {
    fn id(&self) -> &str {
       "0x07ea"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcBattleFieldList {
    pub fn from(buffer: &[u8]) -> PacketZcBattleFieldList {
        let iter_count = (&buffer.len() - 8) / 62;
        let mut vec_field: Vec<BattleFieldInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (62 * (i - 1));
            let end_pos = 8 + 62 * i;
            vec_field.push(BattleFieldInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcBattleFieldList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            ack_type: i16::from_le_bytes([buffer[6], buffer[7]]),
            ack_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            info_list: vec_field.clone(),
            info_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.ack_type).unwrap();
        self.ack_type_raw = wtr.try_into().unwrap();
        self.info_list_raw = {
            self.info_list.iter_mut().for_each(|item| item.fill_raw());
            self.info_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.ack_type_raw.to_vec());
        self.info_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_ack_type(&mut self, value: i16) {
        self.ack_type = value;
    }
    pub fn set_ack_type_raw(&mut self, value: [u8; 2]) {
        self.ack_type_raw = value;
    }
    pub fn set_info_list(&mut self, value: Vec<BattleFieldInfo>) {
        self.info_list = value;
    }
    pub fn set_info_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.info_list_raw = value;
    }
    pub fn new() -> PacketZcBattleFieldList {
        PacketZcBattleFieldList {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7e, 0xb]),
        packet_id_raw: [0x7e, 0xb],
        packet_length: 0,
        packet_length_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        ack_type: 0,
        ack_type_raw: [0; 2],
        info_list: vec![],
        info_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcBattleFieldList {
    fn id(&self) -> &str {
       "0x07eb"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzJoinBattleField {
    pub fn from(buffer: &[u8]) -> PacketCzJoinBattleField {
        PacketCzJoinBattleField {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            bfno: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            join_team: i16::from_le_bytes([buffer[6], buffer[7]]),
            join_team_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.join_team).unwrap();
        self.join_team_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.bfno_raw.to_vec());
        wtr.append(&mut self.join_team_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_bfno(&mut self, value: u32) {
        self.bfno = value;
    }
    pub fn set_bfno_raw(&mut self, value: [u8; 4]) {
        self.bfno_raw = value;
    }
    pub fn set_join_team(&mut self, value: i16) {
        self.join_team = value;
    }
    pub fn set_join_team_raw(&mut self, value: [u8; 2]) {
        self.join_team_raw = value;
    }
    pub fn new() -> PacketCzJoinBattleField {
        PacketCzJoinBattleField {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7e, 0xc]),
        packet_id_raw: [0x7e, 0xc],
        bfno: 0,
        bfno_raw: [0; 4],
        join_team: 0,
        join_team_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzJoinBattleField {
    fn id(&self) -> &str {
       "0x07ec"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcJoinBattleField {
    pub fn from(buffer: &[u8]) -> PacketZcJoinBattleField {
        PacketZcJoinBattleField {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            bfno: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            join_team: i16::from_le_bytes([buffer[6], buffer[7]]),
            join_team_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            result: i16::from_le_bytes([buffer[8], buffer[9]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.join_team).unwrap();
        self.join_team_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.bfno_raw.to_vec());
        wtr.append(&mut self.join_team_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_bfno(&mut self, value: u32) {
        self.bfno = value;
    }
    pub fn set_bfno_raw(&mut self, value: [u8; 4]) {
        self.bfno_raw = value;
    }
    pub fn set_join_team(&mut self, value: i16) {
        self.join_team = value;
    }
    pub fn set_join_team_raw(&mut self, value: [u8; 2]) {
        self.join_team_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcJoinBattleField {
        PacketZcJoinBattleField {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7e, 0xd]),
        packet_id_raw: [0x7e, 0xd],
        bfno: 0,
        bfno_raw: [0; 4],
        join_team: 0,
        join_team_raw: [0; 2],
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcJoinBattleField {
    fn id(&self) -> &str {
       "0x07ed"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzCancelBattleField {
    pub fn from(buffer: &[u8]) -> PacketCzCancelBattleField {
        PacketCzCancelBattleField {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            bfno: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.bfno_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_bfno(&mut self, value: u32) {
        self.bfno = value;
    }
    pub fn set_bfno_raw(&mut self, value: [u8; 4]) {
        self.bfno_raw = value;
    }
    pub fn new() -> PacketCzCancelBattleField {
        PacketCzCancelBattleField {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7e, 0xe]),
        packet_id_raw: [0x7e, 0xe],
        bfno: 0,
        bfno_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzCancelBattleField {
    fn id(&self) -> &str {
       "0x07ee"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcCancelBattleField {
    pub fn from(buffer: &[u8]) -> PacketZcCancelBattleField {
        PacketZcCancelBattleField {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            bfno: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            result: i16::from_le_bytes([buffer[6], buffer[7]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.bfno_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_bfno(&mut self, value: u32) {
        self.bfno = value;
    }
    pub fn set_bfno_raw(&mut self, value: [u8; 4]) {
        self.bfno_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcCancelBattleField {
        PacketZcCancelBattleField {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7e, 0xf]),
        packet_id_raw: [0x7e, 0xf],
        bfno: 0,
        bfno_raw: [0; 4],
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcCancelBattleField {
    fn id(&self) -> &str {
       "0x07ef"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqBattleStateMonitor {
    pub fn from(buffer: &[u8]) -> PacketCzReqBattleStateMonitor {
        PacketCzReqBattleStateMonitor {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            bfno: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            power_switch: i16::from_le_bytes([buffer[6], buffer[7]]),
            power_switch_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.power_switch).unwrap();
        self.power_switch_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.bfno_raw.to_vec());
        wtr.append(&mut self.power_switch_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_bfno(&mut self, value: u32) {
        self.bfno = value;
    }
    pub fn set_bfno_raw(&mut self, value: [u8; 4]) {
        self.bfno_raw = value;
    }
    pub fn set_power_switch(&mut self, value: i16) {
        self.power_switch = value;
    }
    pub fn set_power_switch_raw(&mut self, value: [u8; 2]) {
        self.power_switch_raw = value;
    }
    pub fn new() -> PacketCzReqBattleStateMonitor {
        PacketCzReqBattleStateMonitor {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7f, 0x0]),
        packet_id_raw: [0x7f, 0x0],
        bfno: 0,
        bfno_raw: [0; 4],
        power_switch: 0,
        power_switch_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqBattleStateMonitor {
    fn id(&self) -> &str {
       "0x07f0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckBattleStateMonitor {
    pub fn from(buffer: &[u8]) -> PacketZcAckBattleStateMonitor {
        PacketZcAckBattleStateMonitor {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            bfno: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            play_count: i16::from_le_bytes([buffer[6], buffer[7]]),
            play_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            battle_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            battle_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            team_count_a: i16::from_le_bytes([buffer[10], buffer[11]]),
            team_count_a_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            team_count_b: i16::from_le_bytes([buffer[12], buffer[13]]),
            team_count_b_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            my_count: i16::from_le_bytes([buffer[14], buffer[15]]),
            my_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            join_team: i16::from_le_bytes([buffer[16], buffer[17]]),
            join_team_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.play_count).unwrap();
        self.play_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.battle_state).unwrap();
        self.battle_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.team_count_a).unwrap();
        self.team_count_a_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.team_count_b).unwrap();
        self.team_count_b_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.my_count).unwrap();
        self.my_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.join_team).unwrap();
        self.join_team_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.bfno_raw.to_vec());
        wtr.append(&mut self.play_count_raw.to_vec());
        wtr.append(&mut self.battle_state_raw.to_vec());
        wtr.append(&mut self.team_count_a_raw.to_vec());
        wtr.append(&mut self.team_count_b_raw.to_vec());
        wtr.append(&mut self.my_count_raw.to_vec());
        wtr.append(&mut self.join_team_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_bfno(&mut self, value: u32) {
        self.bfno = value;
    }
    pub fn set_bfno_raw(&mut self, value: [u8; 4]) {
        self.bfno_raw = value;
    }
    pub fn set_play_count(&mut self, value: i16) {
        self.play_count = value;
    }
    pub fn set_play_count_raw(&mut self, value: [u8; 2]) {
        self.play_count_raw = value;
    }
    pub fn set_battle_state(&mut self, value: i16) {
        self.battle_state = value;
    }
    pub fn set_battle_state_raw(&mut self, value: [u8; 2]) {
        self.battle_state_raw = value;
    }
    pub fn set_team_count_a(&mut self, value: i16) {
        self.team_count_a = value;
    }
    pub fn set_team_count_a_raw(&mut self, value: [u8; 2]) {
        self.team_count_a_raw = value;
    }
    pub fn set_team_count_b(&mut self, value: i16) {
        self.team_count_b = value;
    }
    pub fn set_team_count_b_raw(&mut self, value: [u8; 2]) {
        self.team_count_b_raw = value;
    }
    pub fn set_my_count(&mut self, value: i16) {
        self.my_count = value;
    }
    pub fn set_my_count_raw(&mut self, value: [u8; 2]) {
        self.my_count_raw = value;
    }
    pub fn set_join_team(&mut self, value: i16) {
        self.join_team = value;
    }
    pub fn set_join_team_raw(&mut self, value: [u8; 2]) {
        self.join_team_raw = value;
    }
    pub fn new() -> PacketZcAckBattleStateMonitor {
        PacketZcAckBattleStateMonitor {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7f, 0x1]),
        packet_id_raw: [0x7f, 0x1],
        bfno: 0,
        bfno_raw: [0; 4],
        play_count: 0,
        play_count_raw: [0; 2],
        battle_state: 0,
        battle_state_raw: [0; 2],
        team_count_a: 0,
        team_count_a_raw: [0; 2],
        team_count_b: 0,
        team_count_b_raw: [0; 2],
        my_count: 0,
        my_count_raw: [0; 2],
        join_team: 0,
        join_team_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAckBattleStateMonitor {
    fn id(&self) -> &str {
       "0x07f1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcBattleNotiStartStep {
    pub fn from(buffer: &[u8]) -> PacketZcBattleNotiStartStep {
        PacketZcBattleNotiStartStep {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            bfno: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            result: i16::from_le_bytes([buffer[6], buffer[7]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.bfno_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_bfno(&mut self, value: u32) {
        self.bfno = value;
    }
    pub fn set_bfno_raw(&mut self, value: [u8; 4]) {
        self.bfno_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcBattleNotiStartStep {
        PacketZcBattleNotiStartStep {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7f, 0x2]),
        packet_id_raw: [0x7f, 0x2],
        bfno: 0,
        bfno_raw: [0; 4],
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcBattleNotiStartStep {
    fn id(&self) -> &str {
       "0x07f2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcBattleJoinNotiDefer {
    pub fn from(buffer: &[u8]) -> PacketZcBattleJoinNotiDefer {
        PacketZcBattleJoinNotiDefer {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            bfno: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.bfno_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_bfno(&mut self, value: u32) {
        self.bfno = value;
    }
    pub fn set_bfno_raw(&mut self, value: [u8; 4]) {
        self.bfno_raw = value;
    }
    pub fn new() -> PacketZcBattleJoinNotiDefer {
        PacketZcBattleJoinNotiDefer {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7f, 0x3]),
        packet_id_raw: [0x7f, 0x3],
        bfno: 0,
        bfno_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcBattleJoinNotiDefer {
    fn id(&self) -> &str {
       "0x07f3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcBattleJoinDisableState {
    pub fn from(buffer: &[u8]) -> PacketZcBattleJoinDisableState {
        PacketZcBattleJoinDisableState {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            enable: buffer[2] == 1,
            enable_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.enable as u8).unwrap();
        self.enable_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.enable_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_enable(&mut self, value: bool) {
        self.enable = value;
    }
    pub fn set_enable_raw(&mut self, value: [u8; 1]) {
        self.enable_raw = value;
    }
    pub fn new() -> PacketZcBattleJoinDisableState {
        PacketZcBattleJoinDisableState {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7f, 0x4]),
        packet_id_raw: [0x7f, 0x4],
        enable: false,
        enable_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcBattleJoinDisableState {
    fn id(&self) -> &str {
       "0x07f4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzGmFullstrip {
    pub fn from(buffer: &[u8]) -> PacketCzGmFullstrip {
        PacketCzGmFullstrip {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            target_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            target_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_aid).unwrap();
        self.target_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.target_aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_target_aid(&mut self, value: u32) {
        self.target_aid = value;
    }
    pub fn set_target_aid_raw(&mut self, value: [u8; 4]) {
        self.target_aid_raw = value;
    }
    pub fn new() -> PacketCzGmFullstrip {
        PacketCzGmFullstrip {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7f, 0x5]),
        packet_id_raw: [0x7f, 0x5],
        target_aid: 0,
        target_aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzGmFullstrip {
    fn id(&self) -> &str {
       "0x07f5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyExp {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyExp {
        PacketZcNotifyExp {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            amount: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            amount_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            var_id: u16::from_le_bytes([buffer[10], buffer[11]]),
            var_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            exp_type: i16::from_le_bytes([buffer[12], buffer[13]]),
            exp_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.amount).unwrap();
        self.amount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var_id).unwrap();
        self.var_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.exp_type).unwrap();
        self.exp_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.amount_raw.to_vec());
        wtr.append(&mut self.var_id_raw.to_vec());
        wtr.append(&mut self.exp_type_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_amount(&mut self, value: i32) {
        self.amount = value;
    }
    pub fn set_amount_raw(&mut self, value: [u8; 4]) {
        self.amount_raw = value;
    }
    pub fn set_var_id(&mut self, value: u16) {
        self.var_id = value;
    }
    pub fn set_var_id_raw(&mut self, value: [u8; 2]) {
        self.var_id_raw = value;
    }
    pub fn set_exp_type(&mut self, value: i16) {
        self.exp_type = value;
    }
    pub fn set_exp_type_raw(&mut self, value: [u8; 2]) {
        self.exp_type_raw = value;
    }
    pub fn new() -> PacketZcNotifyExp {
        PacketZcNotifyExp {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7f, 0x6]),
        packet_id_raw: [0x7f, 0x6],
        aid: 0,
        aid_raw: [0; 4],
        amount: 0,
        amount_raw: [0; 4],
        var_id: 0,
        var_id_raw: [0; 2],
        exp_type: 0,
        exp_type_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyExp {
    fn id(&self) -> &str {
       "0x07f6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyMoveentry7 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMoveentry7 {
        PacketZcNotifyMoveentry7 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            objecttype: u8::from_le_bytes([buffer[4]]),
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            gid: u32::from_le_bytes([buffer[5], buffer[6], buffer[7], buffer[8]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[5..9]);
                dst
            },
            speed: i16::from_le_bytes([buffer[9], buffer[10]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[11], buffer[12]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[13], buffer[14]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[13..15]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[15], buffer[16], buffer[17], buffer[18]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[15..19]);
                dst
            },
            job: i16::from_le_bytes([buffer[19], buffer[20]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            head: i16::from_le_bytes([buffer[21], buffer[22]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[21..23]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[23], buffer[24], buffer[25], buffer[26]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[23..27]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[27], buffer[28]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[27..29]);
                dst
            },
            move_start_time: u32::from_le_bytes([buffer[29], buffer[30], buffer[31], buffer[32]]),
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[29..33]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[33], buffer[34]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[35], buffer[36]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[35..37]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[37], buffer[38]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[37..39]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[39], buffer[40]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[39..41]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[41], buffer[42]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[41..43]);
                dst
            },
            guid: u32::from_le_bytes([buffer[43], buffer[44], buffer[45], buffer[46]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[43..47]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[47], buffer[48]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[47..49]);
                dst
            },
            honor: i16::from_le_bytes([buffer[49], buffer[50]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[49..51]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[51], buffer[52], buffer[53], buffer[54]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[51..55]);
                dst
            },
            is_pkmode_on: buffer[55] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[55..56]);
                dst
            },
            sex: u8::from_le_bytes([buffer[56]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[56..57]);
                dst
            },
            move_data:  {
                let mut dst: [u16; 6] = [0 as u16; 6];
                for (index, byte) in buffer[57..63].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            },
            move_data_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[57..63]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[63]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[63..64]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[64]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[64..65]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[65], buffer[66]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[65..67]);
                dst
            },
            font: i16::from_le_bytes([buffer[67], buffer[68]]),
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[67..69]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[69..93].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[69..93]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.objecttype_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.move_start_time_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.move_data_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        wtr.append(&mut self.font_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_objecttype(&mut self, value: u8) {
        self.objecttype = value;
    }
    pub fn set_objecttype_raw(&mut self, value: [u8; 1]) {
        self.objecttype_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_move_start_time(&mut self, value: u32) {
        self.move_start_time = value;
    }
    pub fn set_move_start_time_raw(&mut self, value: [u8; 4]) {
        self.move_start_time_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_move_data(&mut self, value: [u16; 6]) {
        self.move_data = value;
    }
    pub fn set_move_data_raw(&mut self, value: [u8; 6]) {
        self.move_data_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn set_font(&mut self, value: i16) {
        self.font = value;
    }
    pub fn set_font_raw(&mut self, value: [u8; 2]) {
        self.font_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new() -> PacketZcNotifyMoveentry7 {
        PacketZcNotifyMoveentry7 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7f, 0x7]),
        packet_id_raw: [0x7f, 0x7],
        packet_length: 0,
        packet_length_raw: [0; 2],
        objecttype: 0,
        objecttype_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        move_start_time: 0,
        move_start_time_raw: [0; 4],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        move_data: [0; 6],
        move_data_raw: [0; 6],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        font: 0,
        font_raw: [0; 2],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcNotifyMoveentry7 {
    fn id(&self) -> &str {
       "0x07f7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyNewentry5 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyNewentry5 {
        PacketZcNotifyNewentry5 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            objecttype: u8::from_le_bytes([buffer[4]]),
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            gid: u32::from_le_bytes([buffer[5], buffer[6], buffer[7], buffer[8]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[5..9]);
                dst
            },
            speed: i16::from_le_bytes([buffer[9], buffer[10]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[11], buffer[12]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[13], buffer[14]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[13..15]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[15], buffer[16], buffer[17], buffer[18]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[15..19]);
                dst
            },
            job: i16::from_le_bytes([buffer[19], buffer[20]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            head: i16::from_le_bytes([buffer[21], buffer[22]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[21..23]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[23], buffer[24], buffer[25], buffer[26]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[23..27]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[27], buffer[28]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[27..29]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[29], buffer[30]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[29..31]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[31], buffer[32]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[31..33]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[33], buffer[34]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[35], buffer[36]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[35..37]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[37], buffer[38]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[37..39]);
                dst
            },
            guid: u32::from_le_bytes([buffer[39], buffer[40], buffer[41], buffer[42]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[39..43]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[43], buffer[44]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[43..45]);
                dst
            },
            honor: i16::from_le_bytes([buffer[45], buffer[46]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[45..47]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[47], buffer[48], buffer[49], buffer[50]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[47..51]);
                dst
            },
            is_pkmode_on: buffer[51] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[51..52]);
                dst
            },
            sex: u8::from_le_bytes([buffer[52]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[52..53]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[53..56].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[53..56]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[56]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[56..57]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[57]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[57..58]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[58], buffer[59]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[58..60]);
                dst
            },
            font: i16::from_le_bytes([buffer[60], buffer[61]]),
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[60..62]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[62..86].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[62..86]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.objecttype_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        wtr.append(&mut self.font_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_objecttype(&mut self, value: u8) {
        self.objecttype = value;
    }
    pub fn set_objecttype_raw(&mut self, value: [u8; 1]) {
        self.objecttype_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [char; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn set_font(&mut self, value: i16) {
        self.font = value;
    }
    pub fn set_font_raw(&mut self, value: [u8; 2]) {
        self.font_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new() -> PacketZcNotifyNewentry5 {
        PacketZcNotifyNewentry5 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7f, 0x8]),
        packet_id_raw: [0x7f, 0x8],
        packet_length: 0,
        packet_length_raw: [0; 2],
        objecttype: 0,
        objecttype_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0 as char; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        font: 0,
        font_raw: [0; 2],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcNotifyNewentry5 {
    fn id(&self) -> &str {
       "0x07f8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyStandentry5 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyStandentry5 {
        PacketZcNotifyStandentry5 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            objecttype: u8::from_le_bytes([buffer[4]]),
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            gid: u32::from_le_bytes([buffer[5], buffer[6], buffer[7], buffer[8]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[5..9]);
                dst
            },
            speed: i16::from_le_bytes([buffer[9], buffer[10]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[11], buffer[12]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[13], buffer[14]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[13..15]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[15], buffer[16], buffer[17], buffer[18]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[15..19]);
                dst
            },
            job: i16::from_le_bytes([buffer[19], buffer[20]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            head: i16::from_le_bytes([buffer[21], buffer[22]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[21..23]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[23], buffer[24], buffer[25], buffer[26]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[23..27]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[27], buffer[28]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[27..29]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[29], buffer[30]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[29..31]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[31], buffer[32]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[31..33]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[33], buffer[34]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[35], buffer[36]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[35..37]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[37], buffer[38]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[37..39]);
                dst
            },
            guid: u32::from_le_bytes([buffer[39], buffer[40], buffer[41], buffer[42]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[39..43]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[43], buffer[44]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[43..45]);
                dst
            },
            honor: i16::from_le_bytes([buffer[45], buffer[46]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[45..47]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[47], buffer[48], buffer[49], buffer[50]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[47..51]);
                dst
            },
            is_pkmode_on: buffer[51] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[51..52]);
                dst
            },
            sex: u8::from_le_bytes([buffer[52]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[52..53]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[53..56].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[53..56]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[56]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[56..57]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[57]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[57..58]);
                dst
            },
            state: u8::from_le_bytes([buffer[58]]),
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[58..59]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[59], buffer[60]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[59..61]);
                dst
            },
            font: i16::from_le_bytes([buffer[61], buffer[62]]),
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[61..63]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[63..87].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[63..87]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.objecttype_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        wtr.append(&mut self.font_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_objecttype(&mut self, value: u8) {
        self.objecttype = value;
    }
    pub fn set_objecttype_raw(&mut self, value: [u8; 1]) {
        self.objecttype_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [char; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_state(&mut self, value: u8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn set_font(&mut self, value: i16) {
        self.font = value;
    }
    pub fn set_font_raw(&mut self, value: [u8; 2]) {
        self.font_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new() -> PacketZcNotifyStandentry5 {
        PacketZcNotifyStandentry5 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7f, 0x9]),
        packet_id_raw: [0x7f, 0x9],
        packet_length: 0,
        packet_length_raw: [0; 2],
        objecttype: 0,
        objecttype_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0 as char; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        state: 0,
        state_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        font: 0,
        font_raw: [0; 2],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcNotifyStandentry5 {
    fn id(&self) -> &str {
       "0x07f9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcDeleteItemFromBody {
    pub fn from(buffer: &[u8]) -> PacketZcDeleteItemFromBody {
        PacketZcDeleteItemFromBody {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            delete_type: i16::from_le_bytes([buffer[2], buffer[3]]),
            delete_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            index: u16::from_le_bytes([buffer[4], buffer[5]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            count: i16::from_le_bytes([buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.delete_type).unwrap();
        self.delete_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.delete_type_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_delete_type(&mut self, value: i16) {
        self.delete_type = value;
    }
    pub fn set_delete_type_raw(&mut self, value: [u8; 2]) {
        self.delete_type_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketZcDeleteItemFromBody {
        PacketZcDeleteItemFromBody {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7f, 0xa]),
        packet_id_raw: [0x7f, 0xa],
        delete_type: 0,
        delete_type_raw: [0; 2],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcDeleteItemFromBody {
    fn id(&self) -> &str {
       "0x07fa"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcUseskillAck2 {
    pub fn from(buffer: &[u8]) -> PacketZcUseskillAck2 {
        PacketZcUseskillAck2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            target_id: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[10], buffer[11]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[12], buffer[13]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            skid: u16::from_le_bytes([buffer[14], buffer[15]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            property: u32::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19]]),
            property_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[16..20]);
                dst
            },
            delay_time: u32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            delay_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
            is_disposable: buffer[24] == 1,
            is_disposable_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[24..25]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.property).unwrap();
        self.property_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.delay_time).unwrap();
        self.delay_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_disposable as u8).unwrap();
        self.is_disposable_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.target_id_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.property_raw.to_vec());
        wtr.append(&mut self.delay_time_raw.to_vec());
        wtr.append(&mut self.is_disposable_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_target_id(&mut self, value: u32) {
        self.target_id = value;
    }
    pub fn set_target_id_raw(&mut self, value: [u8; 4]) {
        self.target_id_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_property(&mut self, value: u32) {
        self.property = value;
    }
    pub fn set_property_raw(&mut self, value: [u8; 4]) {
        self.property_raw = value;
    }
    pub fn set_delay_time(&mut self, value: u32) {
        self.delay_time = value;
    }
    pub fn set_delay_time_raw(&mut self, value: [u8; 4]) {
        self.delay_time_raw = value;
    }
    pub fn set_is_disposable(&mut self, value: bool) {
        self.is_disposable = value;
    }
    pub fn set_is_disposable_raw(&mut self, value: [u8; 1]) {
        self.is_disposable_raw = value;
    }
    pub fn new() -> PacketZcUseskillAck2 {
        PacketZcUseskillAck2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7f, 0xb]),
        packet_id_raw: [0x7f, 0xb],
        aid: 0,
        aid_raw: [0; 4],
        target_id: 0,
        target_id_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        skid: 0,
        skid_raw: [0; 2],
        property: 0,
        property_raw: [0; 4],
        delay_time: 0,
        delay_time_raw: [0; 4],
        is_disposable: false,
        is_disposable_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcUseskillAck2 {
    fn id(&self) -> &str {
       "0x07fb"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcChangeGroupMaster {
    pub fn from(buffer: &[u8]) -> PacketZcChangeGroupMaster {
        PacketZcChangeGroupMaster {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            old_master_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            old_master_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            new_master_aid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            new_master_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.old_master_aid).unwrap();
        self.old_master_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.new_master_aid).unwrap();
        self.new_master_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.old_master_aid_raw.to_vec());
        wtr.append(&mut self.new_master_aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_old_master_aid(&mut self, value: u32) {
        self.old_master_aid = value;
    }
    pub fn set_old_master_aid_raw(&mut self, value: [u8; 4]) {
        self.old_master_aid_raw = value;
    }
    pub fn set_new_master_aid(&mut self, value: u32) {
        self.new_master_aid = value;
    }
    pub fn set_new_master_aid_raw(&mut self, value: [u8; 4]) {
        self.new_master_aid_raw = value;
    }
    pub fn new() -> PacketZcChangeGroupMaster {
        PacketZcChangeGroupMaster {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7f, 0xc]),
        packet_id_raw: [0x7f, 0xc],
        old_master_aid: 0,
        old_master_aid_raw: [0; 4],
        new_master_aid: 0,
        new_master_aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcChangeGroupMaster {
    fn id(&self) -> &str {
       "0x07fc"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPlayNpcBgm {
    pub fn from(buffer: &[u8]) -> PacketZcPlayNpcBgm {
        PacketZcPlayNpcBgm {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            bgm:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            bgm_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.bgm {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.bgm_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.bgm_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_bgm(&mut self, value: [char; 24]) {
        self.bgm = value;
    }
    pub fn set_bgm_raw(&mut self, value: [u8; 24]) {
        self.bgm_raw = value;
    }
    pub fn new() -> PacketZcPlayNpcBgm {
        PacketZcPlayNpcBgm {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7f, 0xe]),
        packet_id_raw: [0x7f, 0xe],
        bgm: [0 as char; 24],
        bgm_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcPlayNpcBgm {
    fn id(&self) -> &str {
       "0x07fe"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcDefineCheck {
    pub fn from(buffer: &[u8]) -> PacketZcDefineCheck {
        PacketZcDefineCheck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            result: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_result(&mut self, value: i32) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 4]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcDefineCheck {
        PacketZcDefineCheck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x7f, 0xf]),
        packet_id_raw: [0x7f, 0xf],
        packet_length: 0,
        packet_length_raw: [0; 2],
        result: 0,
        result_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDefineCheck {
    fn id(&self) -> &str {
       "0x07ff"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPcPurchaseItemlistFrommc2 {
    pub fn from(buffer: &[u8]) -> PacketZcPcPurchaseItemlistFrommc2 {
        let iter_count = (&buffer.len() - 12) / 22;
        let mut vec_field: Vec<PurchaseItemFrommc> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 12 + (22 * (i - 1));
            let end_pos = 12 + 22 * i;
            vec_field.push(PurchaseItemFrommc::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPcPurchaseItemlistFrommc2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            unique_id: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            unique_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.unique_id).unwrap();
        self.unique_id_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.unique_id_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_unique_id(&mut self, value: u32) {
        self.unique_id = value;
    }
    pub fn set_unique_id_raw(&mut self, value: [u8; 4]) {
        self.unique_id_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<PurchaseItemFrommc>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new() -> PacketZcPcPurchaseItemlistFrommc2 {
        PacketZcPcPurchaseItemlistFrommc2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x80, 0x0]),
        packet_id_raw: [0x80, 0x0],
        packet_length: 0,
        packet_length_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        unique_id: 0,
        unique_id_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcPcPurchaseItemlistFrommc2 {
    fn id(&self) -> &str {
       "0x0800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzPcPurchaseItemlistFrommc2 {
    pub fn from(buffer: &[u8]) -> PacketCzPcPurchaseItemlistFrommc2 {
        let iter_count = (&buffer.len() - 12) / 4;
        let mut vec_field: Vec<CzPurchaseItemFrommc> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 12 + (4 * (i - 1));
            let end_pos = 12 + 4 * i;
            vec_field.push(CzPurchaseItemFrommc::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzPcPurchaseItemlistFrommc2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            unique_id: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            unique_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.unique_id).unwrap();
        self.unique_id_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.unique_id_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_unique_id(&mut self, value: u32) {
        self.unique_id = value;
    }
    pub fn set_unique_id_raw(&mut self, value: [u8; 4]) {
        self.unique_id_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<CzPurchaseItemFrommc>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new() -> PacketCzPcPurchaseItemlistFrommc2 {
        PacketCzPcPurchaseItemlistFrommc2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x80, 0x1]),
        packet_id_raw: [0x80, 0x1],
        packet_length: 0,
        packet_length_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        unique_id: 0,
        unique_id_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketCzPcPurchaseItemlistFrommc2 {
    fn id(&self) -> &str {
       "0x0801"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzPartyBookingReqRegister {
    pub fn from(buffer: &[u8]) -> PacketCzPartyBookingReqRegister {
        PacketCzPartyBookingReqRegister {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            register_info: PartyBookingDetail::from(&buffer[2..buffer.len()]),
            register_info_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.register_info.fill_raw();
        self.register_info_raw = self.register_info.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.register_info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_register_info(&mut self, value: PartyBookingDetail) {
        self.register_info = value;
    }
    pub fn set_register_info_raw(&mut self, value: Vec<u8>) {
        self.register_info_raw = value;
    }
    pub fn new() -> PacketCzPartyBookingReqRegister {
        PacketCzPartyBookingReqRegister {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x80, 0x2]),
        packet_id_raw: [0x80, 0x2],
        register_info: PartyBookingDetail::new(),
        register_info_raw: vec![],
        }
    }
}

impl Packet for PacketCzPartyBookingReqRegister {
    fn id(&self) -> &str {
       "0x0802"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPartyBookingAckRegister {
    pub fn from(buffer: &[u8]) -> PacketZcPartyBookingAckRegister {
        PacketZcPartyBookingAckRegister {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcPartyBookingAckRegister {
        PacketZcPartyBookingAckRegister {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x80, 0x3]),
        packet_id_raw: [0x80, 0x3],
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcPartyBookingAckRegister {
    fn id(&self) -> &str {
       "0x0803"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzPartyBookingReqSearch {
    pub fn from(buffer: &[u8]) -> PacketCzPartyBookingReqSearch {
        PacketCzPartyBookingReqSearch {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            level: i16::from_le_bytes([buffer[2], buffer[3]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            map_id: i16::from_le_bytes([buffer[4], buffer[5]]),
            map_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            job: i16::from_le_bytes([buffer[6], buffer[7]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            last_index: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            last_index_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            result_count: i16::from_le_bytes([buffer[12], buffer[13]]),
            result_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.map_id).unwrap();
        self.map_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.last_index).unwrap();
        self.last_index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result_count).unwrap();
        self.result_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.map_id_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.last_index_raw.to_vec());
        wtr.append(&mut self.result_count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_map_id(&mut self, value: i16) {
        self.map_id = value;
    }
    pub fn set_map_id_raw(&mut self, value: [u8; 2]) {
        self.map_id_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_last_index(&mut self, value: u32) {
        self.last_index = value;
    }
    pub fn set_last_index_raw(&mut self, value: [u8; 4]) {
        self.last_index_raw = value;
    }
    pub fn set_result_count(&mut self, value: i16) {
        self.result_count = value;
    }
    pub fn set_result_count_raw(&mut self, value: [u8; 2]) {
        self.result_count_raw = value;
    }
    pub fn new() -> PacketCzPartyBookingReqSearch {
        PacketCzPartyBookingReqSearch {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x80, 0x4]),
        packet_id_raw: [0x80, 0x4],
        level: 0,
        level_raw: [0; 2],
        map_id: 0,
        map_id_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        last_index: 0,
        last_index_raw: [0; 4],
        result_count: 0,
        result_count_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzPartyBookingReqSearch {
    fn id(&self) -> &str {
       "0x0804"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPartyBookingAckSearch {
    pub fn from(buffer: &[u8]) -> PacketZcPartyBookingAckSearch {
        let iter_count = (&buffer.len() - 5) / 48;
        let mut vec_field: Vec<PartyBookingAdInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 5 + (48 * (i - 1));
            let end_pos = 5 + 48 * i;
            vec_field.push(PartyBookingAdInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPartyBookingAckSearch {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            is_exist_more_result: buffer[4] == 1,
            is_exist_more_result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            info: vec_field.clone(),
            info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_exist_more_result as u8).unwrap();
        self.is_exist_more_result_raw = wtr.try_into().unwrap();
        self.info_raw = {
            self.info.iter_mut().for_each(|item| item.fill_raw());
            self.info.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.is_exist_more_result_raw.to_vec());
        self.info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_is_exist_more_result(&mut self, value: bool) {
        self.is_exist_more_result = value;
    }
    pub fn set_is_exist_more_result_raw(&mut self, value: [u8; 1]) {
        self.is_exist_more_result_raw = value;
    }
    pub fn set_info(&mut self, value: Vec<PartyBookingAdInfo>) {
        self.info = value;
    }
    pub fn set_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.info_raw = value;
    }
    pub fn new() -> PacketZcPartyBookingAckSearch {
        PacketZcPartyBookingAckSearch {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x80, 0x5]),
        packet_id_raw: [0x80, 0x5],
        packet_length: 0,
        packet_length_raw: [0; 2],
        is_exist_more_result: false,
        is_exist_more_result_raw: [0; 1],
        info: vec![],
        info_raw: vec![],
        }
    }
}

impl Packet for PacketZcPartyBookingAckSearch {
    fn id(&self) -> &str {
       "0x0805"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzPartyBookingReqDelete {
    pub fn from(buffer: &[u8]) -> PacketCzPartyBookingReqDelete {
        PacketCzPartyBookingReqDelete {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzPartyBookingReqDelete {
        PacketCzPartyBookingReqDelete {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x80, 0x6]),
        packet_id_raw: [0x80, 0x6],
        }
    }
}

impl Packet for PacketCzPartyBookingReqDelete {
    fn id(&self) -> &str {
       "0x0806"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPartyBookingAckDelete {
    pub fn from(buffer: &[u8]) -> PacketZcPartyBookingAckDelete {
        PacketZcPartyBookingAckDelete {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcPartyBookingAckDelete {
        PacketZcPartyBookingAckDelete {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x80, 0x7]),
        packet_id_raw: [0x80, 0x7],
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcPartyBookingAckDelete {
    fn id(&self) -> &str {
       "0x0807"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzPartyBookingReqUpdate {
    pub fn from(buffer: &[u8]) -> PacketCzPartyBookingReqUpdate {
        PacketCzPartyBookingReqUpdate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            job:  {
                let mut dst: [i16; 6] = [0 as i16; 6];
                for (index, byte) in buffer[2..8].iter().enumerate() {
                    dst[index] = *byte as i16;
                }
                dst
            },
            job_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[2..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.job {
            wtr.write_i16::<LittleEndian>(item).unwrap();
        }
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_job(&mut self, value: [i16; 6]) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 6]) {
        self.job_raw = value;
    }
    pub fn new() -> PacketCzPartyBookingReqUpdate {
        PacketCzPartyBookingReqUpdate {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x80, 0x8]),
        packet_id_raw: [0x80, 0x8],
        job: [0; 6],
        job_raw: [0; 6],
        }
    }
}

impl Packet for PacketCzPartyBookingReqUpdate {
    fn id(&self) -> &str {
       "0x0808"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPartyBookingNotifyInsert {
    pub fn from(buffer: &[u8]) -> PacketZcPartyBookingNotifyInsert {
        PacketZcPartyBookingNotifyInsert {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            info: PartyBookingAdInfo::from(&buffer[2..buffer.len()]),
            info_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.info.fill_raw();
        self.info_raw = self.info.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_info(&mut self, value: PartyBookingAdInfo) {
        self.info = value;
    }
    pub fn set_info_raw(&mut self, value: Vec<u8>) {
        self.info_raw = value;
    }
    pub fn new() -> PacketZcPartyBookingNotifyInsert {
        PacketZcPartyBookingNotifyInsert {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x80, 0x9]),
        packet_id_raw: [0x80, 0x9],
        info: PartyBookingAdInfo::new(),
        info_raw: vec![],
        }
    }
}

impl Packet for PacketZcPartyBookingNotifyInsert {
    fn id(&self) -> &str {
       "0x0809"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPartyBookingNotifyUpdate {
    pub fn from(buffer: &[u8]) -> PacketZcPartyBookingNotifyUpdate {
        PacketZcPartyBookingNotifyUpdate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            index_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            job1: i16::from_le_bytes([buffer[6], buffer[7]]),
            job1_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            job2: i16::from_le_bytes([buffer[8], buffer[9]]),
            job2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            job3: i16::from_le_bytes([buffer[10], buffer[11]]),
            job3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            job4: i16::from_le_bytes([buffer[12], buffer[13]]),
            job4_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job5: i16::from_le_bytes([buffer[14], buffer[15]]),
            job5_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            job6: i16::from_le_bytes([buffer[16], buffer[17]]),
            job6_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job1).unwrap();
        self.job1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job2).unwrap();
        self.job2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job3).unwrap();
        self.job3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job4).unwrap();
        self.job4_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job5).unwrap();
        self.job5_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job6).unwrap();
        self.job6_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.job1_raw.to_vec());
        wtr.append(&mut self.job2_raw.to_vec());
        wtr.append(&mut self.job3_raw.to_vec());
        wtr.append(&mut self.job4_raw.to_vec());
        wtr.append(&mut self.job5_raw.to_vec());
        wtr.append(&mut self.job6_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u32) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 4]) {
        self.index_raw = value;
    }
    pub fn set_job1(&mut self, value: i16) {
        self.job1 = value;
    }
    pub fn set_job1_raw(&mut self, value: [u8; 2]) {
        self.job1_raw = value;
    }
    pub fn set_job2(&mut self, value: i16) {
        self.job2 = value;
    }
    pub fn set_job2_raw(&mut self, value: [u8; 2]) {
        self.job2_raw = value;
    }
    pub fn set_job3(&mut self, value: i16) {
        self.job3 = value;
    }
    pub fn set_job3_raw(&mut self, value: [u8; 2]) {
        self.job3_raw = value;
    }
    pub fn set_job4(&mut self, value: i16) {
        self.job4 = value;
    }
    pub fn set_job4_raw(&mut self, value: [u8; 2]) {
        self.job4_raw = value;
    }
    pub fn set_job5(&mut self, value: i16) {
        self.job5 = value;
    }
    pub fn set_job5_raw(&mut self, value: [u8; 2]) {
        self.job5_raw = value;
    }
    pub fn set_job6(&mut self, value: i16) {
        self.job6 = value;
    }
    pub fn set_job6_raw(&mut self, value: [u8; 2]) {
        self.job6_raw = value;
    }
    pub fn new() -> PacketZcPartyBookingNotifyUpdate {
        PacketZcPartyBookingNotifyUpdate {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x80, 0xa]),
        packet_id_raw: [0x80, 0xa],
        index: 0,
        index_raw: [0; 4],
        job1: 0,
        job1_raw: [0; 2],
        job2: 0,
        job2_raw: [0; 2],
        job3: 0,
        job3_raw: [0; 2],
        job4: 0,
        job4_raw: [0; 2],
        job5: 0,
        job5_raw: [0; 2],
        job6: 0,
        job6_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcPartyBookingNotifyUpdate {
    fn id(&self) -> &str {
       "0x080a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcPartyBookingNotifyDelete {
    pub fn from(buffer: &[u8]) -> PacketZcPartyBookingNotifyDelete {
        PacketZcPartyBookingNotifyDelete {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            index_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u32) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 4]) {
        self.index_raw = value;
    }
    pub fn new() -> PacketZcPartyBookingNotifyDelete {
        PacketZcPartyBookingNotifyDelete {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x80, 0xb]),
        packet_id_raw: [0x80, 0xb],
        index: 0,
        index_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcPartyBookingNotifyDelete {
    fn id(&self) -> &str {
       "0x080b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzSimpleCashBtnshow {
    pub fn from(buffer: &[u8]) -> PacketCzSimpleCashBtnshow {
        PacketCzSimpleCashBtnshow {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzSimpleCashBtnshow {
        PacketCzSimpleCashBtnshow {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x80, 0xc]),
        packet_id_raw: [0x80, 0xc],
        }
    }
}

impl Packet for PacketCzSimpleCashBtnshow {
    fn id(&self) -> &str {
       "0x080c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSimpleCashBtnshow {
    pub fn from(buffer: &[u8]) -> PacketZcSimpleCashBtnshow {
        PacketZcSimpleCashBtnshow {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            show: buffer[2] == 1,
            show_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.show as u8).unwrap();
        self.show_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.show_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_show(&mut self, value: bool) {
        self.show = value;
    }
    pub fn set_show_raw(&mut self, value: [u8; 1]) {
        self.show_raw = value;
    }
    pub fn new() -> PacketZcSimpleCashBtnshow {
        PacketZcSimpleCashBtnshow {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x80, 0xd]),
        packet_id_raw: [0x80, 0xd],
        show: false,
        show_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcSimpleCashBtnshow {
    fn id(&self) -> &str {
       "0x080d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcNotifyHpToGroupmR2 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyHpToGroupmR2 {
        PacketZcNotifyHpToGroupmR2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            hp: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            maxhp: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            maxhp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.maxhp).unwrap();
        self.maxhp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.maxhp_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_hp(&mut self, value: i32) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 4]) {
        self.hp_raw = value;
    }
    pub fn set_maxhp(&mut self, value: i32) {
        self.maxhp = value;
    }
    pub fn set_maxhp_raw(&mut self, value: [u8; 4]) {
        self.maxhp_raw = value;
    }
    pub fn new() -> PacketZcNotifyHpToGroupmR2 {
        PacketZcNotifyHpToGroupmR2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x80, 0xe]),
        packet_id_raw: [0x80, 0xe],
        aid: 0,
        aid_raw: [0; 4],
        hp: 0,
        hp_raw: [0; 4],
        maxhp: 0,
        maxhp_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyHpToGroupmR2 {
    fn id(&self) -> &str {
       "0x080e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAddExchangeItem2 {
    pub fn from(buffer: &[u8]) -> PacketZcAddExchangeItem2 {
        PacketZcAddExchangeItem2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: u8::from_le_bytes([buffer[4]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            count: i32::from_le_bytes([buffer[5], buffer[6], buffer[7], buffer[8]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[5..9]);
                dst
            },
            is_identified: buffer[9] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            is_damaged: buffer[10] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[11]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[12..20]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[12..20]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new() -> PacketZcAddExchangeItem2 {
        PacketZcAddExchangeItem2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x80, 0xf]),
        packet_id_raw: [0x80, 0xf],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        count: 0,
        count_raw: [0; 4],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        }
    }
}

impl Packet for PacketZcAddExchangeItem2 {
    fn id(&self) -> &str {
       "0x080f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcOpenBuyingStore {
    pub fn from(buffer: &[u8]) -> PacketZcOpenBuyingStore {
        PacketZcOpenBuyingStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            count: u8::from_le_bytes([buffer[2]]),
            count_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_count(&mut self, value: u8) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 1]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketZcOpenBuyingStore {
        PacketZcOpenBuyingStore {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x81, 0x0]),
        packet_id_raw: [0x81, 0x0],
        count: 0,
        count_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcOpenBuyingStore {
    fn id(&self) -> &str {
       "0x0810"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqOpenBuyingStore {
    pub fn from(buffer: &[u8]) -> PacketCzReqOpenBuyingStore {
        let iter_count = (&buffer.len() - 89) / 8;
        let mut vec_field: Vec<ProductinfoInBuyingStore> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 89 + (8 * (i - 1));
            let end_pos = 89 + 8 * i;
            vec_field.push(ProductinfoInBuyingStore::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzReqOpenBuyingStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            limit_zeny: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            limit_zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            result: u8::from_le_bytes([buffer[8]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            store_name:  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[9..89].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            store_name_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[9..89]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.limit_zeny).unwrap();
        self.limit_zeny_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.store_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.store_name_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.limit_zeny_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.store_name_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_limit_zeny(&mut self, value: u32) {
        self.limit_zeny = value;
    }
    pub fn set_limit_zeny_raw(&mut self, value: [u8; 4]) {
        self.limit_zeny_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn set_store_name(&mut self, value: [char; 80]) {
        self.store_name = value;
    }
    pub fn set_store_name_raw(&mut self, value: [u8; 80]) {
        self.store_name_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<ProductinfoInBuyingStore>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new() -> PacketCzReqOpenBuyingStore {
        PacketCzReqOpenBuyingStore {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x81, 0x1]),
        packet_id_raw: [0x81, 0x1],
        packet_length: 0,
        packet_length_raw: [0; 2],
        limit_zeny: 0,
        limit_zeny_raw: [0; 4],
        result: 0,
        result_raw: [0; 1],
        store_name: [0 as char; 80],
        store_name_raw: [0; 80],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketCzReqOpenBuyingStore {
    fn id(&self) -> &str {
       "0x0811"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcFailedOpenBuyingStoreToBuyer {
    pub fn from(buffer: &[u8]) -> PacketZcFailedOpenBuyingStoreToBuyer {
        PacketZcFailedOpenBuyingStoreToBuyer {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            total_weight: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            total_weight_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.total_weight).unwrap();
        self.total_weight_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.total_weight_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn set_total_weight(&mut self, value: i32) {
        self.total_weight = value;
    }
    pub fn set_total_weight_raw(&mut self, value: [u8; 4]) {
        self.total_weight_raw = value;
    }
    pub fn new() -> PacketZcFailedOpenBuyingStoreToBuyer {
        PacketZcFailedOpenBuyingStoreToBuyer {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x81, 0x2]),
        packet_id_raw: [0x81, 0x2],
        result: 0,
        result_raw: [0; 2],
        total_weight: 0,
        total_weight_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcFailedOpenBuyingStoreToBuyer {
    fn id(&self) -> &str {
       "0x0812"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcMyitemlistBuyingStore {
    pub fn from(buffer: &[u8]) -> PacketZcMyitemlistBuyingStore {
        let iter_count = (&buffer.len() - 12) / 9;
        let mut vec_field: Vec<BuyingStoreItemlist> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 12 + (9 * (i - 1));
            let end_pos = 12 + 9 * i;
            vec_field.push(BuyingStoreItemlist::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcMyitemlistBuyingStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            limit_zeny: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            limit_zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.limit_zeny).unwrap();
        self.limit_zeny_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.limit_zeny_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_limit_zeny(&mut self, value: i32) {
        self.limit_zeny = value;
    }
    pub fn set_limit_zeny_raw(&mut self, value: [u8; 4]) {
        self.limit_zeny_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<BuyingStoreItemlist>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new() -> PacketZcMyitemlistBuyingStore {
        PacketZcMyitemlistBuyingStore {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x81, 0x3]),
        packet_id_raw: [0x81, 0x3],
        packet_length: 0,
        packet_length_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        limit_zeny: 0,
        limit_zeny_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcMyitemlistBuyingStore {
    fn id(&self) -> &str {
       "0x0813"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcBuyingStoreEntry {
    pub fn from(buffer: &[u8]) -> PacketZcBuyingStoreEntry {
        PacketZcBuyingStoreEntry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            maker_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            store_name:  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[6..86].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            store_name_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[6..86]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.store_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.store_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.maker_aid_raw.to_vec());
        wtr.append(&mut self.store_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_maker_aid(&mut self, value: u32) {
        self.maker_aid = value;
    }
    pub fn set_maker_aid_raw(&mut self, value: [u8; 4]) {
        self.maker_aid_raw = value;
    }
    pub fn set_store_name(&mut self, value: [char; 80]) {
        self.store_name = value;
    }
    pub fn set_store_name_raw(&mut self, value: [u8; 80]) {
        self.store_name_raw = value;
    }
    pub fn new() -> PacketZcBuyingStoreEntry {
        PacketZcBuyingStoreEntry {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x81, 0x4]),
        packet_id_raw: [0x81, 0x4],
        maker_aid: 0,
        maker_aid_raw: [0; 4],
        store_name: [0 as char; 80],
        store_name_raw: [0; 80],
        }
    }
}

impl Packet for PacketZcBuyingStoreEntry {
    fn id(&self) -> &str {
       "0x0814"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqCloseBuyingStore {
    pub fn from(buffer: &[u8]) -> PacketCzReqCloseBuyingStore {
        PacketCzReqCloseBuyingStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzReqCloseBuyingStore {
        PacketCzReqCloseBuyingStore {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x81, 0x5]),
        packet_id_raw: [0x81, 0x5],
        }
    }
}

impl Packet for PacketCzReqCloseBuyingStore {
    fn id(&self) -> &str {
       "0x0815"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcDisappearBuyingStoreEntry {
    pub fn from(buffer: &[u8]) -> PacketZcDisappearBuyingStoreEntry {
        PacketZcDisappearBuyingStoreEntry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            maker_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.maker_aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_maker_aid(&mut self, value: u32) {
        self.maker_aid = value;
    }
    pub fn set_maker_aid_raw(&mut self, value: [u8; 4]) {
        self.maker_aid_raw = value;
    }
    pub fn new() -> PacketZcDisappearBuyingStoreEntry {
        PacketZcDisappearBuyingStoreEntry {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x81, 0x6]),
        packet_id_raw: [0x81, 0x6],
        maker_aid: 0,
        maker_aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDisappearBuyingStoreEntry {
    fn id(&self) -> &str {
       "0x0816"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqClickToBuyingStore {
    pub fn from(buffer: &[u8]) -> PacketCzReqClickToBuyingStore {
        PacketCzReqClickToBuyingStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            maker_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.maker_aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_maker_aid(&mut self, value: u32) {
        self.maker_aid = value;
    }
    pub fn set_maker_aid_raw(&mut self, value: [u8; 4]) {
        self.maker_aid_raw = value;
    }
    pub fn new() -> PacketCzReqClickToBuyingStore {
        PacketCzReqClickToBuyingStore {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x81, 0x7]),
        packet_id_raw: [0x81, 0x7],
        maker_aid: 0,
        maker_aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqClickToBuyingStore {
    fn id(&self) -> &str {
       "0x0817"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckItemlistBuyingStore {
    pub fn from(buffer: &[u8]) -> PacketZcAckItemlistBuyingStore {
        let iter_count = (&buffer.len() - 16) / 9;
        let mut vec_field: Vec<BuyingStoreItemlist> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 16 + (9 * (i - 1));
            let end_pos = 16 + 9 * i;
            vec_field.push(BuyingStoreItemlist::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcAckItemlistBuyingStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            maker_aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            store_id: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            store_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            limit_zeny: i32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            limit_zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.store_id).unwrap();
        self.store_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.limit_zeny).unwrap();
        self.limit_zeny_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.maker_aid_raw.to_vec());
        wtr.append(&mut self.store_id_raw.to_vec());
        wtr.append(&mut self.limit_zeny_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_maker_aid(&mut self, value: u32) {
        self.maker_aid = value;
    }
    pub fn set_maker_aid_raw(&mut self, value: [u8; 4]) {
        self.maker_aid_raw = value;
    }
    pub fn set_store_id(&mut self, value: u32) {
        self.store_id = value;
    }
    pub fn set_store_id_raw(&mut self, value: [u8; 4]) {
        self.store_id_raw = value;
    }
    pub fn set_limit_zeny(&mut self, value: i32) {
        self.limit_zeny = value;
    }
    pub fn set_limit_zeny_raw(&mut self, value: [u8; 4]) {
        self.limit_zeny_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<BuyingStoreItemlist>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new() -> PacketZcAckItemlistBuyingStore {
        PacketZcAckItemlistBuyingStore {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x81, 0x8]),
        packet_id_raw: [0x81, 0x8],
        packet_length: 0,
        packet_length_raw: [0; 2],
        maker_aid: 0,
        maker_aid_raw: [0; 4],
        store_id: 0,
        store_id_raw: [0; 4],
        limit_zeny: 0,
        limit_zeny_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcAckItemlistBuyingStore {
    fn id(&self) -> &str {
       "0x0818"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzReqTradeBuyingStore {
    pub fn from(buffer: &[u8]) -> PacketCzReqTradeBuyingStore {
        let iter_count = (&buffer.len() - 12) / 6;
        let mut vec_field: Vec<TradeItemBuyingStore> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 12 + (6 * (i - 1));
            let end_pos = 12 + 6 * i;
            vec_field.push(TradeItemBuyingStore::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzReqTradeBuyingStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            maker_aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            store_id: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            store_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.store_id).unwrap();
        self.store_id_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.maker_aid_raw.to_vec());
        wtr.append(&mut self.store_id_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_maker_aid(&mut self, value: u32) {
        self.maker_aid = value;
    }
    pub fn set_maker_aid_raw(&mut self, value: [u8; 4]) {
        self.maker_aid_raw = value;
    }
    pub fn set_store_id(&mut self, value: u32) {
        self.store_id = value;
    }
    pub fn set_store_id_raw(&mut self, value: [u8; 4]) {
        self.store_id_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<TradeItemBuyingStore>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new() -> PacketCzReqTradeBuyingStore {
        PacketCzReqTradeBuyingStore {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x81, 0x9]),
        packet_id_raw: [0x81, 0x9],
        packet_length: 0,
        packet_length_raw: [0; 2],
        maker_aid: 0,
        maker_aid_raw: [0; 4],
        store_id: 0,
        store_id_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketCzReqTradeBuyingStore {
    fn id(&self) -> &str {
       "0x0819"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcFailedTradeBuyingStoreToBuyer {
    pub fn from(buffer: &[u8]) -> PacketZcFailedTradeBuyingStoreToBuyer {
        PacketZcFailedTradeBuyingStoreToBuyer {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketZcFailedTradeBuyingStoreToBuyer {
        PacketZcFailedTradeBuyingStoreToBuyer {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x81, 0xa]),
        packet_id_raw: [0x81, 0xa],
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcFailedTradeBuyingStoreToBuyer {
    fn id(&self) -> &str {
       "0x081a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcUpdateItemFromBuyingStore {
    pub fn from(buffer: &[u8]) -> PacketZcUpdateItemFromBuyingStore {
        PacketZcUpdateItemFromBuyingStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            limit_zeny: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            limit_zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.limit_zeny).unwrap();
        self.limit_zeny_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.limit_zeny_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_limit_zeny(&mut self, value: i32) {
        self.limit_zeny = value;
    }
    pub fn set_limit_zeny_raw(&mut self, value: [u8; 4]) {
        self.limit_zeny_raw = value;
    }
    pub fn new() -> PacketZcUpdateItemFromBuyingStore {
        PacketZcUpdateItemFromBuyingStore {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x81, 0xb]),
        packet_id_raw: [0x81, 0xb],
        itid: 0,
        itid_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        limit_zeny: 0,
        limit_zeny_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcUpdateItemFromBuyingStore {
    fn id(&self) -> &str {
       "0x081b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcItemDeleteBuyingStore {
    pub fn from(buffer: &[u8]) -> PacketZcItemDeleteBuyingStore {
        PacketZcItemDeleteBuyingStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            zeny: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.zeny).unwrap();
        self.zeny_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.zeny_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_zeny(&mut self, value: i32) {
        self.zeny = value;
    }
    pub fn set_zeny_raw(&mut self, value: [u8; 4]) {
        self.zeny_raw = value;
    }
    pub fn new() -> PacketZcItemDeleteBuyingStore {
        PacketZcItemDeleteBuyingStore {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x81, 0xc]),
        packet_id_raw: [0x81, 0xc],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        zeny: 0,
        zeny_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcItemDeleteBuyingStore {
    fn id(&self) -> &str {
       "0x081c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcElInit {
    pub fn from(buffer: &[u8]) -> PacketZcElInit {
        PacketZcElInit {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            hp: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            max_hp: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            max_hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            sp: i32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            sp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
            max_sp: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            max_sp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.sp).unwrap();
        self.sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_sp).unwrap();
        self.max_sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.max_hp_raw.to_vec());
        wtr.append(&mut self.sp_raw.to_vec());
        wtr.append(&mut self.max_sp_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: i32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_hp(&mut self, value: i32) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 4]) {
        self.hp_raw = value;
    }
    pub fn set_max_hp(&mut self, value: i32) {
        self.max_hp = value;
    }
    pub fn set_max_hp_raw(&mut self, value: [u8; 4]) {
        self.max_hp_raw = value;
    }
    pub fn set_sp(&mut self, value: i32) {
        self.sp = value;
    }
    pub fn set_sp_raw(&mut self, value: [u8; 4]) {
        self.sp_raw = value;
    }
    pub fn set_max_sp(&mut self, value: i32) {
        self.max_sp = value;
    }
    pub fn set_max_sp_raw(&mut self, value: [u8; 4]) {
        self.max_sp_raw = value;
    }
    pub fn new() -> PacketZcElInit {
        PacketZcElInit {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x81, 0xd]),
        packet_id_raw: [0x81, 0xd],
        aid: 0,
        aid_raw: [0; 4],
        hp: 0,
        hp_raw: [0; 4],
        max_hp: 0,
        max_hp_raw: [0; 4],
        sp: 0,
        sp_raw: [0; 4],
        max_sp: 0,
        max_sp_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcElInit {
    fn id(&self) -> &str {
       "0x081d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcElParChange {
    pub fn from(buffer: &[u8]) -> PacketZcElParChange {
        PacketZcElParChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            var: u16::from_le_bytes([buffer[2], buffer[3]]),
            var_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            value: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var).unwrap();
        self.var_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.var_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_var(&mut self, value: u16) {
        self.var = value;
    }
    pub fn set_var_raw(&mut self, value: [u8; 2]) {
        self.var_raw = value;
    }
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new() -> PacketZcElParChange {
        PacketZcElParChange {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x81, 0xe]),
        packet_id_raw: [0x81, 0xe],
        var: 0,
        var_raw: [0; 2],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcElParChange {
    fn id(&self) -> &str {
       "0x081e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcBroadcast4 {
    pub fn from(buffer: &[u8]) -> PacketZcBroadcast4 {
        PacketZcBroadcast4 {
            raw: buffer.to_vec(),
            pakcet_type: i16::from_le_bytes([buffer[0], buffer[1]]),
            pakcet_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msgtype: u8::from_le_bytes([buffer[4]]),
            msgtype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            color_rgb: u32::from_le_bytes([buffer[5], buffer[6], buffer[7], buffer[8]]),
            color_rgb_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[5..9]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[9..buffer.len()]).to_string(),
            msg_raw: buffer[9..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.pakcet_type).unwrap();
        self.pakcet_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.msgtype).unwrap();
        self.msgtype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.color_rgb).unwrap();
        self.color_rgb_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.pakcet_type_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msgtype_raw.to_vec());
        wtr.append(&mut self.color_rgb_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_pakcet_type(&mut self, value: i16) {
        self.pakcet_type = value;
    }
    pub fn set_pakcet_type_raw(&mut self, value: [u8; 2]) {
        self.pakcet_type_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msgtype(&mut self, value: u8) {
        self.msgtype = value;
    }
    pub fn set_msgtype_raw(&mut self, value: [u8; 1]) {
        self.msgtype_raw = value;
    }
    pub fn set_color_rgb(&mut self, value: u32) {
        self.color_rgb = value;
    }
    pub fn set_color_rgb_raw(&mut self, value: [u8; 4]) {
        self.color_rgb_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new() -> PacketZcBroadcast4 {
        PacketZcBroadcast4 {
        raw: vec![],
        pakcet_type: 0,
        pakcet_type_raw: [0; 2],
        packet_length: 0,
        packet_length_raw: [0; 2],
        msgtype: 0,
        msgtype_raw: [0; 1],
        color_rgb: 0,
        color_rgb_raw: [0; 4],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcBroadcast4 {
    fn id(&self) -> &str {
       "0x081f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcCostumeSpriteChange {
    pub fn from(buffer: &[u8]) -> PacketZcCostumeSpriteChange {
        PacketZcCostumeSpriteChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            value: i32::from_le_bytes([buffer[7], buffer[8], buffer[9], buffer[10]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[7..11]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new() -> PacketZcCostumeSpriteChange {
        PacketZcCostumeSpriteChange {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x82, 0x0]),
        packet_id_raw: [0x82, 0x0],
        gid: 0,
        gid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcCostumeSpriteChange {
    fn id(&self) -> &str {
       "0x0820"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcOtpUser {
    pub fn from(buffer: &[u8]) -> PacketAcOtpUser {
        PacketAcOtpUser {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketAcOtpUser {
        PacketAcOtpUser {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x82, 0x1]),
        packet_id_raw: [0x82, 0x1],
        }
    }
}

impl Packet for PacketAcOtpUser {
    fn id(&self) -> &str {
       "0x0821"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCaOtpAuthReq {
    pub fn from(buffer: &[u8]) -> PacketCaOtpAuthReq {
        PacketCaOtpAuthReq {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            otpcode:  {
                let mut dst: [char; 7] = [0 as char; 7];
                for (index, byte) in buffer[2..9].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            otpcode_raw: {
                let mut dst: [u8; 7] = [0u8; 7];
                dst.clone_from_slice(&buffer[2..9]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.otpcode {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.otpcode_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.otpcode_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_otpcode(&mut self, value: [char; 7]) {
        self.otpcode = value;
    }
    pub fn set_otpcode_raw(&mut self, value: [u8; 7]) {
        self.otpcode_raw = value;
    }
    pub fn new() -> PacketCaOtpAuthReq {
        PacketCaOtpAuthReq {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x82, 0x2]),
        packet_id_raw: [0x82, 0x2],
        otpcode: [0 as char; 7],
        otpcode_raw: [0; 7],
        }
    }
}

impl Packet for PacketCaOtpAuthReq {
    fn id(&self) -> &str {
       "0x0822"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcOtpAuthAck {
    pub fn from(buffer: &[u8]) -> PacketAcOtpAuthAck {
        PacketAcOtpAuthAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            login_result: u16::from_le_bytes([buffer[4], buffer[5]]),
            login_result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.login_result).unwrap();
        self.login_result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.login_result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_login_result(&mut self, value: u16) {
        self.login_result = value;
    }
    pub fn set_login_result_raw(&mut self, value: [u8; 2]) {
        self.login_result_raw = value;
    }
    pub fn new() -> PacketAcOtpAuthAck {
        PacketAcOtpAuthAck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x82, 0x3]),
        packet_id_raw: [0x82, 0x3],
        packet_length: 0,
        packet_length_raw: [0; 2],
        login_result: 0,
        login_result_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcOtpAuthAck {
    fn id(&self) -> &str {
       "0x0823"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcFailedTradeBuyingStoreToSeller {
    pub fn from(buffer: &[u8]) -> PacketZcFailedTradeBuyingStoreToSeller {
        PacketZcFailedTradeBuyingStoreToSeller {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            itid: u16::from_le_bytes([buffer[4], buffer[5]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new() -> PacketZcFailedTradeBuyingStoreToSeller {
        PacketZcFailedTradeBuyingStoreToSeller {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x82, 0x4]),
        packet_id_raw: [0x82, 0x4],
        result: 0,
        result_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcFailedTradeBuyingStoreToSeller {
    fn id(&self) -> &str {
       "0x0824"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCaSsoLoginReqa {
    pub fn from(buffer: &[u8]) -> PacketCaSsoLoginReqa {
        PacketCaSsoLoginReqa {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            version: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            clienttype: u8::from_le_bytes([buffer[8]]),
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            id:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[9..33].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[9..33]);
                dst
            },
            mac_addr:  {
                let mut dst: [char; 17] = [0 as char; 17];
                for (index, byte) in buffer[33..50].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            mac_addr_raw: {
                let mut dst: [u8; 17] = [0u8; 17];
                dst.clone_from_slice(&buffer[33..50]);
                dst
            },
            ip_addr:  {
                let mut dst: [char; 15] = [0 as char; 15];
                for (index, byte) in buffer[50..65].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            ip_addr_raw: {
                let mut dst: [u8; 15] = [0u8; 15];
                dst.clone_from_slice(&buffer[50..65]);
                dst
            },
            t1: String::from_utf8_lossy(&buffer[65..buffer.len()]).to_string(),
            t1_raw: buffer[65..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mac_addr {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mac_addr_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.ip_addr {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.ip_addr_raw = wtr.try_into().unwrap();
        self.t1_raw = self.t1.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.version_raw.to_vec());
        wtr.append(&mut self.clienttype_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.mac_addr_raw.to_vec());
        wtr.append(&mut self.ip_addr_raw.to_vec());
        wtr.append(&mut self.t1_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_version(&mut self, value: u32) {
        self.version = value;
    }
    pub fn set_version_raw(&mut self, value: [u8; 4]) {
        self.version_raw = value;
    }
    pub fn set_clienttype(&mut self, value: u8) {
        self.clienttype = value;
    }
    pub fn set_clienttype_raw(&mut self, value: [u8; 1]) {
        self.clienttype_raw = value;
    }
    pub fn set_id(&mut self, value: [char; 24]) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 24]) {
        self.id_raw = value;
    }
    pub fn set_mac_addr(&mut self, value: [char; 17]) {
        self.mac_addr = value;
    }
    pub fn set_mac_addr_raw(&mut self, value: [u8; 17]) {
        self.mac_addr_raw = value;
    }
    pub fn set_ip_addr(&mut self, value: [char; 15]) {
        self.ip_addr = value;
    }
    pub fn set_ip_addr_raw(&mut self, value: [u8; 15]) {
        self.ip_addr_raw = value;
    }
    pub fn set_t1(&mut self, value: String) {
        self.t1 = value;
    }
    pub fn set_t1_raw(&mut self, value: Vec<u8>) {
        self.t1_raw = value;
    }
    pub fn new() -> PacketCaSsoLoginReqa {
        PacketCaSsoLoginReqa {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x82, 0x5a]),
        packet_id_raw: [0x82, 0x5a],
        packet_length: 0,
        packet_length_raw: [0; 2],
        version: 0,
        version_raw: [0; 4],
        clienttype: 0,
        clienttype_raw: [0; 1],
        id: [0 as char; 24],
        id_raw: [0; 24],
        mac_addr: [0 as char; 17],
        mac_addr_raw: [0; 17],
        ip_addr: [0 as char; 15],
        ip_addr_raw: [0; 15],
        t1: String::new(),
        t1_raw: vec![],
        }
    }
}

impl Packet for PacketCaSsoLoginReqa {
    fn id(&self) -> &str {
       "0x825a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCaSsoLoginReq {
    pub fn from(buffer: &[u8]) -> PacketCaSsoLoginReq {
        PacketCaSsoLoginReq {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            version: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            clienttype: u8::from_le_bytes([buffer[8]]),
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            id:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[9..33].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[9..33]);
                dst
            },
            passwd:  {
                let mut dst: [char; 27] = [0 as char; 27];
                for (index, byte) in buffer[33..60].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_raw: {
                let mut dst: [u8; 27] = [0u8; 27];
                dst.clone_from_slice(&buffer[33..60]);
                dst
            },
            mac_adress:  {
                let mut dst: [char; 17] = [0 as char; 17];
                for (index, byte) in buffer[60..77].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            mac_adress_raw: {
                let mut dst: [u8; 17] = [0u8; 17];
                dst.clone_from_slice(&buffer[60..77]);
                dst
            },
            ip:  {
                let mut dst: [char; 15] = [0 as char; 15];
                for (index, byte) in buffer[77..92].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            ip_raw: {
                let mut dst: [u8; 15] = [0u8; 15];
                dst.clone_from_slice(&buffer[77..92]);
                dst
            },
            t1: String::from_utf8_lossy(&buffer[92..buffer.len()]).to_string(),
            t1_raw: buffer[92..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mac_adress {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mac_adress_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.ip {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.ip_raw = wtr.try_into().unwrap();
        self.t1_raw = self.t1.as_bytes().to_vec();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.version_raw.to_vec());
        wtr.append(&mut self.clienttype_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.passwd_raw.to_vec());
        wtr.append(&mut self.mac_adress_raw.to_vec());
        wtr.append(&mut self.ip_raw.to_vec());
        wtr.append(&mut self.t1_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_version(&mut self, value: u32) {
        self.version = value;
    }
    pub fn set_version_raw(&mut self, value: [u8; 4]) {
        self.version_raw = value;
    }
    pub fn set_clienttype(&mut self, value: u8) {
        self.clienttype = value;
    }
    pub fn set_clienttype_raw(&mut self, value: [u8; 1]) {
        self.clienttype_raw = value;
    }
    pub fn set_id(&mut self, value: [char; 24]) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 24]) {
        self.id_raw = value;
    }
    pub fn set_passwd(&mut self, value: [char; 27]) {
        self.passwd = value;
    }
    pub fn set_passwd_raw(&mut self, value: [u8; 27]) {
        self.passwd_raw = value;
    }
    pub fn set_mac_adress(&mut self, value: [char; 17]) {
        self.mac_adress = value;
    }
    pub fn set_mac_adress_raw(&mut self, value: [u8; 17]) {
        self.mac_adress_raw = value;
    }
    pub fn set_ip(&mut self, value: [char; 15]) {
        self.ip = value;
    }
    pub fn set_ip_raw(&mut self, value: [u8; 15]) {
        self.ip_raw = value;
    }
    pub fn set_t1(&mut self, value: String) {
        self.t1 = value;
    }
    pub fn set_t1_raw(&mut self, value: Vec<u8>) {
        self.t1_raw = value;
    }
    pub fn new() -> PacketCaSsoLoginReq {
        PacketCaSsoLoginReq {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x82, 0x5]),
        packet_id_raw: [0x82, 0x5],
        packet_length: 0,
        packet_length_raw: [0; 2],
        version: 0,
        version_raw: [0; 4],
        clienttype: 0,
        clienttype_raw: [0; 1],
        id: [0 as char; 24],
        id_raw: [0; 24],
        passwd: [0 as char; 27],
        passwd_raw: [0; 27],
        mac_adress: [0 as char; 17],
        mac_adress_raw: [0; 17],
        ip: [0 as char; 15],
        ip_raw: [0; 15],
        t1: String::new(),
        t1_raw: vec![],
        }
    }
}

impl Packet for PacketCaSsoLoginReq {
    fn id(&self) -> &str {
       "0x0825"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcSsoLoginAck {
    pub fn from(buffer: &[u8]) -> PacketAcSsoLoginAck {
        PacketAcSsoLoginAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketAcSsoLoginAck {
        PacketAcSsoLoginAck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x82, 0x6]),
        packet_id_raw: [0x82, 0x6],
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcSsoLoginAck {
    fn id(&self) -> &str {
       "0x0826"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketChDeleteChar3Reserved {
    pub fn from(buffer: &[u8]) -> PacketChDeleteChar3Reserved {
        PacketChDeleteChar3Reserved {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new() -> PacketChDeleteChar3Reserved {
        PacketChDeleteChar3Reserved {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x82, 0x7]),
        packet_id_raw: [0x82, 0x7],
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketChDeleteChar3Reserved {
    fn id(&self) -> &str {
       "0x0827"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcDeleteChar3Reserved {
    pub fn from(buffer: &[u8]) -> PacketHcDeleteChar3Reserved {
        PacketHcDeleteChar3Reserved {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            result: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            delete_reserved_date: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            delete_reserved_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.delete_reserved_date).unwrap();
        self.delete_reserved_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.delete_reserved_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_result(&mut self, value: i32) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 4]) {
        self.result_raw = value;
    }
    pub fn set_delete_reserved_date(&mut self, value: i32) {
        self.delete_reserved_date = value;
    }
    pub fn set_delete_reserved_date_raw(&mut self, value: [u8; 4]) {
        self.delete_reserved_date_raw = value;
    }
    pub fn new() -> PacketHcDeleteChar3Reserved {
        PacketHcDeleteChar3Reserved {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x82, 0x8]),
        packet_id_raw: [0x82, 0x8],
        gid: 0,
        gid_raw: [0; 4],
        result: 0,
        result_raw: [0; 4],
        delete_reserved_date: 0,
        delete_reserved_date_raw: [0; 4],
        }
    }
}

impl Packet for PacketHcDeleteChar3Reserved {
    fn id(&self) -> &str {
       "0x0828"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketChDeleteChar3 {
    pub fn from(buffer: &[u8]) -> PacketChDeleteChar3 {
        PacketChDeleteChar3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            birth:  {
                let mut dst: [char; 6] = [0 as char; 6];
                for (index, byte) in buffer[6..12].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            birth_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[6..12]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.birth {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.birth_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.birth_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_birth(&mut self, value: [char; 6]) {
        self.birth = value;
    }
    pub fn set_birth_raw(&mut self, value: [u8; 6]) {
        self.birth_raw = value;
    }
    pub fn new() -> PacketChDeleteChar3 {
        PacketChDeleteChar3 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x82, 0x9]),
        packet_id_raw: [0x82, 0x9],
        gid: 0,
        gid_raw: [0; 4],
        birth: [0 as char; 6],
        birth_raw: [0; 6],
        }
    }
}

impl Packet for PacketChDeleteChar3 {
    fn id(&self) -> &str {
       "0x0829"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcDeleteChar3 {
    pub fn from(buffer: &[u8]) -> PacketHcDeleteChar3 {
        PacketHcDeleteChar3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            result: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_result(&mut self, value: i32) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 4]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketHcDeleteChar3 {
        PacketHcDeleteChar3 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x82, 0xa]),
        packet_id_raw: [0x82, 0xa],
        gid: 0,
        gid_raw: [0; 4],
        result: 0,
        result_raw: [0; 4],
        }
    }
}

impl Packet for PacketHcDeleteChar3 {
    fn id(&self) -> &str {
       "0x082a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketChDeleteChar3Cancel {
    pub fn from(buffer: &[u8]) -> PacketChDeleteChar3Cancel {
        PacketChDeleteChar3Cancel {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new() -> PacketChDeleteChar3Cancel {
        PacketChDeleteChar3Cancel {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x82, 0xb]),
        packet_id_raw: [0x82, 0xb],
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketChDeleteChar3Cancel {
    fn id(&self) -> &str {
       "0x082b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcDeleteChar3Cancel {
    pub fn from(buffer: &[u8]) -> PacketHcDeleteChar3Cancel {
        PacketHcDeleteChar3Cancel {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            result: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_result(&mut self, value: i32) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 4]) {
        self.result_raw = value;
    }
    pub fn new() -> PacketHcDeleteChar3Cancel {
        PacketHcDeleteChar3Cancel {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x82, 0xc]),
        packet_id_raw: [0x82, 0xc],
        gid: 0,
        gid_raw: [0; 4],
        result: 0,
        result_raw: [0; 4],
        }
    }
}

impl Packet for PacketHcDeleteChar3Cancel {
    fn id(&self) -> &str {
       "0x082c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzSearchStoreInfo {
    pub fn from(buffer: &[u8]) -> PacketCzSearchStoreInfo {
        PacketCzSearchStoreInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            store_type: u8::from_le_bytes([buffer[4]]),
            store_type_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            max_price: u32::from_le_bytes([buffer[5], buffer[6], buffer[7], buffer[8]]),
            max_price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[5..9]);
                dst
            },
            min_price: u32::from_le_bytes([buffer[9], buffer[10], buffer[11], buffer[12]]),
            min_price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[9..13]);
                dst
            },
            item_idlist_size: u8::from_le_bytes([buffer[13]]),
            item_idlist_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[13..14]);
                dst
            },
            card_idlist_size: u8::from_le_bytes([buffer[14]]),
            card_idlist_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.store_type).unwrap();
        self.store_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.max_price).unwrap();
        self.max_price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.min_price).unwrap();
        self.min_price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_idlist_size).unwrap();
        self.item_idlist_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.card_idlist_size).unwrap();
        self.card_idlist_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.store_type_raw.to_vec());
        wtr.append(&mut self.max_price_raw.to_vec());
        wtr.append(&mut self.min_price_raw.to_vec());
        wtr.append(&mut self.item_idlist_size_raw.to_vec());
        wtr.append(&mut self.card_idlist_size_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_store_type(&mut self, value: u8) {
        self.store_type = value;
    }
    pub fn set_store_type_raw(&mut self, value: [u8; 1]) {
        self.store_type_raw = value;
    }
    pub fn set_max_price(&mut self, value: u32) {
        self.max_price = value;
    }
    pub fn set_max_price_raw(&mut self, value: [u8; 4]) {
        self.max_price_raw = value;
    }
    pub fn set_min_price(&mut self, value: u32) {
        self.min_price = value;
    }
    pub fn set_min_price_raw(&mut self, value: [u8; 4]) {
        self.min_price_raw = value;
    }
    pub fn set_item_idlist_size(&mut self, value: u8) {
        self.item_idlist_size = value;
    }
    pub fn set_item_idlist_size_raw(&mut self, value: [u8; 1]) {
        self.item_idlist_size_raw = value;
    }
    pub fn set_card_idlist_size(&mut self, value: u8) {
        self.card_idlist_size = value;
    }
    pub fn set_card_idlist_size_raw(&mut self, value: [u8; 1]) {
        self.card_idlist_size_raw = value;
    }
    pub fn new() -> PacketCzSearchStoreInfo {
        PacketCzSearchStoreInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x83, 0x5]),
        packet_id_raw: [0x83, 0x5],
        packet_length: 0,
        packet_length_raw: [0; 2],
        store_type: 0,
        store_type_raw: [0; 1],
        max_price: 0,
        max_price_raw: [0; 4],
        min_price: 0,
        min_price_raw: [0; 4],
        item_idlist_size: 0,
        item_idlist_size_raw: [0; 1],
        card_idlist_size: 0,
        card_idlist_size_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzSearchStoreInfo {
    fn id(&self) -> &str {
       "0x0835"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSearchStoreInfoAck {
    pub fn from(buffer: &[u8]) -> PacketZcSearchStoreInfoAck {
        let iter_count = (&buffer.len() - 7) / 106;
        let mut vec_field: Vec<ResultItemInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 7 + (106 * (i - 1));
            let end_pos = 7 + 106 * i;
            vec_field.push(ResultItemInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcSearchStoreInfoAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            is_first_page: buffer[4] == 1,
            is_first_page_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            is_nex_page: buffer[5] == 1,
            is_nex_page_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            remained_search_cnt: u8::from_le_bytes([buffer[6]]),
            remained_search_cnt_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            ssilist: vec_field.clone(),
            ssilist_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_first_page as u8).unwrap();
        self.is_first_page_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_nex_page as u8).unwrap();
        self.is_nex_page_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.remained_search_cnt).unwrap();
        self.remained_search_cnt_raw = wtr.try_into().unwrap();
        self.ssilist_raw = {
            self.ssilist.iter_mut().for_each(|item| item.fill_raw());
            self.ssilist.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.is_first_page_raw.to_vec());
        wtr.append(&mut self.is_nex_page_raw.to_vec());
        wtr.append(&mut self.remained_search_cnt_raw.to_vec());
        self.ssilist.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_is_first_page(&mut self, value: bool) {
        self.is_first_page = value;
    }
    pub fn set_is_first_page_raw(&mut self, value: [u8; 1]) {
        self.is_first_page_raw = value;
    }
    pub fn set_is_nex_page(&mut self, value: bool) {
        self.is_nex_page = value;
    }
    pub fn set_is_nex_page_raw(&mut self, value: [u8; 1]) {
        self.is_nex_page_raw = value;
    }
    pub fn set_remained_search_cnt(&mut self, value: u8) {
        self.remained_search_cnt = value;
    }
    pub fn set_remained_search_cnt_raw(&mut self, value: [u8; 1]) {
        self.remained_search_cnt_raw = value;
    }
    pub fn set_ssilist(&mut self, value: Vec<ResultItemInfo>) {
        self.ssilist = value;
    }
    pub fn set_ssilist_raw(&mut self, value: Vec<Vec<u8>>) {
        self.ssilist_raw = value;
    }
    pub fn new() -> PacketZcSearchStoreInfoAck {
        PacketZcSearchStoreInfoAck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x83, 0x6]),
        packet_id_raw: [0x83, 0x6],
        packet_length: 0,
        packet_length_raw: [0; 2],
        is_first_page: false,
        is_first_page_raw: [0; 1],
        is_nex_page: false,
        is_nex_page_raw: [0; 1],
        remained_search_cnt: 0,
        remained_search_cnt_raw: [0; 1],
        ssilist: vec![],
        ssilist_raw: vec![],
        }
    }
}

impl Packet for PacketZcSearchStoreInfoAck {
    fn id(&self) -> &str {
       "0x0836"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSearchStoreInfoFailed {
    pub fn from(buffer: &[u8]) -> PacketZcSearchStoreInfoFailed {
        PacketZcSearchStoreInfoFailed {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            reason: u8::from_le_bytes([buffer[2]]),
            reason_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.reason).unwrap();
        self.reason_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.reason_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_reason(&mut self, value: u8) {
        self.reason = value;
    }
    pub fn set_reason_raw(&mut self, value: [u8; 1]) {
        self.reason_raw = value;
    }
    pub fn new() -> PacketZcSearchStoreInfoFailed {
        PacketZcSearchStoreInfoFailed {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x83, 0x7]),
        packet_id_raw: [0x83, 0x7],
        reason: 0,
        reason_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcSearchStoreInfoFailed {
    fn id(&self) -> &str {
       "0x0837"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzSearchStoreInfoNextPage {
    pub fn from(buffer: &[u8]) -> PacketCzSearchStoreInfoNextPage {
        PacketCzSearchStoreInfoNextPage {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzSearchStoreInfoNextPage {
        PacketCzSearchStoreInfoNextPage {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x83, 0x8]),
        packet_id_raw: [0x83, 0x8],
        }
    }
}

impl Packet for PacketCzSearchStoreInfoNextPage {
    fn id(&self) -> &str {
       "0x0838"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAckBanGuildSso {
    pub fn from(buffer: &[u8]) -> PacketZcAckBanGuildSso {
        PacketZcAckBanGuildSso {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            char_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            reason_desc:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[26..66].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            reason_desc_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[26..66]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason_desc {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_desc_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.char_name_raw.to_vec());
        wtr.append(&mut self.reason_desc_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_char_name(&mut self, value: [char; 24]) {
        self.char_name = value;
    }
    pub fn set_char_name_raw(&mut self, value: [u8; 24]) {
        self.char_name_raw = value;
    }
    pub fn set_reason_desc(&mut self, value: [char; 40]) {
        self.reason_desc = value;
    }
    pub fn set_reason_desc_raw(&mut self, value: [u8; 40]) {
        self.reason_desc_raw = value;
    }
    pub fn new() -> PacketZcAckBanGuildSso {
        PacketZcAckBanGuildSso {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x83, 0x9]),
        packet_id_raw: [0x83, 0x9],
        char_name: [0 as char; 24],
        char_name_raw: [0; 24],
        reason_desc: [0 as char; 40],
        reason_desc_raw: [0; 40],
        }
    }
}

impl Packet for PacketZcAckBanGuildSso {
    fn id(&self) -> &str {
       "0x0839"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcOpenSearchStoreInfo {
    pub fn from(buffer: &[u8]) -> PacketZcOpenSearchStoreInfo {
        PacketZcOpenSearchStoreInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            open_type: i16::from_le_bytes([buffer[2], buffer[3]]),
            open_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            search_cnt_max: u8::from_le_bytes([buffer[4]]),
            search_cnt_max_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.open_type).unwrap();
        self.open_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.search_cnt_max).unwrap();
        self.search_cnt_max_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.open_type_raw.to_vec());
        wtr.append(&mut self.search_cnt_max_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_open_type(&mut self, value: i16) {
        self.open_type = value;
    }
    pub fn set_open_type_raw(&mut self, value: [u8; 2]) {
        self.open_type_raw = value;
    }
    pub fn set_search_cnt_max(&mut self, value: u8) {
        self.search_cnt_max = value;
    }
    pub fn set_search_cnt_max_raw(&mut self, value: [u8; 1]) {
        self.search_cnt_max_raw = value;
    }
    pub fn new() -> PacketZcOpenSearchStoreInfo {
        PacketZcOpenSearchStoreInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x83, 0xa]),
        packet_id_raw: [0x83, 0xa],
        open_type: 0,
        open_type_raw: [0; 2],
        search_cnt_max: 0,
        search_cnt_max_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcOpenSearchStoreInfo {
    fn id(&self) -> &str {
       "0x083a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzCloseSearchStoreInfo {
    pub fn from(buffer: &[u8]) -> PacketCzCloseSearchStoreInfo {
        PacketCzCloseSearchStoreInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new() -> PacketCzCloseSearchStoreInfo {
        PacketCzCloseSearchStoreInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x83, 0xb]),
        packet_id_raw: [0x83, 0xb],
        }
    }
}

impl Packet for PacketCzCloseSearchStoreInfo {
    fn id(&self) -> &str {
       "0x083b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzSsilistItemClick {
    pub fn from(buffer: &[u8]) -> PacketCzSsilistItemClick {
        PacketCzSsilistItemClick {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            ssiid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            ssiid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            itid: u16::from_le_bytes([buffer[10], buffer[11]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.ssiid).unwrap();
        self.ssiid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.ssiid_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_ssiid(&mut self, value: u32) {
        self.ssiid = value;
    }
    pub fn set_ssiid_raw(&mut self, value: [u8; 4]) {
        self.ssiid_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new() -> PacketCzSsilistItemClick {
        PacketCzSsilistItemClick {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x83, 0xc]),
        packet_id_raw: [0x83, 0xc],
        aid: 0,
        aid_raw: [0; 4],
        ssiid: 0,
        ssiid_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzSsilistItemClick {
    fn id(&self) -> &str {
       "0x083c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcSsilistItemClickAck {
    pub fn from(buffer: &[u8]) -> PacketZcSsilistItemClickAck {
        PacketZcSsilistItemClickAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            x: i16::from_le_bytes([buffer[2], buffer[3]]),
            x_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            y: i16::from_le_bytes([buffer[4], buffer[5]]),
            y_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x).unwrap();
        self.x_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y).unwrap();
        self.y_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.x_raw.to_vec());
        wtr.append(&mut self.y_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_x(&mut self, value: i16) {
        self.x = value;
    }
    pub fn set_x_raw(&mut self, value: [u8; 2]) {
        self.x_raw = value;
    }
    pub fn set_y(&mut self, value: i16) {
        self.y = value;
    }
    pub fn set_y_raw(&mut self, value: [u8; 2]) {
        self.y_raw = value;
    }
    pub fn new() -> PacketZcSsilistItemClickAck {
        PacketZcSsilistItemClickAck {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x83, 0xd]),
        packet_id_raw: [0x83, 0xd],
        x: 0,
        x_raw: [0; 2],
        y: 0,
        y_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcSsilistItemClickAck {
    fn id(&self) -> &str {
       "0x083d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketAcRefuseLoginR2 {
    pub fn from(buffer: &[u8]) -> PacketAcRefuseLoginR2 {
        PacketAcRefuseLoginR2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            error_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            block_date:  {
                let mut dst: [char; 20] = [0 as char; 20];
                for (index, byte) in buffer[6..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            block_date_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[6..26]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.block_date {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.block_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        wtr.append(&mut self.block_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u32) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 4]) {
        self.error_code_raw = value;
    }
    pub fn set_block_date(&mut self, value: [char; 20]) {
        self.block_date = value;
    }
    pub fn set_block_date_raw(&mut self, value: [u8; 20]) {
        self.block_date_raw = value;
    }
    pub fn new() -> PacketAcRefuseLoginR2 {
        PacketAcRefuseLoginR2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x83, 0xe]),
        packet_id_raw: [0x83, 0xe],
        error_code: 0,
        error_code_raw: [0; 4],
        block_date: [0 as char; 20],
        block_date_raw: [0; 20],
        }
    }
}

impl Packet for PacketAcRefuseLoginR2 {
    fn id(&self) -> &str {
       "0x083e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketChSelectAccessibleMapname {
    pub fn from(buffer: &[u8]) -> PacketChSelectAccessibleMapname {
        PacketChSelectAccessibleMapname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            char_num: u8::from_le_bytes([buffer[2]]),
            char_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            map_list_num: u8::from_le_bytes([buffer[3]]),
            map_list_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[3..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.char_num).unwrap();
        self.char_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.map_list_num).unwrap();
        self.map_list_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.char_num_raw.to_vec());
        wtr.append(&mut self.map_list_num_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_char_num(&mut self, value: u8) {
        self.char_num = value;
    }
    pub fn set_char_num_raw(&mut self, value: [u8; 1]) {
        self.char_num_raw = value;
    }
    pub fn set_map_list_num(&mut self, value: u8) {
        self.map_list_num = value;
    }
    pub fn set_map_list_num_raw(&mut self, value: [u8; 1]) {
        self.map_list_num_raw = value;
    }
    pub fn new() -> PacketChSelectAccessibleMapname {
        PacketChSelectAccessibleMapname {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x84, 0x1]),
        packet_id_raw: [0x84, 0x1],
        char_num: 0,
        char_num_raw: [0; 1],
        map_list_num: 0,
        map_list_num_raw: [0; 1],
        }
    }
}

impl Packet for PacketChSelectAccessibleMapname {
    fn id(&self) -> &str {
       "0x0841"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzRequestMove2 {
    pub fn from(buffer: &[u8]) -> PacketCzRequestMove2 {
        PacketCzRequestMove2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            dest:  {
                let mut dst: [u16; 3] = [0 as u16; 3];
                for (index, byte) in buffer[2..5].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            },
            dest_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[2..5]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.dest {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.dest_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.dest_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_dest(&mut self, value: [u16; 3]) {
        self.dest = value;
    }
    pub fn set_dest_raw(&mut self, value: [u8; 3]) {
        self.dest_raw = value;
    }
    pub fn new() -> PacketCzRequestMove2 {
        PacketCzRequestMove2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x5f, 0x03]),
        packet_id_raw: [0x5f, 0x03],
        dest: [0; 3],
        dest_raw: [0; 3],
        }
    }
}

impl Packet for PacketCzRequestMove2 {
    fn id(&self) -> &str {
       "0x5f03"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketChSendMapInfo {
    pub fn from(buffer: &[u8]) -> PacketChSendMapInfo {
        PacketChSendMapInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[6..22].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[6..22]);
                dst
            },
            map_server_ip: u32::from_le_bytes([buffer[22], buffer[23], buffer[24], buffer[25]]),
            map_server_ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[22..26]);
                dst
            },
            map_server_port: i16::from_le_bytes([buffer[26], buffer[27]]),
            map_server_port_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            dns_host:  {
                let mut dst: [char; 128] = [0 as char; 128];
                for (index, byte) in buffer[28..156].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            dns_host_raw: {
                let mut dst: [u8; 128] = [0u8; 128];
                dst.clone_from_slice(&buffer[28..156]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.map_server_ip).unwrap();
        self.map_server_ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.map_server_port).unwrap();
        self.map_server_port_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.dns_host {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.dns_host_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.map_server_ip_raw.to_vec());
        wtr.append(&mut self.map_server_port_raw.to_vec());
        wtr.append(&mut self.dns_host_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_map_server_ip(&mut self, value: u32) {
        self.map_server_ip = value;
    }
    pub fn set_map_server_ip_raw(&mut self, value: [u8; 4]) {
        self.map_server_ip_raw = value;
    }
    pub fn set_map_server_port(&mut self, value: i16) {
        self.map_server_port = value;
    }
    pub fn set_map_server_port_raw(&mut self, value: [u8; 2]) {
        self.map_server_port_raw = value;
    }
    pub fn set_dns_host(&mut self, value: [char; 128]) {
        self.dns_host = value;
    }
    pub fn set_dns_host_raw(&mut self, value: [u8; 128]) {
        self.dns_host_raw = value;
    }
    pub fn new() -> PacketChSendMapInfo {
        PacketChSendMapInfo {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xc5, 0x0a]),
        packet_id_raw: [0xc5, 0x0a],
        gid: 0,
        gid_raw: [0; 4],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        map_server_ip: 0,
        map_server_ip_raw: [0; 4],
        map_server_port: 0,
        map_server_port_raw: [0; 2],
        dns_host: [0 as char; 128],
        dns_host_raw: [0; 128],
        }
    }
}

impl Packet for PacketChSendMapInfo {
    fn id(&self) -> &str {
       "0xc50a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcAcceptEnterNeoUnionHeader {
    pub fn from(buffer: &[u8]) -> PacketHcAcceptEnterNeoUnionHeader {
        PacketHcAcceptEnterNeoUnionHeader {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_len: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_len_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            char_slot: i8::from_le_bytes([buffer[4]]),
            char_slot_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            max_char: i16::from_le_bytes([buffer[5], buffer[6]]),
            max_char_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[5..7]);
                dst
            },
            premium_slot_start: i8::from_le_bytes([buffer[7]]),
            premium_slot_start_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[7..8]);
                dst
            },
            premium_slot_end: i8::from_le_bytes([buffer[8]]),
            premium_slot_end_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            empty_buffer:  {
                let mut dst: [char; 20] = [0 as char; 20];
                for (index, byte) in buffer[9..29].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            empty_buffer_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[9..29]);
                dst
            },
            char_info: PacketHcAcceptEnterNeoUnion::from(&buffer[29..buffer.len()]),
            char_info_raw: buffer[29..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_len).unwrap();
        self.packet_len_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.char_slot).unwrap();
        self.char_slot_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_char).unwrap();
        self.max_char_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.premium_slot_start).unwrap();
        self.premium_slot_start_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.premium_slot_end).unwrap();
        self.premium_slot_end_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.empty_buffer {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.empty_buffer_raw = wtr.try_into().unwrap();
        self.char_info.fill_raw();
        self.char_info_raw = self.char_info.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_len_raw.to_vec());
        wtr.append(&mut self.char_slot_raw.to_vec());
        wtr.append(&mut self.max_char_raw.to_vec());
        wtr.append(&mut self.premium_slot_start_raw.to_vec());
        wtr.append(&mut self.premium_slot_end_raw.to_vec());
        wtr.append(&mut self.empty_buffer_raw.to_vec());
        wtr.append(&mut self.char_info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_len(&mut self, value: i16) {
        self.packet_len = value;
    }
    pub fn set_packet_len_raw(&mut self, value: [u8; 2]) {
        self.packet_len_raw = value;
    }
    pub fn set_char_slot(&mut self, value: i8) {
        self.char_slot = value;
    }
    pub fn set_char_slot_raw(&mut self, value: [u8; 1]) {
        self.char_slot_raw = value;
    }
    pub fn set_max_char(&mut self, value: i16) {
        self.max_char = value;
    }
    pub fn set_max_char_raw(&mut self, value: [u8; 2]) {
        self.max_char_raw = value;
    }
    pub fn set_premium_slot_start(&mut self, value: i8) {
        self.premium_slot_start = value;
    }
    pub fn set_premium_slot_start_raw(&mut self, value: [u8; 1]) {
        self.premium_slot_start_raw = value;
    }
    pub fn set_premium_slot_end(&mut self, value: i8) {
        self.premium_slot_end = value;
    }
    pub fn set_premium_slot_end_raw(&mut self, value: [u8; 1]) {
        self.premium_slot_end_raw = value;
    }
    pub fn set_empty_buffer(&mut self, value: [char; 20]) {
        self.empty_buffer = value;
    }
    pub fn set_empty_buffer_raw(&mut self, value: [u8; 20]) {
        self.empty_buffer_raw = value;
    }
    pub fn set_char_info(&mut self, value: PacketHcAcceptEnterNeoUnion) {
        self.char_info = value;
    }
    pub fn set_char_info_raw(&mut self, value: Vec<u8>) {
        self.char_info_raw = value;
    }
    pub fn new() -> PacketHcAcceptEnterNeoUnionHeader {
        PacketHcAcceptEnterNeoUnionHeader {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x2d, 0x08]),
        packet_id_raw: [0x2d, 0x08],
        packet_len: 0,
        packet_len_raw: [0; 2],
        char_slot: 0,
        char_slot_raw: [0; 1],
        max_char: 0,
        max_char_raw: [0; 2],
        premium_slot_start: 0,
        premium_slot_start_raw: [0; 1],
        premium_slot_end: 0,
        premium_slot_end_raw: [0; 1],
        empty_buffer: [0 as char; 20],
        empty_buffer_raw: [0; 20],
        char_info: PacketHcAcceptEnterNeoUnion::new(),
        char_info_raw: vec![],
        }
    }
}

impl Packet for PacketHcAcceptEnterNeoUnionHeader {
    fn id(&self) -> &str {
       "0x2d08"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketCzPing {
    pub fn from(buffer: &[u8]) -> PacketCzPing {
        PacketCzPing {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketCzPing {
        PacketCzPing {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x87, 0x01]),
        packet_id_raw: [0x87, 0x01],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzPing {
    fn id(&self) -> &str {
       "0x8701"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketZcAid2 {
    pub fn from(buffer: &[u8]) -> PacketZcAid2 {
        PacketZcAid2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketZcAid2 {
        PacketZcAid2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x87, 0x01]),
        packet_id_raw: [0x87, 0x01],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcAid2 {
    fn id(&self) -> &str {
       "0x8701"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketMapConnection {
    pub fn from(buffer: &[u8]) -> PacketMapConnection {
        PacketMapConnection {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new() -> PacketMapConnection {
        PacketMapConnection {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x83, 0x02]),
        packet_id_raw: [0x83, 0x02],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketMapConnection {
    fn id(&self) -> &str {
       "0x8302"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketPincodeLoginstate {
    pub fn from(buffer: &[u8]) -> PacketPincodeLoginstate {
        PacketPincodeLoginstate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            pincode_seed: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            pincode_seed_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            aid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            response: i16::from_le_bytes([buffer[10], buffer[11]]),
            response_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.pincode_seed).unwrap();
        self.pincode_seed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.response).unwrap();
        self.response_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.pincode_seed_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.response_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_pincode_seed(&mut self, value: i32) {
        self.pincode_seed = value;
    }
    pub fn set_pincode_seed_raw(&mut self, value: [u8; 4]) {
        self.pincode_seed_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_response(&mut self, value: i16) {
        self.response = value;
    }
    pub fn set_response_raw(&mut self, value: [u8; 2]) {
        self.response_raw = value;
    }
    pub fn new() -> PacketPincodeLoginstate {
        PacketPincodeLoginstate {
        raw: vec![],
        packet_id: i16::from_le_bytes([0xb9, 0x08]),
        packet_id_raw: [0xb9, 0x08],
        pincode_seed: 0,
        pincode_seed_raw: [0; 4],
        aid: 0,
        aid_raw: [0; 4],
        response: 0,
        response_raw: [0; 2],
        }
    }
}

impl Packet for PacketPincodeLoginstate {
    fn id(&self) -> &str {
       "0xb908"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketChMakeChar2 {
    pub fn from(buffer: &[u8]) -> PacketChMakeChar2 {
        PacketChMakeChar2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            char_num: u8::from_le_bytes([buffer[26]]),
            char_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[26..27]);
                dst
            },
            head_pal: i16::from_le_bytes([buffer[27], buffer[28]]),
            head_pal_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[27..29]);
                dst
            },
            head: i16::from_le_bytes([buffer[29], buffer[30]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[29..31]);
                dst
            },
            class: i32::from_le_bytes([buffer[31], buffer[32], buffer[33], buffer[34]]),
            class_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[31..35]);
                dst
            },
            sex: u8::from_le_bytes([buffer[35]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[35..36]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.char_num).unwrap();
        self.char_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_pal).unwrap();
        self.head_pal_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.class).unwrap();
        self.class_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.char_num_raw.to_vec());
        wtr.append(&mut self.head_pal_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.class_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_char_num(&mut self, value: u8) {
        self.char_num = value;
    }
    pub fn set_char_num_raw(&mut self, value: [u8; 1]) {
        self.char_num_raw = value;
    }
    pub fn set_head_pal(&mut self, value: i16) {
        self.head_pal = value;
    }
    pub fn set_head_pal_raw(&mut self, value: [u8; 2]) {
        self.head_pal_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_class(&mut self, value: i32) {
        self.class = value;
    }
    pub fn set_class_raw(&mut self, value: [u8; 4]) {
        self.class_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn new() -> PacketChMakeChar2 {
        PacketChMakeChar2 {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x39, 0x0a]),
        packet_id_raw: [0x39, 0x0a],
        name: [0 as char; 24],
        name_raw: [0; 24],
        char_num: 0,
        char_num_raw: [0; 1],
        head_pal: 0,
        head_pal_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        class: 0,
        class_raw: [0; 4],
        sex: 0,
        sex_raw: [0; 1],
        }
    }
}

impl Packet for PacketChMakeChar2 {
    fn id(&self) -> &str {
       "0x390a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketChDeleteChar4Reserved {
    pub fn from(buffer: &[u8]) -> PacketChDeleteChar4Reserved {
        PacketChDeleteChar4Reserved {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new() -> PacketChDeleteChar4Reserved {
        PacketChDeleteChar4Reserved {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x27, 0x08]),
        packet_id_raw: [0x27, 0x08],
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketChDeleteChar4Reserved {
    fn id(&self) -> &str {
       "0x2708"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl PacketHcDeleteChar4Reserved {
    pub fn from(buffer: &[u8]) -> PacketHcDeleteChar4Reserved {
        PacketHcDeleteChar4Reserved {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            result: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            delete_reserved_date: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            delete_reserved_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.delete_reserved_date).unwrap();
        self.delete_reserved_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.delete_reserved_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_result(&mut self, value: i32) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 4]) {
        self.result_raw = value;
    }
    pub fn set_delete_reserved_date(&mut self, value: i32) {
        self.delete_reserved_date = value;
    }
    pub fn set_delete_reserved_date_raw(&mut self, value: [u8; 4]) {
        self.delete_reserved_date_raw = value;
    }
    pub fn new() -> PacketHcDeleteChar4Reserved {
        PacketHcDeleteChar4Reserved {
        raw: vec![],
        packet_id: i16::from_le_bytes([0x28, 0x08]),
        packet_id_raw: [0x28, 0x08],
        gid: 0,
        gid_raw: [0; 4],
        result: 0,
        result_raw: [0; 4],
        delete_reserved_date: 0,
        delete_reserved_date_raw: [0; 4],
        }
    }
}

impl Packet for PacketHcDeleteChar4Reserved {
    fn id(&self) -> &str {
       "0x2808"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

impl ServerAddr {
    pub fn from(buffer: &[u8]) -> ServerAddr {
        ServerAddr {
            raw: buffer.to_vec(),
            ip: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            port: i16::from_le_bytes([buffer[4], buffer[5]]),
            port_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            name:  {
                let mut dst: [char; 20] = [0 as char; 20];
                for (index, byte) in buffer[6..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[6..26]);
                dst
            },
            user_count: u16::from_le_bytes([buffer[26], buffer[27]]),
            user_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            state: u16::from_le_bytes([buffer[28], buffer[29]]),
            state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            property: u16::from_le_bytes([buffer[30], buffer[31]]),
            property_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.ip).unwrap();
        self.ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.port).unwrap();
        self.port_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.user_count).unwrap();
        self.user_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.property).unwrap();
        self.property_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.ip_raw.to_vec());
        wtr.append(&mut self.port_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.user_count_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.property_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_ip(&mut self, value: u32) {
        self.ip = value;
    }
    pub fn set_ip_raw(&mut self, value: [u8; 4]) {
        self.ip_raw = value;
    }
    pub fn set_port(&mut self, value: i16) {
        self.port = value;
    }
    pub fn set_port_raw(&mut self, value: [u8; 2]) {
        self.port_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 20]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 20]) {
        self.name_raw = value;
    }
    pub fn set_user_count(&mut self, value: u16) {
        self.user_count = value;
    }
    pub fn set_user_count_raw(&mut self, value: [u8; 2]) {
        self.user_count_raw = value;
    }
    pub fn set_state(&mut self, value: u16) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 2]) {
        self.state_raw = value;
    }
    pub fn set_property(&mut self, value: u16) {
        self.property = value;
    }
    pub fn set_property_raw(&mut self, value: [u8; 2]) {
        self.property_raw = value;
    }
    pub fn new() -> ServerAddr {
        ServerAddr {
        raw: vec![],
        ip: 0,
        ip_raw: [0; 4],
        port: 0,
        port_raw: [0; 2],
        name: [0 as char; 20],
        name_raw: [0; 20],
        user_count: 0,
        user_count_raw: [0; 2],
        state: 0,
        state_raw: [0; 2],
        property: 0,
        property_raw: [0; 2],
        }
    }
}

impl ServerAddr2 {
    pub fn from(buffer: &[u8]) -> ServerAddr2 {
        ServerAddr2 {
            raw: buffer.to_vec(),
            ip: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            port: i16::from_le_bytes([buffer[4], buffer[5]]),
            port_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            name:  {
                let mut dst: [char; 20] = [0 as char; 20];
                for (index, byte) in buffer[6..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[6..26]);
                dst
            },
            user_count: u16::from_le_bytes([buffer[26], buffer[27]]),
            user_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            state: u16::from_le_bytes([buffer[28], buffer[29]]),
            state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            property: u16::from_le_bytes([buffer[30], buffer[31]]),
            property_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            unknown2:  {
                let mut dst: [char; 128] = [0 as char; 128];
                for (index, byte) in buffer[31..159].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            unknown2_raw: {
                let mut dst: [u8; 128] = [0u8; 128];
                dst.clone_from_slice(&buffer[31..159]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.ip).unwrap();
        self.ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.port).unwrap();
        self.port_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.user_count).unwrap();
        self.user_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.property).unwrap();
        self.property_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.unknown2 {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.unknown2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.ip_raw.to_vec());
        wtr.append(&mut self.port_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.user_count_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.property_raw.to_vec());
        wtr.append(&mut self.unknown2_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_ip(&mut self, value: u32) {
        self.ip = value;
    }
    pub fn set_ip_raw(&mut self, value: [u8; 4]) {
        self.ip_raw = value;
    }
    pub fn set_port(&mut self, value: i16) {
        self.port = value;
    }
    pub fn set_port_raw(&mut self, value: [u8; 2]) {
        self.port_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 20]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 20]) {
        self.name_raw = value;
    }
    pub fn set_user_count(&mut self, value: u16) {
        self.user_count = value;
    }
    pub fn set_user_count_raw(&mut self, value: [u8; 2]) {
        self.user_count_raw = value;
    }
    pub fn set_state(&mut self, value: u16) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 2]) {
        self.state_raw = value;
    }
    pub fn set_property(&mut self, value: u16) {
        self.property = value;
    }
    pub fn set_property_raw(&mut self, value: [u8; 2]) {
        self.property_raw = value;
    }
    pub fn set_unknown2(&mut self, value: [char; 128]) {
        self.unknown2 = value;
    }
    pub fn set_unknown2_raw(&mut self, value: [u8; 128]) {
        self.unknown2_raw = value;
    }
    pub fn new() -> ServerAddr2 {
        ServerAddr2 {
        raw: vec![],
        ip: 0,
        ip_raw: [0; 4],
        port: 0,
        port_raw: [0; 2],
        name: [0 as char; 20],
        name_raw: [0; 20],
        user_count: 0,
        user_count_raw: [0; 2],
        state: 0,
        state_raw: [0; 2],
        property: 0,
        property_raw: [0; 2],
        unknown2: [0 as char; 128],
        unknown2_raw: [0; 128],
        }
    }
}

impl CharacterInfoNeoUnion {
    pub fn from(buffer: &[u8]) -> CharacterInfoNeoUnion {
        CharacterInfoNeoUnion {
            raw: buffer.to_vec(),
            gid: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            exp: u64::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7], buffer[8], buffer[9], buffer[10], buffer[11]]),
            exp_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[4..12]);
                dst
            },
            money: u32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            money_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            jobexp: u64::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19], buffer[20], buffer[21], buffer[22], buffer[23]]),
            jobexp_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[16..24]);
                dst
            },
            joblevel: u32::from_le_bytes([buffer[24], buffer[25], buffer[26], buffer[27]]),
            joblevel_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[24..28]);
                dst
            },
            bodystate: u32::from_le_bytes([buffer[28], buffer[29], buffer[30], buffer[31]]),
            bodystate_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[28..32]);
                dst
            },
            healthstate: u32::from_le_bytes([buffer[32], buffer[33], buffer[34], buffer[35]]),
            healthstate_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[32..36]);
                dst
            },
            effectstate: i32::from_le_bytes([buffer[36], buffer[37], buffer[38], buffer[39]]),
            effectstate_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[36..40]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[40], buffer[41], buffer[42], buffer[43]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[40..44]);
                dst
            },
            honor: i32::from_le_bytes([buffer[44], buffer[45], buffer[46], buffer[47]]),
            honor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[44..48]);
                dst
            },
            status_point: u16::from_le_bytes([buffer[48], buffer[49]]),
            status_point_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[48..50]);
                dst
            },
            hp: u32::from_le_bytes([buffer[50], buffer[51], buffer[52], buffer[53]]),
            hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[50..54]);
                dst
            },
            maxhp: u32::from_le_bytes([buffer[54], buffer[55], buffer[56], buffer[57]]),
            maxhp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[54..58]);
                dst
            },
            sp: u16::from_le_bytes([buffer[58], buffer[59]]),
            sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[58..60]);
                dst
            },
            maxsp: u16::from_le_bytes([buffer[60], buffer[61]]),
            maxsp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[60..62]);
                dst
            },
            speed: u16::from_le_bytes([buffer[62], buffer[63]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[62..64]);
                dst
            },
            class: u16::from_le_bytes([buffer[64], buffer[65]]),
            class_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[64..66]);
                dst
            },
            head: u16::from_le_bytes([buffer[66], buffer[67]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[66..68]);
                dst
            },
            body: u16::from_le_bytes([buffer[68], buffer[69]]),
            body_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[68..70]);
                dst
            },
            weapon: u16::from_le_bytes([buffer[70], buffer[71]]),
            weapon_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[70..72]);
                dst
            },
            level: u16::from_le_bytes([buffer[72], buffer[73]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[72..74]);
                dst
            },
            skill_point: u16::from_le_bytes([buffer[74], buffer[75]]),
            skill_point_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[74..76]);
                dst
            },
            head_bottom: u16::from_le_bytes([buffer[76], buffer[77]]),
            head_bottom_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[76..78]);
                dst
            },
            shield: u16::from_le_bytes([buffer[78], buffer[79]]),
            shield_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[78..80]);
                dst
            },
            head_top: u16::from_le_bytes([buffer[80], buffer[81]]),
            head_top_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[80..82]);
                dst
            },
            head_mid: u16::from_le_bytes([buffer[82], buffer[83]]),
            head_mid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[82..84]);
                dst
            },
            hair_color: u16::from_le_bytes([buffer[84], buffer[85]]),
            hair_color_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[84..86]);
                dst
            },
            body_color: u16::from_le_bytes([buffer[86], buffer[87]]),
            body_color_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[86..88]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[88..112].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[88..112]);
                dst
            },
            str: u8::from_le_bytes([buffer[112]]),
            str_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[112..113]);
                dst
            },
            agi: u8::from_le_bytes([buffer[113]]),
            agi_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[113..114]);
                dst
            },
            vit: u8::from_le_bytes([buffer[114]]),
            vit_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[114..115]);
                dst
            },
            int: u8::from_le_bytes([buffer[115]]),
            int_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[115..116]);
                dst
            },
            dex: u8::from_le_bytes([buffer[116]]),
            dex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[116..117]);
                dst
            },
            luk: u8::from_le_bytes([buffer[117]]),
            luk_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[117..118]);
                dst
            },
            char_num: i8::from_le_bytes([buffer[118]]),
            char_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[118..119]);
                dst
            },
            haircolor: u8::from_le_bytes([buffer[119]]),
            haircolor_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[119..120]);
                dst
            },
            b_is_changed_char_name: u16::from_le_bytes([buffer[120], buffer[121]]),
            b_is_changed_char_name_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[120..122]);
                dst
            },
            last_map:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[122..138].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            last_map_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[122..138]);
                dst
            },
            delete_date: u32::from_le_bytes([buffer[138], buffer[139], buffer[140], buffer[141]]),
            delete_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[138..142]);
                dst
            },
            robe: u32::from_le_bytes([buffer[142], buffer[143], buffer[144], buffer[145]]),
            robe_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[142..146]);
                dst
            },
            slot_addon: u32::from_le_bytes([buffer[146], buffer[147], buffer[148], buffer[149]]),
            slot_addon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[146..150]);
                dst
            },
            rename_addon: u32::from_le_bytes([buffer[150], buffer[151], buffer[152], buffer[153]]),
            rename_addon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[150..154]);
                dst
            },
            sex: u8::from_le_bytes([buffer[154]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[154..155]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u64::<LittleEndian>(self.exp).unwrap();
        self.exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.money).unwrap();
        self.money_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u64::<LittleEndian>(self.jobexp).unwrap();
        self.jobexp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.joblevel).unwrap();
        self.joblevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bodystate).unwrap();
        self.bodystate_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.healthstate).unwrap();
        self.healthstate_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effectstate).unwrap();
        self.effectstate_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.status_point).unwrap();
        self.status_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maxhp).unwrap();
        self.maxhp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.sp).unwrap();
        self.sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.maxsp).unwrap();
        self.maxsp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.class).unwrap();
        self.class_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.body).unwrap();
        self.body_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skill_point).unwrap();
        self.skill_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.head_bottom).unwrap();
        self.head_bottom_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.head_top).unwrap();
        self.head_top_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.head_mid).unwrap();
        self.head_mid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.hair_color).unwrap();
        self.hair_color_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.body_color).unwrap();
        self.body_color_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.str).unwrap();
        self.str_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.agi).unwrap();
        self.agi_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.vit).unwrap();
        self.vit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.int).unwrap();
        self.int_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dex).unwrap();
        self.dex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.luk).unwrap();
        self.luk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.char_num).unwrap();
        self.char_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.haircolor).unwrap();
        self.haircolor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.b_is_changed_char_name).unwrap();
        self.b_is_changed_char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.last_map {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.last_map_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.delete_date).unwrap();
        self.delete_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.robe).unwrap();
        self.robe_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.slot_addon).unwrap();
        self.slot_addon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.rename_addon).unwrap();
        self.rename_addon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.exp_raw.to_vec());
        wtr.append(&mut self.money_raw.to_vec());
        wtr.append(&mut self.jobexp_raw.to_vec());
        wtr.append(&mut self.joblevel_raw.to_vec());
        wtr.append(&mut self.bodystate_raw.to_vec());
        wtr.append(&mut self.healthstate_raw.to_vec());
        wtr.append(&mut self.effectstate_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.status_point_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.maxhp_raw.to_vec());
        wtr.append(&mut self.sp_raw.to_vec());
        wtr.append(&mut self.maxsp_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.class_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.body_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.skill_point_raw.to_vec());
        wtr.append(&mut self.head_bottom_raw.to_vec());
        wtr.append(&mut self.shield_raw.to_vec());
        wtr.append(&mut self.head_top_raw.to_vec());
        wtr.append(&mut self.head_mid_raw.to_vec());
        wtr.append(&mut self.hair_color_raw.to_vec());
        wtr.append(&mut self.body_color_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.str_raw.to_vec());
        wtr.append(&mut self.agi_raw.to_vec());
        wtr.append(&mut self.vit_raw.to_vec());
        wtr.append(&mut self.int_raw.to_vec());
        wtr.append(&mut self.dex_raw.to_vec());
        wtr.append(&mut self.luk_raw.to_vec());
        wtr.append(&mut self.char_num_raw.to_vec());
        wtr.append(&mut self.haircolor_raw.to_vec());
        wtr.append(&mut self.b_is_changed_char_name_raw.to_vec());
        wtr.append(&mut self.last_map_raw.to_vec());
        wtr.append(&mut self.delete_date_raw.to_vec());
        wtr.append(&mut self.robe_raw.to_vec());
        wtr.append(&mut self.slot_addon_raw.to_vec());
        wtr.append(&mut self.rename_addon_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_exp(&mut self, value: u64) {
        self.exp = value;
    }
    pub fn set_exp_raw(&mut self, value: [u8; 8]) {
        self.exp_raw = value;
    }
    pub fn set_money(&mut self, value: u32) {
        self.money = value;
    }
    pub fn set_money_raw(&mut self, value: [u8; 4]) {
        self.money_raw = value;
    }
    pub fn set_jobexp(&mut self, value: u64) {
        self.jobexp = value;
    }
    pub fn set_jobexp_raw(&mut self, value: [u8; 8]) {
        self.jobexp_raw = value;
    }
    pub fn set_joblevel(&mut self, value: u32) {
        self.joblevel = value;
    }
    pub fn set_joblevel_raw(&mut self, value: [u8; 4]) {
        self.joblevel_raw = value;
    }
    pub fn set_bodystate(&mut self, value: u32) {
        self.bodystate = value;
    }
    pub fn set_bodystate_raw(&mut self, value: [u8; 4]) {
        self.bodystate_raw = value;
    }
    pub fn set_healthstate(&mut self, value: u32) {
        self.healthstate = value;
    }
    pub fn set_healthstate_raw(&mut self, value: [u8; 4]) {
        self.healthstate_raw = value;
    }
    pub fn set_effectstate(&mut self, value: i32) {
        self.effectstate = value;
    }
    pub fn set_effectstate_raw(&mut self, value: [u8; 4]) {
        self.effectstate_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_honor(&mut self, value: i32) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 4]) {
        self.honor_raw = value;
    }
    pub fn set_status_point(&mut self, value: u16) {
        self.status_point = value;
    }
    pub fn set_status_point_raw(&mut self, value: [u8; 2]) {
        self.status_point_raw = value;
    }
    pub fn set_hp(&mut self, value: u32) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 4]) {
        self.hp_raw = value;
    }
    pub fn set_maxhp(&mut self, value: u32) {
        self.maxhp = value;
    }
    pub fn set_maxhp_raw(&mut self, value: [u8; 4]) {
        self.maxhp_raw = value;
    }
    pub fn set_sp(&mut self, value: u16) {
        self.sp = value;
    }
    pub fn set_sp_raw(&mut self, value: [u8; 2]) {
        self.sp_raw = value;
    }
    pub fn set_maxsp(&mut self, value: u16) {
        self.maxsp = value;
    }
    pub fn set_maxsp_raw(&mut self, value: [u8; 2]) {
        self.maxsp_raw = value;
    }
    pub fn set_speed(&mut self, value: u16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_class(&mut self, value: u16) {
        self.class = value;
    }
    pub fn set_class_raw(&mut self, value: [u8; 2]) {
        self.class_raw = value;
    }
    pub fn set_head(&mut self, value: u16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_body(&mut self, value: u16) {
        self.body = value;
    }
    pub fn set_body_raw(&mut self, value: [u8; 2]) {
        self.body_raw = value;
    }
    pub fn set_weapon(&mut self, value: u16) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 2]) {
        self.weapon_raw = value;
    }
    pub fn set_level(&mut self, value: u16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_skill_point(&mut self, value: u16) {
        self.skill_point = value;
    }
    pub fn set_skill_point_raw(&mut self, value: [u8; 2]) {
        self.skill_point_raw = value;
    }
    pub fn set_head_bottom(&mut self, value: u16) {
        self.head_bottom = value;
    }
    pub fn set_head_bottom_raw(&mut self, value: [u8; 2]) {
        self.head_bottom_raw = value;
    }
    pub fn set_shield(&mut self, value: u16) {
        self.shield = value;
    }
    pub fn set_shield_raw(&mut self, value: [u8; 2]) {
        self.shield_raw = value;
    }
    pub fn set_head_top(&mut self, value: u16) {
        self.head_top = value;
    }
    pub fn set_head_top_raw(&mut self, value: [u8; 2]) {
        self.head_top_raw = value;
    }
    pub fn set_head_mid(&mut self, value: u16) {
        self.head_mid = value;
    }
    pub fn set_head_mid_raw(&mut self, value: [u8; 2]) {
        self.head_mid_raw = value;
    }
    pub fn set_hair_color(&mut self, value: u16) {
        self.hair_color = value;
    }
    pub fn set_hair_color_raw(&mut self, value: [u8; 2]) {
        self.hair_color_raw = value;
    }
    pub fn set_body_color(&mut self, value: u16) {
        self.body_color = value;
    }
    pub fn set_body_color_raw(&mut self, value: [u8; 2]) {
        self.body_color_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_str(&mut self, value: u8) {
        self.str = value;
    }
    pub fn set_str_raw(&mut self, value: [u8; 1]) {
        self.str_raw = value;
    }
    pub fn set_agi(&mut self, value: u8) {
        self.agi = value;
    }
    pub fn set_agi_raw(&mut self, value: [u8; 1]) {
        self.agi_raw = value;
    }
    pub fn set_vit(&mut self, value: u8) {
        self.vit = value;
    }
    pub fn set_vit_raw(&mut self, value: [u8; 1]) {
        self.vit_raw = value;
    }
    pub fn set_int(&mut self, value: u8) {
        self.int = value;
    }
    pub fn set_int_raw(&mut self, value: [u8; 1]) {
        self.int_raw = value;
    }
    pub fn set_dex(&mut self, value: u8) {
        self.dex = value;
    }
    pub fn set_dex_raw(&mut self, value: [u8; 1]) {
        self.dex_raw = value;
    }
    pub fn set_luk(&mut self, value: u8) {
        self.luk = value;
    }
    pub fn set_luk_raw(&mut self, value: [u8; 1]) {
        self.luk_raw = value;
    }
    pub fn set_char_num(&mut self, value: i8) {
        self.char_num = value;
    }
    pub fn set_char_num_raw(&mut self, value: [u8; 1]) {
        self.char_num_raw = value;
    }
    pub fn set_haircolor(&mut self, value: u8) {
        self.haircolor = value;
    }
    pub fn set_haircolor_raw(&mut self, value: [u8; 1]) {
        self.haircolor_raw = value;
    }
    pub fn set_b_is_changed_char_name(&mut self, value: u16) {
        self.b_is_changed_char_name = value;
    }
    pub fn set_b_is_changed_char_name_raw(&mut self, value: [u8; 2]) {
        self.b_is_changed_char_name_raw = value;
    }
    pub fn set_last_map(&mut self, value: [char; 16]) {
        self.last_map = value;
    }
    pub fn set_last_map_raw(&mut self, value: [u8; 16]) {
        self.last_map_raw = value;
    }
    pub fn set_delete_date(&mut self, value: u32) {
        self.delete_date = value;
    }
    pub fn set_delete_date_raw(&mut self, value: [u8; 4]) {
        self.delete_date_raw = value;
    }
    pub fn set_robe(&mut self, value: u32) {
        self.robe = value;
    }
    pub fn set_robe_raw(&mut self, value: [u8; 4]) {
        self.robe_raw = value;
    }
    pub fn set_slot_addon(&mut self, value: u32) {
        self.slot_addon = value;
    }
    pub fn set_slot_addon_raw(&mut self, value: [u8; 4]) {
        self.slot_addon_raw = value;
    }
    pub fn set_rename_addon(&mut self, value: u32) {
        self.rename_addon = value;
    }
    pub fn set_rename_addon_raw(&mut self, value: [u8; 4]) {
        self.rename_addon_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn new() -> CharacterInfoNeoUnion {
        CharacterInfoNeoUnion {
        raw: vec![],
        gid: 0,
        gid_raw: [0; 4],
        exp: 0,
        exp_raw: [0; 8],
        money: 0,
        money_raw: [0; 4],
        jobexp: 0,
        jobexp_raw: [0; 8],
        joblevel: 0,
        joblevel_raw: [0; 4],
        bodystate: 0,
        bodystate_raw: [0; 4],
        healthstate: 0,
        healthstate_raw: [0; 4],
        effectstate: 0,
        effectstate_raw: [0; 4],
        virtue: 0,
        virtue_raw: [0; 4],
        honor: 0,
        honor_raw: [0; 4],
        status_point: 0,
        status_point_raw: [0; 2],
        hp: 0,
        hp_raw: [0; 4],
        maxhp: 0,
        maxhp_raw: [0; 4],
        sp: 0,
        sp_raw: [0; 2],
        maxsp: 0,
        maxsp_raw: [0; 2],
        speed: 0,
        speed_raw: [0; 2],
        class: 0,
        class_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        body: 0,
        body_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 2],
        level: 0,
        level_raw: [0; 2],
        skill_point: 0,
        skill_point_raw: [0; 2],
        head_bottom: 0,
        head_bottom_raw: [0; 2],
        shield: 0,
        shield_raw: [0; 2],
        head_top: 0,
        head_top_raw: [0; 2],
        head_mid: 0,
        head_mid_raw: [0; 2],
        hair_color: 0,
        hair_color_raw: [0; 2],
        body_color: 0,
        body_color_raw: [0; 2],
        name: [0 as char; 24],
        name_raw: [0; 24],
        str: 0,
        str_raw: [0; 1],
        agi: 0,
        agi_raw: [0; 1],
        vit: 0,
        vit_raw: [0; 1],
        int: 0,
        int_raw: [0; 1],
        dex: 0,
        dex_raw: [0; 1],
        luk: 0,
        luk_raw: [0; 1],
        char_num: 0,
        char_num_raw: [0; 1],
        haircolor: 0,
        haircolor_raw: [0; 1],
        b_is_changed_char_name: 0,
        b_is_changed_char_name_raw: [0; 2],
        last_map: [0 as char; 16],
        last_map_raw: [0; 16],
        delete_date: 0,
        delete_date_raw: [0; 4],
        robe: 0,
        robe_raw: [0; 4],
        slot_addon: 0,
        slot_addon_raw: [0; 4],
        rename_addon: 0,
        rename_addon_raw: [0; 4],
        sex: 0,
        sex_raw: [0; 1],
        }
    }
}

impl ZserverAddr {
    pub fn from(buffer: &[u8]) -> ZserverAddr {
        ZserverAddr {
            raw: buffer.to_vec(),
            ip: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            port: i16::from_le_bytes([buffer[4], buffer[5]]),
            port_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.ip).unwrap();
        self.ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.port).unwrap();
        self.port_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.ip_raw.to_vec());
        wtr.append(&mut self.port_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_ip(&mut self, value: u32) {
        self.ip = value;
    }
    pub fn set_ip_raw(&mut self, value: [u8; 4]) {
        self.ip_raw = value;
    }
    pub fn set_port(&mut self, value: i16) {
        self.port = value;
    }
    pub fn set_port_raw(&mut self, value: [u8; 2]) {
        self.port_raw = value;
    }
    pub fn new() -> ZserverAddr {
        ZserverAddr {
        raw: vec![],
        ip: 0,
        ip_raw: [0; 4],
        port: 0,
        port_raw: [0; 2],
        }
    }
}

impl EQUIPSLOTINFO {
    pub fn from(buffer: &[u8]) -> EQUIPSLOTINFO {
        EQUIPSLOTINFO {
            raw: buffer.to_vec(),
            card1: u16::from_le_bytes([buffer[0], buffer[1]]),
            card1_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            card2: u16::from_le_bytes([buffer[2], buffer[3]]),
            card2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            card3: u16::from_le_bytes([buffer[4], buffer[5]]),
            card3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            card4: u16::from_le_bytes([buffer[6], buffer[7]]),
            card4_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card1).unwrap();
        self.card1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card2).unwrap();
        self.card2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card3).unwrap();
        self.card3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card4).unwrap();
        self.card4_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.card1_raw.to_vec());
        wtr.append(&mut self.card2_raw.to_vec());
        wtr.append(&mut self.card3_raw.to_vec());
        wtr.append(&mut self.card4_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_card1(&mut self, value: u16) {
        self.card1 = value;
    }
    pub fn set_card1_raw(&mut self, value: [u8; 2]) {
        self.card1_raw = value;
    }
    pub fn set_card2(&mut self, value: u16) {
        self.card2 = value;
    }
    pub fn set_card2_raw(&mut self, value: [u8; 2]) {
        self.card2_raw = value;
    }
    pub fn set_card3(&mut self, value: u16) {
        self.card3 = value;
    }
    pub fn set_card3_raw(&mut self, value: [u8; 2]) {
        self.card3_raw = value;
    }
    pub fn set_card4(&mut self, value: u16) {
        self.card4 = value;
    }
    pub fn set_card4_raw(&mut self, value: [u8; 2]) {
        self.card4_raw = value;
    }
    pub fn new() -> EQUIPSLOTINFO {
        EQUIPSLOTINFO {
        raw: vec![],
        card1: 0,
        card1_raw: [0; 2],
        card2: 0,
        card2_raw: [0; 2],
        card3: 0,
        card3_raw: [0; 2],
        card4: 0,
        card4_raw: [0; 2],
        }
    }
}

impl NormalitemExtrainfo {
    pub fn from(buffer: &[u8]) -> NormalitemExtrainfo {
        NormalitemExtrainfo {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: u8::from_le_bytes([buffer[4]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            is_identified: buffer[5] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            count: i16::from_le_bytes([buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            wear_state: u16::from_le_bytes([buffer[8], buffer[9]]),
            wear_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_state).unwrap();
        self.wear_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.wear_state_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_wear_state(&mut self, value: u16) {
        self.wear_state = value;
    }
    pub fn set_wear_state_raw(&mut self, value: [u8; 2]) {
        self.wear_state_raw = value;
    }
    pub fn new() -> NormalitemExtrainfo {
        NormalitemExtrainfo {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        is_identified: false,
        is_identified_raw: [0; 1],
        count: 0,
        count_raw: [0; 2],
        wear_state: 0,
        wear_state_raw: [0; 2],
        }
    }
}

impl EquipmentitemExtrainfo {
    pub fn from(buffer: &[u8]) -> EquipmentitemExtrainfo {
        EquipmentitemExtrainfo {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: u8::from_le_bytes([buffer[4]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            is_identified: buffer[5] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            location: u16::from_le_bytes([buffer[6], buffer[7]]),
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            wear_state: u16::from_le_bytes([buffer[8], buffer[9]]),
            wear_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            is_damaged: buffer[10] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[11]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[12..20]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[12..20]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_state).unwrap();
        self.wear_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.location_raw.to_vec());
        wtr.append(&mut self.wear_state_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_location(&mut self, value: u16) {
        self.location = value;
    }
    pub fn set_location_raw(&mut self, value: [u8; 2]) {
        self.location_raw = value;
    }
    pub fn set_wear_state(&mut self, value: u16) {
        self.wear_state = value;
    }
    pub fn set_wear_state_raw(&mut self, value: [u8; 2]) {
        self.wear_state_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new() -> EquipmentitemExtrainfo {
        EquipmentitemExtrainfo {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        is_identified: false,
        is_identified_raw: [0; 1],
        location: 0,
        location_raw: [0; 2],
        wear_state: 0,
        wear_state_raw: [0; 2],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        }
    }
}

impl PurchaseItem {
    pub fn from(buffer: &[u8]) -> PurchaseItem {
        PurchaseItem {
            raw: buffer.to_vec(),
            price: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            discountprice: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            discountprice_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            atype: u8::from_le_bytes([buffer[8]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            itid: u16::from_le_bytes([buffer[9], buffer[10]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.discountprice).unwrap();
        self.discountprice_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.price_raw.to_vec());
        wtr.append(&mut self.discountprice_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_price(&mut self, value: i32) {
        self.price = value;
    }
    pub fn set_price_raw(&mut self, value: [u8; 4]) {
        self.price_raw = value;
    }
    pub fn set_discountprice(&mut self, value: i32) {
        self.discountprice = value;
    }
    pub fn set_discountprice_raw(&mut self, value: [u8; 4]) {
        self.discountprice_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new() -> PurchaseItem {
        PurchaseItem {
        raw: vec![],
        price: 0,
        price_raw: [0; 4],
        discountprice: 0,
        discountprice_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl SellItem {
    pub fn from(buffer: &[u8]) -> SellItem {
        SellItem {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            price: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            overchargeprice: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            overchargeprice_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.overchargeprice).unwrap();
        self.overchargeprice_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.price_raw.to_vec());
        wtr.append(&mut self.overchargeprice_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_price(&mut self, value: i32) {
        self.price = value;
    }
    pub fn set_price_raw(&mut self, value: [u8; 4]) {
        self.price_raw = value;
    }
    pub fn set_overchargeprice(&mut self, value: i32) {
        self.overchargeprice = value;
    }
    pub fn set_overchargeprice_raw(&mut self, value: [u8; 4]) {
        self.overchargeprice_raw = value;
    }
    pub fn new() -> SellItem {
        SellItem {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        price: 0,
        price_raw: [0; 4],
        overchargeprice: 0,
        overchargeprice_raw: [0; 4],
        }
    }
}

impl CzPurchaseItem {
    pub fn from(buffer: &[u8]) -> CzPurchaseItem {
        CzPurchaseItem {
            raw: buffer.to_vec(),
            count: i16::from_le_bytes([buffer[0], buffer[1]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new() -> CzPurchaseItem {
        CzPurchaseItem {
        raw: vec![],
        count: 0,
        count_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl CzSellItem {
    pub fn from(buffer: &[u8]) -> CzSellItem {
        CzSellItem {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            count: i16::from_le_bytes([buffer[2], buffer[3]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new() -> CzSellItem {
        CzSellItem {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl WhisperItem {
    pub fn from(buffer: &[u8]) -> WhisperItem {
        WhisperItem {
            raw: buffer.to_vec(),
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[0..24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[0..24]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new() -> WhisperItem {
        WhisperItem {
        raw: vec![],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl RoomMember {
    pub fn from(buffer: &[u8]) -> RoomMember {
        RoomMember {
            raw: buffer.to_vec(),
            role: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            role_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.role).unwrap();
        self.role_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.role_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_role(&mut self, value: u32) {
        self.role = value;
    }
    pub fn set_role_raw(&mut self, value: [u8; 4]) {
        self.role_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new() -> RoomMember {
        RoomMember {
        raw: vec![],
        role: 0,
        role_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl GroupmemberInfo {
    pub fn from(buffer: &[u8]) -> GroupmemberInfo {
        GroupmemberInfo {
            raw: buffer.to_vec(),
            aid: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[28..44].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[28..44]);
                dst
            },
            role: u8::from_le_bytes([buffer[44]]),
            role_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[44..45]);
                dst
            },
            state: u8::from_le_bytes([buffer[45]]),
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[45..46]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.role).unwrap();
        self.role_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.role_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_role(&mut self, value: u8) {
        self.role = value;
    }
    pub fn set_role_raw(&mut self, value: [u8; 1]) {
        self.role_raw = value;
    }
    pub fn set_state(&mut self, value: u8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn new() -> GroupmemberInfo {
        GroupmemberInfo {
        raw: vec![],
        aid: 0,
        aid_raw: [0; 4],
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        role: 0,
        role_raw: [0; 1],
        state: 0,
        state_raw: [0; 1],
        }
    }
}

impl SKILLINFO {
    pub fn from(buffer: &[u8]) -> SKILLINFO {
        SKILLINFO {
            raw: buffer.to_vec(),
            skid: i16::from_le_bytes([buffer[0], buffer[1]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            level: i16::from_le_bytes([buffer[6], buffer[7]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            spcost: i16::from_le_bytes([buffer[8], buffer[9]]),
            spcost_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            attack_range: i16::from_le_bytes([buffer[10], buffer[11]]),
            attack_range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            skill_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[12..36].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            skill_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[12..36]);
                dst
            },
            upgradable: i8::from_le_bytes([buffer[36]]),
            upgradable_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[36..37]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.spcost).unwrap();
        self.spcost_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.attack_range).unwrap();
        self.attack_range_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.skill_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.skill_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.upgradable).unwrap();
        self.upgradable_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.spcost_raw.to_vec());
        wtr.append(&mut self.attack_range_raw.to_vec());
        wtr.append(&mut self.skill_name_raw.to_vec());
        wtr.append(&mut self.upgradable_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_skid(&mut self, value: i16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_spcost(&mut self, value: i16) {
        self.spcost = value;
    }
    pub fn set_spcost_raw(&mut self, value: [u8; 2]) {
        self.spcost_raw = value;
    }
    pub fn set_attack_range(&mut self, value: i16) {
        self.attack_range = value;
    }
    pub fn set_attack_range_raw(&mut self, value: [u8; 2]) {
        self.attack_range_raw = value;
    }
    pub fn set_skill_name(&mut self, value: [char; 24]) {
        self.skill_name = value;
    }
    pub fn set_skill_name_raw(&mut self, value: [u8; 24]) {
        self.skill_name_raw = value;
    }
    pub fn set_upgradable(&mut self, value: i8) {
        self.upgradable = value;
    }
    pub fn set_upgradable_raw(&mut self, value: [u8; 1]) {
        self.upgradable_raw = value;
    }
    pub fn new() -> SKILLINFO {
        SKILLINFO {
        raw: vec![],
        skid: 0,
        skid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 4],
        level: 0,
        level_raw: [0; 2],
        spcost: 0,
        spcost_raw: [0; 2],
        attack_range: 0,
        attack_range_raw: [0; 2],
        skill_name: [0 as char; 24],
        skill_name_raw: [0; 24],
        upgradable: 0,
        upgradable_raw: [0; 1],
        }
    }
}

impl StoreItem {
    pub fn from(buffer: &[u8]) -> StoreItem {
        StoreItem {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            count: i16::from_le_bytes([buffer[2], buffer[3]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            price: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.price_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_price(&mut self, value: i32) {
        self.price = value;
    }
    pub fn set_price_raw(&mut self, value: [u8; 4]) {
        self.price_raw = value;
    }
    pub fn new() -> StoreItem {
        StoreItem {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        price: 0,
        price_raw: [0; 4],
        }
    }
}

impl PurchaseItemFrommc {
    pub fn from(buffer: &[u8]) -> PurchaseItemFrommc {
        PurchaseItemFrommc {
            raw: buffer.to_vec(),
            price: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            index: i16::from_le_bytes([buffer[6], buffer[7]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            atype: u8::from_le_bytes([buffer[8]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            itid: u16::from_le_bytes([buffer[9], buffer[10]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            is_identified: u8::from_le_bytes([buffer[11]]),
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            is_damaged: u8::from_le_bytes([buffer[12]]),
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[13]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[13..14]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[14..22]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[14..22]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.price_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_price(&mut self, value: i32) {
        self.price = value;
    }
    pub fn set_price_raw(&mut self, value: [u8; 4]) {
        self.price_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: u8) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: u8) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new() -> PurchaseItemFrommc {
        PurchaseItemFrommc {
        raw: vec![],
        price: 0,
        price_raw: [0; 4],
        count: 0,
        count_raw: [0; 2],
        index: 0,
        index_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: 0,
        is_identified_raw: [0; 1],
        is_damaged: 0,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        }
    }
}

impl CzPurchaseItemFrommc {
    pub fn from(buffer: &[u8]) -> CzPurchaseItemFrommc {
        CzPurchaseItemFrommc {
            raw: buffer.to_vec(),
            count: i16::from_le_bytes([buffer[0], buffer[1]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn new() -> CzPurchaseItemFrommc {
        CzPurchaseItemFrommc {
        raw: vec![],
        count: 0,
        count_raw: [0; 2],
        index: 0,
        index_raw: [0; 2],
        }
    }
}

impl PurchaseMyitem {
    pub fn from(buffer: &[u8]) -> PurchaseMyitem {
        PurchaseMyitem {
            raw: buffer.to_vec(),
            price: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            index: i16::from_le_bytes([buffer[4], buffer[5]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            count: i16::from_le_bytes([buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            atype: u8::from_le_bytes([buffer[8]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            itid: u16::from_le_bytes([buffer[9], buffer[10]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            is_identified: u8::from_le_bytes([buffer[11]]),
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            is_damaged: u8::from_le_bytes([buffer[12]]),
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[13]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[13..14]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[14..22]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[14..22]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.price_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_price(&mut self, value: i32) {
        self.price = value;
    }
    pub fn set_price_raw(&mut self, value: [u8; 4]) {
        self.price_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: u8) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: u8) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new() -> PurchaseMyitem {
        PurchaseMyitem {
        raw: vec![],
        price: 0,
        price_raw: [0; 4],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: 0,
        is_identified_raw: [0; 1],
        is_damaged: 0,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        }
    }
}

impl RelatedGuild {
    pub fn from(buffer: &[u8]) -> RelatedGuild {
        RelatedGuild {
            raw: buffer.to_vec(),
            gdid: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            relation: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            relation_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            guild_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[8..32].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            guild_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[8..32]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.relation).unwrap();
        self.relation_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.guild_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guild_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.relation_raw.to_vec());
        wtr.append(&mut self.guild_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_gdid(&mut self, value: i32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_relation(&mut self, value: i32) {
        self.relation = value;
    }
    pub fn set_relation_raw(&mut self, value: [u8; 4]) {
        self.relation_raw = value;
    }
    pub fn set_guild_name(&mut self, value: [char; 24]) {
        self.guild_name = value;
    }
    pub fn set_guild_name_raw(&mut self, value: [u8; 24]) {
        self.guild_name_raw = value;
    }
    pub fn new() -> RelatedGuild {
        RelatedGuild {
        raw: vec![],
        gdid: 0,
        gdid_raw: [0; 4],
        relation: 0,
        relation_raw: [0; 4],
        guild_name: [0 as char; 24],
        guild_name_raw: [0; 24],
        }
    }
}

impl GuildMembermgrInfo {
    pub fn from(buffer: &[u8]) -> GuildMembermgrInfo {
        GuildMembermgrInfo {
            raw: buffer.to_vec(),
            aid: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            gid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            head_type: i16::from_le_bytes([buffer[8], buffer[9]]),
            head_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            head_palette: i16::from_le_bytes([buffer[10], buffer[11]]),
            head_palette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            sex: i16::from_le_bytes([buffer[12], buffer[13]]),
            sex_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: i16::from_le_bytes([buffer[14], buffer[15]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            level: i16::from_le_bytes([buffer[16], buffer[17]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            member_exp: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            member_exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
            current_state: i32::from_le_bytes([buffer[22], buffer[23], buffer[24], buffer[25]]),
            current_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[22..26]);
                dst
            },
            gposition_id: i32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            gposition_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
            memo:  {
                let mut dst: [char; 50] = [0 as char; 50];
                for (index, byte) in buffer[30..80].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            memo_raw: {
                let mut dst: [u8; 50] = [0u8; 50];
                dst.clone_from_slice(&buffer[30..80]);
                dst
            },
            char_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[80..104].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[80..104]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_type).unwrap();
        self.head_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_palette).unwrap();
        self.head_palette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.member_exp).unwrap();
        self.member_exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.current_state).unwrap();
        self.current_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gposition_id).unwrap();
        self.gposition_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.memo {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.memo_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.head_type_raw.to_vec());
        wtr.append(&mut self.head_palette_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.member_exp_raw.to_vec());
        wtr.append(&mut self.current_state_raw.to_vec());
        wtr.append(&mut self.gposition_id_raw.to_vec());
        wtr.append(&mut self.memo_raw.to_vec());
        wtr.append(&mut self.char_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_head_type(&mut self, value: i16) {
        self.head_type = value;
    }
    pub fn set_head_type_raw(&mut self, value: [u8; 2]) {
        self.head_type_raw = value;
    }
    pub fn set_head_palette(&mut self, value: i16) {
        self.head_palette = value;
    }
    pub fn set_head_palette_raw(&mut self, value: [u8; 2]) {
        self.head_palette_raw = value;
    }
    pub fn set_sex(&mut self, value: i16) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 2]) {
        self.sex_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_member_exp(&mut self, value: i32) {
        self.member_exp = value;
    }
    pub fn set_member_exp_raw(&mut self, value: [u8; 4]) {
        self.member_exp_raw = value;
    }
    pub fn set_current_state(&mut self, value: i32) {
        self.current_state = value;
    }
    pub fn set_current_state_raw(&mut self, value: [u8; 4]) {
        self.current_state_raw = value;
    }
    pub fn set_gposition_id(&mut self, value: i32) {
        self.gposition_id = value;
    }
    pub fn set_gposition_id_raw(&mut self, value: [u8; 4]) {
        self.gposition_id_raw = value;
    }
    pub fn set_memo(&mut self, value: [char; 50]) {
        self.memo = value;
    }
    pub fn set_memo_raw(&mut self, value: [u8; 50]) {
        self.memo_raw = value;
    }
    pub fn set_char_name(&mut self, value: [char; 24]) {
        self.char_name = value;
    }
    pub fn set_char_name_raw(&mut self, value: [u8; 24]) {
        self.char_name_raw = value;
    }
    pub fn new() -> GuildMembermgrInfo {
        GuildMembermgrInfo {
        raw: vec![],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        head_type: 0,
        head_type_raw: [0; 2],
        head_palette: 0,
        head_palette_raw: [0; 2],
        sex: 0,
        sex_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        level: 0,
        level_raw: [0; 2],
        member_exp: 0,
        member_exp_raw: [0; 4],
        current_state: 0,
        current_state_raw: [0; 4],
        gposition_id: 0,
        gposition_id_raw: [0; 4],
        memo: [0 as char; 50],
        memo_raw: [0; 50],
        char_name: [0 as char; 24],
        char_name_raw: [0; 24],
        }
    }
}

impl MemberPositionInfo {
    pub fn from(buffer: &[u8]) -> MemberPositionInfo {
        MemberPositionInfo {
            raw: buffer.to_vec(),
            aid: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            gid: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            position_id: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            position_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.position_id).unwrap();
        self.position_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.position_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_aid(&mut self, value: i32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: i32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_position_id(&mut self, value: i32) {
        self.position_id = value;
    }
    pub fn set_position_id_raw(&mut self, value: [u8; 4]) {
        self.position_id_raw = value;
    }
    pub fn new() -> MemberPositionInfo {
        MemberPositionInfo {
        raw: vec![],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        position_id: 0,
        position_id_raw: [0; 4],
        }
    }
}

impl GuildMemberPositionInfo {
    pub fn from(buffer: &[u8]) -> GuildMemberPositionInfo {
        GuildMemberPositionInfo {
            raw: buffer.to_vec(),
            position_id: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            position_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            right: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            right_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            ranking: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            ranking_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            pay_rate: i32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            pay_rate_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.position_id).unwrap();
        self.position_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.right).unwrap();
        self.right_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.ranking).unwrap();
        self.ranking_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.pay_rate).unwrap();
        self.pay_rate_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.position_id_raw.to_vec());
        wtr.append(&mut self.right_raw.to_vec());
        wtr.append(&mut self.ranking_raw.to_vec());
        wtr.append(&mut self.pay_rate_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_position_id(&mut self, value: i32) {
        self.position_id = value;
    }
    pub fn set_position_id_raw(&mut self, value: [u8; 4]) {
        self.position_id_raw = value;
    }
    pub fn set_right(&mut self, value: i32) {
        self.right = value;
    }
    pub fn set_right_raw(&mut self, value: [u8; 4]) {
        self.right_raw = value;
    }
    pub fn set_ranking(&mut self, value: i32) {
        self.ranking = value;
    }
    pub fn set_ranking_raw(&mut self, value: [u8; 4]) {
        self.ranking_raw = value;
    }
    pub fn set_pay_rate(&mut self, value: i32) {
        self.pay_rate = value;
    }
    pub fn set_pay_rate_raw(&mut self, value: [u8; 4]) {
        self.pay_rate_raw = value;
    }
    pub fn new() -> GuildMemberPositionInfo {
        GuildMemberPositionInfo {
        raw: vec![],
        position_id: 0,
        position_id_raw: [0; 4],
        right: 0,
        right_raw: [0; 4],
        ranking: 0,
        ranking_raw: [0; 4],
        pay_rate: 0,
        pay_rate_raw: [0; 4],
        }
    }
}

impl GuildRegPositionInfo {
    pub fn from(buffer: &[u8]) -> GuildRegPositionInfo {
        GuildRegPositionInfo {
            raw: buffer.to_vec(),
            position_id: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            position_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            right: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            right_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            ranking: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            ranking_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            pay_rate: i32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            pay_rate_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            pos_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[16..40].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[16..40]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.position_id).unwrap();
        self.position_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.right).unwrap();
        self.right_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.ranking).unwrap();
        self.ranking_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.pay_rate).unwrap();
        self.pay_rate_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.position_id_raw.to_vec());
        wtr.append(&mut self.right_raw.to_vec());
        wtr.append(&mut self.ranking_raw.to_vec());
        wtr.append(&mut self.pay_rate_raw.to_vec());
        wtr.append(&mut self.pos_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_position_id(&mut self, value: i32) {
        self.position_id = value;
    }
    pub fn set_position_id_raw(&mut self, value: [u8; 4]) {
        self.position_id_raw = value;
    }
    pub fn set_right(&mut self, value: i32) {
        self.right = value;
    }
    pub fn set_right_raw(&mut self, value: [u8; 4]) {
        self.right_raw = value;
    }
    pub fn set_ranking(&mut self, value: i32) {
        self.ranking = value;
    }
    pub fn set_ranking_raw(&mut self, value: [u8; 4]) {
        self.ranking_raw = value;
    }
    pub fn set_pay_rate(&mut self, value: i32) {
        self.pay_rate = value;
    }
    pub fn set_pay_rate_raw(&mut self, value: [u8; 4]) {
        self.pay_rate_raw = value;
    }
    pub fn set_pos_name(&mut self, value: [char; 24]) {
        self.pos_name = value;
    }
    pub fn set_pos_name_raw(&mut self, value: [u8; 24]) {
        self.pos_name_raw = value;
    }
    pub fn new() -> GuildRegPositionInfo {
        GuildRegPositionInfo {
        raw: vec![],
        position_id: 0,
        position_id_raw: [0; 4],
        right: 0,
        right_raw: [0; 4],
        ranking: 0,
        ranking_raw: [0; 4],
        pay_rate: 0,
        pay_rate_raw: [0; 4],
        pos_name: [0 as char; 24],
        pos_name_raw: [0; 24],
        }
    }
}

impl GuildBanInfo {
    pub fn from(buffer: &[u8]) -> GuildBanInfo {
        GuildBanInfo {
            raw: buffer.to_vec(),
            charname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[0..24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            charname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[0..24]);
                dst
            },
            account:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[24..48].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            account_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[24..48]);
                dst
            },
            reason:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[48..88].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            reason_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[48..88]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        for item in self.charname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.charname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.account {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.account_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.charname_raw.to_vec());
        wtr.append(&mut self.account_raw.to_vec());
        wtr.append(&mut self.reason_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_charname(&mut self, value: [char; 24]) {
        self.charname = value;
    }
    pub fn set_charname_raw(&mut self, value: [u8; 24]) {
        self.charname_raw = value;
    }
    pub fn set_account(&mut self, value: [char; 24]) {
        self.account = value;
    }
    pub fn set_account_raw(&mut self, value: [u8; 24]) {
        self.account_raw = value;
    }
    pub fn set_reason(&mut self, value: [char; 40]) {
        self.reason = value;
    }
    pub fn set_reason_raw(&mut self, value: [u8; 40]) {
        self.reason_raw = value;
    }
    pub fn new() -> GuildBanInfo {
        GuildBanInfo {
        raw: vec![],
        charname: [0 as char; 24],
        charname_raw: [0; 24],
        account: [0 as char; 24],
        account_raw: [0; 24],
        reason: [0 as char; 40],
        reason_raw: [0; 40],
        }
    }
}

impl OtherGuildInfo {
    pub fn from(buffer: &[u8]) -> OtherGuildInfo {
        OtherGuildInfo {
            raw: buffer.to_vec(),
            guildname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[0..24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            guildname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[0..24]);
                dst
            },
            guild_level: i32::from_le_bytes([buffer[24], buffer[25], buffer[26], buffer[27]]),
            guild_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[24..28]);
                dst
            },
            guild_member_size: i32::from_le_bytes([buffer[28], buffer[29], buffer[30], buffer[31]]),
            guild_member_size_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[28..32]);
                dst
            },
            guild_ranking: i32::from_le_bytes([buffer[32], buffer[33], buffer[34], buffer[35]]),
            guild_ranking_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[32..36]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        for item in self.guildname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guildname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.guild_level).unwrap();
        self.guild_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.guild_member_size).unwrap();
        self.guild_member_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.guild_ranking).unwrap();
        self.guild_ranking_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.guildname_raw.to_vec());
        wtr.append(&mut self.guild_level_raw.to_vec());
        wtr.append(&mut self.guild_member_size_raw.to_vec());
        wtr.append(&mut self.guild_ranking_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_guildname(&mut self, value: [char; 24]) {
        self.guildname = value;
    }
    pub fn set_guildname_raw(&mut self, value: [u8; 24]) {
        self.guildname_raw = value;
    }
    pub fn set_guild_level(&mut self, value: i32) {
        self.guild_level = value;
    }
    pub fn set_guild_level_raw(&mut self, value: [u8; 4]) {
        self.guild_level_raw = value;
    }
    pub fn set_guild_member_size(&mut self, value: i32) {
        self.guild_member_size = value;
    }
    pub fn set_guild_member_size_raw(&mut self, value: [u8; 4]) {
        self.guild_member_size_raw = value;
    }
    pub fn set_guild_ranking(&mut self, value: i32) {
        self.guild_ranking = value;
    }
    pub fn set_guild_ranking_raw(&mut self, value: [u8; 4]) {
        self.guild_ranking_raw = value;
    }
    pub fn new() -> OtherGuildInfo {
        OtherGuildInfo {
        raw: vec![],
        guildname: [0 as char; 24],
        guildname_raw: [0; 24],
        guild_level: 0,
        guild_level_raw: [0; 4],
        guild_member_size: 0,
        guild_member_size_raw: [0; 4],
        guild_ranking: 0,
        guild_ranking_raw: [0; 4],
        }
    }
}

impl MemberPositionIdNameInfo {
    pub fn from(buffer: &[u8]) -> MemberPositionIdNameInfo {
        MemberPositionIdNameInfo {
            raw: buffer.to_vec(),
            position_id: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            position_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            pos_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.position_id).unwrap();
        self.position_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.position_id_raw.to_vec());
        wtr.append(&mut self.pos_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_position_id(&mut self, value: i32) {
        self.position_id = value;
    }
    pub fn set_position_id_raw(&mut self, value: [u8; 4]) {
        self.position_id_raw = value;
    }
    pub fn set_pos_name(&mut self, value: [char; 24]) {
        self.pos_name = value;
    }
    pub fn set_pos_name_raw(&mut self, value: [u8; 24]) {
        self.pos_name_raw = value;
    }
    pub fn new() -> MemberPositionIdNameInfo {
        MemberPositionIdNameInfo {
        raw: vec![],
        position_id: 0,
        position_id_raw: [0; 4],
        pos_name: [0 as char; 24],
        pos_name_raw: [0; 24],
        }
    }
}

impl GuildMemberInfo {
    pub fn from(buffer: &[u8]) -> GuildMemberInfo {
        GuildMemberInfo {
            raw: buffer.to_vec(),
            aid: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            gid: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            head: i16::from_le_bytes([buffer[8], buffer[9]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            head_palette: i16::from_le_bytes([buffer[10], buffer[11]]),
            head_palette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            sex: i16::from_le_bytes([buffer[12], buffer[13]]),
            sex_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: i16::from_le_bytes([buffer[14], buffer[15]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            level: i16::from_le_bytes([buffer[16], buffer[17]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            contribution_exp: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            contribution_exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
            current_state: i32::from_le_bytes([buffer[22], buffer[23], buffer[24], buffer[25]]),
            current_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[22..26]);
                dst
            },
            position_id: i32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            position_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
            intro:  {
                let mut dst: [char; 50] = [0 as char; 50];
                for (index, byte) in buffer[30..80].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            intro_raw: {
                let mut dst: [u8; 50] = [0u8; 50];
                dst.clone_from_slice(&buffer[30..80]);
                dst
            },
            charname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[80..104].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            charname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[80..104]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_palette).unwrap();
        self.head_palette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.contribution_exp).unwrap();
        self.contribution_exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.current_state).unwrap();
        self.current_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.position_id).unwrap();
        self.position_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.intro {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.intro_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.charname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.charname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.head_palette_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.contribution_exp_raw.to_vec());
        wtr.append(&mut self.current_state_raw.to_vec());
        wtr.append(&mut self.position_id_raw.to_vec());
        wtr.append(&mut self.intro_raw.to_vec());
        wtr.append(&mut self.charname_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_aid(&mut self, value: i32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: i32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_head_palette(&mut self, value: i16) {
        self.head_palette = value;
    }
    pub fn set_head_palette_raw(&mut self, value: [u8; 2]) {
        self.head_palette_raw = value;
    }
    pub fn set_sex(&mut self, value: i16) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 2]) {
        self.sex_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_contribution_exp(&mut self, value: i32) {
        self.contribution_exp = value;
    }
    pub fn set_contribution_exp_raw(&mut self, value: [u8; 4]) {
        self.contribution_exp_raw = value;
    }
    pub fn set_current_state(&mut self, value: i32) {
        self.current_state = value;
    }
    pub fn set_current_state_raw(&mut self, value: [u8; 4]) {
        self.current_state_raw = value;
    }
    pub fn set_position_id(&mut self, value: i32) {
        self.position_id = value;
    }
    pub fn set_position_id_raw(&mut self, value: [u8; 4]) {
        self.position_id_raw = value;
    }
    pub fn set_intro(&mut self, value: [char; 50]) {
        self.intro = value;
    }
    pub fn set_intro_raw(&mut self, value: [u8; 50]) {
        self.intro_raw = value;
    }
    pub fn set_charname(&mut self, value: [char; 24]) {
        self.charname = value;
    }
    pub fn set_charname_raw(&mut self, value: [u8; 24]) {
        self.charname_raw = value;
    }
    pub fn new() -> GuildMemberInfo {
        GuildMemberInfo {
        raw: vec![],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        head: 0,
        head_raw: [0; 2],
        head_palette: 0,
        head_palette_raw: [0; 2],
        sex: 0,
        sex_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        level: 0,
        level_raw: [0; 2],
        contribution_exp: 0,
        contribution_exp_raw: [0; 4],
        current_state: 0,
        current_state_raw: [0; 4],
        position_id: 0,
        position_id_raw: [0; 4],
        intro: [0 as char; 50],
        intro_raw: [0; 50],
        charname: [0 as char; 24],
        charname_raw: [0; 24],
        }
    }
}

impl RelatedGuildInfo {
    pub fn from(buffer: &[u8]) -> RelatedGuildInfo {
        RelatedGuildInfo {
            raw: buffer.to_vec(),
            relation: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            relation_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            gdid: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            guildname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[8..32].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            guildname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[8..32]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.relation).unwrap();
        self.relation_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.guildname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guildname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.relation_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.guildname_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_relation(&mut self, value: i32) {
        self.relation = value;
    }
    pub fn set_relation_raw(&mut self, value: [u8; 4]) {
        self.relation_raw = value;
    }
    pub fn set_gdid(&mut self, value: i32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_guildname(&mut self, value: [char; 24]) {
        self.guildname = value;
    }
    pub fn set_guildname_raw(&mut self, value: [u8; 24]) {
        self.guildname_raw = value;
    }
    pub fn new() -> RelatedGuildInfo {
        RelatedGuildInfo {
        raw: vec![],
        relation: 0,
        relation_raw: [0; 4],
        gdid: 0,
        gdid_raw: [0; 4],
        guildname: [0 as char; 24],
        guildname_raw: [0; 24],
        }
    }
}

impl MonsterInfoElement {
    pub fn from(buffer: &[u8]) -> MonsterInfoElement {
        MonsterInfoElement {
            raw: buffer.to_vec(),
            water: u8::from_le_bytes([buffer[0]]),
            water_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[0..1]);
                dst
            },
            earth: u8::from_le_bytes([buffer[1]]),
            earth_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[1..2]);
                dst
            },
            fire: u8::from_le_bytes([buffer[2]]),
            fire_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            wind: u8::from_le_bytes([buffer[3]]),
            wind_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[3..4]);
                dst
            },
            poison: u8::from_le_bytes([buffer[4]]),
            poison_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            saint: u8::from_le_bytes([buffer[5]]),
            saint_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            dark: u8::from_le_bytes([buffer[6]]),
            dark_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            mental: u8::from_le_bytes([buffer[7]]),
            mental_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[7..8]);
                dst
            },
            undead: u8::from_le_bytes([buffer[8]]),
            undead_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u8(self.water).unwrap();
        self.water_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.earth).unwrap();
        self.earth_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.fire).unwrap();
        self.fire_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.wind).unwrap();
        self.wind_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.poison).unwrap();
        self.poison_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.saint).unwrap();
        self.saint_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dark).unwrap();
        self.dark_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.mental).unwrap();
        self.mental_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.undead).unwrap();
        self.undead_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.water_raw.to_vec());
        wtr.append(&mut self.earth_raw.to_vec());
        wtr.append(&mut self.fire_raw.to_vec());
        wtr.append(&mut self.wind_raw.to_vec());
        wtr.append(&mut self.poison_raw.to_vec());
        wtr.append(&mut self.saint_raw.to_vec());
        wtr.append(&mut self.dark_raw.to_vec());
        wtr.append(&mut self.mental_raw.to_vec());
        wtr.append(&mut self.undead_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_water(&mut self, value: u8) {
        self.water = value;
    }
    pub fn set_water_raw(&mut self, value: [u8; 1]) {
        self.water_raw = value;
    }
    pub fn set_earth(&mut self, value: u8) {
        self.earth = value;
    }
    pub fn set_earth_raw(&mut self, value: [u8; 1]) {
        self.earth_raw = value;
    }
    pub fn set_fire(&mut self, value: u8) {
        self.fire = value;
    }
    pub fn set_fire_raw(&mut self, value: [u8; 1]) {
        self.fire_raw = value;
    }
    pub fn set_wind(&mut self, value: u8) {
        self.wind = value;
    }
    pub fn set_wind_raw(&mut self, value: [u8; 1]) {
        self.wind_raw = value;
    }
    pub fn set_poison(&mut self, value: u8) {
        self.poison = value;
    }
    pub fn set_poison_raw(&mut self, value: [u8; 1]) {
        self.poison_raw = value;
    }
    pub fn set_saint(&mut self, value: u8) {
        self.saint = value;
    }
    pub fn set_saint_raw(&mut self, value: [u8; 1]) {
        self.saint_raw = value;
    }
    pub fn set_dark(&mut self, value: u8) {
        self.dark = value;
    }
    pub fn set_dark_raw(&mut self, value: [u8; 1]) {
        self.dark_raw = value;
    }
    pub fn set_mental(&mut self, value: u8) {
        self.mental = value;
    }
    pub fn set_mental_raw(&mut self, value: [u8; 1]) {
        self.mental_raw = value;
    }
    pub fn set_undead(&mut self, value: u8) {
        self.undead = value;
    }
    pub fn set_undead_raw(&mut self, value: [u8; 1]) {
        self.undead_raw = value;
    }
    pub fn new() -> MonsterInfoElement {
        MonsterInfoElement {
        raw: vec![],
        water: 0,
        water_raw: [0; 1],
        earth: 0,
        earth_raw: [0; 1],
        fire: 0,
        fire_raw: [0; 1],
        wind: 0,
        wind_raw: [0; 1],
        poison: 0,
        poison_raw: [0; 1],
        saint: 0,
        saint_raw: [0; 1],
        dark: 0,
        dark_raw: [0; 1],
        mental: 0,
        mental_raw: [0; 1],
        undead: 0,
        undead_raw: [0; 1],
        }
    }
}

impl MakableitemInfo {
    pub fn from(buffer: &[u8]) -> MakableitemInfo {
        MakableitemInfo {
            raw: buffer.to_vec(),
            itid: u16::from_le_bytes([buffer[0], buffer[1]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            material_id:  {
                let mut dst: [u16; 3] = [0 as u16; 3];
                for (index, byte) in buffer[2..5].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            },
            material_id_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[2..5]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.material_id {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.material_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.material_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_material_id(&mut self, value: [u16; 3]) {
        self.material_id = value;
    }
    pub fn set_material_id_raw(&mut self, value: [u8; 3]) {
        self.material_id_raw = value;
    }
    pub fn new() -> MakableitemInfo {
        MakableitemInfo {
        raw: vec![],
        itid: 0,
        itid_raw: [0; 2],
        material_id: [0; 3],
        material_id_raw: [0; 3],
        }
    }
}

impl PeteggitemInfo {
    pub fn from(buffer: &[u8]) -> PeteggitemInfo {
        PeteggitemInfo {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn new() -> PeteggitemInfo {
        PeteggitemInfo {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        }
    }
}

impl ArrowitemInfo {
    pub fn from(buffer: &[u8]) -> ArrowitemInfo {
        ArrowitemInfo {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn new() -> ArrowitemInfo {
        ArrowitemInfo {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        }
    }
}

impl NormalitemExtrainfo2 {
    pub fn from(buffer: &[u8]) -> NormalitemExtrainfo2 {
        NormalitemExtrainfo2 {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: u8::from_le_bytes([buffer[4]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            is_identified: buffer[5] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            count: i16::from_le_bytes([buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            wear_state: u16::from_le_bytes([buffer[8], buffer[9]]),
            wear_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[10..18]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[10..18]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_state).unwrap();
        self.wear_state_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.wear_state_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_wear_state(&mut self, value: u16) {
        self.wear_state = value;
    }
    pub fn set_wear_state_raw(&mut self, value: [u8; 2]) {
        self.wear_state_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new() -> NormalitemExtrainfo2 {
        NormalitemExtrainfo2 {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        is_identified: false,
        is_identified_raw: [0; 1],
        count: 0,
        count_raw: [0; 2],
        wear_state: 0,
        wear_state_raw: [0; 2],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        }
    }
}

impl RepairitemInfo {
    pub fn from(buffer: &[u8]) -> RepairitemInfo {
        RepairitemInfo {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[4]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[5..13]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[5..13]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new() -> RepairitemInfo {
        RepairitemInfo {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        }
    }
}

impl StructFriend {
    pub fn from(buffer: &[u8]) -> StructFriend {
        StructFriend {
            raw: buffer.to_vec(),
            aid: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            gid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[8..32].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[8..32]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new() -> StructFriend {
        StructFriend {
        raw: vec![],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl TagCharacterBlockInfo {
    pub fn from(buffer: &[u8]) -> TagCharacterBlockInfo {
        TagCharacterBlockInfo {
            raw: buffer.to_vec(),
            gid: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            sz_expire_date:  {
                let mut dst: [char; 20] = [0 as char; 20];
                for (index, byte) in buffer[4..24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            sz_expire_date_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[4..24]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_expire_date {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_expire_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.sz_expire_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_sz_expire_date(&mut self, value: [char; 20]) {
        self.sz_expire_date = value;
    }
    pub fn set_sz_expire_date_raw(&mut self, value: [u8; 20]) {
        self.sz_expire_date_raw = value;
    }
    pub fn new() -> TagCharacterBlockInfo {
        TagCharacterBlockInfo {
        raw: vec![],
        gid: 0,
        gid_raw: [0; 4],
        sz_expire_date: [0 as char; 20],
        sz_expire_date_raw: [0; 20],
        }
    }
}

impl PVPINFO {
    pub fn from(buffer: &[u8]) -> PVPINFO {
        PVPINFO {
            raw: buffer.to_vec(),
            win_point: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            win_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            lose_point: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            lose_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            point: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.win_point).unwrap();
        self.win_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.lose_point).unwrap();
        self.lose_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.win_point_raw.to_vec());
        wtr.append(&mut self.lose_point_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_win_point(&mut self, value: i32) {
        self.win_point = value;
    }
    pub fn set_win_point_raw(&mut self, value: [u8; 4]) {
        self.win_point_raw = value;
    }
    pub fn set_lose_point(&mut self, value: i32) {
        self.lose_point = value;
    }
    pub fn set_lose_point_raw(&mut self, value: [u8; 4]) {
        self.lose_point_raw = value;
    }
    pub fn set_point(&mut self, value: i32) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 4]) {
        self.point_raw = value;
    }
    pub fn new() -> PVPINFO {
        PVPINFO {
        raw: vec![],
        win_point: 0,
        win_point_raw: [0; 4],
        lose_point: 0,
        lose_point_raw: [0; 4],
        point: 0,
        point_raw: [0; 4],
        }
    }
}

impl Filetime {
    pub fn from(buffer: &[u8]) -> Filetime {
        Filetime {
            raw: buffer.to_vec(),
            dw_low_date_time: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            dw_low_date_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            dw_high_date_time: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            dw_high_date_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_low_date_time).unwrap();
        self.dw_low_date_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_high_date_time).unwrap();
        self.dw_high_date_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.dw_low_date_time_raw.to_vec());
        wtr.append(&mut self.dw_high_date_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_dw_low_date_time(&mut self, value: u32) {
        self.dw_low_date_time = value;
    }
    pub fn set_dw_low_date_time_raw(&mut self, value: [u8; 4]) {
        self.dw_low_date_time_raw = value;
    }
    pub fn set_dw_high_date_time(&mut self, value: u32) {
        self.dw_high_date_time = value;
    }
    pub fn set_dw_high_date_time_raw(&mut self, value: [u8; 4]) {
        self.dw_high_date_time_raw = value;
    }
    pub fn new() -> Filetime {
        Filetime {
        raw: vec![],
        dw_low_date_time: 0,
        dw_low_date_time_raw: [0; 4],
        dw_high_date_time: 0,
        dw_high_date_time_raw: [0; 4],
        }
    }
}

impl MailList {
    pub fn from(buffer: &[u8]) -> MailList {
        MailList {
            raw: buffer.to_vec(),
            mail_id: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            header:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[4..44].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            header_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[4..44]);
                dst
            },
            is_open: i8::from_le_bytes([buffer[44]]),
            is_open_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[44..45]);
                dst
            },
            from_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[45..69].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            from_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[45..69]);
                dst
            },
            delete_time: i32::from_le_bytes([buffer[69], buffer[70], buffer[71], buffer[72]]),
            delete_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[69..73]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.header {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.header_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.is_open).unwrap();
        self.is_open_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.from_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.from_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.delete_time).unwrap();
        self.delete_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.mail_id_raw.to_vec());
        wtr.append(&mut self.header_raw.to_vec());
        wtr.append(&mut self.is_open_raw.to_vec());
        wtr.append(&mut self.from_name_raw.to_vec());
        wtr.append(&mut self.delete_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_mail_id(&mut self, value: u32) {
        self.mail_id = value;
    }
    pub fn set_mail_id_raw(&mut self, value: [u8; 4]) {
        self.mail_id_raw = value;
    }
    pub fn set_header(&mut self, value: [char; 40]) {
        self.header = value;
    }
    pub fn set_header_raw(&mut self, value: [u8; 40]) {
        self.header_raw = value;
    }
    pub fn set_is_open(&mut self, value: i8) {
        self.is_open = value;
    }
    pub fn set_is_open_raw(&mut self, value: [u8; 1]) {
        self.is_open_raw = value;
    }
    pub fn set_from_name(&mut self, value: [char; 24]) {
        self.from_name = value;
    }
    pub fn set_from_name_raw(&mut self, value: [u8; 24]) {
        self.from_name_raw = value;
    }
    pub fn set_delete_time(&mut self, value: i32) {
        self.delete_time = value;
    }
    pub fn set_delete_time_raw(&mut self, value: [u8; 4]) {
        self.delete_time_raw = value;
    }
    pub fn new() -> MailList {
        MailList {
        raw: vec![],
        mail_id: 0,
        mail_id_raw: [0; 4],
        header: [0 as char; 40],
        header_raw: [0; 40],
        is_open: 0,
        is_open_raw: [0; 1],
        from_name: [0 as char; 24],
        from_name_raw: [0; 24],
        delete_time: 0,
        delete_time_raw: [0; 4],
        }
    }
}

impl AuctionItemSearchInfo {
    pub fn from(buffer: &[u8]) -> AuctionItemSearchInfo {
        AuctionItemSearchInfo {
            raw: buffer.to_vec(),
            auction_id: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            auction_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            seller_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            seller_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
            itid: u16::from_le_bytes([buffer[28], buffer[29]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            atype: i32::from_le_bytes([buffer[30], buffer[31], buffer[32], buffer[33]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[30..34]);
                dst
            },
            count: i16::from_le_bytes([buffer[34], buffer[35]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            is_identified: buffer[36] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[36..37]);
                dst
            },
            is_damaged: buffer[37] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[37..38]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[38]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[38..39]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[39..47]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[39..47]);
                dst
            },
            now_price: i32::from_le_bytes([buffer[47], buffer[48], buffer[49], buffer[50]]),
            now_price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[47..51]);
                dst
            },
            max_price: i32::from_le_bytes([buffer[51], buffer[52], buffer[53], buffer[54]]),
            max_price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[51..55]);
                dst
            },
            buyer_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[55..79].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            buyer_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[55..79]);
                dst
            },
            delete_time: i32::from_le_bytes([buffer[79], buffer[80], buffer[81], buffer[82]]),
            delete_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[79..83]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.auction_id).unwrap();
        self.auction_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.seller_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.seller_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.now_price).unwrap();
        self.now_price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_price).unwrap();
        self.max_price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.buyer_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.buyer_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.delete_time).unwrap();
        self.delete_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.auction_id_raw.to_vec());
        wtr.append(&mut self.seller_name_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        wtr.append(&mut self.now_price_raw.to_vec());
        wtr.append(&mut self.max_price_raw.to_vec());
        wtr.append(&mut self.buyer_name_raw.to_vec());
        wtr.append(&mut self.delete_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_auction_id(&mut self, value: u32) {
        self.auction_id = value;
    }
    pub fn set_auction_id_raw(&mut self, value: [u8; 4]) {
        self.auction_id_raw = value;
    }
    pub fn set_seller_name(&mut self, value: [char; 24]) {
        self.seller_name = value;
    }
    pub fn set_seller_name_raw(&mut self, value: [u8; 24]) {
        self.seller_name_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn set_now_price(&mut self, value: i32) {
        self.now_price = value;
    }
    pub fn set_now_price_raw(&mut self, value: [u8; 4]) {
        self.now_price_raw = value;
    }
    pub fn set_max_price(&mut self, value: i32) {
        self.max_price = value;
    }
    pub fn set_max_price_raw(&mut self, value: [u8; 4]) {
        self.max_price_raw = value;
    }
    pub fn set_buyer_name(&mut self, value: [char; 24]) {
        self.buyer_name = value;
    }
    pub fn set_buyer_name_raw(&mut self, value: [u8; 24]) {
        self.buyer_name_raw = value;
    }
    pub fn set_delete_time(&mut self, value: i32) {
        self.delete_time = value;
    }
    pub fn set_delete_time_raw(&mut self, value: [u8; 4]) {
        self.delete_time_raw = value;
    }
    pub fn new() -> AuctionItemSearchInfo {
        AuctionItemSearchInfo {
        raw: vec![],
        auction_id: 0,
        auction_id_raw: [0; 4],
        seller_name: [0 as char; 24],
        seller_name_raw: [0; 24],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 4],
        count: 0,
        count_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        now_price: 0,
        now_price_raw: [0; 4],
        max_price: 0,
        max_price_raw: [0; 4],
        buyer_name: [0 as char; 24],
        buyer_name_raw: [0; 24],
        delete_time: 0,
        delete_time_raw: [0; 4],
        }
    }
}

impl PacketMobHunting {
    pub fn from(buffer: &[u8]) -> PacketMobHunting {
        PacketMobHunting {
            raw: buffer.to_vec(),
            quest_id: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            mob_gid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            mob_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            max_count: i16::from_le_bytes([buffer[8], buffer[9]]),
            max_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            count: i16::from_le_bytes([buffer[10], buffer[11]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.mob_gid).unwrap();
        self.mob_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_count).unwrap();
        self.max_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.quest_id_raw.to_vec());
        wtr.append(&mut self.mob_gid_raw.to_vec());
        wtr.append(&mut self.max_count_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_quest_id(&mut self, value: u32) {
        self.quest_id = value;
    }
    pub fn set_quest_id_raw(&mut self, value: [u8; 4]) {
        self.quest_id_raw = value;
    }
    pub fn set_mob_gid(&mut self, value: u32) {
        self.mob_gid = value;
    }
    pub fn set_mob_gid_raw(&mut self, value: [u8; 4]) {
        self.mob_gid_raw = value;
    }
    pub fn set_max_count(&mut self, value: i16) {
        self.max_count = value;
    }
    pub fn set_max_count_raw(&mut self, value: [u8; 2]) {
        self.max_count_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new() -> PacketMobHunting {
        PacketMobHunting {
        raw: vec![],
        quest_id: 0,
        quest_id_raw: [0; 4],
        mob_gid: 0,
        mob_gid_raw: [0; 4],
        max_count: 0,
        max_count_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl EquipmentitemExtrainfo2 {
    pub fn from(buffer: &[u8]) -> EquipmentitemExtrainfo2 {
        EquipmentitemExtrainfo2 {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: u8::from_le_bytes([buffer[4]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            is_identified: buffer[5] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            location: u16::from_le_bytes([buffer[6], buffer[7]]),
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            wear_state: u16::from_le_bytes([buffer[8], buffer[9]]),
            wear_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            is_damaged: buffer[10] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[11]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[12..20]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[12..20]);
                dst
            },
            hire_expire_date: i32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            hire_expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_state).unwrap();
        self.wear_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hire_expire_date).unwrap();
        self.hire_expire_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.location_raw.to_vec());
        wtr.append(&mut self.wear_state_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        wtr.append(&mut self.hire_expire_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_location(&mut self, value: u16) {
        self.location = value;
    }
    pub fn set_location_raw(&mut self, value: [u8; 2]) {
        self.location_raw = value;
    }
    pub fn set_wear_state(&mut self, value: u16) {
        self.wear_state = value;
    }
    pub fn set_wear_state_raw(&mut self, value: [u8; 2]) {
        self.wear_state_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn set_hire_expire_date(&mut self, value: i32) {
        self.hire_expire_date = value;
    }
    pub fn set_hire_expire_date_raw(&mut self, value: [u8; 4]) {
        self.hire_expire_date_raw = value;
    }
    pub fn new() -> EquipmentitemExtrainfo2 {
        EquipmentitemExtrainfo2 {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        is_identified: false,
        is_identified_raw: [0; 1],
        location: 0,
        location_raw: [0; 2],
        wear_state: 0,
        wear_state_raw: [0; 2],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        hire_expire_date: 0,
        hire_expire_date_raw: [0; 4],
        }
    }
}

impl PggLingoKeyTemp {
    pub fn from(buffer: &[u8]) -> PggLingoKeyTemp {
        PggLingoKeyTemp {
            raw: buffer.to_vec(),
            dw_alg_num: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            dw_alg_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            dw_alg_key1: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            dw_alg_key1_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            dw_alg_key2: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            dw_alg_key2_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            dw_seed: u32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            dw_seed_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_alg_num).unwrap();
        self.dw_alg_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_alg_key1).unwrap();
        self.dw_alg_key1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_alg_key2).unwrap();
        self.dw_alg_key2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_seed).unwrap();
        self.dw_seed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.dw_alg_num_raw.to_vec());
        wtr.append(&mut self.dw_alg_key1_raw.to_vec());
        wtr.append(&mut self.dw_alg_key2_raw.to_vec());
        wtr.append(&mut self.dw_seed_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_dw_alg_num(&mut self, value: u32) {
        self.dw_alg_num = value;
    }
    pub fn set_dw_alg_num_raw(&mut self, value: [u8; 4]) {
        self.dw_alg_num_raw = value;
    }
    pub fn set_dw_alg_key1(&mut self, value: u32) {
        self.dw_alg_key1 = value;
    }
    pub fn set_dw_alg_key1_raw(&mut self, value: [u8; 4]) {
        self.dw_alg_key1_raw = value;
    }
    pub fn set_dw_alg_key2(&mut self, value: u32) {
        self.dw_alg_key2 = value;
    }
    pub fn set_dw_alg_key2_raw(&mut self, value: [u8; 4]) {
        self.dw_alg_key2_raw = value;
    }
    pub fn set_dw_seed(&mut self, value: u32) {
        self.dw_seed = value;
    }
    pub fn set_dw_seed_raw(&mut self, value: [u8; 4]) {
        self.dw_seed_raw = value;
    }
    pub fn new() -> PggLingoKeyTemp {
        PggLingoKeyTemp {
        raw: vec![],
        dw_alg_num: 0,
        dw_alg_num_raw: [0; 4],
        dw_alg_key1: 0,
        dw_alg_key1_raw: [0; 4],
        dw_alg_key2: 0,
        dw_alg_key2_raw: [0; 4],
        dw_seed: 0,
        dw_seed_raw: [0; 4],
        }
    }
}

impl PacketZcQuestInfo {
    pub fn from(buffer: &[u8]) -> PacketZcQuestInfo {
        PacketZcQuestInfo {
            raw: buffer.to_vec(),
            quest_id: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            active: buffer[4] == 1,
            active_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.active as u8).unwrap();
        self.active_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.quest_id_raw.to_vec());
        wtr.append(&mut self.active_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_quest_id(&mut self, value: u32) {
        self.quest_id = value;
    }
    pub fn set_quest_id_raw(&mut self, value: [u8; 4]) {
        self.quest_id_raw = value;
    }
    pub fn set_active(&mut self, value: bool) {
        self.active = value;
    }
    pub fn set_active_raw(&mut self, value: [u8; 1]) {
        self.active_raw = value;
    }
    pub fn new() -> PacketZcQuestInfo {
        PacketZcQuestInfo {
        raw: vec![],
        quest_id: 0,
        quest_id_raw: [0; 4],
        active: false,
        active_raw: [0; 1],
        }
    }
}

impl PacketZcMissionHunt {
    pub fn from(buffer: &[u8]) -> PacketZcMissionHunt {
        PacketZcMissionHunt {
            raw: buffer.to_vec(),
            mob_gid: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            mob_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            hunt_count: i16::from_le_bytes([buffer[4], buffer[5]]),
            hunt_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            mob_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            mob_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.mob_gid).unwrap();
        self.mob_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hunt_count).unwrap();
        self.hunt_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mob_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mob_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.mob_gid_raw.to_vec());
        wtr.append(&mut self.hunt_count_raw.to_vec());
        wtr.append(&mut self.mob_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_mob_gid(&mut self, value: u32) {
        self.mob_gid = value;
    }
    pub fn set_mob_gid_raw(&mut self, value: [u8; 4]) {
        self.mob_gid_raw = value;
    }
    pub fn set_hunt_count(&mut self, value: i16) {
        self.hunt_count = value;
    }
    pub fn set_hunt_count_raw(&mut self, value: [u8; 2]) {
        self.hunt_count_raw = value;
    }
    pub fn set_mob_name(&mut self, value: [char; 24]) {
        self.mob_name = value;
    }
    pub fn set_mob_name_raw(&mut self, value: [u8; 24]) {
        self.mob_name_raw = value;
    }
    pub fn new() -> PacketZcMissionHunt {
        PacketZcMissionHunt {
        raw: vec![],
        mob_gid: 0,
        mob_gid_raw: [0; 4],
        hunt_count: 0,
        hunt_count_raw: [0; 2],
        mob_name: [0 as char; 24],
        mob_name_raw: [0; 24],
        }
    }
}

impl PacketZcQuestMissionInfo {
    pub fn from(buffer: &[u8]) -> PacketZcQuestMissionInfo {
        let iter_count = (&buffer.len() - 14) / 30;
        let mut vec_field: Vec<PacketZcMissionHunt> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 14 + (30 * (i - 1));
            let end_pos = 14 + 30 * i;
            vec_field.push(PacketZcMissionHunt::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcQuestMissionInfo {
            raw: buffer.to_vec(),
            quest_id: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            quest_svr_time: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            quest_svr_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            quest_end_time: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            quest_end_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            count: i16::from_le_bytes([buffer[12], buffer[13]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            hunt: vec_field.clone(),
            hunt_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.quest_svr_time).unwrap();
        self.quest_svr_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.quest_end_time).unwrap();
        self.quest_end_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        self.hunt_raw = {
            self.hunt.iter_mut().for_each(|item| item.fill_raw());
            self.hunt.iter().map(|item| item.raw.clone()).collect()
      };

        wtr = vec![];
        wtr.append(&mut self.quest_id_raw.to_vec());
        wtr.append(&mut self.quest_svr_time_raw.to_vec());
        wtr.append(&mut self.quest_end_time_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.hunt.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn set_quest_id(&mut self, value: u32) {
        self.quest_id = value;
    }
    pub fn set_quest_id_raw(&mut self, value: [u8; 4]) {
        self.quest_id_raw = value;
    }
    pub fn set_quest_svr_time(&mut self, value: i32) {
        self.quest_svr_time = value;
    }
    pub fn set_quest_svr_time_raw(&mut self, value: [u8; 4]) {
        self.quest_svr_time_raw = value;
    }
    pub fn set_quest_end_time(&mut self, value: i32) {
        self.quest_end_time = value;
    }
    pub fn set_quest_end_time_raw(&mut self, value: [u8; 4]) {
        self.quest_end_time_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_hunt(&mut self, value: Vec<PacketZcMissionHunt>) {
        self.hunt = value;
    }
    pub fn set_hunt_raw(&mut self, value: Vec<Vec<u8>>) {
        self.hunt_raw = value;
    }
    pub fn new() -> PacketZcQuestMissionInfo {
        PacketZcQuestMissionInfo {
        raw: vec![],
        quest_id: 0,
        quest_id_raw: [0; 4],
        quest_svr_time: 0,
        quest_svr_time_raw: [0; 4],
        quest_end_time: 0,
        quest_end_time_raw: [0; 4],
        count: 0,
        count_raw: [0; 2],
        hunt: vec![],
        hunt_raw: vec![],
        }
    }
}

impl ShortCutKey {
    pub fn from(buffer: &[u8]) -> ShortCutKey {
        ShortCutKey {
            raw: buffer.to_vec(),
            is_skill: i8::from_le_bytes([buffer[0]]),
            is_skill_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[0..1]);
                dst
            },
            id: u32::from_le_bytes([buffer[1], buffer[2], buffer[3], buffer[4]]),
            id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[1..5]);
                dst
            },
            count: i16::from_le_bytes([buffer[5], buffer[6]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[5..7]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i8(self.is_skill).unwrap();
        self.is_skill_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.id).unwrap();
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.is_skill_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_is_skill(&mut self, value: i8) {
        self.is_skill = value;
    }
    pub fn set_is_skill_raw(&mut self, value: [u8; 1]) {
        self.is_skill_raw = value;
    }
    pub fn set_id(&mut self, value: u32) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 4]) {
        self.id_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new() -> ShortCutKey {
        ShortCutKey {
        raw: vec![],
        is_skill: 0,
        is_skill_raw: [0; 1],
        id: 0,
        id_raw: [0; 4],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl EquipmentitemExtrainfo301 {
    pub fn from(buffer: &[u8]) -> EquipmentitemExtrainfo301 {
        EquipmentitemExtrainfo301 {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: u8::from_le_bytes([buffer[4]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            is_identified: buffer[5] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            location: u16::from_le_bytes([buffer[6], buffer[7]]),
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            wear_state: u16::from_le_bytes([buffer[8], buffer[9]]),
            wear_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            is_damaged: buffer[10] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[11]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[12..20]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[12..20]);
                dst
            },
            hire_expire_date: i32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            hire_expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
            bind_on_equip_type: u16::from_le_bytes([buffer[24], buffer[25]]),
            bind_on_equip_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            w_item_sprite_number: u16::from_le_bytes([buffer[26], buffer[27]]),
            w_item_sprite_number_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_state).unwrap();
        self.wear_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hire_expire_date).unwrap();
        self.hire_expire_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.bind_on_equip_type).unwrap();
        self.bind_on_equip_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.w_item_sprite_number).unwrap();
        self.w_item_sprite_number_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.location_raw.to_vec());
        wtr.append(&mut self.wear_state_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        wtr.append(&mut self.hire_expire_date_raw.to_vec());
        wtr.append(&mut self.bind_on_equip_type_raw.to_vec());
        wtr.append(&mut self.w_item_sprite_number_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_location(&mut self, value: u16) {
        self.location = value;
    }
    pub fn set_location_raw(&mut self, value: [u8; 2]) {
        self.location_raw = value;
    }
    pub fn set_wear_state(&mut self, value: u16) {
        self.wear_state = value;
    }
    pub fn set_wear_state_raw(&mut self, value: [u8; 2]) {
        self.wear_state_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn set_hire_expire_date(&mut self, value: i32) {
        self.hire_expire_date = value;
    }
    pub fn set_hire_expire_date_raw(&mut self, value: [u8; 4]) {
        self.hire_expire_date_raw = value;
    }
    pub fn set_bind_on_equip_type(&mut self, value: u16) {
        self.bind_on_equip_type = value;
    }
    pub fn set_bind_on_equip_type_raw(&mut self, value: [u8; 2]) {
        self.bind_on_equip_type_raw = value;
    }
    pub fn set_w_item_sprite_number(&mut self, value: u16) {
        self.w_item_sprite_number = value;
    }
    pub fn set_w_item_sprite_number_raw(&mut self, value: [u8; 2]) {
        self.w_item_sprite_number_raw = value;
    }
    pub fn new() -> EquipmentitemExtrainfo301 {
        EquipmentitemExtrainfo301 {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        is_identified: false,
        is_identified_raw: [0; 1],
        location: 0,
        location_raw: [0; 2],
        wear_state: 0,
        wear_state_raw: [0; 2],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        hire_expire_date: 0,
        hire_expire_date_raw: [0; 4],
        bind_on_equip_type: 0,
        bind_on_equip_type_raw: [0; 2],
        w_item_sprite_number: 0,
        w_item_sprite_number_raw: [0; 2],
        }
    }
}

impl NormalitemExtrainfo3 {
    pub fn from(buffer: &[u8]) -> NormalitemExtrainfo3 {
        NormalitemExtrainfo3 {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: u8::from_le_bytes([buffer[4]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            is_identified: buffer[5] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            count: i16::from_le_bytes([buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            wear_state: u16::from_le_bytes([buffer[8], buffer[9]]),
            wear_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[10..18]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[10..18]);
                dst
            },
            hire_expire_date: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            hire_expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_state).unwrap();
        self.wear_state_raw = wtr.try_into().unwrap();
        self.slot.fill_raw();
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hire_expire_date).unwrap();
        self.hire_expire_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.wear_state_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        wtr.append(&mut self.hire_expire_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_wear_state(&mut self, value: u16) {
        self.wear_state = value;
    }
    pub fn set_wear_state_raw(&mut self, value: [u8; 2]) {
        self.wear_state_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn set_hire_expire_date(&mut self, value: i32) {
        self.hire_expire_date = value;
    }
    pub fn set_hire_expire_date_raw(&mut self, value: [u8; 4]) {
        self.hire_expire_date_raw = value;
    }
    pub fn new() -> NormalitemExtrainfo3 {
        NormalitemExtrainfo3 {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        is_identified: false,
        is_identified_raw: [0; 1],
        count: 0,
        count_raw: [0; 2],
        wear_state: 0,
        wear_state_raw: [0; 2],
        slot: EQUIPSLOTINFO::new(),
        slot_raw: [0; 8],
        hire_expire_date: 0,
        hire_expire_date_raw: [0; 4],
        }
    }
}

impl SkillPostdelay {
    pub fn from(buffer: &[u8]) -> SkillPostdelay {
        SkillPostdelay {
            raw: buffer.to_vec(),
            skid: u16::from_le_bytes([buffer[0], buffer[1]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            delay_tm: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            delay_tm_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.delay_tm).unwrap();
        self.delay_tm_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.delay_tm_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_delay_tm(&mut self, value: u32) {
        self.delay_tm = value;
    }
    pub fn set_delay_tm_raw(&mut self, value: [u8; 4]) {
        self.delay_tm_raw = value;
    }
    pub fn new() -> SkillPostdelay {
        SkillPostdelay {
        raw: vec![],
        skid: 0,
        skid_raw: [0; 2],
        delay_tm: 0,
        delay_tm_raw: [0; 4],
        }
    }
}

impl CharacterList {
    pub fn from(buffer: &[u8]) -> CharacterList {
        CharacterList {
            raw: buffer.to_vec(),
            dw_gid: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            dw_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            slot_idx: u8::from_le_bytes([buffer[4]]),
            slot_idx_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_gid).unwrap();
        self.dw_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.slot_idx).unwrap();
        self.slot_idx_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.dw_gid_raw.to_vec());
        wtr.append(&mut self.slot_idx_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_dw_gid(&mut self, value: u32) {
        self.dw_gid = value;
    }
    pub fn set_dw_gid_raw(&mut self, value: [u8; 4]) {
        self.dw_gid_raw = value;
    }
    pub fn set_slot_idx(&mut self, value: u8) {
        self.slot_idx = value;
    }
    pub fn set_slot_idx_raw(&mut self, value: [u8; 1]) {
        self.slot_idx_raw = value;
    }
    pub fn new() -> CharacterList {
        CharacterList {
        raw: vec![],
        dw_gid: 0,
        dw_gid_raw: [0; 4],
        slot_idx: 0,
        slot_idx_raw: [0; 1],
        }
    }
}

impl BattleFieldInfo {
    pub fn from(buffer: &[u8]) -> BattleFieldInfo {
        BattleFieldInfo {
            raw: buffer.to_vec(),
            bfno: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            battle_field_name:  {
                let mut dst: [char; 56] = [0 as char; 56];
                for (index, byte) in buffer[4..60].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            battle_field_name_raw: {
                let mut dst: [u8; 56] = [0u8; 56];
                dst.clone_from_slice(&buffer[4..60]);
                dst
            },
            join_team: i16::from_le_bytes([buffer[60], buffer[61]]),
            join_team_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[60..62]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.battle_field_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.battle_field_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.join_team).unwrap();
        self.join_team_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.bfno_raw.to_vec());
        wtr.append(&mut self.battle_field_name_raw.to_vec());
        wtr.append(&mut self.join_team_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_bfno(&mut self, value: u32) {
        self.bfno = value;
    }
    pub fn set_bfno_raw(&mut self, value: [u8; 4]) {
        self.bfno_raw = value;
    }
    pub fn set_battle_field_name(&mut self, value: [char; 56]) {
        self.battle_field_name = value;
    }
    pub fn set_battle_field_name_raw(&mut self, value: [u8; 56]) {
        self.battle_field_name_raw = value;
    }
    pub fn set_join_team(&mut self, value: i16) {
        self.join_team = value;
    }
    pub fn set_join_team_raw(&mut self, value: [u8; 2]) {
        self.join_team_raw = value;
    }
    pub fn new() -> BattleFieldInfo {
        BattleFieldInfo {
        raw: vec![],
        bfno: 0,
        bfno_raw: [0; 4],
        battle_field_name: [0 as char; 56],
        battle_field_name_raw: [0; 56],
        join_team: 0,
        join_team_raw: [0; 2],
        }
    }
}

impl PartyBookingDetail {
    pub fn from(buffer: &[u8]) -> PartyBookingDetail {
        PartyBookingDetail {
            raw: buffer.to_vec(),
            level: i16::from_le_bytes([buffer[0], buffer[1]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            map_id: i16::from_le_bytes([buffer[2], buffer[3]]),
            map_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            job:  {
                let mut dst: [i16; 6] = [0 as i16; 6];
                for (index, byte) in buffer[4..10].iter().enumerate() {
                    dst[index] = *byte as i16;
                }
                dst
            },
            job_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[4..10]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.map_id).unwrap();
        self.map_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.job {
            wtr.write_i16::<LittleEndian>(item).unwrap();
        }
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.map_id_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_map_id(&mut self, value: i16) {
        self.map_id = value;
    }
    pub fn set_map_id_raw(&mut self, value: [u8; 2]) {
        self.map_id_raw = value;
    }
    pub fn set_job(&mut self, value: [i16; 6]) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 6]) {
        self.job_raw = value;
    }
    pub fn new() -> PartyBookingDetail {
        PartyBookingDetail {
        raw: vec![],
        level: 0,
        level_raw: [0; 2],
        map_id: 0,
        map_id_raw: [0; 2],
        job: [0; 6],
        job_raw: [0; 6],
        }
    }
}

impl PartyBookingAdInfo {
    pub fn from(buffer: &[u8]) -> PartyBookingAdInfo {
        PartyBookingAdInfo {
            raw: buffer.to_vec(),
            index: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            char_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
            expire_time: i32::from_le_bytes([buffer[28], buffer[29], buffer[30], buffer[31]]),
            expire_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[28..32]);
                dst
            },
            detail: PartyBookingDetail::from(&buffer[32..buffer.len()]),
            detail_raw: buffer[32..buffer.len()].to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.expire_time).unwrap();
        self.expire_time_raw = wtr.try_into().unwrap();
        self.detail.fill_raw();
        self.detail_raw = self.detail.clone().raw;

        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.char_name_raw.to_vec());
        wtr.append(&mut self.expire_time_raw.to_vec());
        wtr.append(&mut self.detail_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_index(&mut self, value: u32) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 4]) {
        self.index_raw = value;
    }
    pub fn set_char_name(&mut self, value: [char; 24]) {
        self.char_name = value;
    }
    pub fn set_char_name_raw(&mut self, value: [u8; 24]) {
        self.char_name_raw = value;
    }
    pub fn set_expire_time(&mut self, value: i32) {
        self.expire_time = value;
    }
    pub fn set_expire_time_raw(&mut self, value: [u8; 4]) {
        self.expire_time_raw = value;
    }
    pub fn set_detail(&mut self, value: PartyBookingDetail) {
        self.detail = value;
    }
    pub fn set_detail_raw(&mut self, value: Vec<u8>) {
        self.detail_raw = value;
    }
    pub fn new() -> PartyBookingAdInfo {
        PartyBookingAdInfo {
        raw: vec![],
        index: 0,
        index_raw: [0; 4],
        char_name: [0 as char; 24],
        char_name_raw: [0; 24],
        expire_time: 0,
        expire_time_raw: [0; 4],
        detail: PartyBookingDetail::new(),
        detail_raw: vec![],
        }
    }
}

impl ProductinfoInBuyingStore {
    pub fn from(buffer: &[u8]) -> ProductinfoInBuyingStore {
        ProductinfoInBuyingStore {
            raw: buffer.to_vec(),
            itid: u16::from_le_bytes([buffer[0], buffer[1]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            count: i16::from_le_bytes([buffer[2], buffer[3]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            price: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.price_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_price(&mut self, value: i32) {
        self.price = value;
    }
    pub fn set_price_raw(&mut self, value: [u8; 4]) {
        self.price_raw = value;
    }
    pub fn new() -> ProductinfoInBuyingStore {
        ProductinfoInBuyingStore {
        raw: vec![],
        itid: 0,
        itid_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        price: 0,
        price_raw: [0; 4],
        }
    }
}

impl BuyingStoreItemlist {
    pub fn from(buffer: &[u8]) -> BuyingStoreItemlist {
        BuyingStoreItemlist {
            raw: buffer.to_vec(),
            price: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            itid: u16::from_le_bytes([buffer[7], buffer[8]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[7..9]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.price_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_price(&mut self, value: i32) {
        self.price = value;
    }
    pub fn set_price_raw(&mut self, value: [u8; 4]) {
        self.price_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new() -> BuyingStoreItemlist {
        BuyingStoreItemlist {
        raw: vec![],
        price: 0,
        price_raw: [0; 4],
        count: 0,
        count_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl TradeItemBuyingStore {
    pub fn from(buffer: &[u8]) -> TradeItemBuyingStore {
        TradeItemBuyingStore {
            raw: buffer.to_vec(),
            index: u16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new() -> TradeItemBuyingStore {
        TradeItemBuyingStore {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl ResultItemInfo {
    pub fn from(buffer: &[u8]) -> ResultItemInfo {
        ResultItemInfo {
            raw: buffer.to_vec(),
            ssiid: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            ssiid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            store_name:  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[8..88].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            store_name_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[8..88]);
                dst
            },
            itid: u16::from_le_bytes([buffer[88], buffer[89]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[88..90]);
                dst
            },
            item_type: u8::from_le_bytes([buffer[90]]),
            item_type_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[90..91]);
                dst
            },
            price: i32::from_le_bytes([buffer[91], buffer[92], buffer[93], buffer[94]]),
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[91..95]);
                dst
            },
            count: u16::from_le_bytes([buffer[95], buffer[96]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[95..97]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[97]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[97..98]);
                dst
            },
            card1: u16::from_le_bytes([buffer[98], buffer[99]]),
            card1_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[98..100]);
                dst
            },
            card2: u16::from_le_bytes([buffer[100], buffer[101]]),
            card2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[100..102]);
                dst
            },
            card3: u16::from_le_bytes([buffer[102], buffer[103]]),
            card3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[102..104]);
                dst
            },
            card4: u16::from_le_bytes([buffer[104], buffer[105]]),
            card4_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[104..106]);
                dst
            },
        }
    }
    pub fn fill_raw(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.ssiid).unwrap();
        self.ssiid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.store_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.store_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_type).unwrap();
        self.item_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card1).unwrap();
        self.card1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card2).unwrap();
        self.card2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card3).unwrap();
        self.card3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card4).unwrap();
        self.card4_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.append(&mut self.ssiid_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.store_name_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.item_type_raw.to_vec());
        wtr.append(&mut self.price_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.card1_raw.to_vec());
        wtr.append(&mut self.card2_raw.to_vec());
        wtr.append(&mut self.card3_raw.to_vec());
        wtr.append(&mut self.card4_raw.to_vec());
        self.raw = wtr;
    }
    pub fn set_ssiid(&mut self, value: u32) {
        self.ssiid = value;
    }
    pub fn set_ssiid_raw(&mut self, value: [u8; 4]) {
        self.ssiid_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_store_name(&mut self, value: [char; 80]) {
        self.store_name = value;
    }
    pub fn set_store_name_raw(&mut self, value: [u8; 80]) {
        self.store_name_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_item_type(&mut self, value: u8) {
        self.item_type = value;
    }
    pub fn set_item_type_raw(&mut self, value: [u8; 1]) {
        self.item_type_raw = value;
    }
    pub fn set_price(&mut self, value: i32) {
        self.price = value;
    }
    pub fn set_price_raw(&mut self, value: [u8; 4]) {
        self.price_raw = value;
    }
    pub fn set_count(&mut self, value: u16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_card1(&mut self, value: u16) {
        self.card1 = value;
    }
    pub fn set_card1_raw(&mut self, value: [u8; 2]) {
        self.card1_raw = value;
    }
    pub fn set_card2(&mut self, value: u16) {
        self.card2 = value;
    }
    pub fn set_card2_raw(&mut self, value: [u8; 2]) {
        self.card2_raw = value;
    }
    pub fn set_card3(&mut self, value: u16) {
        self.card3 = value;
    }
    pub fn set_card3_raw(&mut self, value: [u8; 2]) {
        self.card3_raw = value;
    }
    pub fn set_card4(&mut self, value: u16) {
        self.card4 = value;
    }
    pub fn set_card4_raw(&mut self, value: [u8; 2]) {
        self.card4_raw = value;
    }
    pub fn new() -> ResultItemInfo {
        ResultItemInfo {
        raw: vec![],
        ssiid: 0,
        ssiid_raw: [0; 4],
        aid: 0,
        aid_raw: [0; 4],
        store_name: [0 as char; 80],
        store_name_raw: [0; 80],
        itid: 0,
        itid_raw: [0; 2],
        item_type: 0,
        item_type_raw: [0; 1],
        price: 0,
        price_raw: [0; 4],
        count: 0,
        count_raw: [0; 2],
        refining_level: 0,
        refining_level_raw: [0; 1],
        card1: 0,
        card1_raw: [0; 2],
        card2: 0,
        card2_raw: [0; 2],
        card3: 0,
        card3_raw: [0; 2],
        card4: 0,
        card4_raw: [0; 2],
        }
    }
}

