// Generated by tools/packets_db/main.rs
// Auto generated file do not edit manually

use std::any::Any;
use byteorder::{LittleEndian,WriteBytesExt};
use std::convert::TryInto;

pub fn parse(buffer: &[u8]) -> Box<dyn Packet> {
    if buffer[0] == 0x64 && buffer[1] == 0x00 {
        return Box::new(PacketCaLogin::from(buffer));
    }
    if buffer[0] == 0x65 && buffer[1] == 0x00 {
        return Box::new(PacketChEnter::from(buffer));
    }
    if buffer[0] == 0x66 && buffer[1] == 0x00 {
        return Box::new(PacketChSelectChar::from(buffer));
    }
    if buffer[0] == 0x67 && buffer[1] == 0x00 {
        return Box::new(PacketChMakeChar::from(buffer));
    }
    if buffer[0] == 0x68 && buffer[1] == 0x00 {
        return Box::new(PacketChDeleteChar::from(buffer));
    }
    if buffer[0] == 0x69 && buffer[1] == 0x00 {
        return Box::new(PacketAcAcceptLogin::from(buffer));
    }
    if buffer[0] == 0xc4 && buffer[1] == 0x0a {
        return Box::new(PacketAcAcceptLogin2::from(buffer));
    }
    if buffer[0] == 0x6a && buffer[1] == 0x00 {
        return Box::new(PacketAcRefuseLogin::from(buffer));
    }
    if buffer[0] == 0x6b && buffer[1] == 0x00 {
        return Box::new(PacketHcAcceptEnterNeoUnion::from(buffer));
    }
    if buffer[0] == 0x6c && buffer[1] == 0x00 {
        return Box::new(PacketHcRefuseEnter::from(buffer));
    }
    if buffer[0] == 0x6d && buffer[1] == 0x00 {
        return Box::new(PacketHcAcceptMakecharNeoUnion::from(buffer));
    }
    if buffer[0] == 0x6e && buffer[1] == 0x00 {
        return Box::new(PacketHcRefuseMakechar::from(buffer));
    }
    if buffer[0] == 0x6f && buffer[1] == 0x00 {
        return Box::new(PacketHcAcceptDeletechar::from(buffer));
    }
    if buffer[0] == 0x70 && buffer[1] == 0x00 {
        return Box::new(PacketHcRefuseDeletechar::from(buffer));
    }
    if buffer[0] == 0x71 && buffer[1] == 0x00 {
        return Box::new(PacketHcNotifyZonesvr::from(buffer));
    }
    if buffer[0] == 0x72 && buffer[1] == 0x00 {
        return Box::new(PacketCzEnter::from(buffer));
    }
    if buffer[0] == 0x73 && buffer[1] == 0x00 {
        return Box::new(PacketZcAcceptEnter::from(buffer));
    }
    if buffer[0] == 0x74 && buffer[1] == 0x00 {
        return Box::new(PacketZcRefuseEnter::from(buffer));
    }
    if buffer[0] == 0x75 && buffer[1] == 0x00 {
        return Box::new(PacketZcNotifyInitchar::from(buffer));
    }
    if buffer[0] == 0x76 && buffer[1] == 0x00 {
        return Box::new(PacketZcNotifyUpdatechar::from(buffer));
    }
    if buffer[0] == 0x77 && buffer[1] == 0x00 {
        return Box::new(PacketZcNotifyUpdateplayer::from(buffer));
    }
    if buffer[0] == 0x78 && buffer[1] == 0x00 {
        return Box::new(PacketZcNotifyStandentry::from(buffer));
    }
    if buffer[0] == 0x79 && buffer[1] == 0x00 {
        return Box::new(PacketZcNotifyNewentry::from(buffer));
    }
    if buffer[0] == 0x7a && buffer[1] == 0x00 {
        return Box::new(PacketZcNotifyActentry::from(buffer));
    }
    if buffer[0] == 0x7b && buffer[1] == 0x00 {
        return Box::new(PacketZcNotifyMoveentry::from(buffer));
    }
    if buffer[0] == 0x7c && buffer[1] == 0x00 {
        return Box::new(PacketZcNotifyStandentryNpc::from(buffer));
    }
    if buffer[0] == 0x7d && buffer[1] == 0x00 {
        return Box::new(PacketCzNotifyActorinit::from(buffer));
    }
    if buffer[0] == 0x7e && buffer[1] == 0x00 {
        return Box::new(PacketCzRequestTime::from(buffer));
    }
    if buffer[0] == 0x7f && buffer[1] == 0x00 {
        return Box::new(PacketZcNotifyTime::from(buffer));
    }
    if buffer[0] == 0x80 && buffer[1] == 0x00 {
        return Box::new(PacketZcNotifyVanish::from(buffer));
    }
    if buffer[0] == 0x81 && buffer[1] == 0x00 {
        return Box::new(PacketScNotifyBan::from(buffer));
    }
    if buffer[0] == 0x82 && buffer[1] == 0x00 {
        return Box::new(PacketCzRequestQuit::from(buffer));
    }
    if buffer[0] == 0x83 && buffer[1] == 0x00 {
        return Box::new(PacketZcAcceptQuit::from(buffer));
    }
    if buffer[0] == 0x84 && buffer[1] == 0x00 {
        return Box::new(PacketZcRefuseQuit::from(buffer));
    }
    if buffer[0] == 0x85 && buffer[1] == 0x00 {
        return Box::new(PacketCzRequestMove::from(buffer));
    }
    if buffer[0] == 0x86 && buffer[1] == 0x00 {
        return Box::new(PacketZcNotifyMove::from(buffer));
    }
    if buffer[0] == 0x87 && buffer[1] == 0x00 {
        return Box::new(PacketZcNotifyPlayermove::from(buffer));
    }
    if buffer[0] == 0x88 && buffer[1] == 0x00 {
        return Box::new(PacketZcStopmove::from(buffer));
    }
    if buffer[0] == 0x89 && buffer[1] == 0x00 {
        return Box::new(PacketCzRequestAct::from(buffer));
    }
    if buffer[0] == 0x8a && buffer[1] == 0x00 {
        return Box::new(PacketZcNotifyAct::from(buffer));
    }
    if buffer[0] == 0x8b && buffer[1] == 0x00 {
        return Box::new(PacketZcNotifyActPosition::from(buffer));
    }
    if buffer[0] == 0x8c && buffer[1] == 0x00 {
        return Box::new(PacketCzRequestChat::from(buffer));
    }
    if buffer[0] == 0x8d && buffer[1] == 0x00 {
        return Box::new(PacketZcNotifyChat::from(buffer));
    }
    if buffer[0] == 0x8e && buffer[1] == 0x00 {
        return Box::new(PacketZcNotifyPlayerchat::from(buffer));
    }
    if buffer[0] == 0x8f && buffer[1] == 0x00 {
        return Box::new(PacketServerEntryAck::from(buffer));
    }
    if buffer[0] == 0x90 && buffer[1] == 0x00 {
        return Box::new(PacketCzContactnpc::from(buffer));
    }
    if buffer[0] == 0x91 && buffer[1] == 0x00 {
        return Box::new(PacketZcNpcackMapmove::from(buffer));
    }
    if buffer[0] == 0x92 && buffer[1] == 0x00 {
        return Box::new(PacketZcNpcackServermove::from(buffer));
    }
    if buffer[0] == 0x93 && buffer[1] == 0x00 {
        return Box::new(PacketZcNpcackEnable::from(buffer));
    }
    if buffer[0] == 0x94 && buffer[1] == 0x00 {
        return Box::new(PacketCzReqname::from(buffer));
    }
    if buffer[0] == 0x95 && buffer[1] == 0x00 {
        return Box::new(PacketZcAckReqname::from(buffer));
    }
    if buffer[0] == 0x96 && buffer[1] == 0x00 {
        return Box::new(PacketCzWhisper::from(buffer));
    }
    if buffer[0] == 0x97 && buffer[1] == 0x00 {
        return Box::new(PacketZcWhisper::from(buffer));
    }
    if buffer[0] == 0x98 && buffer[1] == 0x00 {
        return Box::new(PacketZcAckWhisper::from(buffer));
    }
    if buffer[0] == 0x99 && buffer[1] == 0x00 {
        return Box::new(PacketCzBroadcast::from(buffer));
    }
    if buffer[0] == 0x9a && buffer[1] == 0x00 {
        return Box::new(PacketZcBroadcast::from(buffer));
    }
    if buffer[0] == 0x9b && buffer[1] == 0x00 {
        return Box::new(PacketCzChangeDirection::from(buffer));
    }
    if buffer[0] == 0x9c && buffer[1] == 0x00 {
        return Box::new(PacketZcChangeDirection::from(buffer));
    }
    if buffer[0] == 0x9d && buffer[1] == 0x00 {
        return Box::new(PacketZcItemEntry::from(buffer));
    }
    if buffer[0] == 0x9e && buffer[1] == 0x00 {
        return Box::new(PacketZcItemFallEntry::from(buffer));
    }
    if buffer[0] == 0x9f && buffer[1] == 0x00 {
        return Box::new(PacketCzItemPickup::from(buffer));
    }
    if buffer[0] == 0xa0 && buffer[1] == 0x00 {
        return Box::new(PacketZcItemPickupAck::from(buffer));
    }
    if buffer[0] == 0xa1 && buffer[1] == 0x00 {
        return Box::new(PacketZcItemDisappear::from(buffer));
    }
    if buffer[0] == 0xa2 && buffer[1] == 0x00 {
        return Box::new(PacketCzItemThrow::from(buffer));
    }
    if buffer[0] == 0xa3 && buffer[1] == 0x00 {
        return Box::new(PacketZcNormalItemlist::from(buffer));
    }
    if buffer[0] == 0xa4 && buffer[1] == 0x00 {
        return Box::new(PacketZcEquipmentItemlist::from(buffer));
    }
    if buffer[0] == 0xa5 && buffer[1] == 0x00 {
        return Box::new(PacketZcStoreNormalItemlist::from(buffer));
    }
    if buffer[0] == 0xa6 && buffer[1] == 0x00 {
        return Box::new(PacketZcStoreEquipmentItemlist::from(buffer));
    }
    if buffer[0] == 0xa7 && buffer[1] == 0x00 {
        return Box::new(PacketCzUseItem::from(buffer));
    }
    if buffer[0] == 0xa8 && buffer[1] == 0x00 {
        return Box::new(PacketZcUseItemAck::from(buffer));
    }
    if buffer[0] == 0xa9 && buffer[1] == 0x00 {
        return Box::new(PacketCzReqWearEquip::from(buffer));
    }
    if buffer[0] == 0xaa && buffer[1] == 0x00 {
        return Box::new(PacketZcReqWearEquipAck::from(buffer));
    }
    if buffer[0] == 0xab && buffer[1] == 0x00 {
        return Box::new(PacketCzReqTakeoffEquip::from(buffer));
    }
    if buffer[0] == 0xac && buffer[1] == 0x00 {
        return Box::new(PacketZcReqTakeoffEquipAck::from(buffer));
    }
    if buffer[0] == 0xaf && buffer[1] == 0x00 {
        return Box::new(PacketZcItemThrowAck::from(buffer));
    }
    if buffer[0] == 0xb0 && buffer[1] == 0x00 {
        return Box::new(PacketZcParChange::from(buffer));
    }
    if buffer[0] == 0xb1 && buffer[1] == 0x00 {
        return Box::new(PacketZcLongparChange::from(buffer));
    }
    if buffer[0] == 0xb2 && buffer[1] == 0x00 {
        return Box::new(PacketCzRestart::from(buffer));
    }
    if buffer[0] == 0xb3 && buffer[1] == 0x00 {
        return Box::new(PacketZcRestartAck::from(buffer));
    }
    if buffer[0] == 0xb4 && buffer[1] == 0x00 {
        return Box::new(PacketZcSayDialog::from(buffer));
    }
    if buffer[0] == 0xb5 && buffer[1] == 0x00 {
        return Box::new(PacketZcWaitDialog::from(buffer));
    }
    if buffer[0] == 0xb6 && buffer[1] == 0x00 {
        return Box::new(PacketZcCloseDialog::from(buffer));
    }
    if buffer[0] == 0xb7 && buffer[1] == 0x00 {
        return Box::new(PacketZcMenuList::from(buffer));
    }
    if buffer[0] == 0xb8 && buffer[1] == 0x00 {
        return Box::new(PacketCzChooseMenu::from(buffer));
    }
    if buffer[0] == 0xb9 && buffer[1] == 0x00 {
        return Box::new(PacketCzReqNextScript::from(buffer));
    }
    if buffer[0] == 0xba && buffer[1] == 0x00 {
        return Box::new(PacketCzReqStatus::from(buffer));
    }
    if buffer[0] == 0xbb && buffer[1] == 0x00 {
        return Box::new(PacketCzStatusChange::from(buffer));
    }
    if buffer[0] == 0xbc && buffer[1] == 0x00 {
        return Box::new(PacketZcStatusChangeAck::from(buffer));
    }
    if buffer[0] == 0xbd && buffer[1] == 0x00 {
        return Box::new(PacketZcStatus::from(buffer));
    }
    if buffer[0] == 0xbe && buffer[1] == 0x00 {
        return Box::new(PacketZcStatusChange::from(buffer));
    }
    if buffer[0] == 0xbf && buffer[1] == 0x00 {
        return Box::new(PacketCzReqEmotion::from(buffer));
    }
    if buffer[0] == 0xc0 && buffer[1] == 0x00 {
        return Box::new(PacketZcEmotion::from(buffer));
    }
    if buffer[0] == 0xc1 && buffer[1] == 0x00 {
        return Box::new(PacketCzReqUserCount::from(buffer));
    }
    if buffer[0] == 0xc2 && buffer[1] == 0x00 {
        return Box::new(PacketZcUserCount::from(buffer));
    }
    if buffer[0] == 0xc3 && buffer[1] == 0x00 {
        return Box::new(PacketZcSpriteChange::from(buffer));
    }
    if buffer[0] == 0xc4 && buffer[1] == 0x00 {
        return Box::new(PacketZcSelectDealtype::from(buffer));
    }
    if buffer[0] == 0xc5 && buffer[1] == 0x00 {
        return Box::new(PacketCzAckSelectDealtype::from(buffer));
    }
    if buffer[0] == 0xc6 && buffer[1] == 0x00 {
        return Box::new(PacketZcPcPurchaseItemlist::from(buffer));
    }
    if buffer[0] == 0xc7 && buffer[1] == 0x00 {
        return Box::new(PacketZcPcSellItemlist::from(buffer));
    }
    if buffer[0] == 0xc8 && buffer[1] == 0x00 {
        return Box::new(PacketCzPcPurchaseItemlist::from(buffer));
    }
    if buffer[0] == 0xc9 && buffer[1] == 0x00 {
        return Box::new(PacketCzPcSellItemlist::from(buffer));
    }
    if buffer[0] == 0xca && buffer[1] == 0x00 {
        return Box::new(PacketZcPcPurchaseResult::from(buffer));
    }
    if buffer[0] == 0xcb && buffer[1] == 0x00 {
        return Box::new(PacketZcPcSellResult::from(buffer));
    }
    if buffer[0] == 0xcc && buffer[1] == 0x00 {
        return Box::new(PacketCzDisconnectCharacter::from(buffer));
    }
    if buffer[0] == 0xcd && buffer[1] == 0x00 {
        return Box::new(PacketZcAckDisconnectCharacter::from(buffer));
    }
    if buffer[0] == 0xce && buffer[1] == 0x00 {
        return Box::new(PacketCzDisconnectAllCharacter::from(buffer));
    }
    if buffer[0] == 0xcf && buffer[1] == 0x00 {
        return Box::new(PacketCzSettingWhisperPc::from(buffer));
    }
    if buffer[0] == 0xd0 && buffer[1] == 0x00 {
        return Box::new(PacketCzSettingWhisperState::from(buffer));
    }
    if buffer[0] == 0xd1 && buffer[1] == 0x00 {
        return Box::new(PacketZcSettingWhisperPc::from(buffer));
    }
    if buffer[0] == 0xd2 && buffer[1] == 0x00 {
        return Box::new(PacketZcSettingWhisperState::from(buffer));
    }
    if buffer[0] == 0xd3 && buffer[1] == 0x00 {
        return Box::new(PacketCzReqWhisperList::from(buffer));
    }
    if buffer[0] == 0xd4 && buffer[1] == 0x00 {
        return Box::new(PacketZcWhisperList::from(buffer));
    }
    if buffer[0] == 0xd5 && buffer[1] == 0x00 {
        return Box::new(PacketCzCreateChatroom::from(buffer));
    }
    if buffer[0] == 0xd6 && buffer[1] == 0x00 {
        return Box::new(PacketZcAckCreateChatroom::from(buffer));
    }
    if buffer[0] == 0xd7 && buffer[1] == 0x00 {
        return Box::new(PacketZcRoomNewentry::from(buffer));
    }
    if buffer[0] == 0xd8 && buffer[1] == 0x00 {
        return Box::new(PacketZcDestroyRoom::from(buffer));
    }
    if buffer[0] == 0xd9 && buffer[1] == 0x00 {
        return Box::new(PacketCzReqEnterRoom::from(buffer));
    }
    if buffer[0] == 0xda && buffer[1] == 0x00 {
        return Box::new(PacketZcRefuseEnterRoom::from(buffer));
    }
    if buffer[0] == 0xdb && buffer[1] == 0x00 {
        return Box::new(PacketZcEnterRoom::from(buffer));
    }
    if buffer[0] == 0xdc && buffer[1] == 0x00 {
        return Box::new(PacketZcMemberNewentry::from(buffer));
    }
    if buffer[0] == 0xdd && buffer[1] == 0x00 {
        return Box::new(PacketZcMemberExit::from(buffer));
    }
    if buffer[0] == 0xde && buffer[1] == 0x00 {
        return Box::new(PacketCzChangeChatroom::from(buffer));
    }
    if buffer[0] == 0xdf && buffer[1] == 0x00 {
        return Box::new(PacketZcChangeChatroom::from(buffer));
    }
    if buffer[0] == 0xe0 && buffer[1] == 0x00 {
        return Box::new(PacketCzReqRoleChange::from(buffer));
    }
    if buffer[0] == 0xe1 && buffer[1] == 0x00 {
        return Box::new(PacketZcRoleChange::from(buffer));
    }
    if buffer[0] == 0xe2 && buffer[1] == 0x00 {
        return Box::new(PacketCzReqExpelMember::from(buffer));
    }
    if buffer[0] == 0xe3 && buffer[1] == 0x00 {
        return Box::new(PacketCzExitRoom::from(buffer));
    }
    if buffer[0] == 0xe4 && buffer[1] == 0x00 {
        return Box::new(PacketCzReqExchangeItem::from(buffer));
    }
    if buffer[0] == 0xe5 && buffer[1] == 0x00 {
        return Box::new(PacketZcReqExchangeItem::from(buffer));
    }
    if buffer[0] == 0xe6 && buffer[1] == 0x00 {
        return Box::new(PacketCzAckExchangeItem::from(buffer));
    }
    if buffer[0] == 0xe7 && buffer[1] == 0x00 {
        return Box::new(PacketZcAckExchangeItem::from(buffer));
    }
    if buffer[0] == 0xe8 && buffer[1] == 0x00 {
        return Box::new(PacketCzAddExchangeItem::from(buffer));
    }
    if buffer[0] == 0xe9 && buffer[1] == 0x00 {
        return Box::new(PacketZcAddExchangeItem::from(buffer));
    }
    if buffer[0] == 0xea && buffer[1] == 0x00 {
        return Box::new(PacketZcAckAddExchangeItem::from(buffer));
    }
    if buffer[0] == 0xeb && buffer[1] == 0x00 {
        return Box::new(PacketCzConcludeExchangeItem::from(buffer));
    }
    if buffer[0] == 0xec && buffer[1] == 0x00 {
        return Box::new(PacketZcConcludeExchangeItem::from(buffer));
    }
    if buffer[0] == 0xed && buffer[1] == 0x00 {
        return Box::new(PacketCzCancelExchangeItem::from(buffer));
    }
    if buffer[0] == 0xee && buffer[1] == 0x00 {
        return Box::new(PacketZcCancelExchangeItem::from(buffer));
    }
    if buffer[0] == 0xef && buffer[1] == 0x00 {
        return Box::new(PacketCzExecExchangeItem::from(buffer));
    }
    if buffer[0] == 0xf0 && buffer[1] == 0x00 {
        return Box::new(PacketZcExecExchangeItem::from(buffer));
    }
    if buffer[0] == 0xf1 && buffer[1] == 0x00 {
        return Box::new(PacketZcExchangeitemUndo::from(buffer));
    }
    if buffer[0] == 0xf2 && buffer[1] == 0x00 {
        return Box::new(PacketZcNotifyStoreitemCountinfo::from(buffer));
    }
    if buffer[0] == 0xf3 && buffer[1] == 0x00 {
        return Box::new(PacketCzMoveItemFromBodyToStore::from(buffer));
    }
    if buffer[0] == 0xf4 && buffer[1] == 0x00 {
        return Box::new(PacketZcAddItemToStore::from(buffer));
    }
    if buffer[0] == 0xf5 && buffer[1] == 0x00 {
        return Box::new(PacketCzMoveItemFromStoreToBody::from(buffer));
    }
    if buffer[0] == 0xf6 && buffer[1] == 0x00 {
        return Box::new(PacketZcDeleteItemFromStore::from(buffer));
    }
    if buffer[0] == 0xf7 && buffer[1] == 0x00 {
        return Box::new(PacketCzCloseStore::from(buffer));
    }
    if buffer[0] == 0xf8 && buffer[1] == 0x00 {
        return Box::new(PacketZcCloseStore::from(buffer));
    }
    if buffer[0] == 0xf9 && buffer[1] == 0x00 {
        return Box::new(PacketCzMakeGroup::from(buffer));
    }
    if buffer[0] == 0xfa && buffer[1] == 0x00 {
        return Box::new(PacketZcAckMakeGroup::from(buffer));
    }
    if buffer[0] == 0xfb && buffer[1] == 0x00 {
        return Box::new(PacketZcGroupList::from(buffer));
    }
    if buffer[0] == 0xfc && buffer[1] == 0x00 {
        return Box::new(PacketCzReqJoinGroup::from(buffer));
    }
    if buffer[0] == 0xfd && buffer[1] == 0x00 {
        return Box::new(PacketZcAckReqJoinGroup::from(buffer));
    }
    if buffer[0] == 0xfe && buffer[1] == 0x00 {
        return Box::new(PacketZcReqJoinGroup::from(buffer));
    }
    if buffer[0] == 0xff && buffer[1] == 0x00 {
        return Box::new(PacketCzJoinGroup::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x00 {
        return Box::new(PacketCzReqLeaveGroup::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x01 {
        return Box::new(PacketZcGroupinfoChange::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x02 {
        return Box::new(PacketCzChangeGroupexpoption::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x03 {
        return Box::new(PacketCzReqExpelGroupMember::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x04 {
        return Box::new(PacketZcAddMemberToGroup::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x05 {
        return Box::new(PacketZcDeleteMemberFromGroup::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x06 {
        return Box::new(PacketZcNotifyHpToGroupm::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x07 {
        return Box::new(PacketZcNotifyPositionToGroupm::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x08 {
        return Box::new(PacketCzRequestChatParty::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x09 {
        return Box::new(PacketZcNotifyChatParty::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x0a {
        return Box::new(PacketZcMvpGettingItem::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x0b {
        return Box::new(PacketZcMvpGettingSpecialExp::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x0c {
        return Box::new(PacketZcMvp::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x0d {
        return Box::new(PacketZcThrowMvpitem::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x0e {
        return Box::new(PacketZcSkillinfoUpdate::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x0f {
        return Box::new(PacketZcSkillinfoList::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x10 {
        return Box::new(PacketZcAckTouseskill::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x11 {
        return Box::new(PacketZcAddSkill::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x12 {
        return Box::new(PacketCzUpgradeSkilllevel::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x13 {
        return Box::new(PacketCzUseSkill::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x14 {
        return Box::new(PacketZcNotifySkill::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x15 {
        return Box::new(PacketZcNotifySkillPosition::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x16 {
        return Box::new(PacketCzUseSkillToground::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x17 {
        return Box::new(PacketZcNotifyGroundskill::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x18 {
        return Box::new(PacketCzCancelLockon::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x19 {
        return Box::new(PacketZcStateChange::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x1a {
        return Box::new(PacketZcUseSkill::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x1b {
        return Box::new(PacketCzSelectWarppoint::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x1c {
        return Box::new(PacketZcWarplist::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x1d {
        return Box::new(PacketCzRememberWarppoint::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x1e {
        return Box::new(PacketZcAckRememberWarppoint::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x1f {
        return Box::new(PacketZcSkillEntry::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x20 {
        return Box::new(PacketZcSkillDisappear::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x21 {
        return Box::new(PacketZcNotifyCartitemCountinfo::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x22 {
        return Box::new(PacketZcCartEquipmentItemlist::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x23 {
        return Box::new(PacketZcCartNormalItemlist::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x24 {
        return Box::new(PacketZcAddItemToCart::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x25 {
        return Box::new(PacketZcDeleteItemFromCart::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x26 {
        return Box::new(PacketCzMoveItemFromBodyToCart::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x27 {
        return Box::new(PacketCzMoveItemFromCartToBody::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x28 {
        return Box::new(PacketCzMoveItemFromStoreToCart::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x29 {
        return Box::new(PacketCzMoveItemFromCartToStore::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x2a {
        return Box::new(PacketCzReqCartoff::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x2b {
        return Box::new(PacketZcCartoff::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x2c {
        return Box::new(PacketZcAckAdditemToCart::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x2d {
        return Box::new(PacketZcOpenstore::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x2e {
        return Box::new(PacketCzReqClosestore::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x2f {
        return Box::new(PacketCzReqOpenstore::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x30 {
        return Box::new(PacketCzReqBuyFrommc::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x31 {
        return Box::new(PacketZcStoreEntry::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x32 {
        return Box::new(PacketZcDisappearEntry::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x33 {
        return Box::new(PacketZcPcPurchaseItemlistFrommc::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x34 {
        return Box::new(PacketCzPcPurchaseItemlistFrommc::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x35 {
        return Box::new(PacketZcPcPurchaseResultFrommc::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x36 {
        return Box::new(PacketZcPcPurchaseMyitemlist::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x37 {
        return Box::new(PacketZcDeleteitemFromMcstore::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x38 {
        return Box::new(PacketCzPkmodeChange::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x39 {
        return Box::new(PacketZcAttackFailureForDistance::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x3a {
        return Box::new(PacketZcAttackRange::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x3b {
        return Box::new(PacketZcActionFailure::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x3c {
        return Box::new(PacketZcEquipArrow::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x3d {
        return Box::new(PacketZcRecovery::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x3e {
        return Box::new(PacketZcUseskillAck::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x3f {
        return Box::new(PacketCzItemCreate::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x40 {
        return Box::new(PacketCzMovetoMap::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x41 {
        return Box::new(PacketZcCouplestatus::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x42 {
        return Box::new(PacketZcOpenEditdlg::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x43 {
        return Box::new(PacketCzInputEditdlg::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x44 {
        return Box::new(PacketZcCompass::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x45 {
        return Box::new(PacketZcShowImage::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x46 {
        return Box::new(PacketCzCloseDialog::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x47 {
        return Box::new(PacketZcAutorunSkill::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x48 {
        return Box::new(PacketZcResurrection::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x49 {
        return Box::new(PacketCzReqGiveMannerPoint::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x4a {
        return Box::new(PacketZcAckGiveMannerPoint::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x4b {
        return Box::new(PacketZcNotifyMannerPointGiven::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x4c {
        return Box::new(PacketZcMyguildBasicInfo::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x4d {
        return Box::new(PacketCzReqGuildMenuinterface::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x4e {
        return Box::new(PacketZcAckGuildMenuinterface::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x4f {
        return Box::new(PacketCzReqGuildMenu::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x50 {
        return Box::new(PacketZcGuildInfo::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x51 {
        return Box::new(PacketCzReqGuildEmblemImg::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x52 {
        return Box::new(PacketZcGuildEmblemImg::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x53 {
        return Box::new(PacketCzRegisterGuildEmblemImg::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x54 {
        return Box::new(PacketZcMembermgrInfo::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x55 {
        return Box::new(PacketCzReqChangeMemberpos::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x56 {
        return Box::new(PacketZcAckReqChangeMembers::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x57 {
        return Box::new(PacketCzReqOpenMemberInfo::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x58 {
        return Box::new(PacketZcAckOpenMemberInfo::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x59 {
        return Box::new(PacketCzReqLeaveGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x5a {
        return Box::new(PacketZcAckLeaveGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x5b {
        return Box::new(PacketCzReqBanGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x5c {
        return Box::new(PacketZcAckBanGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x5d {
        return Box::new(PacketCzReqDisorganizeGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x5e {
        return Box::new(PacketZcAckDisorganizeGuildResult::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x5f {
        return Box::new(PacketZcAckDisorganizeGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x60 {
        return Box::new(PacketZcPositionInfo::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x61 {
        return Box::new(PacketCzRegChangeGuildPositioninfo::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x62 {
        return Box::new(PacketZcGuildSkillinfo::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x63 {
        return Box::new(PacketZcBanList::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x64 {
        return Box::new(PacketZcOtherGuildList::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x65 {
        return Box::new(PacketCzReqMakeGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x66 {
        return Box::new(PacketZcPositionIdNameInfo::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x67 {
        return Box::new(PacketZcResultMakeGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x68 {
        return Box::new(PacketCzReqJoinGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x69 {
        return Box::new(PacketZcAckReqJoinGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x6a {
        return Box::new(PacketZcReqJoinGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x6b {
        return Box::new(PacketCzJoinGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x6c {
        return Box::new(PacketZcUpdateGdid::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x6d {
        return Box::new(PacketZcUpdateCharstat::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x6e {
        return Box::new(PacketCzGuildNotice::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x6f {
        return Box::new(PacketZcGuildNotice::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x70 {
        return Box::new(PacketCzReqAllyGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x71 {
        return Box::new(PacketZcReqAllyGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x72 {
        return Box::new(PacketCzAllyGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x73 {
        return Box::new(PacketZcAckReqAllyGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x74 {
        return Box::new(PacketZcAckChangeGuildPositioninfo::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x75 {
        return Box::new(PacketCzReqGuildMemberInfo::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x76 {
        return Box::new(PacketZcAckGuildMemberInfo::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x77 {
        return Box::new(PacketZcItemidentifyList::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x78 {
        return Box::new(PacketCzReqItemidentify::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x79 {
        return Box::new(PacketZcAckItemidentify::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x7a {
        return Box::new(PacketCzReqItemcompositionList::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x7b {
        return Box::new(PacketZcItemcompositionList::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x7c {
        return Box::new(PacketCzReqItemcomposition::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x7d {
        return Box::new(PacketZcAckItemcomposition::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x7e {
        return Box::new(PacketCzGuildChat::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x7f {
        return Box::new(PacketZcGuildChat::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x80 {
        return Box::new(PacketCzReqHostileGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x81 {
        return Box::new(PacketZcAckReqHostileGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x82 {
        return Box::new(PacketZcMemberAdd::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x83 {
        return Box::new(PacketCzReqDeleteRelatedGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x84 {
        return Box::new(PacketZcDeleteRelatedGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x85 {
        return Box::new(PacketZcAddRelatedGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x86 {
        return Box::new(PacketCollectordead::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x87 {
        return Box::new(PacketPing::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x88 {
        return Box::new(PacketZcAckItemrefining::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x89 {
        return Box::new(PacketZcNotifyMapinfo::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x8a {
        return Box::new(PacketCzReqDisconnect::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x8b {
        return Box::new(PacketZcAckReqDisconnect::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x8c {
        return Box::new(PacketZcMonsterInfo::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x8d {
        return Box::new(PacketZcMakableitemlist::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x8e {
        return Box::new(PacketCzReqmakingitem::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x8f {
        return Box::new(PacketZcAckReqmakingitem::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x90 {
        return Box::new(PacketCzUseSkillTogroundWithtalkbox::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x91 {
        return Box::new(PacketZcTalkboxChatcontents::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x92 {
        return Box::new(PacketZcUpdateMapinfo::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x93 {
        return Box::new(PacketCzReqnameBygid::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x94 {
        return Box::new(PacketZcAckReqnameBygid::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x95 {
        return Box::new(PacketZcAckReqnameall::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x96 {
        return Box::new(PacketZcMsgStateChange::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x97 {
        return Box::new(PacketCzReset::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x98 {
        return Box::new(PacketCzChangeMaptype::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x99 {
        return Box::new(PacketZcNotifyMapproperty::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x9a {
        return Box::new(PacketZcNotifyRanking::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x9b {
        return Box::new(PacketZcNotifyEffect::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x9d {
        return Box::new(PacketCzChangeEffectstate::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x9e {
        return Box::new(PacketZcStartCapture::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0x9f {
        return Box::new(PacketCzTrycaptureMonster::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xa0 {
        return Box::new(PacketZcTrycaptureMonster::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xa1 {
        return Box::new(PacketCzCommandPet::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xa2 {
        return Box::new(PacketZcPropertyPet::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xa3 {
        return Box::new(PacketZcFeedPet::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xa4 {
        return Box::new(PacketZcChangestatePet::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xa5 {
        return Box::new(PacketCzRenamePet::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xa6 {
        return Box::new(PacketZcPeteggList::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xa7 {
        return Box::new(PacketCzSelectPetegg::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xa8 {
        return Box::new(PacketCzPeteggInfo::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xa9 {
        return Box::new(PacketCzPetAct::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xaa {
        return Box::new(PacketZcPetAct::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xab {
        return Box::new(PacketZcParChangeUser::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xac {
        return Box::new(PacketZcSkillUpdate::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xad {
        return Box::new(PacketZcMakingarrowList::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xae {
        return Box::new(PacketCzReqMakingarrow::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xaf {
        return Box::new(PacketCzReqChangecart::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xb0 {
        return Box::new(PacketZcNpcspriteChange::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xb1 {
        return Box::new(PacketZcShowdigit::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xb2 {
        return Box::new(PacketCzReqOpenstore2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xb3 {
        return Box::new(PacketZcShowImage2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xb4 {
        return Box::new(PacketZcChangeGuild::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xb5 {
        return Box::new(PacketScBillingInfo::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xb6 {
        return Box::new(PacketZcGuildInfo2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xb7 {
        return Box::new(PacketCzGuildZeny::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xb8 {
        return Box::new(PacketZcGuildZenyAck::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xb9 {
        return Box::new(PacketZcDispel::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xba {
        return Box::new(PacketCzRemoveAid::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xbb {
        return Box::new(PacketCzShift::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xbc {
        return Box::new(PacketCzRecall::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xbd {
        return Box::new(PacketCzRecallGid::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xbe {
        return Box::new(PacketAcAskPngameroom::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xbf {
        return Box::new(PacketCaReplyPngameroom::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xc0 {
        return Box::new(PacketCzReqRemaintime::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xc1 {
        return Box::new(PacketZcReplyRemaintime::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xc2 {
        return Box::new(PacketZcInfoRemaintime::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xc3 {
        return Box::new(PacketZcBroadcast2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xc4 {
        return Box::new(PacketZcAddItemToStore2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xc5 {
        return Box::new(PacketZcAddItemToCart2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xc6 {
        return Box::new(PacketCsReqEncryption::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xc7 {
        return Box::new(PacketScAckEncryption::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xc8 {
        return Box::new(PacketZcUseItemAck2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xc9 {
        return Box::new(PacketZcSkillEntry2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xca {
        return Box::new(PacketCzReqmakinghomun::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xcb {
        return Box::new(PacketCzMonsterTalk::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xcc {
        return Box::new(PacketZcMonsterTalk::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xcd {
        return Box::new(PacketZcAutospelllist::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xce {
        return Box::new(PacketCzSelectautospell::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xcf {
        return Box::new(PacketZcDevotionlist::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xd0 {
        return Box::new(PacketZcSpirits::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xd1 {
        return Box::new(PacketZcBladestop::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xd2 {
        return Box::new(PacketZcCombodelay::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xd3 {
        return Box::new(PacketZcSound::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xd4 {
        return Box::new(PacketZcOpenEditdlgstr::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xd5 {
        return Box::new(PacketCzInputEditdlgstr::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xd6 {
        return Box::new(PacketZcNotifyMapproperty2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xd7 {
        return Box::new(PacketZcSpriteChange2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xd8 {
        return Box::new(PacketZcNotifyStandentry2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xd9 {
        return Box::new(PacketZcNotifyNewentry2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xda {
        return Box::new(PacketZcNotifyMoveentry2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xdb {
        return Box::new(PacketCaReqHash::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xdc {
        return Box::new(PacketAcAckHash::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xdd {
        return Box::new(PacketCaLogin2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xde {
        return Box::new(PacketZcNotifySkill2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xdf {
        return Box::new(PacketCzReqAccountname::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xe0 {
        return Box::new(PacketZcAckAccountname::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xe1 {
        return Box::new(PacketZcSpirits2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xe2 {
        return Box::new(PacketZcReqCouple::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xe3 {
        return Box::new(PacketCzJoinCouple::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xe4 {
        return Box::new(PacketZcStartCouple::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xe5 {
        return Box::new(PacketCzReqJoinCouple::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xe6 {
        return Box::new(PacketZcCouplename::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xe7 {
        return Box::new(PacketCzDoridori::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xe8 {
        return Box::new(PacketCzMakeGroup2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xe9 {
        return Box::new(PacketZcAddMemberToGroup2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xea {
        return Box::new(PacketZcCongratulation::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xeb {
        return Box::new(PacketZcNotifyPositionToGuildm::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xec {
        return Box::new(PacketZcGuildMemberMapChange::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xed {
        return Box::new(PacketCzChopokgi::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xee {
        return Box::new(PacketZcNormalItemlist2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xef {
        return Box::new(PacketZcCartNormalItemlist2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xf0 {
        return Box::new(PacketZcStoreNormalItemlist2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xf1 {
        return Box::new(PacketAcNotifyError::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xf2 {
        return Box::new(PacketZcUpdateCharstat2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xf3 {
        return Box::new(PacketZcNotifyEffect2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xf4 {
        return Box::new(PacketZcReqExchangeItem2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xf5 {
        return Box::new(PacketZcAckExchangeItem2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xf6 {
        return Box::new(PacketZcReqBaby::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xf7 {
        return Box::new(PacketCzJoinBaby::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xf8 {
        return Box::new(PacketZcStartBaby::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xf9 {
        return Box::new(PacketCzReqJoinBaby::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xfa {
        return Box::new(PacketCaLogin3::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xfb {
        return Box::new(PacketChDeleteChar2::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xfc {
        return Box::new(PacketZcRepairitemlist::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xfd {
        return Box::new(PacketCzReqItemrepair::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xfe {
        return Box::new(PacketZcAckItemrepair::from(buffer));
    }
    if buffer[0] == 0x01 && buffer[1] == 0xff {
        return Box::new(PacketZcHighjump::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x00 {
        return Box::new(PacketCaConnectInfoChanged::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x01 {
        return Box::new(PacketZcFriendsList::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x02 {
        return Box::new(PacketCzAddFriends::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x03 {
        return Box::new(PacketCzDeleteFriends::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x04 {
        return Box::new(PacketCaExeHashcheck::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x05 {
        return Box::new(PacketZcDivorce::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x06 {
        return Box::new(PacketZcFriendsState::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x07 {
        return Box::new(PacketZcReqAddFriends::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x08 {
        return Box::new(PacketCzAckReqAddFriends::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x09 {
        return Box::new(PacketZcAddFriendsList::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x0a {
        return Box::new(PacketZcDeleteFriends::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x0b {
        return Box::new(PacketChExeHashcheck::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x0c {
        return Box::new(PacketCzExeHashcheck::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x0d {
        return Box::new(PacketHcBlockCharacter::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x0e {
        return Box::new(PacketZcStarskill::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x0f {
        return Box::new(PacketCzReqPvppoint::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x10 {
        return Box::new(PacketZcAckPvppoint::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x11 {
        return Box::new(PacketZhMovePvpworld::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x12 {
        return Box::new(PacketCzReqGiveMannerByname::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x13 {
        return Box::new(PacketCzReqStatusGm::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x14 {
        return Box::new(PacketZcAckStatusGm::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x15 {
        return Box::new(PacketZcSkillmsg::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x16 {
        return Box::new(PacketZcBabymsg::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x17 {
        return Box::new(PacketCzBlacksmithRank::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x18 {
        return Box::new(PacketCzAlchemistRank::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x19 {
        return Box::new(PacketZcBlacksmithRank::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x1a {
        return Box::new(PacketZcAlchemistRank::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x1b {
        return Box::new(PacketZcBlacksmithPoint::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x1c {
        return Box::new(PacketZcAlchemistPoint::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x1d {
        return Box::new(PacketCzLesseffect::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x1e {
        return Box::new(PacketZcLesseffect::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x1f {
        return Box::new(PacketZcNotifyPkinfo::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x20 {
        return Box::new(PacketZcNotifyCrazykiller::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x21 {
        return Box::new(PacketZcNotifyWeaponitemlist::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x22 {
        return Box::new(PacketCzReqWeaponrefine::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x23 {
        return Box::new(PacketZcAckWeaponrefine::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x24 {
        return Box::new(PacketZcTaekwonPoint::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x25 {
        return Box::new(PacketCzTaekwonRank::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x26 {
        return Box::new(PacketZcTaekwonRank::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x27 {
        return Box::new(PacketZcGameGuard::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x28 {
        return Box::new(PacketCzAckGameGuard::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x29 {
        return Box::new(PacketZcStateChange3::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x2a {
        return Box::new(PacketZcNotifyStandentry3::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x2b {
        return Box::new(PacketZcNotifyNewentry3::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x2c {
        return Box::new(PacketZcNotifyMoveentry3::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x2d {
        return Box::new(PacketCzCommandMer::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x2e {
        return Box::new(PacketZcPropertyHomun::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x30 {
        return Box::new(PacketZcChangestateMer::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x31 {
        return Box::new(PacketCzRenameMer::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x32 {
        return Box::new(PacketCzRequestMovenpc::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x33 {
        return Box::new(PacketCzRequestActnpc::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x34 {
        return Box::new(PacketCzRequestMovetoowner::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x3a {
        return Box::new(PacketZcReqStorePassword::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x3b {
        return Box::new(PacketCzAckStorePassword::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x3c {
        return Box::new(PacketZcResultStorePassword::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x3d {
        return Box::new(PacketAcEventResult::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x3e {
        return Box::new(PacketHcRequestCharacterPassword::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x3f {
        return Box::new(PacketCzMailGetList::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x40 {
        return Box::new(PacketZcMailReqGetList::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x41 {
        return Box::new(PacketCzMailOpen::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x42 {
        return Box::new(PacketZcMailReqOpen::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x43 {
        return Box::new(PacketCzMailDelete::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x44 {
        return Box::new(PacketCzMailGetItem::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x45 {
        return Box::new(PacketZcMailReqGetItem::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x46 {
        return Box::new(PacketCzMailResetItem::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x47 {
        return Box::new(PacketCzMailAddItem::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x48 {
        return Box::new(PacketCzMailSend::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x49 {
        return Box::new(PacketZcMailReqSend::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x4a {
        return Box::new(PacketZcMailReceive::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x4b {
        return Box::new(PacketCzAuctionCreate::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x4c {
        return Box::new(PacketCzAuctionAddItem::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x4d {
        return Box::new(PacketCzAuctionAdd::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x4e {
        return Box::new(PacketCzAuctionAddCancel::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x4f {
        return Box::new(PacketCzAuctionBuy::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x50 {
        return Box::new(PacketZcAuctionResult::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x51 {
        return Box::new(PacketCzAuctionItemSearch::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x52 {
        return Box::new(PacketZcAuctionItemReqSearch::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x53 {
        return Box::new(PacketZcStarplace::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x54 {
        return Box::new(PacketCzAgreeStarplace::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x55 {
        return Box::new(PacketZcAckMailAddItem::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x56 {
        return Box::new(PacketZcAckAuctionAddItem::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x57 {
        return Box::new(PacketZcAckMailDelete::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x58 {
        return Box::new(PacketCaReqGameGuardCheck::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x59 {
        return Box::new(PacketAcAckGameGuard::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x5a {
        return Box::new(PacketZcMakingitemList::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x5b {
        return Box::new(PacketCzReqMakingitem::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x5c {
        return Box::new(PacketCzAuctionReqMyInfo::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x5d {
        return Box::new(PacketCzAuctionReqMySellStop::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x5e {
        return Box::new(PacketZcAuctionAckMySellStop::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x5f {
        return Box::new(PacketZcAuctionWindows::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x60 {
        return Box::new(PacketZcMailWindows::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x61 {
        return Box::new(PacketAcReqLoginOldekey::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x62 {
        return Box::new(PacketAcReqLoginNewekey::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x63 {
        return Box::new(PacketAcReqLoginCardpass::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x64 {
        return Box::new(PacketCaAckLoginOldekey::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x65 {
        return Box::new(PacketCaAckLoginNewekey::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x66 {
        return Box::new(PacketCaAckLoginCardpass::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x67 {
        return Box::new(PacketAcAckEkeyFailNotexist::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x68 {
        return Box::new(PacketAcAckEkeyFailNotusesekey::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x69 {
        return Box::new(PacketAcAckEkeyFailNotusedekey::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x6a {
        return Box::new(PacketAcAckEkeyFailAuthrefuse::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x6b {
        return Box::new(PacketAcAckEkeyFailInputekey::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x6c {
        return Box::new(PacketAcAckEkeyFailNotice::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x6d {
        return Box::new(PacketAcAckEkeyFailNeedcardpass::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x6e {
        return Box::new(PacketAcAckAuthekeyFailNotmatchcardpass::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x6f {
        return Box::new(PacketAcAckFirstLogin::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x70 {
        return Box::new(PacketAcReqLoginAccountInfo::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x71 {
        return Box::new(PacketCaAckLoginAccountInfo::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x72 {
        return Box::new(PacketAcAckPtIdInfo::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x73 {
        return Box::new(PacketCzReqMailReturn::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x74 {
        return Box::new(PacketZcAckMailReturn::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x75 {
        return Box::new(PacketChEnter2::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x76 {
        return Box::new(PacketCaAcceptLogin2::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x77 {
        return Box::new(PacketCaLoginPcbang::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x78 {
        return Box::new(PacketZcNotifyPcbang::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x79 {
        return Box::new(PacketCzHuntinglist::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x7a {
        return Box::new(PacketZcHuntinglist::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x7b {
        return Box::new(PacketZcPcbangEffect::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x7c {
        return Box::new(PacketCaLogin4::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x7d {
        return Box::new(PacketZcPropertyMerce::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x7e {
        return Box::new(PacketZcShandaProtect::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x7f {
        return Box::new(PacketCaClientType::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x80 {
        return Box::new(PacketZcGangsiPoint::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x81 {
        return Box::new(PacketCzGangsiRank::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x82 {
        return Box::new(PacketZcGangsiRank::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x83 {
        return Box::new(PacketZcAid::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x84 {
        return Box::new(PacketZcNotifyEffect3::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x85 {
        return Box::new(PacketZcDeathQuestion::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x86 {
        return Box::new(PacketCzDeathQuestion::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x87 {
        return Box::new(PacketZcPcCashPointItemlist::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x88 {
        return Box::new(PacketCzPcBuyCashPointItem::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x89 {
        return Box::new(PacketZcPcCashPointUpdate::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x8a {
        return Box::new(PacketZcNpcShowefstUpdate::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x8c {
        return Box::new(PacketChSelectCharGoingtobeused::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x8d {
        return Box::new(PacketChReqIsValidCharname::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x8e {
        return Box::new(PacketHcAckIsValidCharname::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x8f {
        return Box::new(PacketChReqChangeCharname::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x90 {
        return Box::new(PacketHcAckChangeCharname::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x91 {
        return Box::new(PacketZcMsg::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x92 {
        return Box::new(PacketCzStandingResurrection::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x93 {
        return Box::new(PacketZcBossInfo::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x94 {
        return Box::new(PacketZcReadBook::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x95 {
        return Box::new(PacketZcEquipmentItemlist2::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x96 {
        return Box::new(PacketZcStoreEquipmentItemlist2::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x97 {
        return Box::new(PacketZcCartEquipmentItemlist2::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x98 {
        return Box::new(PacketZcCashTimeCounter::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x99 {
        return Box::new(PacketZcCashItemDelete::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x9a {
        return Box::new(PacketZcItemPickupAck2::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x9b {
        return Box::new(PacketZcMerInit::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x9c {
        return Box::new(PacketZcMerProperty::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x9d {
        return Box::new(PacketZcMerSkillinfoList::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x9e {
        return Box::new(PacketZcMerSkillinfoUpdate::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0x9f {
        return Box::new(PacketCzMerCommand::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xa0 {
        return Box::new(UnusedPacketCzMerUseSkill::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xa1 {
        return Box::new(UnusedPacketCzMerUpgradeSkilllevel::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xa2 {
        return Box::new(PacketZcMerParChange::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xa3 {
        return Box::new(PacketZcGameguardLingoKey::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xa5 {
        return Box::new(PacketCzKsyEvent::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xaa {
        return Box::new(PacketZcReqCashPassword::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xab {
        return Box::new(PacketCzAckCashPassword::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xac {
        return Box::new(PacketZcResultCashPassword::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xad {
        return Box::new(PacketAcRequestSecondPassword::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xb0 {
        return Box::new(PacketCaLoginHan::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xb1 {
        return Box::new(PacketZcAllQuestList::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xb2 {
        return Box::new(PacketZcAllQuestMission::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xb3 {
        return Box::new(PacketZcAddQuest::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xb4 {
        return Box::new(PacketZcDelQuest::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xb5 {
        return Box::new(PacketZcUpdateMissionHunt::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xb6 {
        return Box::new(PacketCzActiveQuest::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xb7 {
        return Box::new(PacketZcActiveQuest::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xb8 {
        return Box::new(PacketZcItemPickupParty::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xb9 {
        return Box::new(PacketZcShortcutKeyList::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xba {
        return Box::new(PacketCzShortcutKeyChange::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xbb {
        return Box::new(PacketZcEquipitemDamaged::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xbc {
        return Box::new(PacketZcNotifyPcbangPlayingTime::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xbf {
        return Box::new(PacketZcSrpacketr2Init::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xc0 {
        return Box::new(PacketCzSrpacketr2Start::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xc1 {
        return Box::new(PacketZcNpcChat::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xc2 {
        return Box::new(PacketZcFormatstringMsg::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xc4 {
        return Box::new(PacketCzPartyJoinReq::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xc5 {
        return Box::new(PacketZcPartyJoinReqAck::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xc6 {
        return Box::new(PacketZcPartyJoinReq::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xc7 {
        return Box::new(PacketCzPartyJoinReqAck::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xc8 {
        return Box::new(PacketCzPartyConfig::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xc9 {
        return Box::new(PacketZcPartyConfig::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xca {
        return Box::new(PacketHcRefuseSelectchar::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xcb {
        return Box::new(PacketZcMemorialdungeonSubscriptionInfo::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xcc {
        return Box::new(PacketZcMemorialdungeonSubscriptionNotify::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xcd {
        return Box::new(PacketZcMemorialdungeonInfo::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xce {
        return Box::new(PacketZcMemorialdungeonNotify::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xcf {
        return Box::new(PacketCzMemorialdungeonCommand::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xd0 {
        return Box::new(PacketZcEquipmentItemlist3::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xd1 {
        return Box::new(PacketZcStoreEquipmentItemlist3::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xd2 {
        return Box::new(PacketZcCartEquipmentItemlist3::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xd3 {
        return Box::new(PacketZcNotifyBindOnEquip::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xd4 {
        return Box::new(PacketZcItemPickupAck3::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xd5 {
        return Box::new(PacketZcIsvrDisconnect::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xd6 {
        return Box::new(PacketCzEquipwinMicroscope::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xd7 {
        return Box::new(PacketZcEquipwinMicroscope::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xd8 {
        return Box::new(PacketCzConfig::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xd9 {
        return Box::new(PacketZcConfig::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xda {
        return Box::new(PacketZcConfigNotify::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xdb {
        return Box::new(PacketCzBattlefieldChat::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xdc {
        return Box::new(PacketZcBattlefieldChat::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xdd {
        return Box::new(PacketZcBattlefieldNotifyCampinfo::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xde {
        return Box::new(PacketZcBattlefieldNotifyPoint::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xdf {
        return Box::new(PacketZcBattlefieldNotifyPosition::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xe0 {
        return Box::new(PacketZcBattlefieldNotifyHp::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xe1 {
        return Box::new(PacketZcNotifyAct2::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xe6 {
        return Box::new(PacketCzBotCheck::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xe7 {
        return Box::new(PacketZcMapproperty::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xe8 {
        return Box::new(PacketZcNormalItemlist3::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xe9 {
        return Box::new(PacketZcCartNormalItemlist3::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xea {
        return Box::new(PacketZcStoreNormalItemlist3::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xeb {
        return Box::new(PacketZcAcceptEnter2::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xec {
        return Box::new(PacketZcNotifyMoveentry4::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xed {
        return Box::new(PacketZcNotifyNewentry4::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xee {
        return Box::new(PacketZcNotifyStandentry4::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xef {
        return Box::new(PacketZcNotifyFont::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xf0 {
        return Box::new(PacketZcProgress::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xf1 {
        return Box::new(PacketCzProgress::from(buffer));
    }
    if buffer[0] == 0x02 && buffer[1] == 0xf2 {
        return Box::new(PacketZcProgressCancel::from(buffer));
    }
    if buffer[0] == 0x03 && buffer[1] == 0x5c {
        return Box::new(PacketCzOpenSimpleCashshopItemlist::from(buffer));
    }
    if buffer[0] == 0x03 && buffer[1] == 0x5d {
        return Box::new(PacketZcSimpleCashshopPointItemlist::from(buffer));
    }
    if buffer[0] == 0x03 && buffer[1] == 0x5e {
        return Box::new(PacketCzCloseWindow::from(buffer));
    }
    if buffer[0] == 0x03 && buffer[1] == 0xdd {
        return Box::new(PacketAhcGameGuard::from(buffer));
    }
    if buffer[0] == 0x03 && buffer[1] == 0xde {
        return Box::new(PacketCahAckGameGuard::from(buffer));
    }
    if buffer[0] == 0x04 && buffer[1] == 0x36 {
        return Box::new(PacketCzEnter2::from(buffer));
    }
    if buffer[0] == 0x04 && buffer[1] == 0x37 {
        return Box::new(PacketCzRequestAct2::from(buffer));
    }
    if buffer[0] == 0x04 && buffer[1] == 0x38 {
        return Box::new(PacketCzUseSkill2::from(buffer));
    }
    if buffer[0] == 0x04 && buffer[1] == 0x39 {
        return Box::new(PacketCzUseItem2::from(buffer));
    }
    if buffer[0] == 0x04 && buffer[1] == 0x3d {
        return Box::new(PacketZcSkillPostdelay::from(buffer));
    }
    if buffer[0] == 0x04 && buffer[1] == 0x3e {
        return Box::new(PacketZcSkillPostdelayList::from(buffer));
    }
    if buffer[0] == 0x04 && buffer[1] == 0x3f {
        return Box::new(PacketZcMsgStateChange2::from(buffer));
    }
    if buffer[0] == 0x04 && buffer[1] == 0x40 {
        return Box::new(PacketZcMillenniumshield::from(buffer));
    }
    if buffer[0] == 0x04 && buffer[1] == 0x41 {
        return Box::new(PacketZcSkillinfoDelete::from(buffer));
    }
    if buffer[0] == 0x04 && buffer[1] == 0x42 {
        return Box::new(PacketZcSkillSelectRequest::from(buffer));
    }
    if buffer[0] == 0x04 && buffer[1] == 0x43 {
        return Box::new(PacketCzSkillSelectResponse::from(buffer));
    }
    if buffer[0] == 0x04 && buffer[1] == 0x44 {
        return Box::new(PacketZcSimpleCashPointItemlist::from(buffer));
    }
    if buffer[0] == 0x04 && buffer[1] == 0x45 {
        return Box::new(PacketCzSimpleBuyCashPointItem::from(buffer));
    }
    if buffer[0] == 0x04 && buffer[1] == 0x46 {
        return Box::new(PacketZcQuestNotifyEffect::from(buffer));
    }
    if buffer[0] == 0x04 && buffer[1] == 0x47 {
        return Box::new(PacketCzBlockingPlayCancel::from(buffer));
    }
    if buffer[0] == 0x04 && buffer[1] == 0x48 {
        return Box::new(PacketHcCharacterList::from(buffer));
    }
    if buffer[0] == 0x04 && buffer[1] == 0x49 {
        return Box::new(PacketZcHackshErrorMsg::from(buffer));
    }
    if buffer[0] == 0x04 && buffer[1] == 0x4a {
        return Box::new(PacketCzClientVersion::from(buffer));
    }
    if buffer[0] == 0x04 && buffer[1] == 0x4b {
        return Box::new(PacketCzCloseSimplecashShop::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xd0 {
        return Box::new(PacketZcEsResult::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xd1 {
        return Box::new(PacketCzEsGetList::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xd2 {
        return Box::new(PacketZcEsList::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xd3 {
        return Box::new(PacketCzEsChoose::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xd4 {
        return Box::new(PacketCzEsCancel::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xd5 {
        return Box::new(PacketZcEsReady::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xd6 {
        return Box::new(PacketZcEsGoto::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xd7 {
        return Box::new(PacketCzGroupinfoChangeV2::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xd8 {
        return Box::new(PacketZcReqGroupinfoChangeV2::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xd9 {
        return Box::new(PacketZcShortcutKeyListV2::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xda {
        return Box::new(PacketCzChangeGroupMaster::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xdb {
        return Box::new(PacketZcHoParChange::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xdc {
        return Box::new(PacketCzSeekParty::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xdd {
        return Box::new(PacketZcSeekParty::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xde {
        return Box::new(PacketCzSeekPartyMember::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xdf {
        return Box::new(PacketZcSeekPartyMember::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xe0 {
        return Box::new(PacketZcEsNotiMyinfo::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xe1 {
        return Box::new(PacketZcSkillinfoUpdate2::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xe2 {
        return Box::new(PacketZcMsgValue::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xe3 {
        return Box::new(PacketZcItemlistwinOpen::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xe4 {
        return Box::new(PacketCzItemlistwinRes::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xe5 {
        return Box::new(PacketChEnterCheckbot::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xe6 {
        return Box::new(PacketZcMsgSkill::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xe7 {
        return Box::new(PacketChCheckbot::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xe8 {
        return Box::new(PacketHcCheckbot::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xe9 {
        return Box::new(PacketHcCheckbotResult::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xea {
        return Box::new(PacketCzBattleFieldList::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xeb {
        return Box::new(PacketZcBattleFieldList::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xec {
        return Box::new(PacketCzJoinBattleField::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xed {
        return Box::new(PacketZcJoinBattleField::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xee {
        return Box::new(PacketCzCancelBattleField::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xef {
        return Box::new(PacketZcCancelBattleField::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xf0 {
        return Box::new(PacketCzReqBattleStateMonitor::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xf1 {
        return Box::new(PacketZcAckBattleStateMonitor::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xf2 {
        return Box::new(PacketZcBattleNotiStartStep::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xf3 {
        return Box::new(PacketZcBattleJoinNotiDefer::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xf4 {
        return Box::new(PacketZcBattleJoinDisableState::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xf5 {
        return Box::new(PacketCzGmFullstrip::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xf6 {
        return Box::new(PacketZcNotifyExp::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xf7 {
        return Box::new(PacketZcNotifyMoveentry7::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xf8 {
        return Box::new(PacketZcNotifyNewentry5::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xf9 {
        return Box::new(PacketZcNotifyStandentry5::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xfa {
        return Box::new(PacketZcDeleteItemFromBody::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xfb {
        return Box::new(PacketZcUseskillAck2::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xfc {
        return Box::new(PacketZcChangeGroupMaster::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xfe {
        return Box::new(PacketZcPlayNpcBgm::from(buffer));
    }
    if buffer[0] == 0x07 && buffer[1] == 0xff {
        return Box::new(PacketZcDefineCheck::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x00 {
        return Box::new(PacketZcPcPurchaseItemlistFrommc2::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x01 {
        return Box::new(PacketCzPcPurchaseItemlistFrommc2::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x02 {
        return Box::new(PacketCzPartyBookingReqRegister::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x03 {
        return Box::new(PacketZcPartyBookingAckRegister::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x04 {
        return Box::new(PacketCzPartyBookingReqSearch::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x05 {
        return Box::new(PacketZcPartyBookingAckSearch::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x06 {
        return Box::new(PacketCzPartyBookingReqDelete::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x07 {
        return Box::new(PacketZcPartyBookingAckDelete::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x08 {
        return Box::new(PacketCzPartyBookingReqUpdate::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x09 {
        return Box::new(PacketZcPartyBookingNotifyInsert::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x0a {
        return Box::new(PacketZcPartyBookingNotifyUpdate::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x0b {
        return Box::new(PacketZcPartyBookingNotifyDelete::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x0c {
        return Box::new(PacketCzSimpleCashBtnshow::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x0d {
        return Box::new(PacketZcSimpleCashBtnshow::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x0e {
        return Box::new(PacketZcNotifyHpToGroupmR2::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x0f {
        return Box::new(PacketZcAddExchangeItem2::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x10 {
        return Box::new(PacketZcOpenBuyingStore::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x11 {
        return Box::new(PacketCzReqOpenBuyingStore::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x12 {
        return Box::new(PacketZcFailedOpenBuyingStoreToBuyer::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x13 {
        return Box::new(PacketZcMyitemlistBuyingStore::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x14 {
        return Box::new(PacketZcBuyingStoreEntry::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x15 {
        return Box::new(PacketCzReqCloseBuyingStore::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x16 {
        return Box::new(PacketZcDisappearBuyingStoreEntry::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x17 {
        return Box::new(PacketCzReqClickToBuyingStore::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x18 {
        return Box::new(PacketZcAckItemlistBuyingStore::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x19 {
        return Box::new(PacketCzReqTradeBuyingStore::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x1a {
        return Box::new(PacketZcFailedTradeBuyingStoreToBuyer::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x1b {
        return Box::new(PacketZcUpdateItemFromBuyingStore::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x1c {
        return Box::new(PacketZcItemDeleteBuyingStore::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x1d {
        return Box::new(PacketZcElInit::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x1e {
        return Box::new(PacketZcElParChange::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x1f {
        return Box::new(PacketZcBroadcast4::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x20 {
        return Box::new(PacketZcCostumeSpriteChange::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x21 {
        return Box::new(PacketAcOtpUser::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x22 {
        return Box::new(PacketCaOtpAuthReq::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x23 {
        return Box::new(PacketAcOtpAuthAck::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x24 {
        return Box::new(PacketZcFailedTradeBuyingStoreToSeller::from(buffer));
    }
    if buffer[0] == 0x82 && buffer[1] == 0x5a {
        return Box::new(PacketCaSsoLoginReqa::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x25 {
        return Box::new(PacketCaSsoLoginReq::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x26 {
        return Box::new(PacketAcSsoLoginAck::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x27 {
        return Box::new(PacketChDeleteChar3Reserved::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x28 {
        return Box::new(PacketHcDeleteChar3Reserved::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x29 {
        return Box::new(PacketChDeleteChar3::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x2a {
        return Box::new(PacketHcDeleteChar3::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x2b {
        return Box::new(PacketChDeleteChar3Cancel::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x2c {
        return Box::new(PacketHcDeleteChar3Cancel::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x35 {
        return Box::new(PacketCzSearchStoreInfo::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x36 {
        return Box::new(PacketZcSearchStoreInfoAck::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x37 {
        return Box::new(PacketZcSearchStoreInfoFailed::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x38 {
        return Box::new(PacketCzSearchStoreInfoNextPage::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x39 {
        return Box::new(PacketZcAckBanGuildSso::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x3a {
        return Box::new(PacketZcOpenSearchStoreInfo::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x3b {
        return Box::new(PacketCzCloseSearchStoreInfo::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x3c {
        return Box::new(PacketCzSsilistItemClick::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x3d {
        return Box::new(PacketZcSsilistItemClickAck::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x3e {
        return Box::new(PacketAcRefuseLoginR2::from(buffer));
    }
    if buffer[0] == 0x08 && buffer[1] == 0x41 {
        return Box::new(PacketChSelectAccessibleMapname::from(buffer));
    }
    if buffer[0] == 0x5f && buffer[1] == 0x03 {
        return Box::new(PacketCzRequestMove2::from(buffer));
    }
    Box::new(PacketUnknown::from(buffer))
}

pub trait Packet {
    fn id(&self) -> &str;
    fn display(&self);
    fn debug(&self);
    fn pretty_debug(&self);
    fn raw(&self) -> &Vec<u8>;
    fn as_any(&self) -> &dyn Any;
    fn as_any_mut(&mut self) -> &mut dyn Any;
}

#[derive(Clone)]
pub struct PacketCaLogin {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub version: u32,
    pub version_raw: [u8; 4],
    pub id: [char; 24],
    pub id_raw: [u8; 24],
    pub passwd: [char; 24],
    pub passwd_raw: [u8; 24],
    pub client_type: u8,
    pub client_type_raw: [u8; 1],
}

impl PacketCaLogin {
    pub fn from(buffer: &[u8]) -> PacketCaLogin {
        PacketCaLogin {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            version: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            id:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            passwd:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[30..54].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[30..54]);
                dst
            },
            client_type: u8::from_le_bytes([buffer[54]]),
            client_type_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[54..55]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.client_type).unwrap();
        self.client_type_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCaLogin {
    fn id(&self) -> &str {
       "0x6400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketChEnter {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub auth_code: i32,
    pub auth_code_raw: [u8; 4],
    pub user_level: u32,
    pub user_level_raw: [u8; 4],
    pub client_type: u16,
    pub client_type_raw: [u8; 2],
    pub sex: u8,
    pub sex_raw: [u8; 1],
}

impl PacketChEnter {
    pub fn from(buffer: &[u8]) -> PacketChEnter {
        PacketChEnter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            auth_code: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            user_level: u32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            user_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            client_type: u16::from_le_bytes([buffer[14], buffer[15]]),
            client_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            sex: u8::from_le_bytes([buffer[16]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[16..17]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.user_level).unwrap();
        self.user_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.client_type).unwrap();
        self.client_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketChEnter {
    fn id(&self) -> &str {
       "0x6500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketChSelectChar {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub char_num: u8,
    pub char_num_raw: [u8; 1],
}

impl PacketChSelectChar {
    pub fn from(buffer: &[u8]) -> PacketChSelectChar {
        PacketChSelectChar {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            char_num: u8::from_le_bytes([buffer[2]]),
            char_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.char_num).unwrap();
        self.char_num_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketChSelectChar {
    fn id(&self) -> &str {
       "0x6600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketChMakeChar {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
    pub str: u8,
    pub str_raw: [u8; 1],
    pub agi: u8,
    pub agi_raw: [u8; 1],
    pub vit: u8,
    pub vit_raw: [u8; 1],
    pub int: u8,
    pub int_raw: [u8; 1],
    pub dex: u8,
    pub dex_raw: [u8; 1],
    pub luk: u8,
    pub luk_raw: [u8; 1],
    pub char_num: u8,
    pub char_num_raw: [u8; 1],
    pub head_pal: i16,
    pub head_pal_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
}

impl PacketChMakeChar {
    pub fn from(buffer: &[u8]) -> PacketChMakeChar {
        PacketChMakeChar {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            str: u8::from_le_bytes([buffer[26]]),
            str_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[26..27]);
                dst
            },
            agi: u8::from_le_bytes([buffer[27]]),
            agi_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[27..28]);
                dst
            },
            vit: u8::from_le_bytes([buffer[28]]),
            vit_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[28..29]);
                dst
            },
            int: u8::from_le_bytes([buffer[29]]),
            int_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[29..30]);
                dst
            },
            dex: u8::from_le_bytes([buffer[30]]),
            dex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[30..31]);
                dst
            },
            luk: u8::from_le_bytes([buffer[31]]),
            luk_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[31..32]);
                dst
            },
            char_num: u8::from_le_bytes([buffer[32]]),
            char_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[32..33]);
                dst
            },
            head_pal: i16::from_le_bytes([buffer[33], buffer[34]]),
            head_pal_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            head: i16::from_le_bytes([buffer[35], buffer[36]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[35..37]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.str).unwrap();
        self.str_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.agi).unwrap();
        self.agi_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.vit).unwrap();
        self.vit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.int).unwrap();
        self.int_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dex).unwrap();
        self.dex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.luk).unwrap();
        self.luk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.char_num).unwrap();
        self.char_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_pal).unwrap();
        self.head_pal_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketChMakeChar {
    fn id(&self) -> &str {
       "0x6700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketChDeleteChar {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub key: [char; 40],
    pub key_raw: [u8; 40],
}

impl PacketChDeleteChar {
    pub fn from(buffer: &[u8]) -> PacketChDeleteChar {
        PacketChDeleteChar {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            key:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[6..46].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            key_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[6..46]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.key {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.key_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketChDeleteChar {
    fn id(&self) -> &str {
       "0x6800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcAcceptLogin {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub auth_code: i32,
    pub auth_code_raw: [u8; 4],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub user_level: u32,
    pub user_level_raw: [u8; 4],
    pub last_login_ip: u32,
    pub last_login_ip_raw: [u8; 4],
    pub last_login_time: [char; 26],
    pub last_login_time_raw: [u8; 26],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub server_list: Vec<ServerAddr>,
    pub server_list_raw: Vec<Vec<u8>>,
}

impl PacketAcAcceptLogin {
    pub fn from(buffer: &[u8]) -> PacketAcAcceptLogin {
        let iter_count = &buffer.len() / 32;
        let mut vec_field: Vec<ServerAddr> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 47 * i;
            let end_pos = 79 * i;
            vec_field.push(ServerAddr::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketAcAcceptLogin {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            auth_code: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            aid: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            user_level: u32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            user_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            last_login_ip: u32::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19]]),
            last_login_ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[16..20]);
                dst
            },
            last_login_time:  {
                let mut dst: [char; 26] = [0 as char; 26];
                for (index, byte) in buffer[20..46].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            last_login_time_raw: {
                let mut dst: [u8; 26] = [0u8; 26];
                dst.clone_from_slice(&buffer[20..46]);
                dst
            },
            sex: u8::from_le_bytes([buffer[46]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[46..47]);
                dst
            },
            server_list: vec_field.clone(),
            server_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.user_level).unwrap();
        self.user_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.last_login_ip).unwrap();
        self.last_login_ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.last_login_time {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.last_login_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        self.server_list_raw = {
            self.server_list.iter_mut().for_each(|item| item.serialize());
            self.server_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketAcAcceptLogin {
    fn id(&self) -> &str {
       "0x6900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcAcceptLogin2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub auth_code: i32,
    pub auth_code_raw: [u8; 4],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub user_level: u32,
    pub user_level_raw: [u8; 4],
    pub last_login_ip: u32,
    pub last_login_ip_raw: [u8; 4],
    pub last_login_time: [char; 26],
    pub last_login_time_raw: [u8; 26],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub twitter_auth_token: [char; 16],
    pub twitter_auth_token_raw: [u8; 16],
    pub twitter_flag: u16,
    pub twitter_flag_raw: [u8; 2],
    pub server_list: Vec<ServerAddr2>,
    pub server_list_raw: Vec<Vec<u8>>,
}

impl PacketAcAcceptLogin2 {
    pub fn from(buffer: &[u8]) -> PacketAcAcceptLogin2 {
        let iter_count = &buffer.len() / 160;
        let mut vec_field: Vec<ServerAddr2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 64 * i;
            let end_pos = 224 * i;
            vec_field.push(ServerAddr2::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketAcAcceptLogin2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            auth_code: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            aid: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            user_level: u32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            user_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            last_login_ip: u32::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19]]),
            last_login_ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[16..20]);
                dst
            },
            last_login_time:  {
                let mut dst: [char; 26] = [0 as char; 26];
                for (index, byte) in buffer[20..46].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            last_login_time_raw: {
                let mut dst: [u8; 26] = [0u8; 26];
                dst.clone_from_slice(&buffer[20..46]);
                dst
            },
            sex: u8::from_le_bytes([buffer[46]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[46..47]);
                dst
            },
            twitter_auth_token:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[47..63].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            twitter_auth_token_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[47..63]);
                dst
            },
            twitter_flag: u16::from_le_bytes([buffer[63], buffer[64]]),
            twitter_flag_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[63..65]);
                dst
            },
            server_list: vec_field.clone(),
            server_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.user_level).unwrap();
        self.user_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.last_login_ip).unwrap();
        self.last_login_ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.last_login_time {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.last_login_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.twitter_auth_token {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.twitter_auth_token_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.twitter_flag).unwrap();
        self.twitter_flag_raw = wtr.try_into().unwrap();
        self.server_list_raw = {
            self.server_list.iter_mut().for_each(|item| item.serialize());
            self.server_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketAcAcceptLogin2 {
    fn id(&self) -> &str {
       "0xc40a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcRefuseLogin {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub error_code: u8,
    pub error_code_raw: [u8; 1],
    pub block_date: [char; 20],
    pub block_date_raw: [u8; 20],
}

impl PacketAcRefuseLogin {
    pub fn from(buffer: &[u8]) -> PacketAcRefuseLogin {
        PacketAcRefuseLogin {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: u8::from_le_bytes([buffer[2]]),
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            block_date:  {
                let mut dst: [char; 20] = [0 as char; 20];
                for (index, byte) in buffer[3..23].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            block_date_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[3..23]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.block_date {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.block_date_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcRefuseLogin {
    fn id(&self) -> &str {
       "0x6a00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketHcAcceptEnterNeoUnion {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub total_slot_num: u8,
    pub total_slot_num_raw: [u8; 1],
    pub premium_start_slot: u8,
    pub premium_start_slot_raw: [u8; 1],
    pub premium_end_slot: u8,
    pub premium_end_slot_raw: [u8; 1],
    pub dummy1_beginbilling: i8,
    pub dummy1_beginbilling_raw: [u8; 1],
    pub code: u32,
    pub code_raw: [u8; 4],
    pub time1: u32,
    pub time1_raw: [u8; 4],
    pub time2: u32,
    pub time2_raw: [u8; 4],
    pub dummy2_endbilling: [char; 7],
    pub dummy2_endbilling_raw: [u8; 7],
    pub char_info: Vec<CharacterInfoNeoUnion>,
    pub char_info_raw: Vec<Vec<u8>>,
}

impl PacketHcAcceptEnterNeoUnion {
    pub fn from(buffer: &[u8]) -> PacketHcAcceptEnterNeoUnion {
        let iter_count = &buffer.len() / 144;
        let mut vec_field: Vec<CharacterInfoNeoUnion> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 27 * i;
            let end_pos = 171 * i;
            vec_field.push(CharacterInfoNeoUnion::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketHcAcceptEnterNeoUnion {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            total_slot_num: u8::from_le_bytes([buffer[4]]),
            total_slot_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            premium_start_slot: u8::from_le_bytes([buffer[5]]),
            premium_start_slot_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            premium_end_slot: u8::from_le_bytes([buffer[6]]),
            premium_end_slot_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            dummy1_beginbilling: i8::from_le_bytes([buffer[7]]),
            dummy1_beginbilling_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[7..8]);
                dst
            },
            code: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            time1: u32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            time1_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            time2: u32::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19]]),
            time2_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[16..20]);
                dst
            },
            dummy2_endbilling:  {
                let mut dst: [char; 7] = [0 as char; 7];
                for (index, byte) in buffer[20..27].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            dummy2_endbilling_raw: {
                let mut dst: [u8; 7] = [0u8; 7];
                dst.clone_from_slice(&buffer[20..27]);
                dst
            },
            char_info: vec_field.clone(),
            char_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.total_slot_num).unwrap();
        self.total_slot_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.premium_start_slot).unwrap();
        self.premium_start_slot_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.premium_end_slot).unwrap();
        self.premium_end_slot_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.dummy1_beginbilling).unwrap();
        self.dummy1_beginbilling_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.code).unwrap();
        self.code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.time1).unwrap();
        self.time1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.time2).unwrap();
        self.time2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.dummy2_endbilling {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.dummy2_endbilling_raw = wtr.try_into().unwrap();
        self.char_info_raw = {
            self.char_info.iter_mut().for_each(|item| item.serialize());
            self.char_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketHcAcceptEnterNeoUnion {
    fn id(&self) -> &str {
       "0x6b00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketHcRefuseEnter {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub error_code: u8,
    pub error_code_raw: [u8; 1],
}

impl PacketHcRefuseEnter {
    pub fn from(buffer: &[u8]) -> PacketHcRefuseEnter {
        PacketHcRefuseEnter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: u8::from_le_bytes([buffer[2]]),
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketHcRefuseEnter {
    fn id(&self) -> &str {
       "0x6c00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketHcAcceptMakecharNeoUnion {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub charinfo: CharacterInfoNeoUnion,
    pub charinfo_raw: Vec<u8>,
}

impl PacketHcAcceptMakecharNeoUnion {
    pub fn from(buffer: &[u8]) -> PacketHcAcceptMakecharNeoUnion {
        PacketHcAcceptMakecharNeoUnion {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            charinfo: CharacterInfoNeoUnion::from(&buffer[2..buffer.len()]),
            charinfo_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketHcAcceptMakecharNeoUnion {
    fn id(&self) -> &str {
       "0x6d00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketHcRefuseMakechar {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub error_code: u8,
    pub error_code_raw: [u8; 1],
}

impl PacketHcRefuseMakechar {
    pub fn from(buffer: &[u8]) -> PacketHcRefuseMakechar {
        PacketHcRefuseMakechar {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: u8::from_le_bytes([buffer[2]]),
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketHcRefuseMakechar {
    fn id(&self) -> &str {
       "0x6e00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketHcAcceptDeletechar {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketHcAcceptDeletechar {
    pub fn from(buffer: &[u8]) -> PacketHcAcceptDeletechar {
        PacketHcAcceptDeletechar {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketHcAcceptDeletechar {
    fn id(&self) -> &str {
       "0x6f00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketHcRefuseDeletechar {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub error_code: u8,
    pub error_code_raw: [u8; 1],
}

impl PacketHcRefuseDeletechar {
    pub fn from(buffer: &[u8]) -> PacketHcRefuseDeletechar {
        PacketHcRefuseDeletechar {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: u8::from_le_bytes([buffer[2]]),
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketHcRefuseDeletechar {
    fn id(&self) -> &str {
       "0x7000"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketHcNotifyZonesvr {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub map_name: [char; 16],
    pub map_name_raw: [u8; 16],
    pub addr: ZserverAddr,
    pub addr_raw: Vec<u8>,
}

impl PacketHcNotifyZonesvr {
    pub fn from(buffer: &[u8]) -> PacketHcNotifyZonesvr {
        PacketHcNotifyZonesvr {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[6..22].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[6..22]);
                dst
            },
            addr: ZserverAddr::from(&buffer[22..buffer.len()]),
            addr_raw: buffer[22..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketHcNotifyZonesvr {
    fn id(&self) -> &str {
       "0x7100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzEnter {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub auth_code: i32,
    pub auth_code_raw: [u8; 4],
    pub client_time: u32,
    pub client_time_raw: [u8; 4],
    pub sex: u8,
    pub sex_raw: [u8; 1],
}

impl PacketCzEnter {
    pub fn from(buffer: &[u8]) -> PacketCzEnter {
        PacketCzEnter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            auth_code: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            client_time: u32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            client_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
            sex: u8::from_le_bytes([buffer[18]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[18..19]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.client_time).unwrap();
        self.client_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzEnter {
    fn id(&self) -> &str {
       "0x7200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAcceptEnter {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub start_time: u32,
    pub start_time_raw: [u8; 4],
    pub pos_dir: [char; 3],
    pub pos_dir_raw: [u8; 3],
    pub x_size: u8,
    pub x_size_raw: [u8; 1],
    pub y_size: u8,
    pub y_size_raw: [u8; 1],
}

impl PacketZcAcceptEnter {
    pub fn from(buffer: &[u8]) -> PacketZcAcceptEnter {
        PacketZcAcceptEnter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            start_time: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[6..9].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[6..9]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[9]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[10]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAcceptEnter {
    fn id(&self) -> &str {
       "0x7300"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcRefuseEnter {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub error_code: u8,
    pub error_code_raw: [u8; 1],
}

impl PacketZcRefuseEnter {
    pub fn from(buffer: &[u8]) -> PacketZcRefuseEnter {
        PacketZcRefuseEnter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: u8::from_le_bytes([buffer[2]]),
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcRefuseEnter {
    fn id(&self) -> &str {
       "0x7400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyInitchar {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub style: i16,
    pub style_raw: [u8; 2],
    pub item: u8,
    pub item_raw: [u8; 1],
}

impl PacketZcNotifyInitchar {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyInitchar {
        PacketZcNotifyInitchar {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            gid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            style: i16::from_le_bytes([buffer[8], buffer[9]]),
            style_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            item: u8::from_le_bytes([buffer[10]]),
            item_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.style).unwrap();
        self.style_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item).unwrap();
        self.item_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyInitchar {
    fn id(&self) -> &str {
       "0x7500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyUpdatechar {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub style: i16,
    pub style_raw: [u8; 2],
    pub item: u8,
    pub item_raw: [u8; 1],
}

impl PacketZcNotifyUpdatechar {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyUpdatechar {
        PacketZcNotifyUpdatechar {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            style: i16::from_le_bytes([buffer[6], buffer[7]]),
            style_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            item: u8::from_le_bytes([buffer[8]]),
            item_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.style).unwrap();
        self.style_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item).unwrap();
        self.item_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyUpdatechar {
    fn id(&self) -> &str {
       "0x7600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyUpdateplayer {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub style: i16,
    pub style_raw: [u8; 2],
    pub item: u8,
    pub item_raw: [u8; 1],
}

impl PacketZcNotifyUpdateplayer {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyUpdateplayer {
        PacketZcNotifyUpdateplayer {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            style: i16::from_le_bytes([buffer[2], buffer[3]]),
            style_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item: u8::from_le_bytes([buffer[4]]),
            item_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.style).unwrap();
        self.style_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item).unwrap();
        self.item_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyUpdateplayer {
    fn id(&self) -> &str {
       "0x7700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyStandentry {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub objecttype: u8,
    pub objecttype_raw: [u8; 1],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub speed: i16,
    pub speed_raw: [u8; 2],
    pub body_state: i16,
    pub body_state_raw: [u8; 2],
    pub health_state: i16,
    pub health_state_raw: [u8; 2],
    pub effect_state: i16,
    pub effect_state_raw: [u8; 2],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub weapon: i16,
    pub weapon_raw: [u8; 2],
    pub accessory: i16,
    pub accessory_raw: [u8; 2],
    pub shield: i16,
    pub shield_raw: [u8; 2],
    pub accessory2: i16,
    pub accessory2_raw: [u8; 2],
    pub accessory3: i16,
    pub accessory3_raw: [u8; 2],
    pub headpalette: i16,
    pub headpalette_raw: [u8; 2],
    pub bodypalette: i16,
    pub bodypalette_raw: [u8; 2],
    pub head_dir: i16,
    pub head_dir_raw: [u8; 2],
    pub guid: u32,
    pub guid_raw: [u8; 4],
    pub gemblem_ver: i16,
    pub gemblem_ver_raw: [u8; 2],
    pub honor: i16,
    pub honor_raw: [u8; 2],
    pub virtue: i16,
    pub virtue_raw: [u8; 2],
    pub is_pkmode_on: bool,
    pub is_pkmode_on_raw: [u8; 1],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub pos_dir: [char; 3],
    pub pos_dir_raw: [u8; 3],
    pub x_size: u8,
    pub x_size_raw: [u8; 1],
    pub y_size: u8,
    pub y_size_raw: [u8; 1],
    pub state: u8,
    pub state_raw: [u8; 1],
    pub clevel: i16,
    pub clevel_raw: [u8; 2],
}

impl PacketZcNotifyStandentry {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyStandentry {
        PacketZcNotifyStandentry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            objecttype: u8::from_le_bytes([buffer[2]]),
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            gid: u32::from_le_bytes([buffer[3], buffer[4], buffer[5], buffer[6]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[3..7]);
                dst
            },
            speed: i16::from_le_bytes([buffer[7], buffer[8]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[7..9]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[9], buffer[10]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[11], buffer[12]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            effect_state: i16::from_le_bytes([buffer[13], buffer[14]]),
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[13..15]);
                dst
            },
            job: i16::from_le_bytes([buffer[15], buffer[16]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[15..17]);
                dst
            },
            head: i16::from_le_bytes([buffer[17], buffer[18]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[17..19]);
                dst
            },
            weapon: i16::from_le_bytes([buffer[19], buffer[20]]),
            weapon_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[21], buffer[22]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[21..23]);
                dst
            },
            shield: i16::from_le_bytes([buffer[23], buffer[24]]),
            shield_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[23..25]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[25], buffer[26]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[25..27]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[27], buffer[28]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[27..29]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[29], buffer[30]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[29..31]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[31], buffer[32]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[31..33]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[33], buffer[34]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            guid: u32::from_le_bytes([buffer[35], buffer[36], buffer[37], buffer[38]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[35..39]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[39], buffer[40]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[39..41]);
                dst
            },
            honor: i16::from_le_bytes([buffer[41], buffer[42]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[41..43]);
                dst
            },
            virtue: i16::from_le_bytes([buffer[43], buffer[44]]),
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[43..45]);
                dst
            },
            is_pkmode_on: buffer[45] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[45..46]);
                dst
            },
            sex: u8::from_le_bytes([buffer[46]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[46..47]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[47..50].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[47..50]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[50]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[50..51]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[51]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[51..52]);
                dst
            },
            state: u8::from_le_bytes([buffer[52]]),
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[52..53]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[53], buffer[54]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[53..55]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyStandentry {
    fn id(&self) -> &str {
       "0x7800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyNewentry {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub speed: i16,
    pub speed_raw: [u8; 2],
    pub body_state: i16,
    pub body_state_raw: [u8; 2],
    pub health_state: i16,
    pub health_state_raw: [u8; 2],
    pub effect_state: i16,
    pub effect_state_raw: [u8; 2],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub weapon: i16,
    pub weapon_raw: [u8; 2],
    pub accessory: i16,
    pub accessory_raw: [u8; 2],
    pub shield: i16,
    pub shield_raw: [u8; 2],
    pub accessory2: i16,
    pub accessory2_raw: [u8; 2],
    pub accessory3: i16,
    pub accessory3_raw: [u8; 2],
    pub headpalette: i16,
    pub headpalette_raw: [u8; 2],
    pub bodypalette: i16,
    pub bodypalette_raw: [u8; 2],
    pub head_dir: i16,
    pub head_dir_raw: [u8; 2],
    pub guid: u32,
    pub guid_raw: [u8; 4],
    pub gemblem_ver: i16,
    pub gemblem_ver_raw: [u8; 2],
    pub honor: i16,
    pub honor_raw: [u8; 2],
    pub virtue: i16,
    pub virtue_raw: [u8; 2],
    pub is_pkmode_on: bool,
    pub is_pkmode_on_raw: [u8; 1],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub pos_dir: [char; 3],
    pub pos_dir_raw: [u8; 3],
    pub x_size: u8,
    pub x_size_raw: [u8; 1],
    pub y_size: u8,
    pub y_size_raw: [u8; 1],
    pub clevel: i16,
    pub clevel_raw: [u8; 2],
}

impl PacketZcNotifyNewentry {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyNewentry {
        PacketZcNotifyNewentry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i16::from_le_bytes([buffer[12], buffer[13]]),
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: i16::from_le_bytes([buffer[14], buffer[15]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            head: i16::from_le_bytes([buffer[16], buffer[17]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            weapon: i16::from_le_bytes([buffer[18], buffer[19]]),
            weapon_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[20], buffer[21]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
            shield: i16::from_le_bytes([buffer[22], buffer[23]]),
            shield_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[22..24]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[24], buffer[25]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[26], buffer[27]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[28], buffer[29]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[30], buffer[31]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[32], buffer[33]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            guid: u32::from_le_bytes([buffer[34], buffer[35], buffer[36], buffer[37]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[34..38]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[38], buffer[39]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[38..40]);
                dst
            },
            honor: i16::from_le_bytes([buffer[40], buffer[41]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            virtue: i16::from_le_bytes([buffer[42], buffer[43]]),
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            is_pkmode_on: buffer[44] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[44..45]);
                dst
            },
            sex: u8::from_le_bytes([buffer[45]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[45..46]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[46..49].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[46..49]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[49]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[50]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[50..51]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[51], buffer[52]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[51..53]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyNewentry {
    fn id(&self) -> &str {
       "0x7900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyActentry {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub speed: i16,
    pub speed_raw: [u8; 2],
    pub body_state: i16,
    pub body_state_raw: [u8; 2],
    pub health_state: i16,
    pub health_state_raw: [u8; 2],
    pub effect_state: i16,
    pub effect_state_raw: [u8; 2],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub weapon: i16,
    pub weapon_raw: [u8; 2],
    pub accessory: i16,
    pub accessory_raw: [u8; 2],
    pub shield: i16,
    pub shield_raw: [u8; 2],
    pub accessory2: i16,
    pub accessory2_raw: [u8; 2],
    pub accessory3: i16,
    pub accessory3_raw: [u8; 2],
    pub headpalette: i16,
    pub headpalette_raw: [u8; 2],
    pub bodypalette: i16,
    pub bodypalette_raw: [u8; 2],
    pub head_dir: i16,
    pub head_dir_raw: [u8; 2],
    pub guid: u32,
    pub guid_raw: [u8; 4],
    pub gemblem_ver: i16,
    pub gemblem_ver_raw: [u8; 2],
    pub honor: i16,
    pub honor_raw: [u8; 2],
    pub virtue: i16,
    pub virtue_raw: [u8; 2],
    pub is_pkmode_on: bool,
    pub is_pkmode_on_raw: [u8; 1],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub pos_dir: [char; 3],
    pub pos_dir_raw: [u8; 3],
    pub x_size: u8,
    pub x_size_raw: [u8; 1],
    pub y_size: u8,
    pub y_size_raw: [u8; 1],
    pub action: u8,
    pub action_raw: [u8; 1],
    pub act_start_time: u32,
    pub act_start_time_raw: [u8; 4],
    pub clevel: i16,
    pub clevel_raw: [u8; 2],
}

impl PacketZcNotifyActentry {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyActentry {
        PacketZcNotifyActentry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i16::from_le_bytes([buffer[12], buffer[13]]),
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: i16::from_le_bytes([buffer[14], buffer[15]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            head: i16::from_le_bytes([buffer[16], buffer[17]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            weapon: i16::from_le_bytes([buffer[18], buffer[19]]),
            weapon_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[20], buffer[21]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
            shield: i16::from_le_bytes([buffer[22], buffer[23]]),
            shield_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[22..24]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[24], buffer[25]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[26], buffer[27]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[28], buffer[29]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[30], buffer[31]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[32], buffer[33]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            guid: u32::from_le_bytes([buffer[34], buffer[35], buffer[36], buffer[37]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[34..38]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[38], buffer[39]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[38..40]);
                dst
            },
            honor: i16::from_le_bytes([buffer[40], buffer[41]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            virtue: i16::from_le_bytes([buffer[42], buffer[43]]),
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            is_pkmode_on: buffer[44] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[44..45]);
                dst
            },
            sex: u8::from_le_bytes([buffer[45]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[45..46]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[46..49].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[46..49]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[49]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[50]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[50..51]);
                dst
            },
            action: u8::from_le_bytes([buffer[51]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[51..52]);
                dst
            },
            act_start_time: u32::from_le_bytes([buffer[52], buffer[53], buffer[54], buffer[55]]),
            act_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[52..56]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[56], buffer[57]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[56..58]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.act_start_time).unwrap();
        self.act_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyActentry {
    fn id(&self) -> &str {
       "0x7a00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyMoveentry {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub speed: i16,
    pub speed_raw: [u8; 2],
    pub body_state: i16,
    pub body_state_raw: [u8; 2],
    pub health_state: i16,
    pub health_state_raw: [u8; 2],
    pub effect_state: i16,
    pub effect_state_raw: [u8; 2],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub weapon: i16,
    pub weapon_raw: [u8; 2],
    pub accessory: i16,
    pub accessory_raw: [u8; 2],
    pub move_start_time: u32,
    pub move_start_time_raw: [u8; 4],
    pub shield: i16,
    pub shield_raw: [u8; 2],
    pub accessory2: i16,
    pub accessory2_raw: [u8; 2],
    pub accessory3: i16,
    pub accessory3_raw: [u8; 2],
    pub headpalette: i16,
    pub headpalette_raw: [u8; 2],
    pub bodypalette: i16,
    pub bodypalette_raw: [u8; 2],
    pub head_dir: i16,
    pub head_dir_raw: [u8; 2],
    pub guid: u32,
    pub guid_raw: [u8; 4],
    pub gemblem_ver: i16,
    pub gemblem_ver_raw: [u8; 2],
    pub honor: i16,
    pub honor_raw: [u8; 2],
    pub virtue: i16,
    pub virtue_raw: [u8; 2],
    pub is_pkmode_on: bool,
    pub is_pkmode_on_raw: [u8; 1],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub move_data: [u16; 6],
    pub move_data_raw: [u8; 6],
    pub x_size: u8,
    pub x_size_raw: [u8; 1],
    pub y_size: u8,
    pub y_size_raw: [u8; 1],
    pub clevel: i16,
    pub clevel_raw: [u8; 2],
}

impl PacketZcNotifyMoveentry {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMoveentry {
        PacketZcNotifyMoveentry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i16::from_le_bytes([buffer[12], buffer[13]]),
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: i16::from_le_bytes([buffer[14], buffer[15]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            head: i16::from_le_bytes([buffer[16], buffer[17]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            weapon: i16::from_le_bytes([buffer[18], buffer[19]]),
            weapon_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[20], buffer[21]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
            move_start_time: u32::from_le_bytes([buffer[22], buffer[23], buffer[24], buffer[25]]),
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[22..26]);
                dst
            },
            shield: i16::from_le_bytes([buffer[26], buffer[27]]),
            shield_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[28], buffer[29]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[30], buffer[31]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[32], buffer[33]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[34], buffer[35]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[36], buffer[37]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[36..38]);
                dst
            },
            guid: u32::from_le_bytes([buffer[38], buffer[39], buffer[40], buffer[41]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[38..42]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[42], buffer[43]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            honor: i16::from_le_bytes([buffer[44], buffer[45]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[44..46]);
                dst
            },
            virtue: i16::from_le_bytes([buffer[46], buffer[47]]),
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[46..48]);
                dst
            },
            is_pkmode_on: buffer[48] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[48..49]);
                dst
            },
            sex: u8::from_le_bytes([buffer[49]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            move_data:  {
                let mut dst: [u16; 6] = [0 as u16; 6];
                for (index, byte) in buffer[50..56].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            },
            move_data_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[50..56]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[56]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[56..57]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[57]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[57..58]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[58], buffer[59]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[58..60]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyMoveentry {
    fn id(&self) -> &str {
       "0x7b00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyStandentryNpc {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub objecttype: u8,
    pub objecttype_raw: [u8; 1],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub speed: i16,
    pub speed_raw: [u8; 2],
    pub body_state: i16,
    pub body_state_raw: [u8; 2],
    pub health_state: i16,
    pub health_state_raw: [u8; 2],
    pub effect_state: i16,
    pub effect_state_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub weapon: i16,
    pub weapon_raw: [u8; 2],
    pub accessory: i16,
    pub accessory_raw: [u8; 2],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub shield: i16,
    pub shield_raw: [u8; 2],
    pub accessory2: i16,
    pub accessory2_raw: [u8; 2],
    pub accessory3: i16,
    pub accessory3_raw: [u8; 2],
    pub headpalette: i16,
    pub headpalette_raw: [u8; 2],
    pub bodypalette: i16,
    pub bodypalette_raw: [u8; 2],
    pub head_dir: i16,
    pub head_dir_raw: [u8; 2],
    pub is_pkmode_on: bool,
    pub is_pkmode_on_raw: [u8; 1],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub pos_dir: [char; 3],
    pub pos_dir_raw: [u8; 3],
    pub x_size: u8,
    pub x_size_raw: [u8; 1],
    pub y_size: u8,
    pub y_size_raw: [u8; 1],
}

impl PacketZcNotifyStandentryNpc {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyStandentryNpc {
        PacketZcNotifyStandentryNpc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            objecttype: u8::from_le_bytes([buffer[2]]),
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            gid: u32::from_le_bytes([buffer[3], buffer[4], buffer[5], buffer[6]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[3..7]);
                dst
            },
            speed: i16::from_le_bytes([buffer[7], buffer[8]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[7..9]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[9], buffer[10]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[11], buffer[12]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            effect_state: i16::from_le_bytes([buffer[13], buffer[14]]),
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[13..15]);
                dst
            },
            head: i16::from_le_bytes([buffer[15], buffer[16]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[15..17]);
                dst
            },
            weapon: i16::from_le_bytes([buffer[17], buffer[18]]),
            weapon_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[17..19]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[19], buffer[20]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            job: i16::from_le_bytes([buffer[21], buffer[22]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[21..23]);
                dst
            },
            shield: i16::from_le_bytes([buffer[23], buffer[24]]),
            shield_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[23..25]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[25], buffer[26]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[25..27]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[27], buffer[28]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[27..29]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[29], buffer[30]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[29..31]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[31], buffer[32]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[31..33]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[33], buffer[34]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            is_pkmode_on: buffer[35] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[35..36]);
                dst
            },
            sex: u8::from_le_bytes([buffer[36]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[36..37]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[37..40].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[37..40]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[40]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[40..41]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[41]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[41..42]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyStandentryNpc {
    fn id(&self) -> &str {
       "0x7c00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzNotifyActorinit {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzNotifyActorinit {
    pub fn from(buffer: &[u8]) -> PacketCzNotifyActorinit {
        PacketCzNotifyActorinit {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzNotifyActorinit {
    fn id(&self) -> &str {
       "0x7d00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRequestTime {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub client_time: u32,
    pub client_time_raw: [u8; 4],
}

impl PacketCzRequestTime {
    pub fn from(buffer: &[u8]) -> PacketCzRequestTime {
        PacketCzRequestTime {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            client_time: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            client_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.client_time).unwrap();
        self.client_time_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzRequestTime {
    fn id(&self) -> &str {
       "0x7e00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyTime {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub time: u32,
    pub time_raw: [u8; 4],
}

impl PacketZcNotifyTime {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyTime {
        PacketZcNotifyTime {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            time: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.time).unwrap();
        self.time_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyTime {
    fn id(&self) -> &str {
       "0x7f00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyVanish {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub atype: u8,
    pub atype_raw: [u8; 1],
}

impl PacketZcNotifyVanish {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyVanish {
        PacketZcNotifyVanish {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyVanish {
    fn id(&self) -> &str {
       "0x8000"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketScNotifyBan {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub error_code: u8,
    pub error_code_raw: [u8; 1],
}

impl PacketScNotifyBan {
    pub fn from(buffer: &[u8]) -> PacketScNotifyBan {
        PacketScNotifyBan {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: u8::from_le_bytes([buffer[2]]),
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketScNotifyBan {
    fn id(&self) -> &str {
       "0x8100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRequestQuit {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzRequestQuit {
    pub fn from(buffer: &[u8]) -> PacketCzRequestQuit {
        PacketCzRequestQuit {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzRequestQuit {
    fn id(&self) -> &str {
       "0x8200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAcceptQuit {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketZcAcceptQuit {
    pub fn from(buffer: &[u8]) -> PacketZcAcceptQuit {
        PacketZcAcceptQuit {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAcceptQuit {
    fn id(&self) -> &str {
       "0x8300"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcRefuseQuit {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketZcRefuseQuit {
    pub fn from(buffer: &[u8]) -> PacketZcRefuseQuit {
        PacketZcRefuseQuit {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcRefuseQuit {
    fn id(&self) -> &str {
       "0x8400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRequestMove {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub dest: [char; 3],
    pub dest_raw: [u8; 3],
}

impl PacketCzRequestMove {
    pub fn from(buffer: &[u8]) -> PacketCzRequestMove {
        PacketCzRequestMove {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            dest:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[2..5].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            dest_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[2..5]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.dest {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.dest_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzRequestMove {
    fn id(&self) -> &str {
       "0x8500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyMove {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub move_data: [u16; 6],
    pub move_data_raw: [u8; 6],
    pub move_start_time: u32,
    pub move_start_time_raw: [u8; 4],
}

impl PacketZcNotifyMove {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMove {
        PacketZcNotifyMove {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            move_data:  {
                let mut dst: [u16; 6] = [0 as u16; 6];
                for (index, byte) in buffer[6..12].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            },
            move_data_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[6..12]);
                dst
            },
            move_start_time: u32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyMove {
    fn id(&self) -> &str {
       "0x8600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyPlayermove {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub move_start_time: u32,
    pub move_start_time_raw: [u8; 4],
    pub move_data: [u16; 6],
    pub move_data_raw: [u8; 6],
}

impl PacketZcNotifyPlayermove {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyPlayermove {
        PacketZcNotifyPlayermove {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            move_start_time: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            move_data:  {
                let mut dst: [u16; 6] = [0 as u16; 6];
                for (index, byte) in buffer[6..12].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            },
            move_data_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[6..12]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyPlayermove {
    fn id(&self) -> &str {
       "0x8700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcStopmove {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
}

impl PacketZcStopmove {
    pub fn from(buffer: &[u8]) -> PacketZcStopmove {
        PacketZcStopmove {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[6], buffer[7]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[8], buffer[9]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcStopmove {
    fn id(&self) -> &str {
       "0x8800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRequestAct {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub target_gid: u32,
    pub target_gid_raw: [u8; 4],
    pub action: u8,
    pub action_raw: [u8; 1],
}

impl PacketCzRequestAct {
    pub fn from(buffer: &[u8]) -> PacketCzRequestAct {
        PacketCzRequestAct {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            target_gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            target_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            action: u8::from_le_bytes([buffer[6]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_gid).unwrap();
        self.target_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzRequestAct {
    fn id(&self) -> &str {
       "0x8900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyAct {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub target_gid: u32,
    pub target_gid_raw: [u8; 4],
    pub start_time: u32,
    pub start_time_raw: [u8; 4],
    pub attack_mt: i32,
    pub attack_mt_raw: [u8; 4],
    pub attacked_mt: i32,
    pub attacked_mt_raw: [u8; 4],
    pub damage: i16,
    pub damage_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub action: u8,
    pub action_raw: [u8; 1],
    pub left_damage: i16,
    pub left_damage_raw: [u8; 2],
}

impl PacketZcNotifyAct {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyAct {
        PacketZcNotifyAct {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            target_gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            start_time: u32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            attack_mt: i32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            attack_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
            attacked_mt: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            attacked_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
            damage: i16::from_le_bytes([buffer[22], buffer[23]]),
            damage_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[22..24]);
                dst
            },
            count: i16::from_le_bytes([buffer[24], buffer[25]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            action: u8::from_le_bytes([buffer[26]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[26..27]);
                dst
            },
            left_damage: i16::from_le_bytes([buffer[27], buffer[28]]),
            left_damage_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[27..29]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_gid).unwrap();
        self.target_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attack_mt).unwrap();
        self.attack_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attacked_mt).unwrap();
        self.attacked_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.damage).unwrap();
        self.damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.left_damage).unwrap();
        self.left_damage_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyAct {
    fn id(&self) -> &str {
       "0x8a00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyActPosition {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub target_gid: u32,
    pub target_gid_raw: [u8; 4],
    pub start_time: u32,
    pub start_time_raw: [u8; 4],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
    pub damage: i16,
    pub damage_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub action: u8,
    pub action_raw: [u8; 1],
}

impl PacketZcNotifyActPosition {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyActPosition {
        PacketZcNotifyActPosition {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            target_gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            start_time: u32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[14], buffer[15]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[16], buffer[17]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            damage: i16::from_le_bytes([buffer[18], buffer[19]]),
            damage_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            count: i16::from_le_bytes([buffer[20], buffer[21]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
            action: u8::from_le_bytes([buffer[22]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[22..23]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_gid).unwrap();
        self.target_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.damage).unwrap();
        self.damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyActPosition {
    fn id(&self) -> &str {
       "0x8b00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRequestChat {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketCzRequestChat {
    pub fn from(buffer: &[u8]) -> PacketCzRequestChat {
        PacketCzRequestChat {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            msg_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketCzRequestChat {
    fn id(&self) -> &str {
       "0x8c00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyChat {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketZcNotifyChat {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyChat {
        PacketZcNotifyChat {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            gid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[8..buffer.len()]).to_string(),
            msg_raw: buffer[8..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketZcNotifyChat {
    fn id(&self) -> &str {
       "0x8d00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyPlayerchat {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketZcNotifyPlayerchat {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyPlayerchat {
        PacketZcNotifyPlayerchat {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            msg_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketZcNotifyPlayerchat {
    fn id(&self) -> &str {
       "0x8e00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketServerEntryAck {
    pub raw: Vec<u8>,
    pub header: i16,
    pub header_raw: [u8; 2],
    pub aid: i32,
    pub aid_raw: [u8; 4],
}

impl PacketServerEntryAck {
    pub fn from(buffer: &[u8]) -> PacketServerEntryAck {
        PacketServerEntryAck {
            raw: buffer.to_vec(),
            header: i16::from_le_bytes([buffer[0], buffer[1]]),
            header_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.header).unwrap();
        self.header_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketServerEntryAck {
    fn id(&self) -> &str {
       "0x8f00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzContactnpc {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub naid: u32,
    pub naid_raw: [u8; 4],
    pub atype: u8,
    pub atype_raw: [u8; 1],
}

impl PacketCzContactnpc {
    pub fn from(buffer: &[u8]) -> PacketCzContactnpc {
        PacketCzContactnpc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzContactnpc {
    fn id(&self) -> &str {
       "0x9000"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNpcackMapmove {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub map_name: [char; 16],
    pub map_name_raw: [u8; 16],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
}

impl PacketZcNpcackMapmove {
    pub fn from(buffer: &[u8]) -> PacketZcNpcackMapmove {
        PacketZcNpcackMapmove {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[2..18].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[2..18]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[18], buffer[19]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[20], buffer[21]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNpcackMapmove {
    fn id(&self) -> &str {
       "0x9100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNpcackServermove {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub map_name: [char; 16],
    pub map_name_raw: [u8; 16],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
    pub addr: ZserverAddr,
    pub addr_raw: Vec<u8>,
}

impl PacketZcNpcackServermove {
    pub fn from(buffer: &[u8]) -> PacketZcNpcackServermove {
        PacketZcNpcackServermove {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[2..18].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[2..18]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[18], buffer[19]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[20], buffer[21]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
            addr: ZserverAddr::from(&buffer[22..buffer.len()]),
            addr_raw: buffer[22..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcNpcackServermove {
    fn id(&self) -> &str {
       "0x9200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNpcackEnable {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketZcNpcackEnable {
    pub fn from(buffer: &[u8]) -> PacketZcNpcackEnable {
        PacketZcNpcackEnable {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNpcackEnable {
    fn id(&self) -> &str {
       "0x9300"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqname {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketCzReqname {
    pub fn from(buffer: &[u8]) -> PacketCzReqname {
        PacketCzReqname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqname {
    fn id(&self) -> &str {
       "0x9400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckReqname {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub cname: [char; 24],
    pub cname_raw: [u8; 24],
}

impl PacketZcAckReqname {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqname {
        PacketZcAckReqname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            cname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            cname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.cname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.cname_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckReqname {
    fn id(&self) -> &str {
       "0x9500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzWhisper {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub receiver: [char; 24],
    pub receiver_raw: [u8; 24],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketCzWhisper {
    pub fn from(buffer: &[u8]) -> PacketCzWhisper {
        PacketCzWhisper {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            receiver:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            receiver_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[44..buffer.len()]).to_string(),
            msg_raw: buffer[44..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.receiver {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.receiver_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketCzWhisper {
    fn id(&self) -> &str {
       "0x9600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcWhisper {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub sender: [char; 24],
    pub sender_raw: [u8; 24],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketZcWhisper {
    pub fn from(buffer: &[u8]) -> PacketZcWhisper {
        PacketZcWhisper {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            sender:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            sender_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[44..buffer.len()]).to_string(),
            msg_raw: buffer[44..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sender {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sender_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketZcWhisper {
    fn id(&self) -> &str {
       "0x9700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckWhisper {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcAckWhisper {
    pub fn from(buffer: &[u8]) -> PacketZcAckWhisper {
        PacketZcAckWhisper {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckWhisper {
    fn id(&self) -> &str {
       "0x9800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzBroadcast {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketCzBroadcast {
    pub fn from(buffer: &[u8]) -> PacketCzBroadcast {
        PacketCzBroadcast {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            msg_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketCzBroadcast {
    fn id(&self) -> &str {
       "0x9900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcBroadcast {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketZcBroadcast {
    pub fn from(buffer: &[u8]) -> PacketZcBroadcast {
        PacketZcBroadcast {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            msg_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketZcBroadcast {
    fn id(&self) -> &str {
       "0x9a00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzChangeDirection {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub head_dir: i16,
    pub head_dir_raw: [u8; 2],
    pub dir: u8,
    pub dir_raw: [u8; 1],
}

impl PacketCzChangeDirection {
    pub fn from(buffer: &[u8]) -> PacketCzChangeDirection {
        PacketCzChangeDirection {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[2], buffer[3]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            dir: u8::from_le_bytes([buffer[4]]),
            dir_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dir).unwrap();
        self.dir_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzChangeDirection {
    fn id(&self) -> &str {
       "0x9b00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcChangeDirection {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub head_dir: i16,
    pub head_dir_raw: [u8; 2],
    pub dir: u8,
    pub dir_raw: [u8; 1],
}

impl PacketZcChangeDirection {
    pub fn from(buffer: &[u8]) -> PacketZcChangeDirection {
        PacketZcChangeDirection {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[6], buffer[7]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            dir: u8::from_le_bytes([buffer[8]]),
            dir_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dir).unwrap();
        self.dir_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcChangeDirection {
    fn id(&self) -> &str {
       "0x9c00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcItemEntry {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub itaid: u32,
    pub itaid_raw: [u8; 4],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub sub_x: u8,
    pub sub_x_raw: [u8; 1],
    pub sub_y: u8,
    pub sub_y_raw: [u8; 1],
}

impl PacketZcItemEntry {
    pub fn from(buffer: &[u8]) -> PacketZcItemEntry {
        PacketZcItemEntry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itaid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            itaid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            itid: u16::from_le_bytes([buffer[6], buffer[7]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            is_identified: buffer[8] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[9], buffer[10]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[11], buffer[12]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            count: i16::from_le_bytes([buffer[13], buffer[14]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[13..15]);
                dst
            },
            sub_x: u8::from_le_bytes([buffer[15]]),
            sub_x_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[15..16]);
                dst
            },
            sub_y: u8::from_le_bytes([buffer[16]]),
            sub_y_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[16..17]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.itaid).unwrap();
        self.itaid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sub_x).unwrap();
        self.sub_x_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sub_y).unwrap();
        self.sub_y_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcItemEntry {
    fn id(&self) -> &str {
       "0x9d00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcItemFallEntry {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub itaid: u32,
    pub itaid_raw: [u8; 4],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
    pub sub_x: u8,
    pub sub_x_raw: [u8; 1],
    pub sub_y: u8,
    pub sub_y_raw: [u8; 1],
    pub count: i16,
    pub count_raw: [u8; 2],
}

impl PacketZcItemFallEntry {
    pub fn from(buffer: &[u8]) -> PacketZcItemFallEntry {
        PacketZcItemFallEntry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itaid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            itaid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            itid: u16::from_le_bytes([buffer[6], buffer[7]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            is_identified: buffer[8] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[9], buffer[10]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[11], buffer[12]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            sub_x: u8::from_le_bytes([buffer[13]]),
            sub_x_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[13..14]);
                dst
            },
            sub_y: u8::from_le_bytes([buffer[14]]),
            sub_y_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
            count: i16::from_le_bytes([buffer[15], buffer[16]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[15..17]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.itaid).unwrap();
        self.itaid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sub_x).unwrap();
        self.sub_x_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sub_y).unwrap();
        self.sub_y_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcItemFallEntry {
    fn id(&self) -> &str {
       "0x9e00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzItemPickup {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub itaid: u32,
    pub itaid_raw: [u8; 4],
}

impl PacketCzItemPickup {
    pub fn from(buffer: &[u8]) -> PacketCzItemPickup {
        PacketCzItemPickup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itaid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            itaid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.itaid).unwrap();
        self.itaid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzItemPickup {
    fn id(&self) -> &str {
       "0x9f00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcItemPickupAck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: u16,
    pub index_raw: [u8; 2],
    pub count: u16,
    pub count_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub is_damaged: bool,
    pub is_damaged_raw: [u8; 1],
    pub refining_level: u8,
    pub refining_level_raw: [u8; 1],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
    pub location: u16,
    pub location_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcItemPickupAck {
    pub fn from(buffer: &[u8]) -> PacketZcItemPickupAck {
        PacketZcItemPickupAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: u16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            itid: u16::from_le_bytes([buffer[6], buffer[7]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            is_identified: buffer[8] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            is_damaged: buffer[9] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[10]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[11..19]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[11..19]);
                dst
            },
            location: u16::from_le_bytes([buffer[19], buffer[20]]),
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            atype: u8::from_le_bytes([buffer[21]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[21..22]);
                dst
            },
            result: u8::from_le_bytes([buffer[22]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[22..23]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcItemPickupAck {
    fn id(&self) -> &str {
       "0xa000"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcItemDisappear {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub itaid: u32,
    pub itaid_raw: [u8; 4],
}

impl PacketZcItemDisappear {
    pub fn from(buffer: &[u8]) -> PacketZcItemDisappear {
        PacketZcItemDisappear {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itaid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            itaid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.itaid).unwrap();
        self.itaid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcItemDisappear {
    fn id(&self) -> &str {
       "0xa100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzItemThrow {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: u16,
    pub index_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
}

impl PacketCzItemThrow {
    pub fn from(buffer: &[u8]) -> PacketCzItemThrow {
        PacketCzItemThrow {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzItemThrow {
    fn id(&self) -> &str {
       "0xa200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNormalItemlist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_info: Vec<NormalitemExtrainfo>,
    pub item_info_raw: Vec<Vec<u8>>,
}

impl PacketZcNormalItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcNormalItemlist {
        let iter_count = &buffer.len() / 10;
        let mut vec_field: Vec<NormalitemExtrainfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 14 * i;
            vec_field.push(NormalitemExtrainfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcNormalItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.serialize());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcNormalItemlist {
    fn id(&self) -> &str {
       "0xa300"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcEquipmentItemlist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_info: Vec<EquipmentitemExtrainfo>,
    pub item_info_raw: Vec<Vec<u8>>,
}

impl PacketZcEquipmentItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcEquipmentItemlist {
        let iter_count = &buffer.len() / 20;
        let mut vec_field: Vec<EquipmentitemExtrainfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 24 * i;
            vec_field.push(EquipmentitemExtrainfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcEquipmentItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.serialize());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcEquipmentItemlist {
    fn id(&self) -> &str {
       "0xa400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcStoreNormalItemlist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_info: Vec<NormalitemExtrainfo>,
    pub item_info_raw: Vec<Vec<u8>>,
}

impl PacketZcStoreNormalItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcStoreNormalItemlist {
        let iter_count = &buffer.len() / 10;
        let mut vec_field: Vec<NormalitemExtrainfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 14 * i;
            vec_field.push(NormalitemExtrainfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcStoreNormalItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.serialize());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcStoreNormalItemlist {
    fn id(&self) -> &str {
       "0xa500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcStoreEquipmentItemlist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_info: Vec<EquipmentitemExtrainfo>,
    pub item_info_raw: Vec<Vec<u8>>,
}

impl PacketZcStoreEquipmentItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcStoreEquipmentItemlist {
        let iter_count = &buffer.len() / 20;
        let mut vec_field: Vec<EquipmentitemExtrainfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 24 * i;
            vec_field.push(EquipmentitemExtrainfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcStoreEquipmentItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.serialize());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcStoreEquipmentItemlist {
    fn id(&self) -> &str {
       "0xa600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzUseItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: u16,
    pub index_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketCzUseItem {
    pub fn from(buffer: &[u8]) -> PacketCzUseItem {
        PacketCzUseItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzUseItem {
    fn id(&self) -> &str {
       "0xa700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcUseItemAck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: u16,
    pub index_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub result: bool,
    pub result_raw: [u8; 1],
}

impl PacketZcUseItemAck {
    pub fn from(buffer: &[u8]) -> PacketZcUseItemAck {
        PacketZcUseItemAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            result: buffer[6] == 1,
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcUseItemAck {
    fn id(&self) -> &str {
       "0xa800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqWearEquip {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: u16,
    pub index_raw: [u8; 2],
    pub wear_location: u16,
    pub wear_location_raw: [u8; 2],
}

impl PacketCzReqWearEquip {
    pub fn from(buffer: &[u8]) -> PacketCzReqWearEquip {
        PacketCzReqWearEquip {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            wear_location: u16::from_le_bytes([buffer[4], buffer[5]]),
            wear_location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_location).unwrap();
        self.wear_location_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqWearEquip {
    fn id(&self) -> &str {
       "0xa900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcReqWearEquipAck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: u16,
    pub index_raw: [u8; 2],
    pub wear_location: u16,
    pub wear_location_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcReqWearEquipAck {
    pub fn from(buffer: &[u8]) -> PacketZcReqWearEquipAck {
        PacketZcReqWearEquipAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            wear_location: u16::from_le_bytes([buffer[4], buffer[5]]),
            wear_location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            result: u8::from_le_bytes([buffer[6]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_location).unwrap();
        self.wear_location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcReqWearEquipAck {
    fn id(&self) -> &str {
       "0xaa00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqTakeoffEquip {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: u16,
    pub index_raw: [u8; 2],
}

impl PacketCzReqTakeoffEquip {
    pub fn from(buffer: &[u8]) -> PacketCzReqTakeoffEquip {
        PacketCzReqTakeoffEquip {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqTakeoffEquip {
    fn id(&self) -> &str {
       "0xab00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcReqTakeoffEquipAck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: u16,
    pub index_raw: [u8; 2],
    pub wear_location: u16,
    pub wear_location_raw: [u8; 2],
    pub result: bool,
    pub result_raw: [u8; 1],
}

impl PacketZcReqTakeoffEquipAck {
    pub fn from(buffer: &[u8]) -> PacketZcReqTakeoffEquipAck {
        PacketZcReqTakeoffEquipAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            wear_location: u16::from_le_bytes([buffer[4], buffer[5]]),
            wear_location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            result: buffer[6] == 1,
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_location).unwrap();
        self.wear_location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcReqTakeoffEquipAck {
    fn id(&self) -> &str {
       "0xac00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcItemThrowAck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: u16,
    pub index_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
}

impl PacketZcItemThrowAck {
    pub fn from(buffer: &[u8]) -> PacketZcItemThrowAck {
        PacketZcItemThrowAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcItemThrowAck {
    fn id(&self) -> &str {
       "0xaf00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcParChange {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub var_id: u16,
    pub var_id_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
}

impl PacketZcParChange {
    pub fn from(buffer: &[u8]) -> PacketZcParChange {
        PacketZcParChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            var_id: u16::from_le_bytes([buffer[2], buffer[3]]),
            var_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var_id).unwrap();
        self.var_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcParChange {
    fn id(&self) -> &str {
       "0xb000"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcLongparChange {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub var_id: u16,
    pub var_id_raw: [u8; 2],
    pub amount: i32,
    pub amount_raw: [u8; 4],
}

impl PacketZcLongparChange {
    pub fn from(buffer: &[u8]) -> PacketZcLongparChange {
        PacketZcLongparChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            var_id: u16::from_le_bytes([buffer[2], buffer[3]]),
            var_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            amount: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            amount_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var_id).unwrap();
        self.var_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.amount).unwrap();
        self.amount_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcLongparChange {
    fn id(&self) -> &str {
       "0xb100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRestart {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
}

impl PacketCzRestart {
    pub fn from(buffer: &[u8]) -> PacketCzRestart {
        PacketCzRestart {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: u8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzRestart {
    fn id(&self) -> &str {
       "0xb200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcRestartAck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
}

impl PacketZcRestartAck {
    pub fn from(buffer: &[u8]) -> PacketZcRestartAck {
        PacketZcRestartAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: u8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcRestartAck {
    fn id(&self) -> &str {
       "0xb300"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSayDialog {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub naid: u32,
    pub naid_raw: [u8; 4],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketZcSayDialog {
    pub fn from(buffer: &[u8]) -> PacketZcSayDialog {
        PacketZcSayDialog {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            naid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[8..buffer.len()]).to_string(),
            msg_raw: buffer[8..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketZcSayDialog {
    fn id(&self) -> &str {
       "0xb400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcWaitDialog {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub naid: u32,
    pub naid_raw: [u8; 4],
}

impl PacketZcWaitDialog {
    pub fn from(buffer: &[u8]) -> PacketZcWaitDialog {
        PacketZcWaitDialog {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcWaitDialog {
    fn id(&self) -> &str {
       "0xb500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcCloseDialog {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub naid: u32,
    pub naid_raw: [u8; 4],
}

impl PacketZcCloseDialog {
    pub fn from(buffer: &[u8]) -> PacketZcCloseDialog {
        PacketZcCloseDialog {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcCloseDialog {
    fn id(&self) -> &str {
       "0xb600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMenuList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub naid: u32,
    pub naid_raw: [u8; 4],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketZcMenuList {
    pub fn from(buffer: &[u8]) -> PacketZcMenuList {
        PacketZcMenuList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            naid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[8..buffer.len()]).to_string(),
            msg_raw: buffer[8..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketZcMenuList {
    fn id(&self) -> &str {
       "0xb700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzChooseMenu {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub naid: u32,
    pub naid_raw: [u8; 4],
    pub num: u8,
    pub num_raw: [u8; 1],
}

impl PacketCzChooseMenu {
    pub fn from(buffer: &[u8]) -> PacketCzChooseMenu {
        PacketCzChooseMenu {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            num: u8::from_le_bytes([buffer[6]]),
            num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.num).unwrap();
        self.num_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzChooseMenu {
    fn id(&self) -> &str {
       "0xb800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqNextScript {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub naid: u32,
    pub naid_raw: [u8; 4],
}

impl PacketCzReqNextScript {
    pub fn from(buffer: &[u8]) -> PacketCzReqNextScript {
        PacketCzReqNextScript {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqNextScript {
    fn id(&self) -> &str {
       "0xb900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqStatus {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzReqStatus {
    pub fn from(buffer: &[u8]) -> PacketCzReqStatus {
        PacketCzReqStatus {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqStatus {
    fn id(&self) -> &str {
       "0xba00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzStatusChange {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub status_id: u16,
    pub status_id_raw: [u8; 2],
    pub change_amount: u8,
    pub change_amount_raw: [u8; 1],
}

impl PacketCzStatusChange {
    pub fn from(buffer: &[u8]) -> PacketCzStatusChange {
        PacketCzStatusChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            status_id: u16::from_le_bytes([buffer[2], buffer[3]]),
            status_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            change_amount: u8::from_le_bytes([buffer[4]]),
            change_amount_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.status_id).unwrap();
        self.status_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.change_amount).unwrap();
        self.change_amount_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzStatusChange {
    fn id(&self) -> &str {
       "0xbb00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcStatusChangeAck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub status_id: u16,
    pub status_id_raw: [u8; 2],
    pub result: bool,
    pub result_raw: [u8; 1],
    pub value: u8,
    pub value_raw: [u8; 1],
}

impl PacketZcStatusChangeAck {
    pub fn from(buffer: &[u8]) -> PacketZcStatusChangeAck {
        PacketZcStatusChangeAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            status_id: u16::from_le_bytes([buffer[2], buffer[3]]),
            status_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            result: buffer[4] == 1,
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            value: u8::from_le_bytes([buffer[5]]),
            value_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.status_id).unwrap();
        self.status_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcStatusChangeAck {
    fn id(&self) -> &str {
       "0xbc00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcStatus {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub point: i16,
    pub point_raw: [u8; 2],
    pub str: u8,
    pub str_raw: [u8; 1],
    pub standard_str: u8,
    pub standard_str_raw: [u8; 1],
    pub agi: u8,
    pub agi_raw: [u8; 1],
    pub standard_agi: u8,
    pub standard_agi_raw: [u8; 1],
    pub vit: u8,
    pub vit_raw: [u8; 1],
    pub standard_vit: u8,
    pub standard_vit_raw: [u8; 1],
    pub int: u8,
    pub int_raw: [u8; 1],
    pub standard_int: u8,
    pub standard_int_raw: [u8; 1],
    pub dex: u8,
    pub dex_raw: [u8; 1],
    pub standard_dex: u8,
    pub standard_dex_raw: [u8; 1],
    pub luk: u8,
    pub luk_raw: [u8; 1],
    pub standard_luk: u8,
    pub standard_luk_raw: [u8; 1],
    pub att_power: i16,
    pub att_power_raw: [u8; 2],
    pub refining_power: i16,
    pub refining_power_raw: [u8; 2],
    pub max_matt_power: i16,
    pub max_matt_power_raw: [u8; 2],
    pub min_matt_power: i16,
    pub min_matt_power_raw: [u8; 2],
    pub itemdef_power: i16,
    pub itemdef_power_raw: [u8; 2],
    pub plusdef_power: i16,
    pub plusdef_power_raw: [u8; 2],
    pub mdef_power: i16,
    pub mdef_power_raw: [u8; 2],
    pub plusmdef_power: i16,
    pub plusmdef_power_raw: [u8; 2],
    pub hit_success_value: i16,
    pub hit_success_value_raw: [u8; 2],
    pub avoid_success_value: i16,
    pub avoid_success_value_raw: [u8; 2],
    pub plus_avoid_success_value: i16,
    pub plus_avoid_success_value_raw: [u8; 2],
    pub critical_success_value: i16,
    pub critical_success_value_raw: [u8; 2],
    pub aspd: i16,
    pub aspd_raw: [u8; 2],
    pub plus_aspd: i16,
    pub plus_aspd_raw: [u8; 2],
}

impl PacketZcStatus {
    pub fn from(buffer: &[u8]) -> PacketZcStatus {
        PacketZcStatus {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            point: i16::from_le_bytes([buffer[2], buffer[3]]),
            point_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            str: u8::from_le_bytes([buffer[4]]),
            str_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            standard_str: u8::from_le_bytes([buffer[5]]),
            standard_str_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            agi: u8::from_le_bytes([buffer[6]]),
            agi_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            standard_agi: u8::from_le_bytes([buffer[7]]),
            standard_agi_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[7..8]);
                dst
            },
            vit: u8::from_le_bytes([buffer[8]]),
            vit_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            standard_vit: u8::from_le_bytes([buffer[9]]),
            standard_vit_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            int: u8::from_le_bytes([buffer[10]]),
            int_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            standard_int: u8::from_le_bytes([buffer[11]]),
            standard_int_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            dex: u8::from_le_bytes([buffer[12]]),
            dex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
            standard_dex: u8::from_le_bytes([buffer[13]]),
            standard_dex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[13..14]);
                dst
            },
            luk: u8::from_le_bytes([buffer[14]]),
            luk_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
            standard_luk: u8::from_le_bytes([buffer[15]]),
            standard_luk_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[15..16]);
                dst
            },
            att_power: i16::from_le_bytes([buffer[16], buffer[17]]),
            att_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            refining_power: i16::from_le_bytes([buffer[18], buffer[19]]),
            refining_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            max_matt_power: i16::from_le_bytes([buffer[20], buffer[21]]),
            max_matt_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
            min_matt_power: i16::from_le_bytes([buffer[22], buffer[23]]),
            min_matt_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[22..24]);
                dst
            },
            itemdef_power: i16::from_le_bytes([buffer[24], buffer[25]]),
            itemdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            plusdef_power: i16::from_le_bytes([buffer[26], buffer[27]]),
            plusdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            mdef_power: i16::from_le_bytes([buffer[28], buffer[29]]),
            mdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            plusmdef_power: i16::from_le_bytes([buffer[30], buffer[31]]),
            plusmdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            hit_success_value: i16::from_le_bytes([buffer[32], buffer[33]]),
            hit_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            avoid_success_value: i16::from_le_bytes([buffer[34], buffer[35]]),
            avoid_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            plus_avoid_success_value: i16::from_le_bytes([buffer[36], buffer[37]]),
            plus_avoid_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[36..38]);
                dst
            },
            critical_success_value: i16::from_le_bytes([buffer[38], buffer[39]]),
            critical_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[38..40]);
                dst
            },
            aspd: i16::from_le_bytes([buffer[40], buffer[41]]),
            aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            plus_aspd: i16::from_le_bytes([buffer[42], buffer[43]]),
            plus_aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.str).unwrap();
        self.str_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_str).unwrap();
        self.standard_str_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.agi).unwrap();
        self.agi_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_agi).unwrap();
        self.standard_agi_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.vit).unwrap();
        self.vit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_vit).unwrap();
        self.standard_vit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.int).unwrap();
        self.int_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_int).unwrap();
        self.standard_int_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dex).unwrap();
        self.dex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_dex).unwrap();
        self.standard_dex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.luk).unwrap();
        self.luk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_luk).unwrap();
        self.standard_luk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.att_power).unwrap();
        self.att_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.refining_power).unwrap();
        self.refining_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_matt_power).unwrap();
        self.max_matt_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.min_matt_power).unwrap();
        self.min_matt_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.itemdef_power).unwrap();
        self.itemdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plusdef_power).unwrap();
        self.plusdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef_power).unwrap();
        self.mdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plusmdef_power).unwrap();
        self.plusmdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hit_success_value).unwrap();
        self.hit_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.avoid_success_value).unwrap();
        self.avoid_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plus_avoid_success_value).unwrap();
        self.plus_avoid_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.critical_success_value).unwrap();
        self.critical_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.aspd).unwrap();
        self.aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plus_aspd).unwrap();
        self.plus_aspd_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcStatus {
    fn id(&self) -> &str {
       "0xbd00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcStatusChange {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub status_id: u16,
    pub status_id_raw: [u8; 2],
    pub value: u8,
    pub value_raw: [u8; 1],
}

impl PacketZcStatusChange {
    pub fn from(buffer: &[u8]) -> PacketZcStatusChange {
        PacketZcStatusChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            status_id: u16::from_le_bytes([buffer[2], buffer[3]]),
            status_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            value: u8::from_le_bytes([buffer[4]]),
            value_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.status_id).unwrap();
        self.status_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcStatusChange {
    fn id(&self) -> &str {
       "0xbe00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqEmotion {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
}

impl PacketCzReqEmotion {
    pub fn from(buffer: &[u8]) -> PacketCzReqEmotion {
        PacketCzReqEmotion {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: u8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqEmotion {
    fn id(&self) -> &str {
       "0xbf00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcEmotion {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub atype: u8,
    pub atype_raw: [u8; 1],
}

impl PacketZcEmotion {
    pub fn from(buffer: &[u8]) -> PacketZcEmotion {
        PacketZcEmotion {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcEmotion {
    fn id(&self) -> &str {
       "0xc000"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqUserCount {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzReqUserCount {
    pub fn from(buffer: &[u8]) -> PacketCzReqUserCount {
        PacketCzReqUserCount {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqUserCount {
    fn id(&self) -> &str {
       "0xc100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcUserCount {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
}

impl PacketZcUserCount {
    pub fn from(buffer: &[u8]) -> PacketZcUserCount {
        PacketZcUserCount {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            count: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcUserCount {
    fn id(&self) -> &str {
       "0xc200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSpriteChange {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub value: u8,
    pub value_raw: [u8; 1],
}

impl PacketZcSpriteChange {
    pub fn from(buffer: &[u8]) -> PacketZcSpriteChange {
        PacketZcSpriteChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            value: u8::from_le_bytes([buffer[7]]),
            value_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[7..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSpriteChange {
    fn id(&self) -> &str {
       "0xc300"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSelectDealtype {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub naid: u32,
    pub naid_raw: [u8; 4],
}

impl PacketZcSelectDealtype {
    pub fn from(buffer: &[u8]) -> PacketZcSelectDealtype {
        PacketZcSelectDealtype {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSelectDealtype {
    fn id(&self) -> &str {
       "0xc400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzAckSelectDealtype {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub naid: u32,
    pub naid_raw: [u8; 4],
    pub atype: u8,
    pub atype_raw: [u8; 1],
}

impl PacketCzAckSelectDealtype {
    pub fn from(buffer: &[u8]) -> PacketCzAckSelectDealtype {
        PacketCzAckSelectDealtype {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzAckSelectDealtype {
    fn id(&self) -> &str {
       "0xc500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPcPurchaseItemlist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_list: Vec<PurchaseItem>,
    pub item_list_raw: Vec<Vec<u8>>,
}

impl PacketZcPcPurchaseItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcPcPurchaseItemlist {
        let iter_count = &buffer.len() / 11;
        let mut vec_field: Vec<PurchaseItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 15 * i;
            vec_field.push(PurchaseItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPcPurchaseItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.serialize());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcPcPurchaseItemlist {
    fn id(&self) -> &str {
       "0xc600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPcSellItemlist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_list: Vec<SellItem>,
    pub item_list_raw: Vec<Vec<u8>>,
}

impl PacketZcPcSellItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcPcSellItemlist {
        let iter_count = &buffer.len() / 10;
        let mut vec_field: Vec<SellItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 14 * i;
            vec_field.push(SellItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPcSellItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.serialize());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcPcSellItemlist {
    fn id(&self) -> &str {
       "0xc700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzPcPurchaseItemlist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_list: Vec<CzPurchaseItem>,
    pub item_list_raw: Vec<Vec<u8>>,
}

impl PacketCzPcPurchaseItemlist {
    pub fn from(buffer: &[u8]) -> PacketCzPcPurchaseItemlist {
        let iter_count = &buffer.len() / 4;
        let mut vec_field: Vec<CzPurchaseItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 8 * i;
            vec_field.push(CzPurchaseItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzPcPurchaseItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.serialize());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketCzPcPurchaseItemlist {
    fn id(&self) -> &str {
       "0xc800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzPcSellItemlist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_list: Vec<CzSellItem>,
    pub item_list_raw: Vec<Vec<u8>>,
}

impl PacketCzPcSellItemlist {
    pub fn from(buffer: &[u8]) -> PacketCzPcSellItemlist {
        let iter_count = &buffer.len() / 4;
        let mut vec_field: Vec<CzSellItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 8 * i;
            vec_field.push(CzSellItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzPcSellItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.serialize());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketCzPcSellItemlist {
    fn id(&self) -> &str {
       "0xc900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPcPurchaseResult {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcPcPurchaseResult {
    pub fn from(buffer: &[u8]) -> PacketZcPcPurchaseResult {
        PacketZcPcPurchaseResult {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcPcPurchaseResult {
    fn id(&self) -> &str {
       "0xca00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPcSellResult {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcPcSellResult {
    pub fn from(buffer: &[u8]) -> PacketZcPcSellResult {
        PacketZcPcSellResult {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcPcSellResult {
    fn id(&self) -> &str {
       "0xcb00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzDisconnectCharacter {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketCzDisconnectCharacter {
    pub fn from(buffer: &[u8]) -> PacketCzDisconnectCharacter {
        PacketCzDisconnectCharacter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzDisconnectCharacter {
    fn id(&self) -> &str {
       "0xcc00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckDisconnectCharacter {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcAckDisconnectCharacter {
    pub fn from(buffer: &[u8]) -> PacketZcAckDisconnectCharacter {
        PacketZcAckDisconnectCharacter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckDisconnectCharacter {
    fn id(&self) -> &str {
       "0xcd00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzDisconnectAllCharacter {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzDisconnectAllCharacter {
    pub fn from(buffer: &[u8]) -> PacketCzDisconnectAllCharacter {
        PacketCzDisconnectAllCharacter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzDisconnectAllCharacter {
    fn id(&self) -> &str {
       "0xce00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzSettingWhisperPc {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
    pub atype: u8,
    pub atype_raw: [u8; 1],
}

impl PacketCzSettingWhisperPc {
    pub fn from(buffer: &[u8]) -> PacketCzSettingWhisperPc {
        PacketCzSettingWhisperPc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            atype: u8::from_le_bytes([buffer[26]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[26..27]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzSettingWhisperPc {
    fn id(&self) -> &str {
       "0xcf00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzSettingWhisperState {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
}

impl PacketCzSettingWhisperState {
    pub fn from(buffer: &[u8]) -> PacketCzSettingWhisperState {
        PacketCzSettingWhisperState {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: u8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzSettingWhisperState {
    fn id(&self) -> &str {
       "0xd000"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSettingWhisperPc {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcSettingWhisperPc {
    pub fn from(buffer: &[u8]) -> PacketZcSettingWhisperPc {
        PacketZcSettingWhisperPc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: u8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            result: u8::from_le_bytes([buffer[3]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[3..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSettingWhisperPc {
    fn id(&self) -> &str {
       "0xd100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSettingWhisperState {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcSettingWhisperState {
    pub fn from(buffer: &[u8]) -> PacketZcSettingWhisperState {
        PacketZcSettingWhisperState {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: u8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            result: u8::from_le_bytes([buffer[3]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[3..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSettingWhisperState {
    fn id(&self) -> &str {
       "0xd200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqWhisperList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzReqWhisperList {
    pub fn from(buffer: &[u8]) -> PacketCzReqWhisperList {
        PacketCzReqWhisperList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqWhisperList {
    fn id(&self) -> &str {
       "0xd300"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcWhisperList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub wisper_list: Vec<WhisperItem>,
    pub wisper_list_raw: Vec<Vec<u8>>,
}

impl PacketZcWhisperList {
    pub fn from(buffer: &[u8]) -> PacketZcWhisperList {
        let iter_count = &buffer.len() / 24;
        let mut vec_field: Vec<WhisperItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 28 * i;
            vec_field.push(WhisperItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcWhisperList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            wisper_list: vec_field.clone(),
            wisper_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.wisper_list_raw = {
            self.wisper_list.iter_mut().for_each(|item| item.serialize());
            self.wisper_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcWhisperList {
    fn id(&self) -> &str {
       "0xd400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzCreateChatroom {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub size: i16,
    pub size_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub passwd: [char; 8],
    pub passwd_raw: [u8; 8],
    pub title: String,
    pub title_raw: Vec<u8>,
}

impl PacketCzCreateChatroom {
    pub fn from(buffer: &[u8]) -> PacketCzCreateChatroom {
        PacketCzCreateChatroom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            size: i16::from_le_bytes([buffer[4], buffer[5]]),
            size_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            passwd:  {
                let mut dst: [char; 8] = [0 as char; 8];
                for (index, byte) in buffer[7..15].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[7..15]);
                dst
            },
            title: String::from_utf8_lossy(&buffer[15..buffer.len()]).to_string(),
            title_raw: buffer[15..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.size).unwrap();
        self.size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
        self.title_raw = self.title.as_bytes().to_vec()
    }
}

impl Packet for PacketCzCreateChatroom {
    fn id(&self) -> &str {
       "0xd500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckCreateChatroom {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcAckCreateChatroom {
    pub fn from(buffer: &[u8]) -> PacketZcAckCreateChatroom {
        PacketZcAckCreateChatroom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckCreateChatroom {
    fn id(&self) -> &str {
       "0xd600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcRoomNewentry {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub room_id: u32,
    pub room_id_raw: [u8; 4],
    pub maxcount: i16,
    pub maxcount_raw: [u8; 2],
    pub curcount: i16,
    pub curcount_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub title: String,
    pub title_raw: Vec<u8>,
}

impl PacketZcRoomNewentry {
    pub fn from(buffer: &[u8]) -> PacketZcRoomNewentry {
        PacketZcRoomNewentry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            room_id: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            room_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            maxcount: i16::from_le_bytes([buffer[12], buffer[13]]),
            maxcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            curcount: i16::from_le_bytes([buffer[14], buffer[15]]),
            curcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            atype: u8::from_le_bytes([buffer[16]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[16..17]);
                dst
            },
            title: String::from_utf8_lossy(&buffer[17..buffer.len()]).to_string(),
            title_raw: buffer[17..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.room_id).unwrap();
        self.room_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.maxcount).unwrap();
        self.maxcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.curcount).unwrap();
        self.curcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        self.title_raw = self.title.as_bytes().to_vec()
    }
}

impl Packet for PacketZcRoomNewentry {
    fn id(&self) -> &str {
       "0xd700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcDestroyRoom {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub room_id: u32,
    pub room_id_raw: [u8; 4],
}

impl PacketZcDestroyRoom {
    pub fn from(buffer: &[u8]) -> PacketZcDestroyRoom {
        PacketZcDestroyRoom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            room_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            room_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.room_id).unwrap();
        self.room_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcDestroyRoom {
    fn id(&self) -> &str {
       "0xd800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqEnterRoom {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub room_id: u32,
    pub room_id_raw: [u8; 4],
    pub passwd: [char; 8],
    pub passwd_raw: [u8; 8],
}

impl PacketCzReqEnterRoom {
    pub fn from(buffer: &[u8]) -> PacketCzReqEnterRoom {
        PacketCzReqEnterRoom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            room_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            room_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            passwd:  {
                let mut dst: [char; 8] = [0 as char; 8];
                for (index, byte) in buffer[6..14].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[6..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.room_id).unwrap();
        self.room_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqEnterRoom {
    fn id(&self) -> &str {
       "0xd900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcRefuseEnterRoom {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcRefuseEnterRoom {
    pub fn from(buffer: &[u8]) -> PacketZcRefuseEnterRoom {
        PacketZcRefuseEnterRoom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcRefuseEnterRoom {
    fn id(&self) -> &str {
       "0xda00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcEnterRoom {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub room_id: u32,
    pub room_id_raw: [u8; 4],
    pub member_list: Vec<RoomMember>,
    pub member_list_raw: Vec<Vec<u8>>,
}

impl PacketZcEnterRoom {
    pub fn from(buffer: &[u8]) -> PacketZcEnterRoom {
        let iter_count = &buffer.len() / 28;
        let mut vec_field: Vec<RoomMember> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 * i;
            let end_pos = 36 * i;
            vec_field.push(RoomMember::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcEnterRoom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            room_id: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            room_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            member_list: vec_field.clone(),
            member_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.room_id).unwrap();
        self.room_id_raw = wtr.try_into().unwrap();
        self.member_list_raw = {
            self.member_list.iter_mut().for_each(|item| item.serialize());
            self.member_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcEnterRoom {
    fn id(&self) -> &str {
       "0xdb00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMemberNewentry {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub curcount: i16,
    pub curcount_raw: [u8; 2],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
}

impl PacketZcMemberNewentry {
    pub fn from(buffer: &[u8]) -> PacketZcMemberNewentry {
        PacketZcMemberNewentry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            curcount: i16::from_le_bytes([buffer[2], buffer[3]]),
            curcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.curcount).unwrap();
        self.curcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMemberNewentry {
    fn id(&self) -> &str {
       "0xdc00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMemberExit {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub curcount: i16,
    pub curcount_raw: [u8; 2],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
    pub atype: u8,
    pub atype_raw: [u8; 1],
}

impl PacketZcMemberExit {
    pub fn from(buffer: &[u8]) -> PacketZcMemberExit {
        PacketZcMemberExit {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            curcount: i16::from_le_bytes([buffer[2], buffer[3]]),
            curcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
            atype: u8::from_le_bytes([buffer[28]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[28..29]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.curcount).unwrap();
        self.curcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMemberExit {
    fn id(&self) -> &str {
       "0xdd00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzChangeChatroom {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub size: i16,
    pub size_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub passwd: [char; 8],
    pub passwd_raw: [u8; 8],
    pub title: String,
    pub title_raw: Vec<u8>,
}

impl PacketCzChangeChatroom {
    pub fn from(buffer: &[u8]) -> PacketCzChangeChatroom {
        PacketCzChangeChatroom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            size: i16::from_le_bytes([buffer[4], buffer[5]]),
            size_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            passwd:  {
                let mut dst: [char; 8] = [0 as char; 8];
                for (index, byte) in buffer[7..15].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[7..15]);
                dst
            },
            title: String::from_utf8_lossy(&buffer[15..buffer.len()]).to_string(),
            title_raw: buffer[15..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.size).unwrap();
        self.size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
        self.title_raw = self.title.as_bytes().to_vec()
    }
}

impl Packet for PacketCzChangeChatroom {
    fn id(&self) -> &str {
       "0xde00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcChangeChatroom {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub room_id: u32,
    pub room_id_raw: [u8; 4],
    pub maxcount: i16,
    pub maxcount_raw: [u8; 2],
    pub curcount: i16,
    pub curcount_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub title: String,
    pub title_raw: Vec<u8>,
}

impl PacketZcChangeChatroom {
    pub fn from(buffer: &[u8]) -> PacketZcChangeChatroom {
        PacketZcChangeChatroom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            room_id: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            room_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            maxcount: i16::from_le_bytes([buffer[12], buffer[13]]),
            maxcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            curcount: i16::from_le_bytes([buffer[14], buffer[15]]),
            curcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            atype: u8::from_le_bytes([buffer[16]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[16..17]);
                dst
            },
            title: String::from_utf8_lossy(&buffer[17..buffer.len()]).to_string(),
            title_raw: buffer[17..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.room_id).unwrap();
        self.room_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.maxcount).unwrap();
        self.maxcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.curcount).unwrap();
        self.curcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        self.title_raw = self.title.as_bytes().to_vec()
    }
}

impl Packet for PacketZcChangeChatroom {
    fn id(&self) -> &str {
       "0xdf00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqRoleChange {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub role: u32,
    pub role_raw: [u8; 4],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
}

impl PacketCzReqRoleChange {
    pub fn from(buffer: &[u8]) -> PacketCzReqRoleChange {
        PacketCzReqRoleChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            role: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            role_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.role).unwrap();
        self.role_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqRoleChange {
    fn id(&self) -> &str {
       "0xe000"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcRoleChange {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub role: u32,
    pub role_raw: [u8; 4],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
}

impl PacketZcRoleChange {
    pub fn from(buffer: &[u8]) -> PacketZcRoleChange {
        PacketZcRoleChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            role: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            role_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.role).unwrap();
        self.role_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcRoleChange {
    fn id(&self) -> &str {
       "0xe100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqExpelMember {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
}

impl PacketCzReqExpelMember {
    pub fn from(buffer: &[u8]) -> PacketCzReqExpelMember {
        PacketCzReqExpelMember {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqExpelMember {
    fn id(&self) -> &str {
       "0xe200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzExitRoom {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzExitRoom {
    pub fn from(buffer: &[u8]) -> PacketCzExitRoom {
        PacketCzExitRoom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzExitRoom {
    fn id(&self) -> &str {
       "0xe300"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqExchangeItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketCzReqExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketCzReqExchangeItem {
        PacketCzReqExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqExchangeItem {
    fn id(&self) -> &str {
       "0xe400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcReqExchangeItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
}

impl PacketZcReqExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketZcReqExchangeItem {
        PacketZcReqExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcReqExchangeItem {
    fn id(&self) -> &str {
       "0xe500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzAckExchangeItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketCzAckExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketCzAckExchangeItem {
        PacketCzAckExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzAckExchangeItem {
    fn id(&self) -> &str {
       "0xe600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckExchangeItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcAckExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketZcAckExchangeItem {
        PacketZcAckExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckExchangeItem {
    fn id(&self) -> &str {
       "0xe700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzAddExchangeItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
}

impl PacketCzAddExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketCzAddExchangeItem {
        PacketCzAddExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzAddExchangeItem {
    fn id(&self) -> &str {
       "0xe800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAddExchangeItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub is_damaged: bool,
    pub is_damaged_raw: [u8; 1],
    pub refining_level: u8,
    pub refining_level_raw: [u8; 1],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
}

impl PacketZcAddExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketZcAddExchangeItem {
        PacketZcAddExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            count: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            itid: u16::from_le_bytes([buffer[6], buffer[7]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            is_identified: buffer[8] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            is_damaged: buffer[9] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[10]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[11..19]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[11..19]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcAddExchangeItem {
    fn id(&self) -> &str {
       "0xe900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckAddExchangeItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcAckAddExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketZcAckAddExchangeItem {
        PacketZcAckAddExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            result: u8::from_le_bytes([buffer[4]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckAddExchangeItem {
    fn id(&self) -> &str {
       "0xea00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzConcludeExchangeItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzConcludeExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketCzConcludeExchangeItem {
        PacketCzConcludeExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzConcludeExchangeItem {
    fn id(&self) -> &str {
       "0xeb00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcConcludeExchangeItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub who: u8,
    pub who_raw: [u8; 1],
}

impl PacketZcConcludeExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketZcConcludeExchangeItem {
        PacketZcConcludeExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            who: u8::from_le_bytes([buffer[2]]),
            who_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.who).unwrap();
        self.who_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcConcludeExchangeItem {
    fn id(&self) -> &str {
       "0xec00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzCancelExchangeItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzCancelExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketCzCancelExchangeItem {
        PacketCzCancelExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzCancelExchangeItem {
    fn id(&self) -> &str {
       "0xed00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcCancelExchangeItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketZcCancelExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketZcCancelExchangeItem {
        PacketZcCancelExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcCancelExchangeItem {
    fn id(&self) -> &str {
       "0xee00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzExecExchangeItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzExecExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketCzExecExchangeItem {
        PacketCzExecExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzExecExchangeItem {
    fn id(&self) -> &str {
       "0xef00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcExecExchangeItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcExecExchangeItem {
    pub fn from(buffer: &[u8]) -> PacketZcExecExchangeItem {
        PacketZcExecExchangeItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcExecExchangeItem {
    fn id(&self) -> &str {
       "0xf000"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcExchangeitemUndo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketZcExchangeitemUndo {
    pub fn from(buffer: &[u8]) -> PacketZcExchangeitemUndo {
        PacketZcExchangeitemUndo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcExchangeitemUndo {
    fn id(&self) -> &str {
       "0xf100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyStoreitemCountinfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub cur_count: i16,
    pub cur_count_raw: [u8; 2],
    pub max_count: i16,
    pub max_count_raw: [u8; 2],
}

impl PacketZcNotifyStoreitemCountinfo {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyStoreitemCountinfo {
        PacketZcNotifyStoreitemCountinfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            cur_count: i16::from_le_bytes([buffer[2], buffer[3]]),
            cur_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            max_count: i16::from_le_bytes([buffer[4], buffer[5]]),
            max_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.cur_count).unwrap();
        self.cur_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_count).unwrap();
        self.max_count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyStoreitemCountinfo {
    fn id(&self) -> &str {
       "0xf200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzMoveItemFromBodyToStore {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
}

impl PacketCzMoveItemFromBodyToStore {
    pub fn from(buffer: &[u8]) -> PacketCzMoveItemFromBodyToStore {
        PacketCzMoveItemFromBodyToStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzMoveItemFromBodyToStore {
    fn id(&self) -> &str {
       "0xf300"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAddItemToStore {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub is_damaged: bool,
    pub is_damaged_raw: [u8; 1],
    pub refining_level: u8,
    pub refining_level_raw: [u8; 1],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
}

impl PacketZcAddItemToStore {
    pub fn from(buffer: &[u8]) -> PacketZcAddItemToStore {
        PacketZcAddItemToStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            itid: u16::from_le_bytes([buffer[8], buffer[9]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            is_identified: buffer[10] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            is_damaged: buffer[11] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[12]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[13..21]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[13..21]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcAddItemToStore {
    fn id(&self) -> &str {
       "0xf400"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzMoveItemFromStoreToBody {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
}

impl PacketCzMoveItemFromStoreToBody {
    pub fn from(buffer: &[u8]) -> PacketCzMoveItemFromStoreToBody {
        PacketCzMoveItemFromStoreToBody {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzMoveItemFromStoreToBody {
    fn id(&self) -> &str {
       "0xf500"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcDeleteItemFromStore {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
}

impl PacketZcDeleteItemFromStore {
    pub fn from(buffer: &[u8]) -> PacketZcDeleteItemFromStore {
        PacketZcDeleteItemFromStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcDeleteItemFromStore {
    fn id(&self) -> &str {
       "0xf600"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzCloseStore {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzCloseStore {
    pub fn from(buffer: &[u8]) -> PacketCzCloseStore {
        PacketCzCloseStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzCloseStore {
    fn id(&self) -> &str {
       "0xf700"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcCloseStore {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketZcCloseStore {
    pub fn from(buffer: &[u8]) -> PacketZcCloseStore {
        PacketZcCloseStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcCloseStore {
    fn id(&self) -> &str {
       "0xf800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzMakeGroup {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub group_name: [char; 24],
    pub group_name_raw: [u8; 24],
}

impl PacketCzMakeGroup {
    pub fn from(buffer: &[u8]) -> PacketCzMakeGroup {
        PacketCzMakeGroup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            group_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzMakeGroup {
    fn id(&self) -> &str {
       "0xf900"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckMakeGroup {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcAckMakeGroup {
    pub fn from(buffer: &[u8]) -> PacketZcAckMakeGroup {
        PacketZcAckMakeGroup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckMakeGroup {
    fn id(&self) -> &str {
       "0xfa00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcGroupList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub group_name: [char; 24],
    pub group_name_raw: [u8; 24],
    pub group_info: Vec<GroupmemberInfo>,
    pub group_info_raw: Vec<Vec<u8>>,
}

impl PacketZcGroupList {
    pub fn from(buffer: &[u8]) -> PacketZcGroupList {
        let iter_count = &buffer.len() / 46;
        let mut vec_field: Vec<GroupmemberInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 28 * i;
            let end_pos = 74 * i;
            vec_field.push(GroupmemberInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcGroupList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            group_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
            group_info: vec_field.clone(),
            group_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();
        self.group_info_raw = {
            self.group_info.iter_mut().for_each(|item| item.serialize());
            self.group_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcGroupList {
    fn id(&self) -> &str {
       "0xfb00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqJoinGroup {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketCzReqJoinGroup {
    pub fn from(buffer: &[u8]) -> PacketCzReqJoinGroup {
        PacketCzReqJoinGroup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqJoinGroup {
    fn id(&self) -> &str {
       "0xfc00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckReqJoinGroup {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub character_name: [char; 24],
    pub character_name_raw: [u8; 24],
    pub answer: u8,
    pub answer_raw: [u8; 1],
}

impl PacketZcAckReqJoinGroup {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqJoinGroup {
        PacketZcAckReqJoinGroup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            answer: u8::from_le_bytes([buffer[26]]),
            answer_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[26..27]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckReqJoinGroup {
    fn id(&self) -> &str {
       "0xfd00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcReqJoinGroup {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub grid: u32,
    pub grid_raw: [u8; 4],
    pub group_name: [char; 24],
    pub group_name_raw: [u8; 24],
}

impl PacketZcReqJoinGroup {
    pub fn from(buffer: &[u8]) -> PacketZcReqJoinGroup {
        PacketZcReqJoinGroup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            grid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            grid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            group_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.grid).unwrap();
        self.grid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcReqJoinGroup {
    fn id(&self) -> &str {
       "0xfe00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzJoinGroup {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub grid: u32,
    pub grid_raw: [u8; 4],
    pub answer: i32,
    pub answer_raw: [u8; 4],
}

impl PacketCzJoinGroup {
    pub fn from(buffer: &[u8]) -> PacketCzJoinGroup {
        PacketCzJoinGroup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            grid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            grid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            answer: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            answer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.grid).unwrap();
        self.grid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzJoinGroup {
    fn id(&self) -> &str {
       "0xff00"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqLeaveGroup {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzReqLeaveGroup {
    pub fn from(buffer: &[u8]) -> PacketCzReqLeaveGroup {
        PacketCzReqLeaveGroup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqLeaveGroup {
    fn id(&self) -> &str {
       "0x0100"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcGroupinfoChange {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub exp_option: u32,
    pub exp_option_raw: [u8; 4],
}

impl PacketZcGroupinfoChange {
    pub fn from(buffer: &[u8]) -> PacketZcGroupinfoChange {
        PacketZcGroupinfoChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            exp_option: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            exp_option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.exp_option).unwrap();
        self.exp_option_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcGroupinfoChange {
    fn id(&self) -> &str {
       "0x0101"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzChangeGroupexpoption {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub exp_option: u32,
    pub exp_option_raw: [u8; 4],
}

impl PacketCzChangeGroupexpoption {
    pub fn from(buffer: &[u8]) -> PacketCzChangeGroupexpoption {
        PacketCzChangeGroupexpoption {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            exp_option: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            exp_option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.exp_option).unwrap();
        self.exp_option_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzChangeGroupexpoption {
    fn id(&self) -> &str {
       "0x0102"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqExpelGroupMember {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub character_name: [char; 24],
    pub character_name_raw: [u8; 24],
}

impl PacketCzReqExpelGroupMember {
    pub fn from(buffer: &[u8]) -> PacketCzReqExpelGroupMember {
        PacketCzReqExpelGroupMember {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqExpelGroupMember {
    fn id(&self) -> &str {
       "0x0103"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAddMemberToGroup {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub role: u32,
    pub role_raw: [u8; 4],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
    pub state: u8,
    pub state_raw: [u8; 1],
    pub group_name: [char; 24],
    pub group_name_raw: [u8; 24],
    pub character_name: [char; 24],
    pub character_name_raw: [u8; 24],
    pub map_name: [char; 16],
    pub map_name_raw: [u8; 16],
}

impl PacketZcAddMemberToGroup {
    pub fn from(buffer: &[u8]) -> PacketZcAddMemberToGroup {
        PacketZcAddMemberToGroup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            role: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            role_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[10], buffer[11]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[12], buffer[13]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            state: u8::from_le_bytes([buffer[14]]),
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
            group_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[15..39].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[15..39]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[39..63].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[39..63]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[63..79].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[63..79]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.role).unwrap();
        self.role_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAddMemberToGroup {
    fn id(&self) -> &str {
       "0x0104"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcDeleteMemberFromGroup {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub character_name: [char; 24],
    pub character_name_raw: [u8; 24],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcDeleteMemberFromGroup {
    pub fn from(buffer: &[u8]) -> PacketZcDeleteMemberFromGroup {
        PacketZcDeleteMemberFromGroup {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            result: u8::from_le_bytes([buffer[30]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[30..31]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcDeleteMemberFromGroup {
    fn id(&self) -> &str {
       "0x0105"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyHpToGroupm {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub hp: i16,
    pub hp_raw: [u8; 2],
    pub maxhp: i16,
    pub maxhp_raw: [u8; 2],
}

impl PacketZcNotifyHpToGroupm {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyHpToGroupm {
        PacketZcNotifyHpToGroupm {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            hp: i16::from_le_bytes([buffer[6], buffer[7]]),
            hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            maxhp: i16::from_le_bytes([buffer[8], buffer[9]]),
            maxhp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.maxhp).unwrap();
        self.maxhp_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyHpToGroupm {
    fn id(&self) -> &str {
       "0x0106"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyPositionToGroupm {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
}

impl PacketZcNotifyPositionToGroupm {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyPositionToGroupm {
        PacketZcNotifyPositionToGroupm {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[6], buffer[7]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[8], buffer[9]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyPositionToGroupm {
    fn id(&self) -> &str {
       "0x0107"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRequestChatParty {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketCzRequestChatParty {
    pub fn from(buffer: &[u8]) -> PacketCzRequestChatParty {
        PacketCzRequestChatParty {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            msg_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketCzRequestChatParty {
    fn id(&self) -> &str {
       "0x0108"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyChatParty {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketZcNotifyChatParty {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyChatParty {
        PacketZcNotifyChatParty {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[8..buffer.len()]).to_string(),
            msg_raw: buffer[8..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketZcNotifyChatParty {
    fn id(&self) -> &str {
       "0x0109"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMvpGettingItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
}

impl PacketZcMvpGettingItem {
    pub fn from(buffer: &[u8]) -> PacketZcMvpGettingItem {
        PacketZcMvpGettingItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMvpGettingItem {
    fn id(&self) -> &str {
       "0x010a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMvpGettingSpecialExp {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub exp: u32,
    pub exp_raw: [u8; 4],
}

impl PacketZcMvpGettingSpecialExp {
    pub fn from(buffer: &[u8]) -> PacketZcMvpGettingSpecialExp {
        PacketZcMvpGettingSpecialExp {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            exp: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.exp).unwrap();
        self.exp_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMvpGettingSpecialExp {
    fn id(&self) -> &str {
       "0x010b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMvp {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketZcMvp {
    pub fn from(buffer: &[u8]) -> PacketZcMvp {
        PacketZcMvp {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMvp {
    fn id(&self) -> &str {
       "0x010c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcThrowMvpitem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketZcThrowMvpitem {
    pub fn from(buffer: &[u8]) -> PacketZcThrowMvpitem {
        PacketZcThrowMvpitem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcThrowMvpitem {
    fn id(&self) -> &str {
       "0x010d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSkillinfoUpdate {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub level: i16,
    pub level_raw: [u8; 2],
    pub spcost: i16,
    pub spcost_raw: [u8; 2],
    pub attack_range: i16,
    pub attack_range_raw: [u8; 2],
    pub upgradable: bool,
    pub upgradable_raw: [u8; 1],
}

impl PacketZcSkillinfoUpdate {
    pub fn from(buffer: &[u8]) -> PacketZcSkillinfoUpdate {
        PacketZcSkillinfoUpdate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            level: i16::from_le_bytes([buffer[4], buffer[5]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            spcost: i16::from_le_bytes([buffer[6], buffer[7]]),
            spcost_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            attack_range: i16::from_le_bytes([buffer[8], buffer[9]]),
            attack_range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            upgradable: buffer[10] == 1,
            upgradable_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.spcost).unwrap();
        self.spcost_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.attack_range).unwrap();
        self.attack_range_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.upgradable as u8).unwrap();
        self.upgradable_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSkillinfoUpdate {
    fn id(&self) -> &str {
       "0x010e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSkillinfoList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub skill_list: Vec<SKILLINFO>,
    pub skill_list_raw: Vec<Vec<u8>>,
}

impl PacketZcSkillinfoList {
    pub fn from(buffer: &[u8]) -> PacketZcSkillinfoList {
        let iter_count = &buffer.len() / 37;
        let mut vec_field: Vec<SKILLINFO> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 41 * i;
            vec_field.push(SKILLINFO::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcSkillinfoList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            skill_list: vec_field.clone(),
            skill_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.skill_list_raw = {
            self.skill_list.iter_mut().for_each(|item| item.serialize());
            self.skill_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcSkillinfoList {
    fn id(&self) -> &str {
       "0x010f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckTouseskill {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub num: u32,
    pub num_raw: [u8; 4],
    pub result: bool,
    pub result_raw: [u8; 1],
    pub cause: u8,
    pub cause_raw: [u8; 1],
}

impl PacketZcAckTouseskill {
    pub fn from(buffer: &[u8]) -> PacketZcAckTouseskill {
        PacketZcAckTouseskill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            num: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            result: buffer[8] == 1,
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            cause: u8::from_le_bytes([buffer[9]]),
            cause_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.num).unwrap();
        self.num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.cause).unwrap();
        self.cause_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckTouseskill {
    fn id(&self) -> &str {
       "0x0110"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAddSkill {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub data: SKILLINFO,
    pub data_raw: Vec<u8>,
}

impl PacketZcAddSkill {
    pub fn from(buffer: &[u8]) -> PacketZcAddSkill {
        PacketZcAddSkill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            data: SKILLINFO::from(&buffer[2..buffer.len()]),
            data_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcAddSkill {
    fn id(&self) -> &str {
       "0x0111"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzUpgradeSkilllevel {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
}

impl PacketCzUpgradeSkilllevel {
    pub fn from(buffer: &[u8]) -> PacketCzUpgradeSkilllevel {
        PacketCzUpgradeSkilllevel {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzUpgradeSkilllevel {
    fn id(&self) -> &str {
       "0x0112"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzUseSkill {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub selected_level: i16,
    pub selected_level_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub target_id: u32,
    pub target_id_raw: [u8; 4],
}

impl PacketCzUseSkill {
    pub fn from(buffer: &[u8]) -> PacketCzUseSkill {
        PacketCzUseSkill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            selected_level: i16::from_le_bytes([buffer[2], buffer[3]]),
            selected_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            skid: u16::from_le_bytes([buffer[4], buffer[5]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            target_id: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.selected_level).unwrap();
        self.selected_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzUseSkill {
    fn id(&self) -> &str {
       "0x0113"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifySkill {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub target_id: u32,
    pub target_id_raw: [u8; 4],
    pub start_time: u32,
    pub start_time_raw: [u8; 4],
    pub attack_mt: i32,
    pub attack_mt_raw: [u8; 4],
    pub attacked_mt: i32,
    pub attacked_mt_raw: [u8; 4],
    pub damage: i16,
    pub damage_raw: [u8; 2],
    pub level: i16,
    pub level_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub action: u8,
    pub action_raw: [u8; 1],
}

impl PacketZcNotifySkill {
    pub fn from(buffer: &[u8]) -> PacketZcNotifySkill {
        PacketZcNotifySkill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            target_id: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            start_time: u32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            attack_mt: i32::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19]]),
            attack_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[16..20]);
                dst
            },
            attacked_mt: i32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            attacked_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
            damage: i16::from_le_bytes([buffer[24], buffer[25]]),
            damage_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            level: i16::from_le_bytes([buffer[26], buffer[27]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            count: i16::from_le_bytes([buffer[28], buffer[29]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            action: u8::from_le_bytes([buffer[30]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[30..31]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attack_mt).unwrap();
        self.attack_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attacked_mt).unwrap();
        self.attacked_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.damage).unwrap();
        self.damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifySkill {
    fn id(&self) -> &str {
       "0x0114"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifySkillPosition {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub target_id: u32,
    pub target_id_raw: [u8; 4],
    pub start_time: u32,
    pub start_time_raw: [u8; 4],
    pub attack_mt: i32,
    pub attack_mt_raw: [u8; 4],
    pub attacked_mt: i32,
    pub attacked_mt_raw: [u8; 4],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
    pub damage: i16,
    pub damage_raw: [u8; 2],
    pub level: i16,
    pub level_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub action: u8,
    pub action_raw: [u8; 1],
}

impl PacketZcNotifySkillPosition {
    pub fn from(buffer: &[u8]) -> PacketZcNotifySkillPosition {
        PacketZcNotifySkillPosition {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            target_id: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            start_time: u32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            attack_mt: i32::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19]]),
            attack_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[16..20]);
                dst
            },
            attacked_mt: i32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            attacked_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[24], buffer[25]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[26], buffer[27]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            damage: i16::from_le_bytes([buffer[28], buffer[29]]),
            damage_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            level: i16::from_le_bytes([buffer[30], buffer[31]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            count: i16::from_le_bytes([buffer[32], buffer[33]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            action: u8::from_le_bytes([buffer[34]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[34..35]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attack_mt).unwrap();
        self.attack_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attacked_mt).unwrap();
        self.attacked_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.damage).unwrap();
        self.damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifySkillPosition {
    fn id(&self) -> &str {
       "0x0115"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzUseSkillToground {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub selected_level: i16,
    pub selected_level_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
}

impl PacketCzUseSkillToground {
    pub fn from(buffer: &[u8]) -> PacketCzUseSkillToground {
        PacketCzUseSkillToground {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            selected_level: i16::from_le_bytes([buffer[2], buffer[3]]),
            selected_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            skid: u16::from_le_bytes([buffer[4], buffer[5]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[6], buffer[7]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[8], buffer[9]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.selected_level).unwrap();
        self.selected_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzUseSkillToground {
    fn id(&self) -> &str {
       "0x0116"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyGroundskill {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub level: i16,
    pub level_raw: [u8; 2],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
    pub start_time: u32,
    pub start_time_raw: [u8; 4],
}

impl PacketZcNotifyGroundskill {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyGroundskill {
        PacketZcNotifyGroundskill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            level: i16::from_le_bytes([buffer[8], buffer[9]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[10], buffer[11]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[12], buffer[13]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            start_time: u32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyGroundskill {
    fn id(&self) -> &str {
       "0x0117"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzCancelLockon {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzCancelLockon {
    pub fn from(buffer: &[u8]) -> PacketCzCancelLockon {
        PacketCzCancelLockon {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzCancelLockon {
    fn id(&self) -> &str {
       "0x0118"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcStateChange {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub body_state: i16,
    pub body_state_raw: [u8; 2],
    pub health_state: i16,
    pub health_state_raw: [u8; 2],
    pub effect_state: i16,
    pub effect_state_raw: [u8; 2],
    pub is_pkmode_on: bool,
    pub is_pkmode_on_raw: [u8; 1],
}

impl PacketZcStateChange {
    pub fn from(buffer: &[u8]) -> PacketZcStateChange {
        PacketZcStateChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[6], buffer[7]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            effect_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            is_pkmode_on: buffer[12] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcStateChange {
    fn id(&self) -> &str {
       "0x0119"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcUseSkill {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub level: i16,
    pub level_raw: [u8; 2],
    pub target_aid: u32,
    pub target_aid_raw: [u8; 4],
    pub src_aid: u32,
    pub src_aid_raw: [u8; 4],
    pub result: bool,
    pub result_raw: [u8; 1],
}

impl PacketZcUseSkill {
    pub fn from(buffer: &[u8]) -> PacketZcUseSkill {
        PacketZcUseSkill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            level: i16::from_le_bytes([buffer[4], buffer[5]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            target_aid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            src_aid: u32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            src_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            result: buffer[14] == 1,
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_aid).unwrap();
        self.target_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.src_aid).unwrap();
        self.src_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcUseSkill {
    fn id(&self) -> &str {
       "0x011a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzSelectWarppoint {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub map_name: [char; 16],
    pub map_name_raw: [u8; 16],
}

impl PacketCzSelectWarppoint {
    pub fn from(buffer: &[u8]) -> PacketCzSelectWarppoint {
        PacketCzSelectWarppoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[4..20].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[4..20]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzSelectWarppoint {
    fn id(&self) -> &str {
       "0x011b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcWarplist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub map_name: [char; 4],
    pub map_name_raw: [u8; 4],
}

impl PacketZcWarplist {
    pub fn from(buffer: &[u8]) -> PacketZcWarplist {
        PacketZcWarplist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            map_name:  {
                let mut dst: [char; 4] = [0 as char; 4];
                for (index, byte) in buffer[4..8].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcWarplist {
    fn id(&self) -> &str {
       "0x011c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRememberWarppoint {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzRememberWarppoint {
    pub fn from(buffer: &[u8]) -> PacketCzRememberWarppoint {
        PacketCzRememberWarppoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzRememberWarppoint {
    fn id(&self) -> &str {
       "0x011d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckRememberWarppoint {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub error_code: u8,
    pub error_code_raw: [u8; 1],
}

impl PacketZcAckRememberWarppoint {
    pub fn from(buffer: &[u8]) -> PacketZcAckRememberWarppoint {
        PacketZcAckRememberWarppoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: u8::from_le_bytes([buffer[2]]),
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckRememberWarppoint {
    fn id(&self) -> &str {
       "0x011e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSkillEntry {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub creator_aid: u32,
    pub creator_aid_raw: [u8; 4],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
    pub job: u8,
    pub job_raw: [u8; 1],
    pub is_visible: bool,
    pub is_visible_raw: [u8; 1],
}

impl PacketZcSkillEntry {
    pub fn from(buffer: &[u8]) -> PacketZcSkillEntry {
        PacketZcSkillEntry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            creator_aid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            creator_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[10], buffer[11]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[12], buffer[13]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: u8::from_le_bytes([buffer[14]]),
            job_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
            is_visible: buffer[15] == 1,
            is_visible_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[15..16]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.creator_aid).unwrap();
        self.creator_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_visible as u8).unwrap();
        self.is_visible_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSkillEntry {
    fn id(&self) -> &str {
       "0x011f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSkillDisappear {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketZcSkillDisappear {
    pub fn from(buffer: &[u8]) -> PacketZcSkillDisappear {
        PacketZcSkillDisappear {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSkillDisappear {
    fn id(&self) -> &str {
       "0x0120"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyCartitemCountinfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub cur_count: i16,
    pub cur_count_raw: [u8; 2],
    pub max_count: i16,
    pub max_count_raw: [u8; 2],
    pub cur_weight: i32,
    pub cur_weight_raw: [u8; 4],
    pub max_weight: i32,
    pub max_weight_raw: [u8; 4],
}

impl PacketZcNotifyCartitemCountinfo {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyCartitemCountinfo {
        PacketZcNotifyCartitemCountinfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            cur_count: i16::from_le_bytes([buffer[2], buffer[3]]),
            cur_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            max_count: i16::from_le_bytes([buffer[4], buffer[5]]),
            max_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            cur_weight: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            cur_weight_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            max_weight: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            max_weight_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.cur_count).unwrap();
        self.cur_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_count).unwrap();
        self.max_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.cur_weight).unwrap();
        self.cur_weight_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_weight).unwrap();
        self.max_weight_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyCartitemCountinfo {
    fn id(&self) -> &str {
       "0x0121"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcCartEquipmentItemlist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_info: Vec<EquipmentitemExtrainfo>,
    pub item_info_raw: Vec<Vec<u8>>,
}

impl PacketZcCartEquipmentItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcCartEquipmentItemlist {
        let iter_count = &buffer.len() / 20;
        let mut vec_field: Vec<EquipmentitemExtrainfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 24 * i;
            vec_field.push(EquipmentitemExtrainfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcCartEquipmentItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.serialize());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcCartEquipmentItemlist {
    fn id(&self) -> &str {
       "0x0122"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcCartNormalItemlist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_info: Vec<NormalitemExtrainfo>,
    pub item_info_raw: Vec<Vec<u8>>,
}

impl PacketZcCartNormalItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcCartNormalItemlist {
        let iter_count = &buffer.len() / 10;
        let mut vec_field: Vec<NormalitemExtrainfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 14 * i;
            vec_field.push(NormalitemExtrainfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcCartNormalItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.serialize());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcCartNormalItemlist {
    fn id(&self) -> &str {
       "0x0123"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAddItemToCart {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub is_damaged: bool,
    pub is_damaged_raw: [u8; 1],
    pub refining_level: u8,
    pub refining_level_raw: [u8; 1],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
}

impl PacketZcAddItemToCart {
    pub fn from(buffer: &[u8]) -> PacketZcAddItemToCart {
        PacketZcAddItemToCart {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            itid: u16::from_le_bytes([buffer[8], buffer[9]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            is_identified: buffer[10] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            is_damaged: buffer[11] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[12]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[13..21]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[13..21]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcAddItemToCart {
    fn id(&self) -> &str {
       "0x0124"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcDeleteItemFromCart {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
}

impl PacketZcDeleteItemFromCart {
    pub fn from(buffer: &[u8]) -> PacketZcDeleteItemFromCart {
        PacketZcDeleteItemFromCart {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcDeleteItemFromCart {
    fn id(&self) -> &str {
       "0x0125"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzMoveItemFromBodyToCart {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
}

impl PacketCzMoveItemFromBodyToCart {
    pub fn from(buffer: &[u8]) -> PacketCzMoveItemFromBodyToCart {
        PacketCzMoveItemFromBodyToCart {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzMoveItemFromBodyToCart {
    fn id(&self) -> &str {
       "0x0126"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzMoveItemFromCartToBody {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
}

impl PacketCzMoveItemFromCartToBody {
    pub fn from(buffer: &[u8]) -> PacketCzMoveItemFromCartToBody {
        PacketCzMoveItemFromCartToBody {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzMoveItemFromCartToBody {
    fn id(&self) -> &str {
       "0x0127"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzMoveItemFromStoreToCart {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
}

impl PacketCzMoveItemFromStoreToCart {
    pub fn from(buffer: &[u8]) -> PacketCzMoveItemFromStoreToCart {
        PacketCzMoveItemFromStoreToCart {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzMoveItemFromStoreToCart {
    fn id(&self) -> &str {
       "0x0128"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzMoveItemFromCartToStore {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
}

impl PacketCzMoveItemFromCartToStore {
    pub fn from(buffer: &[u8]) -> PacketCzMoveItemFromCartToStore {
        PacketCzMoveItemFromCartToStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzMoveItemFromCartToStore {
    fn id(&self) -> &str {
       "0x0129"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqCartoff {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzReqCartoff {
    pub fn from(buffer: &[u8]) -> PacketCzReqCartoff {
        PacketCzReqCartoff {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqCartoff {
    fn id(&self) -> &str {
       "0x012a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcCartoff {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketZcCartoff {
    pub fn from(buffer: &[u8]) -> PacketZcCartoff {
        PacketZcCartoff {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcCartoff {
    fn id(&self) -> &str {
       "0x012b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckAdditemToCart {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcAckAdditemToCart {
    pub fn from(buffer: &[u8]) -> PacketZcAckAdditemToCart {
        PacketZcAckAdditemToCart {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckAdditemToCart {
    fn id(&self) -> &str {
       "0x012c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcOpenstore {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub itemcount: i16,
    pub itemcount_raw: [u8; 2],
}

impl PacketZcOpenstore {
    pub fn from(buffer: &[u8]) -> PacketZcOpenstore {
        PacketZcOpenstore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itemcount: i16::from_le_bytes([buffer[2], buffer[3]]),
            itemcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.itemcount).unwrap();
        self.itemcount_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcOpenstore {
    fn id(&self) -> &str {
       "0x012d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqClosestore {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzReqClosestore {
    pub fn from(buffer: &[u8]) -> PacketCzReqClosestore {
        PacketCzReqClosestore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqClosestore {
    fn id(&self) -> &str {
       "0x012e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqOpenstore {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub store_name: [char; 80],
    pub store_name_raw: [u8; 80],
    pub store_list: Vec<StoreItem>,
    pub store_list_raw: Vec<Vec<u8>>,
}

impl PacketCzReqOpenstore {
    pub fn from(buffer: &[u8]) -> PacketCzReqOpenstore {
        let iter_count = &buffer.len() / 8;
        let mut vec_field: Vec<StoreItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 84 * i;
            let end_pos = 92 * i;
            vec_field.push(StoreItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzReqOpenstore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            store_name:  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[4..84].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            store_name_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[4..84]);
                dst
            },
            store_list: vec_field.clone(),
            store_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.store_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.store_name_raw = wtr.try_into().unwrap();
        self.store_list_raw = {
            self.store_list.iter_mut().for_each(|item| item.serialize());
            self.store_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketCzReqOpenstore {
    fn id(&self) -> &str {
       "0x012f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqBuyFrommc {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketCzReqBuyFrommc {
    pub fn from(buffer: &[u8]) -> PacketCzReqBuyFrommc {
        PacketCzReqBuyFrommc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqBuyFrommc {
    fn id(&self) -> &str {
       "0x0130"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcStoreEntry {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub maker_aid: u32,
    pub maker_aid_raw: [u8; 4],
    pub store_name: [char; 80],
    pub store_name_raw: [u8; 80],
}

impl PacketZcStoreEntry {
    pub fn from(buffer: &[u8]) -> PacketZcStoreEntry {
        PacketZcStoreEntry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            maker_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            store_name:  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[6..86].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            store_name_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[6..86]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.store_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.store_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcStoreEntry {
    fn id(&self) -> &str {
       "0x0131"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcDisappearEntry {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub maker_aid: u32,
    pub maker_aid_raw: [u8; 4],
}

impl PacketZcDisappearEntry {
    pub fn from(buffer: &[u8]) -> PacketZcDisappearEntry {
        PacketZcDisappearEntry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            maker_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcDisappearEntry {
    fn id(&self) -> &str {
       "0x0132"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPcPurchaseItemlistFrommc {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub item_list: Vec<PurchaseItemFrommc>,
    pub item_list_raw: Vec<Vec<u8>>,
}

impl PacketZcPcPurchaseItemlistFrommc {
    pub fn from(buffer: &[u8]) -> PacketZcPcPurchaseItemlistFrommc {
        let iter_count = &buffer.len() / 22;
        let mut vec_field: Vec<PurchaseItemFrommc> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 * i;
            let end_pos = 30 * i;
            vec_field.push(PurchaseItemFrommc::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPcPurchaseItemlistFrommc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.serialize());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcPcPurchaseItemlistFrommc {
    fn id(&self) -> &str {
       "0x0133"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzPcPurchaseItemlistFrommc {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub item_list: Vec<CzPurchaseItemFrommc>,
    pub item_list_raw: Vec<Vec<u8>>,
}

impl PacketCzPcPurchaseItemlistFrommc {
    pub fn from(buffer: &[u8]) -> PacketCzPcPurchaseItemlistFrommc {
        let iter_count = &buffer.len() / 4;
        let mut vec_field: Vec<CzPurchaseItemFrommc> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 * i;
            let end_pos = 12 * i;
            vec_field.push(CzPurchaseItemFrommc::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzPcPurchaseItemlistFrommc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.serialize());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketCzPcPurchaseItemlistFrommc {
    fn id(&self) -> &str {
       "0x0134"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPcPurchaseResultFrommc {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub curcount: i16,
    pub curcount_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcPcPurchaseResultFrommc {
    pub fn from(buffer: &[u8]) -> PacketZcPcPurchaseResultFrommc {
        PacketZcPcPurchaseResultFrommc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            curcount: i16::from_le_bytes([buffer[4], buffer[5]]),
            curcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            result: u8::from_le_bytes([buffer[6]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.curcount).unwrap();
        self.curcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcPcPurchaseResultFrommc {
    fn id(&self) -> &str {
       "0x0135"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPcPurchaseMyitemlist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub item_list: Vec<PurchaseMyitem>,
    pub item_list_raw: Vec<Vec<u8>>,
}

impl PacketZcPcPurchaseMyitemlist {
    pub fn from(buffer: &[u8]) -> PacketZcPcPurchaseMyitemlist {
        let iter_count = &buffer.len() / 22;
        let mut vec_field: Vec<PurchaseMyitem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 * i;
            let end_pos = 30 * i;
            vec_field.push(PurchaseMyitem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPcPurchaseMyitemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.serialize());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcPcPurchaseMyitemlist {
    fn id(&self) -> &str {
       "0x0136"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcDeleteitemFromMcstore {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
}

impl PacketZcDeleteitemFromMcstore {
    pub fn from(buffer: &[u8]) -> PacketZcDeleteitemFromMcstore {
        PacketZcDeleteitemFromMcstore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcDeleteitemFromMcstore {
    fn id(&self) -> &str {
       "0x0137"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzPkmodeChange {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub is_turn_on: bool,
    pub is_turn_on_raw: [u8; 1],
}

impl PacketCzPkmodeChange {
    pub fn from(buffer: &[u8]) -> PacketCzPkmodeChange {
        PacketCzPkmodeChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            is_turn_on: buffer[2] == 1,
            is_turn_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_turn_on as u8).unwrap();
        self.is_turn_on_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzPkmodeChange {
    fn id(&self) -> &str {
       "0x0138"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAttackFailureForDistance {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub target_aid: u32,
    pub target_aid_raw: [u8; 4],
    pub target_xpos: i16,
    pub target_xpos_raw: [u8; 2],
    pub target_ypos: i16,
    pub target_ypos_raw: [u8; 2],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
    pub current_att_range: i16,
    pub current_att_range_raw: [u8; 2],
}

impl PacketZcAttackFailureForDistance {
    pub fn from(buffer: &[u8]) -> PacketZcAttackFailureForDistance {
        PacketZcAttackFailureForDistance {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            target_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            target_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            target_xpos: i16::from_le_bytes([buffer[6], buffer[7]]),
            target_xpos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            target_ypos: i16::from_le_bytes([buffer[8], buffer[9]]),
            target_ypos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[10], buffer[11]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[12], buffer[13]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            current_att_range: i16::from_le_bytes([buffer[14], buffer[15]]),
            current_att_range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_aid).unwrap();
        self.target_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.target_xpos).unwrap();
        self.target_xpos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.target_ypos).unwrap();
        self.target_ypos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.current_att_range).unwrap();
        self.current_att_range_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAttackFailureForDistance {
    fn id(&self) -> &str {
       "0x0139"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAttackRange {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub current_att_range: i16,
    pub current_att_range_raw: [u8; 2],
}

impl PacketZcAttackRange {
    pub fn from(buffer: &[u8]) -> PacketZcAttackRange {
        PacketZcAttackRange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            current_att_range: i16::from_le_bytes([buffer[2], buffer[3]]),
            current_att_range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.current_att_range).unwrap();
        self.current_att_range_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAttackRange {
    fn id(&self) -> &str {
       "0x013a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcActionFailure {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub error_code: i16,
    pub error_code_raw: [u8; 2],
}

impl PacketZcActionFailure {
    pub fn from(buffer: &[u8]) -> PacketZcActionFailure {
        PacketZcActionFailure {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcActionFailure {
    fn id(&self) -> &str {
       "0x013b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcEquipArrow {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
}

impl PacketZcEquipArrow {
    pub fn from(buffer: &[u8]) -> PacketZcEquipArrow {
        PacketZcEquipArrow {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcEquipArrow {
    fn id(&self) -> &str {
       "0x013c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcRecovery {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub var_id: i16,
    pub var_id_raw: [u8; 2],
    pub amount: i16,
    pub amount_raw: [u8; 2],
}

impl PacketZcRecovery {
    pub fn from(buffer: &[u8]) -> PacketZcRecovery {
        PacketZcRecovery {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            var_id: i16::from_le_bytes([buffer[2], buffer[3]]),
            var_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            amount: i16::from_le_bytes([buffer[4], buffer[5]]),
            amount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.var_id).unwrap();
        self.var_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.amount).unwrap();
        self.amount_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcRecovery {
    fn id(&self) -> &str {
       "0x013d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcUseskillAck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub target_id: u32,
    pub target_id_raw: [u8; 4],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub property: u32,
    pub property_raw: [u8; 4],
    pub delay_time: u32,
    pub delay_time_raw: [u8; 4],
}

impl PacketZcUseskillAck {
    pub fn from(buffer: &[u8]) -> PacketZcUseskillAck {
        PacketZcUseskillAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            target_id: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[10], buffer[11]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[12], buffer[13]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            skid: u16::from_le_bytes([buffer[14], buffer[15]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            property: u32::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19]]),
            property_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[16..20]);
                dst
            },
            delay_time: u32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            delay_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.property).unwrap();
        self.property_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.delay_time).unwrap();
        self.delay_time_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcUseskillAck {
    fn id(&self) -> &str {
       "0x013e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzItemCreate {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub item_name: [char; 24],
    pub item_name_raw: [u8; 24],
}

impl PacketCzItemCreate {
    pub fn from(buffer: &[u8]) -> PacketCzItemCreate {
        PacketCzItemCreate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            item_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            item_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.item_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.item_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzItemCreate {
    fn id(&self) -> &str {
       "0x013f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzMovetoMap {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub map_name: [char; 16],
    pub map_name_raw: [u8; 16],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
}

impl PacketCzMovetoMap {
    pub fn from(buffer: &[u8]) -> PacketCzMovetoMap {
        PacketCzMovetoMap {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[2..18].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[2..18]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[18], buffer[19]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[20], buffer[21]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzMovetoMap {
    fn id(&self) -> &str {
       "0x0140"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcCouplestatus {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub status_type: u32,
    pub status_type_raw: [u8; 4],
    pub default_status: i32,
    pub default_status_raw: [u8; 4],
    pub plus_status: i32,
    pub plus_status_raw: [u8; 4],
}

impl PacketZcCouplestatus {
    pub fn from(buffer: &[u8]) -> PacketZcCouplestatus {
        PacketZcCouplestatus {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            status_type: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            status_type_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            default_status: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            default_status_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            plus_status: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            plus_status_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.status_type).unwrap();
        self.status_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.default_status).unwrap();
        self.default_status_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.plus_status).unwrap();
        self.plus_status_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcCouplestatus {
    fn id(&self) -> &str {
       "0x0141"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcOpenEditdlg {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub naid: u32,
    pub naid_raw: [u8; 4],
}

impl PacketZcOpenEditdlg {
    pub fn from(buffer: &[u8]) -> PacketZcOpenEditdlg {
        PacketZcOpenEditdlg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcOpenEditdlg {
    fn id(&self) -> &str {
       "0x0142"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzInputEditdlg {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub naid: u32,
    pub naid_raw: [u8; 4],
    pub value: i32,
    pub value_raw: [u8; 4],
}

impl PacketCzInputEditdlg {
    pub fn from(buffer: &[u8]) -> PacketCzInputEditdlg {
        PacketCzInputEditdlg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            value: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzInputEditdlg {
    fn id(&self) -> &str {
       "0x0143"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcCompass {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub naid: u32,
    pub naid_raw: [u8; 4],
    pub atype: i32,
    pub atype_raw: [u8; 4],
    pub x_pos: i32,
    pub x_pos_raw: [u8; 4],
    pub y_pos: i32,
    pub y_pos_raw: [u8; 4],
    pub id: u8,
    pub id_raw: [u8; 1],
    pub color: u32,
    pub color_raw: [u8; 4],
}

impl PacketZcCompass {
    pub fn from(buffer: &[u8]) -> PacketZcCompass {
        PacketZcCompass {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            x_pos: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            x_pos_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            y_pos: i32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            y_pos_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
            id: u8::from_le_bytes([buffer[18]]),
            id_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[18..19]);
                dst
            },
            color: u32::from_le_bytes([buffer[19], buffer[20], buffer[21], buffer[22]]),
            color_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[19..23]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.id).unwrap();
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.color).unwrap();
        self.color_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcCompass {
    fn id(&self) -> &str {
       "0x0144"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcShowImage {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub image_name: [char; 16],
    pub image_name_raw: [u8; 16],
    pub atype: u8,
    pub atype_raw: [u8; 1],
}

impl PacketZcShowImage {
    pub fn from(buffer: &[u8]) -> PacketZcShowImage {
        PacketZcShowImage {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            image_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[2..18].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            image_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[2..18]);
                dst
            },
            atype: u8::from_le_bytes([buffer[18]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[18..19]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.image_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.image_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcShowImage {
    fn id(&self) -> &str {
       "0x0145"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzCloseDialog {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub naid: u32,
    pub naid_raw: [u8; 4],
}

impl PacketCzCloseDialog {
    pub fn from(buffer: &[u8]) -> PacketCzCloseDialog {
        PacketCzCloseDialog {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzCloseDialog {
    fn id(&self) -> &str {
       "0x0146"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAutorunSkill {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub data: SKILLINFO,
    pub data_raw: Vec<u8>,
}

impl PacketZcAutorunSkill {
    pub fn from(buffer: &[u8]) -> PacketZcAutorunSkill {
        PacketZcAutorunSkill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            data: SKILLINFO::from(&buffer[2..buffer.len()]),
            data_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcAutorunSkill {
    fn id(&self) -> &str {
       "0x0147"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcResurrection {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub atype: i16,
    pub atype_raw: [u8; 2],
}

impl PacketZcResurrection {
    pub fn from(buffer: &[u8]) -> PacketZcResurrection {
        PacketZcResurrection {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: i16::from_le_bytes([buffer[6], buffer[7]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcResurrection {
    fn id(&self) -> &str {
       "0x0148"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqGiveMannerPoint {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub other_aid: u32,
    pub other_aid_raw: [u8; 4],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub point: i16,
    pub point_raw: [u8; 2],
}

impl PacketCzReqGiveMannerPoint {
    pub fn from(buffer: &[u8]) -> PacketCzReqGiveMannerPoint {
        PacketCzReqGiveMannerPoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            other_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            other_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            point: i16::from_le_bytes([buffer[7], buffer[8]]),
            point_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[7..9]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.other_aid).unwrap();
        self.other_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqGiveMannerPoint {
    fn id(&self) -> &str {
       "0x0149"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckGiveMannerPoint {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: u32,
    pub result_raw: [u8; 4],
}

impl PacketZcAckGiveMannerPoint {
    pub fn from(buffer: &[u8]) -> PacketZcAckGiveMannerPoint {
        PacketZcAckGiveMannerPoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckGiveMannerPoint {
    fn id(&self) -> &str {
       "0x014a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyMannerPointGiven {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub other_char_name: [char; 24],
    pub other_char_name_raw: [u8; 24],
}

impl PacketZcNotifyMannerPointGiven {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMannerPointGiven {
        PacketZcNotifyMannerPointGiven {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: u8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            other_char_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[3..27].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            other_char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[3..27]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.other_char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.other_char_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyMannerPointGiven {
    fn id(&self) -> &str {
       "0x014b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMyguildBasicInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub related_guild_list: Vec<RelatedGuild>,
    pub related_guild_list_raw: Vec<Vec<u8>>,
}

impl PacketZcMyguildBasicInfo {
    pub fn from(buffer: &[u8]) -> PacketZcMyguildBasicInfo {
        let iter_count = &buffer.len() / 32;
        let mut vec_field: Vec<RelatedGuild> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 36 * i;
            vec_field.push(RelatedGuild::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcMyguildBasicInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            related_guild_list: vec_field.clone(),
            related_guild_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.related_guild_list_raw = {
            self.related_guild_list.iter_mut().for_each(|item| item.serialize());
            self.related_guild_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcMyguildBasicInfo {
    fn id(&self) -> &str {
       "0x014c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqGuildMenuinterface {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzReqGuildMenuinterface {
    pub fn from(buffer: &[u8]) -> PacketCzReqGuildMenuinterface {
        PacketCzReqGuildMenuinterface {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqGuildMenuinterface {
    fn id(&self) -> &str {
       "0x014d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckGuildMenuinterface {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub guild_memu_flag: i32,
    pub guild_memu_flag_raw: [u8; 4],
}

impl PacketZcAckGuildMenuinterface {
    pub fn from(buffer: &[u8]) -> PacketZcAckGuildMenuinterface {
        PacketZcAckGuildMenuinterface {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            guild_memu_flag: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            guild_memu_flag_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.guild_memu_flag).unwrap();
        self.guild_memu_flag_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckGuildMenuinterface {
    fn id(&self) -> &str {
       "0x014e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqGuildMenu {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i32,
    pub atype_raw: [u8; 4],
}

impl PacketCzReqGuildMenu {
    pub fn from(buffer: &[u8]) -> PacketCzReqGuildMenu {
        PacketCzReqGuildMenu {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqGuildMenu {
    fn id(&self) -> &str {
       "0x014f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcGuildInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gdid: i32,
    pub gdid_raw: [u8; 4],
    pub level: i32,
    pub level_raw: [u8; 4],
    pub user_num: i32,
    pub user_num_raw: [u8; 4],
    pub max_user_num: i32,
    pub max_user_num_raw: [u8; 4],
    pub user_average_level: i32,
    pub user_average_level_raw: [u8; 4],
    pub exp: i32,
    pub exp_raw: [u8; 4],
    pub max_exp: i32,
    pub max_exp_raw: [u8; 4],
    pub point: i32,
    pub point_raw: [u8; 4],
    pub honor: i32,
    pub honor_raw: [u8; 4],
    pub virtue: i32,
    pub virtue_raw: [u8; 4],
    pub emblem_version: i32,
    pub emblem_version_raw: [u8; 4],
    pub guildname: [char; 24],
    pub guildname_raw: [u8; 24],
    pub master_name: [char; 24],
    pub master_name_raw: [u8; 24],
    pub manage_land: [char; 16],
    pub manage_land_raw: [u8; 16],
}

impl PacketZcGuildInfo {
    pub fn from(buffer: &[u8]) -> PacketZcGuildInfo {
        PacketZcGuildInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            level: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            user_num: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            user_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            max_user_num: i32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            max_user_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
            user_average_level: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            user_average_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
            exp: i32::from_le_bytes([buffer[22], buffer[23], buffer[24], buffer[25]]),
            exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[22..26]);
                dst
            },
            max_exp: i32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            max_exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
            point: i32::from_le_bytes([buffer[30], buffer[31], buffer[32], buffer[33]]),
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[30..34]);
                dst
            },
            honor: i32::from_le_bytes([buffer[34], buffer[35], buffer[36], buffer[37]]),
            honor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[34..38]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[38], buffer[39], buffer[40], buffer[41]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[38..42]);
                dst
            },
            emblem_version: i32::from_le_bytes([buffer[42], buffer[43], buffer[44], buffer[45]]),
            emblem_version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[42..46]);
                dst
            },
            guildname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[46..70].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            guildname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[46..70]);
                dst
            },
            master_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[70..94].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            master_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[70..94]);
                dst
            },
            manage_land:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[94..110].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            manage_land_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[94..110]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.user_num).unwrap();
        self.user_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_user_num).unwrap();
        self.max_user_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.user_average_level).unwrap();
        self.user_average_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.exp).unwrap();
        self.exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_exp).unwrap();
        self.max_exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.emblem_version).unwrap();
        self.emblem_version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.guildname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guildname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.master_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.master_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.manage_land {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.manage_land_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcGuildInfo {
    fn id(&self) -> &str {
       "0x0150"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqGuildEmblemImg {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gdid: i32,
    pub gdid_raw: [u8; 4],
}

impl PacketCzReqGuildEmblemImg {
    pub fn from(buffer: &[u8]) -> PacketCzReqGuildEmblemImg {
        PacketCzReqGuildEmblemImg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqGuildEmblemImg {
    fn id(&self) -> &str {
       "0x0151"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcGuildEmblemImg {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub gdid: i32,
    pub gdid_raw: [u8; 4],
    pub emblem_version: i32,
    pub emblem_version_raw: [u8; 4],
    pub img: String,
    pub img_raw: Vec<u8>,
}

impl PacketZcGuildEmblemImg {
    pub fn from(buffer: &[u8]) -> PacketZcGuildEmblemImg {
        PacketZcGuildEmblemImg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            gdid: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            emblem_version: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            emblem_version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            img: String::from_utf8_lossy(&buffer[12..buffer.len()]).to_string(),
            img_raw: buffer[12..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.emblem_version).unwrap();
        self.emblem_version_raw = wtr.try_into().unwrap();
        self.img_raw = self.img.as_bytes().to_vec()
    }
}

impl Packet for PacketZcGuildEmblemImg {
    fn id(&self) -> &str {
       "0x0152"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRegisterGuildEmblemImg {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub img: String,
    pub img_raw: Vec<u8>,
}

impl PacketCzRegisterGuildEmblemImg {
    pub fn from(buffer: &[u8]) -> PacketCzRegisterGuildEmblemImg {
        PacketCzRegisterGuildEmblemImg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            img: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            img_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.img_raw = self.img.as_bytes().to_vec()
    }
}

impl Packet for PacketCzRegisterGuildEmblemImg {
    fn id(&self) -> &str {
       "0x0153"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMembermgrInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub member_info: Vec<GuildMembermgrInfo>,
    pub member_info_raw: Vec<Vec<u8>>,
}

impl PacketZcMembermgrInfo {
    pub fn from(buffer: &[u8]) -> PacketZcMembermgrInfo {
        let iter_count = &buffer.len() / 104;
        let mut vec_field: Vec<GuildMembermgrInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 108 * i;
            vec_field.push(GuildMembermgrInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcMembermgrInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            member_info: vec_field.clone(),
            member_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_info_raw = {
            self.member_info.iter_mut().for_each(|item| item.serialize());
            self.member_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcMembermgrInfo {
    fn id(&self) -> &str {
       "0x0154"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqChangeMemberpos {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub member_info: Vec<MemberPositionInfo>,
    pub member_info_raw: Vec<Vec<u8>>,
}

impl PacketCzReqChangeMemberpos {
    pub fn from(buffer: &[u8]) -> PacketCzReqChangeMemberpos {
        let iter_count = &buffer.len() / 12;
        let mut vec_field: Vec<MemberPositionInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 16 * i;
            vec_field.push(MemberPositionInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzReqChangeMemberpos {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            member_info: vec_field.clone(),
            member_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_info_raw = {
            self.member_info.iter_mut().for_each(|item| item.serialize());
            self.member_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketCzReqChangeMemberpos {
    fn id(&self) -> &str {
       "0x0155"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckReqChangeMembers {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub member_info: Vec<MemberPositionInfo>,
    pub member_info_raw: Vec<Vec<u8>>,
}

impl PacketZcAckReqChangeMembers {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqChangeMembers {
        let iter_count = &buffer.len() / 12;
        let mut vec_field: Vec<MemberPositionInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 16 * i;
            vec_field.push(MemberPositionInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcAckReqChangeMembers {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            member_info: vec_field.clone(),
            member_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_info_raw = {
            self.member_info.iter_mut().for_each(|item| item.serialize());
            self.member_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcAckReqChangeMembers {
    fn id(&self) -> &str {
       "0x0156"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqOpenMemberInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: i32,
    pub aid_raw: [u8; 4],
}

impl PacketCzReqOpenMemberInfo {
    pub fn from(buffer: &[u8]) -> PacketCzReqOpenMemberInfo {
        PacketCzReqOpenMemberInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqOpenMemberInfo {
    fn id(&self) -> &str {
       "0x0157"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckOpenMemberInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketZcAckOpenMemberInfo {
    pub fn from(buffer: &[u8]) -> PacketZcAckOpenMemberInfo {
        PacketZcAckOpenMemberInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckOpenMemberInfo {
    fn id(&self) -> &str {
       "0x0158"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqLeaveGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gdid: u32,
    pub gdid_raw: [u8; 4],
    pub aid: i32,
    pub aid_raw: [u8; 4],
    pub gid: i32,
    pub gid_raw: [u8; 4],
    pub reason_desc: [char; 40],
    pub reason_desc_raw: [u8; 40],
}

impl PacketCzReqLeaveGuild {
    pub fn from(buffer: &[u8]) -> PacketCzReqLeaveGuild {
        PacketCzReqLeaveGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            aid: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            gid: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            reason_desc:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[14..54].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            reason_desc_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[14..54]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason_desc {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_desc_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqLeaveGuild {
    fn id(&self) -> &str {
       "0x0159"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckLeaveGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub char_name: [char; 24],
    pub char_name_raw: [u8; 24],
    pub reason_desc: [char; 40],
    pub reason_desc_raw: [u8; 40],
}

impl PacketZcAckLeaveGuild {
    pub fn from(buffer: &[u8]) -> PacketZcAckLeaveGuild {
        PacketZcAckLeaveGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            char_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            reason_desc:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[26..66].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            reason_desc_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[26..66]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason_desc {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_desc_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckLeaveGuild {
    fn id(&self) -> &str {
       "0x015a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqBanGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gdid: u32,
    pub gdid_raw: [u8; 4],
    pub aid: i32,
    pub aid_raw: [u8; 4],
    pub gid: i32,
    pub gid_raw: [u8; 4],
    pub reason_desc: [char; 40],
    pub reason_desc_raw: [u8; 40],
}

impl PacketCzReqBanGuild {
    pub fn from(buffer: &[u8]) -> PacketCzReqBanGuild {
        PacketCzReqBanGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            aid: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            gid: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            reason_desc:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[14..54].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            reason_desc_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[14..54]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason_desc {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_desc_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqBanGuild {
    fn id(&self) -> &str {
       "0x015b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckBanGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub char_name: [char; 24],
    pub char_name_raw: [u8; 24],
    pub reason_desc: [char; 40],
    pub reason_desc_raw: [u8; 40],
    pub account: [char; 24],
    pub account_raw: [u8; 24],
}

impl PacketZcAckBanGuild {
    pub fn from(buffer: &[u8]) -> PacketZcAckBanGuild {
        PacketZcAckBanGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            char_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            reason_desc:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[26..66].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            reason_desc_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[26..66]);
                dst
            },
            account:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[66..90].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            account_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[66..90]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason_desc {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_desc_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.account {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.account_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckBanGuild {
    fn id(&self) -> &str {
       "0x015c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqDisorganizeGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub key: [char; 40],
    pub key_raw: [u8; 40],
}

impl PacketCzReqDisorganizeGuild {
    pub fn from(buffer: &[u8]) -> PacketCzReqDisorganizeGuild {
        PacketCzReqDisorganizeGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            key:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[2..42].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            key_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[2..42]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.key {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.key_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqDisorganizeGuild {
    fn id(&self) -> &str {
       "0x015d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckDisorganizeGuildResult {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub reason: i32,
    pub reason_raw: [u8; 4],
}

impl PacketZcAckDisorganizeGuildResult {
    pub fn from(buffer: &[u8]) -> PacketZcAckDisorganizeGuildResult {
        PacketZcAckDisorganizeGuildResult {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            reason: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            reason_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.reason).unwrap();
        self.reason_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckDisorganizeGuildResult {
    fn id(&self) -> &str {
       "0x015e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckDisorganizeGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub reason_desc: [char; 40],
    pub reason_desc_raw: [u8; 40],
}

impl PacketZcAckDisorganizeGuild {
    pub fn from(buffer: &[u8]) -> PacketZcAckDisorganizeGuild {
        PacketZcAckDisorganizeGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            reason_desc:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[2..42].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            reason_desc_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[2..42]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason_desc {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_desc_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckDisorganizeGuild {
    fn id(&self) -> &str {
       "0x015f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPositionInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub member_info: Vec<GuildMemberPositionInfo>,
    pub member_info_raw: Vec<Vec<u8>>,
}

impl PacketZcPositionInfo {
    pub fn from(buffer: &[u8]) -> PacketZcPositionInfo {
        let iter_count = &buffer.len() / 16;
        let mut vec_field: Vec<GuildMemberPositionInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 20 * i;
            vec_field.push(GuildMemberPositionInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPositionInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            member_info: vec_field.clone(),
            member_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_info_raw = {
            self.member_info.iter_mut().for_each(|item| item.serialize());
            self.member_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcPositionInfo {
    fn id(&self) -> &str {
       "0x0160"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRegChangeGuildPositioninfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub member_list: Vec<GuildRegPositionInfo>,
    pub member_list_raw: Vec<Vec<u8>>,
}

impl PacketCzRegChangeGuildPositioninfo {
    pub fn from(buffer: &[u8]) -> PacketCzRegChangeGuildPositioninfo {
        let iter_count = &buffer.len() / 40;
        let mut vec_field: Vec<GuildRegPositionInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 44 * i;
            vec_field.push(GuildRegPositionInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzRegChangeGuildPositioninfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            member_list: vec_field.clone(),
            member_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_list_raw = {
            self.member_list.iter_mut().for_each(|item| item.serialize());
            self.member_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketCzRegChangeGuildPositioninfo {
    fn id(&self) -> &str {
       "0x0161"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcGuildSkillinfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub skill_point: i16,
    pub skill_point_raw: [u8; 2],
    pub skill_list: Vec<SKILLINFO>,
    pub skill_list_raw: Vec<Vec<u8>>,
}

impl PacketZcGuildSkillinfo {
    pub fn from(buffer: &[u8]) -> PacketZcGuildSkillinfo {
        let iter_count = &buffer.len() / 37;
        let mut vec_field: Vec<SKILLINFO> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 6 * i;
            let end_pos = 43 * i;
            vec_field.push(SKILLINFO::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcGuildSkillinfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            skill_point: i16::from_le_bytes([buffer[4], buffer[5]]),
            skill_point_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            skill_list: vec_field.clone(),
            skill_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.skill_point).unwrap();
        self.skill_point_raw = wtr.try_into().unwrap();
        self.skill_list_raw = {
            self.skill_list.iter_mut().for_each(|item| item.serialize());
            self.skill_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcGuildSkillinfo {
    fn id(&self) -> &str {
       "0x0162"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcBanList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub ban_list: Vec<GuildBanInfo>,
    pub ban_list_raw: Vec<Vec<u8>>,
}

impl PacketZcBanList {
    pub fn from(buffer: &[u8]) -> PacketZcBanList {
        let iter_count = &buffer.len() / 88;
        let mut vec_field: Vec<GuildBanInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 92 * i;
            vec_field.push(GuildBanInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcBanList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            ban_list: vec_field.clone(),
            ban_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.ban_list_raw = {
            self.ban_list.iter_mut().for_each(|item| item.serialize());
            self.ban_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcBanList {
    fn id(&self) -> &str {
       "0x0163"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcOtherGuildList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub guild_list: Vec<OtherGuildInfo>,
    pub guild_list_raw: Vec<Vec<u8>>,
}

impl PacketZcOtherGuildList {
    pub fn from(buffer: &[u8]) -> PacketZcOtherGuildList {
        let iter_count = &buffer.len() / 36;
        let mut vec_field: Vec<OtherGuildInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 40 * i;
            vec_field.push(OtherGuildInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcOtherGuildList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            guild_list: vec_field.clone(),
            guild_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.guild_list_raw = {
            self.guild_list.iter_mut().for_each(|item| item.serialize());
            self.guild_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcOtherGuildList {
    fn id(&self) -> &str {
       "0x0164"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqMakeGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub gname: [char; 24],
    pub gname_raw: [u8; 24],
}

impl PacketCzReqMakeGuild {
    pub fn from(buffer: &[u8]) -> PacketCzReqMakeGuild {
        PacketCzReqMakeGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            gname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.gname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.gname_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqMakeGuild {
    fn id(&self) -> &str {
       "0x0165"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPositionIdNameInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub member_list: Vec<MemberPositionIdNameInfo>,
    pub member_list_raw: Vec<Vec<u8>>,
}

impl PacketZcPositionIdNameInfo {
    pub fn from(buffer: &[u8]) -> PacketZcPositionIdNameInfo {
        let iter_count = &buffer.len() / 28;
        let mut vec_field: Vec<MemberPositionIdNameInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 32 * i;
            vec_field.push(MemberPositionIdNameInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPositionIdNameInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            member_list: vec_field.clone(),
            member_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_list_raw = {
            self.member_list.iter_mut().for_each(|item| item.serialize());
            self.member_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcPositionIdNameInfo {
    fn id(&self) -> &str {
       "0x0166"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcResultMakeGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcResultMakeGuild {
    pub fn from(buffer: &[u8]) -> PacketZcResultMakeGuild {
        PacketZcResultMakeGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcResultMakeGuild {
    fn id(&self) -> &str {
       "0x0167"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqJoinGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub my_aid: u32,
    pub my_aid_raw: [u8; 4],
    pub my_gid: u32,
    pub my_gid_raw: [u8; 4],
}

impl PacketCzReqJoinGuild {
    pub fn from(buffer: &[u8]) -> PacketCzReqJoinGuild {
        PacketCzReqJoinGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            my_aid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            my_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            my_gid: u32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            my_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.my_aid).unwrap();
        self.my_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.my_gid).unwrap();
        self.my_gid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqJoinGuild {
    fn id(&self) -> &str {
       "0x0168"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckReqJoinGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub answer: u8,
    pub answer_raw: [u8; 1],
}

impl PacketZcAckReqJoinGuild {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqJoinGuild {
        PacketZcAckReqJoinGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            answer: u8::from_le_bytes([buffer[2]]),
            answer_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckReqJoinGuild {
    fn id(&self) -> &str {
       "0x0169"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcReqJoinGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gdid: u32,
    pub gdid_raw: [u8; 4],
    pub guild_name: [char; 24],
    pub guild_name_raw: [u8; 24],
}

impl PacketZcReqJoinGuild {
    pub fn from(buffer: &[u8]) -> PacketZcReqJoinGuild {
        PacketZcReqJoinGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            guild_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            guild_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.guild_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guild_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcReqJoinGuild {
    fn id(&self) -> &str {
       "0x016a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzJoinGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gdid: u32,
    pub gdid_raw: [u8; 4],
    pub answer: i32,
    pub answer_raw: [u8; 4],
}

impl PacketCzJoinGuild {
    pub fn from(buffer: &[u8]) -> PacketCzJoinGuild {
        PacketCzJoinGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            answer: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            answer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzJoinGuild {
    fn id(&self) -> &str {
       "0x016b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcUpdateGdid {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gdid: u32,
    pub gdid_raw: [u8; 4],
    pub emblem_version: i32,
    pub emblem_version_raw: [u8; 4],
    pub right: i32,
    pub right_raw: [u8; 4],
    pub is_master: bool,
    pub is_master_raw: [u8; 1],
    pub inter_sid: i32,
    pub inter_sid_raw: [u8; 4],
    pub gname: [char; 24],
    pub gname_raw: [u8; 24],
}

impl PacketZcUpdateGdid {
    pub fn from(buffer: &[u8]) -> PacketZcUpdateGdid {
        PacketZcUpdateGdid {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            emblem_version: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            emblem_version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            right: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            right_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            is_master: buffer[14] == 1,
            is_master_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
            inter_sid: i32::from_le_bytes([buffer[15], buffer[16], buffer[17], buffer[18]]),
            inter_sid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[15..19]);
                dst
            },
            gname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[19..43].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            gname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[19..43]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.emblem_version).unwrap();
        self.emblem_version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.right).unwrap();
        self.right_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_master as u8).unwrap();
        self.is_master_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.inter_sid).unwrap();
        self.inter_sid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.gname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.gname_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcUpdateGdid {
    fn id(&self) -> &str {
       "0x016c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcUpdateCharstat {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub status: i32,
    pub status_raw: [u8; 4],
}

impl PacketZcUpdateCharstat {
    pub fn from(buffer: &[u8]) -> PacketZcUpdateCharstat {
        PacketZcUpdateCharstat {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            status: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            status_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.status).unwrap();
        self.status_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcUpdateCharstat {
    fn id(&self) -> &str {
       "0x016d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzGuildNotice {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gdid: u32,
    pub gdid_raw: [u8; 4],
    pub subject: [char; 60],
    pub subject_raw: [u8; 60],
    pub notice: [char; 120],
    pub notice_raw: [u8; 120],
}

impl PacketCzGuildNotice {
    pub fn from(buffer: &[u8]) -> PacketCzGuildNotice {
        PacketCzGuildNotice {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            subject:  {
                let mut dst: [char; 60] = [0 as char; 60];
                for (index, byte) in buffer[6..66].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            subject_raw: {
                let mut dst: [u8; 60] = [0u8; 60];
                dst.clone_from_slice(&buffer[6..66]);
                dst
            },
            notice:  {
                let mut dst: [char; 120] = [0 as char; 120];
                for (index, byte) in buffer[66..186].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            notice_raw: {
                let mut dst: [u8; 120] = [0u8; 120];
                dst.clone_from_slice(&buffer[66..186]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.subject {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.subject_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.notice {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.notice_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzGuildNotice {
    fn id(&self) -> &str {
       "0x016e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcGuildNotice {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub subject: [char; 60],
    pub subject_raw: [u8; 60],
    pub notice: [char; 120],
    pub notice_raw: [u8; 120],
}

impl PacketZcGuildNotice {
    pub fn from(buffer: &[u8]) -> PacketZcGuildNotice {
        PacketZcGuildNotice {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            subject:  {
                let mut dst: [char; 60] = [0 as char; 60];
                for (index, byte) in buffer[2..62].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            subject_raw: {
                let mut dst: [u8; 60] = [0u8; 60];
                dst.clone_from_slice(&buffer[2..62]);
                dst
            },
            notice:  {
                let mut dst: [char; 120] = [0 as char; 120];
                for (index, byte) in buffer[62..182].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            notice_raw: {
                let mut dst: [u8; 120] = [0u8; 120];
                dst.clone_from_slice(&buffer[62..182]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.subject {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.subject_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.notice {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.notice_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcGuildNotice {
    fn id(&self) -> &str {
       "0x016f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqAllyGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub my_aid: u32,
    pub my_aid_raw: [u8; 4],
    pub my_gid: u32,
    pub my_gid_raw: [u8; 4],
}

impl PacketCzReqAllyGuild {
    pub fn from(buffer: &[u8]) -> PacketCzReqAllyGuild {
        PacketCzReqAllyGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            my_aid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            my_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            my_gid: u32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            my_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.my_aid).unwrap();
        self.my_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.my_gid).unwrap();
        self.my_gid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqAllyGuild {
    fn id(&self) -> &str {
       "0x0170"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcReqAllyGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub other_aid: u32,
    pub other_aid_raw: [u8; 4],
    pub guild_name: [char; 24],
    pub guild_name_raw: [u8; 24],
}

impl PacketZcReqAllyGuild {
    pub fn from(buffer: &[u8]) -> PacketZcReqAllyGuild {
        PacketZcReqAllyGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            other_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            other_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            guild_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            guild_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.other_aid).unwrap();
        self.other_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.guild_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guild_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcReqAllyGuild {
    fn id(&self) -> &str {
       "0x0171"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzAllyGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub other_aid: u32,
    pub other_aid_raw: [u8; 4],
    pub answer: i32,
    pub answer_raw: [u8; 4],
}

impl PacketCzAllyGuild {
    pub fn from(buffer: &[u8]) -> PacketCzAllyGuild {
        PacketCzAllyGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            other_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            other_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            answer: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            answer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.other_aid).unwrap();
        self.other_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzAllyGuild {
    fn id(&self) -> &str {
       "0x0172"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckReqAllyGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub answer: u8,
    pub answer_raw: [u8; 1],
}

impl PacketZcAckReqAllyGuild {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqAllyGuild {
        PacketZcAckReqAllyGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            answer: u8::from_le_bytes([buffer[2]]),
            answer_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckReqAllyGuild {
    fn id(&self) -> &str {
       "0x0173"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckChangeGuildPositioninfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub member_list: Vec<GuildRegPositionInfo>,
    pub member_list_raw: Vec<Vec<u8>>,
}

impl PacketZcAckChangeGuildPositioninfo {
    pub fn from(buffer: &[u8]) -> PacketZcAckChangeGuildPositioninfo {
        let iter_count = &buffer.len() / 30;
        let mut vec_field: Vec<GuildRegPositionInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 34 * i;
            vec_field.push(GuildRegPositionInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcAckChangeGuildPositioninfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            member_list: vec_field.clone(),
            member_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_list_raw = {
            self.member_list.iter_mut().for_each(|item| item.serialize());
            self.member_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcAckChangeGuildPositioninfo {
    fn id(&self) -> &str {
       "0x0174"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqGuildMemberInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: i32,
    pub gid_raw: [u8; 4],
}

impl PacketCzReqGuildMemberInfo {
    pub fn from(buffer: &[u8]) -> PacketCzReqGuildMemberInfo {
        PacketCzReqGuildMemberInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqGuildMemberInfo {
    fn id(&self) -> &str {
       "0x0175"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckGuildMemberInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub info: GuildMemberInfo,
    pub info_raw: Vec<u8>,
}

impl PacketZcAckGuildMemberInfo {
    pub fn from(buffer: &[u8]) -> PacketZcAckGuildMemberInfo {
        PacketZcAckGuildMemberInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            info: GuildMemberInfo::from(&buffer[2..buffer.len()]),
            info_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcAckGuildMemberInfo {
    fn id(&self) -> &str {
       "0x0176"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcItemidentifyList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub itidlist: Vec<u8>,
    pub itidlist_raw: Vec<u8>,
}

impl PacketZcItemidentifyList {
    pub fn from(buffer: &[u8]) -> PacketZcItemidentifyList {
        PacketZcItemidentifyList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            itidlist:  {
                let dst: Vec<u8> = buffer[4..buffer.len()].to_vec();
                dst
            },
            itidlist_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcItemidentifyList {
    fn id(&self) -> &str {
       "0x0177"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqItemidentify {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
}

impl PacketCzReqItemidentify {
    pub fn from(buffer: &[u8]) -> PacketCzReqItemidentify {
        PacketCzReqItemidentify {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqItemidentify {
    fn id(&self) -> &str {
       "0x0178"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckItemidentify {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcAckItemidentify {
    pub fn from(buffer: &[u8]) -> PacketZcAckItemidentify {
        PacketZcAckItemidentify {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            result: u8::from_le_bytes([buffer[4]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckItemidentify {
    fn id(&self) -> &str {
       "0x0179"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqItemcompositionList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub card_index: i16,
    pub card_index_raw: [u8; 2],
}

impl PacketCzReqItemcompositionList {
    pub fn from(buffer: &[u8]) -> PacketCzReqItemcompositionList {
        PacketCzReqItemcompositionList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            card_index: i16::from_le_bytes([buffer[2], buffer[3]]),
            card_index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.card_index).unwrap();
        self.card_index_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqItemcompositionList {
    fn id(&self) -> &str {
       "0x017a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcItemcompositionList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub itidlist: Vec<u8>,
    pub itidlist_raw: Vec<u8>,
}

impl PacketZcItemcompositionList {
    pub fn from(buffer: &[u8]) -> PacketZcItemcompositionList {
        PacketZcItemcompositionList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            itidlist:  {
                let dst: Vec<u8> = buffer[4..buffer.len()].to_vec();
                dst
            },
            itidlist_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcItemcompositionList {
    fn id(&self) -> &str {
       "0x017b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqItemcomposition {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub card_index: i16,
    pub card_index_raw: [u8; 2],
    pub equip_index: i16,
    pub equip_index_raw: [u8; 2],
}

impl PacketCzReqItemcomposition {
    pub fn from(buffer: &[u8]) -> PacketCzReqItemcomposition {
        PacketCzReqItemcomposition {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            card_index: i16::from_le_bytes([buffer[2], buffer[3]]),
            card_index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            equip_index: i16::from_le_bytes([buffer[4], buffer[5]]),
            equip_index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.card_index).unwrap();
        self.card_index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.equip_index).unwrap();
        self.equip_index_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqItemcomposition {
    fn id(&self) -> &str {
       "0x017c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckItemcomposition {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub equip_index: i16,
    pub equip_index_raw: [u8; 2],
    pub card_index: i16,
    pub card_index_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcAckItemcomposition {
    pub fn from(buffer: &[u8]) -> PacketZcAckItemcomposition {
        PacketZcAckItemcomposition {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            equip_index: i16::from_le_bytes([buffer[2], buffer[3]]),
            equip_index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            card_index: i16::from_le_bytes([buffer[4], buffer[5]]),
            card_index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            result: u8::from_le_bytes([buffer[6]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.equip_index).unwrap();
        self.equip_index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.card_index).unwrap();
        self.card_index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckItemcomposition {
    fn id(&self) -> &str {
       "0x017d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzGuildChat {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketCzGuildChat {
    pub fn from(buffer: &[u8]) -> PacketCzGuildChat {
        PacketCzGuildChat {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            msg_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketCzGuildChat {
    fn id(&self) -> &str {
       "0x017e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcGuildChat {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketZcGuildChat {
    pub fn from(buffer: &[u8]) -> PacketZcGuildChat {
        PacketZcGuildChat {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            msg_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketZcGuildChat {
    fn id(&self) -> &str {
       "0x017f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqHostileGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketCzReqHostileGuild {
    pub fn from(buffer: &[u8]) -> PacketCzReqHostileGuild {
        PacketCzReqHostileGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqHostileGuild {
    fn id(&self) -> &str {
       "0x0180"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckReqHostileGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcAckReqHostileGuild {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqHostileGuild {
        PacketZcAckReqHostileGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckReqHostileGuild {
    fn id(&self) -> &str {
       "0x0181"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMemberAdd {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub info: GuildMemberInfo,
    pub info_raw: Vec<u8>,
}

impl PacketZcMemberAdd {
    pub fn from(buffer: &[u8]) -> PacketZcMemberAdd {
        PacketZcMemberAdd {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            info: GuildMemberInfo::from(&buffer[2..buffer.len()]),
            info_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcMemberAdd {
    fn id(&self) -> &str {
       "0x0182"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqDeleteRelatedGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub opponent_gdid: u32,
    pub opponent_gdid_raw: [u8; 4],
    pub relation: i32,
    pub relation_raw: [u8; 4],
}

impl PacketCzReqDeleteRelatedGuild {
    pub fn from(buffer: &[u8]) -> PacketCzReqDeleteRelatedGuild {
        PacketCzReqDeleteRelatedGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            opponent_gdid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            opponent_gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            relation: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            relation_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.opponent_gdid).unwrap();
        self.opponent_gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.relation).unwrap();
        self.relation_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqDeleteRelatedGuild {
    fn id(&self) -> &str {
       "0x0183"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcDeleteRelatedGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub opponent_gdid: u32,
    pub opponent_gdid_raw: [u8; 4],
    pub relation: i32,
    pub relation_raw: [u8; 4],
}

impl PacketZcDeleteRelatedGuild {
    pub fn from(buffer: &[u8]) -> PacketZcDeleteRelatedGuild {
        PacketZcDeleteRelatedGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            opponent_gdid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            opponent_gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            relation: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            relation_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.opponent_gdid).unwrap();
        self.opponent_gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.relation).unwrap();
        self.relation_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcDeleteRelatedGuild {
    fn id(&self) -> &str {
       "0x0184"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAddRelatedGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub info: RelatedGuildInfo,
    pub info_raw: Vec<u8>,
}

impl PacketZcAddRelatedGuild {
    pub fn from(buffer: &[u8]) -> PacketZcAddRelatedGuild {
        PacketZcAddRelatedGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            info: RelatedGuildInfo::from(&buffer[2..buffer.len()]),
            info_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcAddRelatedGuild {
    fn id(&self) -> &str {
       "0x0185"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCollectordead {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub server_id: u32,
    pub server_id_raw: [u8; 4],
}

impl PacketCollectordead {
    pub fn from(buffer: &[u8]) -> PacketCollectordead {
        PacketCollectordead {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            server_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            server_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.server_id).unwrap();
        self.server_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCollectordead {
    fn id(&self) -> &str {
       "0x0186"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketPing {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketPing {
    pub fn from(buffer: &[u8]) -> PacketPing {
        PacketPing {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketPing {
    fn id(&self) -> &str {
       "0x0187"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckItemrefining {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: i16,
    pub result_raw: [u8; 2],
    pub item_index: i16,
    pub item_index_raw: [u8; 2],
    pub refining_level: i16,
    pub refining_level_raw: [u8; 2],
}

impl PacketZcAckItemrefining {
    pub fn from(buffer: &[u8]) -> PacketZcAckItemrefining {
        PacketZcAckItemrefining {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_index: i16::from_le_bytes([buffer[4], buffer[5]]),
            item_index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            refining_level: i16::from_le_bytes([buffer[6], buffer[7]]),
            refining_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.item_index).unwrap();
        self.item_index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckItemrefining {
    fn id(&self) -> &str {
       "0x0188"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyMapinfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i16,
    pub atype_raw: [u8; 2],
}

impl PacketZcNotifyMapinfo {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMapinfo {
        PacketZcNotifyMapinfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyMapinfo {
    fn id(&self) -> &str {
       "0x0189"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqDisconnect {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i16,
    pub atype_raw: [u8; 2],
}

impl PacketCzReqDisconnect {
    pub fn from(buffer: &[u8]) -> PacketCzReqDisconnect {
        PacketCzReqDisconnect {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqDisconnect {
    fn id(&self) -> &str {
       "0x018a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckReqDisconnect {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: i16,
    pub result_raw: [u8; 2],
}

impl PacketZcAckReqDisconnect {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqDisconnect {
        PacketZcAckReqDisconnect {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckReqDisconnect {
    fn id(&self) -> &str {
       "0x018b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMonsterInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub level: i16,
    pub level_raw: [u8; 2],
    pub size: i16,
    pub size_raw: [u8; 2],
    pub hp: i32,
    pub hp_raw: [u8; 4],
    pub def: i16,
    pub def_raw: [u8; 2],
    pub race_type: i16,
    pub race_type_raw: [u8; 2],
    pub mdef_power: i16,
    pub mdef_power_raw: [u8; 2],
    pub property: i16,
    pub property_raw: [u8; 2],
    pub property_table: MonsterInfoElement,
    pub property_table_raw: Vec<u8>,
}

impl PacketZcMonsterInfo {
    pub fn from(buffer: &[u8]) -> PacketZcMonsterInfo {
        PacketZcMonsterInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            job: i16::from_le_bytes([buffer[2], buffer[3]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            level: i16::from_le_bytes([buffer[4], buffer[5]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            size: i16::from_le_bytes([buffer[6], buffer[7]]),
            size_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            hp: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            def: i16::from_le_bytes([buffer[12], buffer[13]]),
            def_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            race_type: i16::from_le_bytes([buffer[14], buffer[15]]),
            race_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            mdef_power: i16::from_le_bytes([buffer[16], buffer[17]]),
            mdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            property: i16::from_le_bytes([buffer[18], buffer[19]]),
            property_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            property_table: MonsterInfoElement::from(&buffer[20..buffer.len()]),
            property_table_raw: buffer[20..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.size).unwrap();
        self.size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.def).unwrap();
        self.def_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.race_type).unwrap();
        self.race_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef_power).unwrap();
        self.mdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.property).unwrap();
        self.property_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcMonsterInfo {
    fn id(&self) -> &str {
       "0x018c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMakableitemlist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub info: MakableitemInfo,
    pub info_raw: Vec<u8>,
}

impl PacketZcMakableitemlist {
    pub fn from(buffer: &[u8]) -> PacketZcMakableitemlist {
        PacketZcMakableitemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            info: MakableitemInfo::from(&buffer[4..buffer.len()]),
            info_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcMakableitemlist {
    fn id(&self) -> &str {
       "0x018d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqmakingitem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub info: MakableitemInfo,
    pub info_raw: Vec<u8>,
}

impl PacketCzReqmakingitem {
    pub fn from(buffer: &[u8]) -> PacketCzReqmakingitem {
        PacketCzReqmakingitem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            info: MakableitemInfo::from(&buffer[2..buffer.len()]),
            info_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketCzReqmakingitem {
    fn id(&self) -> &str {
       "0x018e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckReqmakingitem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: i16,
    pub result_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
}

impl PacketZcAckReqmakingitem {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqmakingitem {
        PacketZcAckReqmakingitem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            itid: u16::from_le_bytes([buffer[4], buffer[5]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckReqmakingitem {
    fn id(&self) -> &str {
       "0x018f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzUseSkillTogroundWithtalkbox {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub selected_level: i16,
    pub selected_level_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
    pub contents: [char; 80],
    pub contents_raw: [u8; 80],
}

impl PacketCzUseSkillTogroundWithtalkbox {
    pub fn from(buffer: &[u8]) -> PacketCzUseSkillTogroundWithtalkbox {
        PacketCzUseSkillTogroundWithtalkbox {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            selected_level: i16::from_le_bytes([buffer[2], buffer[3]]),
            selected_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            skid: u16::from_le_bytes([buffer[4], buffer[5]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[6], buffer[7]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[8], buffer[9]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            contents:  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[10..90].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            contents_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[10..90]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.selected_level).unwrap();
        self.selected_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.contents {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.contents_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzUseSkillTogroundWithtalkbox {
    fn id(&self) -> &str {
       "0x0190"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcTalkboxChatcontents {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub contents: [char; 80],
    pub contents_raw: [u8; 80],
}

impl PacketZcTalkboxChatcontents {
    pub fn from(buffer: &[u8]) -> PacketZcTalkboxChatcontents {
        PacketZcTalkboxChatcontents {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            contents:  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[6..86].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            contents_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[6..86]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.contents {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.contents_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcTalkboxChatcontents {
    fn id(&self) -> &str {
       "0x0191"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcUpdateMapinfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
    pub atype: i16,
    pub atype_raw: [u8; 2],
    pub map_name: [char; 16],
    pub map_name_raw: [u8; 16],
}

impl PacketZcUpdateMapinfo {
    pub fn from(buffer: &[u8]) -> PacketZcUpdateMapinfo {
        PacketZcUpdateMapinfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[2], buffer[3]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[4], buffer[5]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            atype: i16::from_le_bytes([buffer[6], buffer[7]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[8..24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[8..24]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcUpdateMapinfo {
    fn id(&self) -> &str {
       "0x0192"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqnameBygid {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
}

impl PacketCzReqnameBygid {
    pub fn from(buffer: &[u8]) -> PacketCzReqnameBygid {
        PacketCzReqnameBygid {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqnameBygid {
    fn id(&self) -> &str {
       "0x0193"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckReqnameBygid {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub cname: [char; 24],
    pub cname_raw: [u8; 24],
}

impl PacketZcAckReqnameBygid {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqnameBygid {
        PacketZcAckReqnameBygid {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            cname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            cname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.cname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.cname_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckReqnameBygid {
    fn id(&self) -> &str {
       "0x0194"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckReqnameall {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub cname: [char; 24],
    pub cname_raw: [u8; 24],
    pub pname: [char; 24],
    pub pname_raw: [u8; 24],
    pub gname: [char; 24],
    pub gname_raw: [u8; 24],
    pub rname: [char; 24],
    pub rname_raw: [u8; 24],
}

impl PacketZcAckReqnameall {
    pub fn from(buffer: &[u8]) -> PacketZcAckReqnameall {
        PacketZcAckReqnameall {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            cname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            cname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            pname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[30..54].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[30..54]);
                dst
            },
            gname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[54..78].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            gname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[54..78]);
                dst
            },
            rname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[78..102].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            rname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[78..102]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.cname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.cname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.gname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.gname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.rname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.rname_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckReqnameall {
    fn id(&self) -> &str {
       "0x0195"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMsgStateChange {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub state: bool,
    pub state_raw: [u8; 1],
}

impl PacketZcMsgStateChange {
    pub fn from(buffer: &[u8]) -> PacketZcMsgStateChange {
        PacketZcMsgStateChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            state: buffer[8] == 1,
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state as u8).unwrap();
        self.state_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMsgStateChange {
    fn id(&self) -> &str {
       "0x0196"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReset {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i16,
    pub atype_raw: [u8; 2],
}

impl PacketCzReset {
    pub fn from(buffer: &[u8]) -> PacketCzReset {
        PacketCzReset {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReset {
    fn id(&self) -> &str {
       "0x0197"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzChangeMaptype {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
    pub atype: i16,
    pub atype_raw: [u8; 2],
}

impl PacketCzChangeMaptype {
    pub fn from(buffer: &[u8]) -> PacketCzChangeMaptype {
        PacketCzChangeMaptype {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[2], buffer[3]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[4], buffer[5]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            atype: i16::from_le_bytes([buffer[6], buffer[7]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzChangeMaptype {
    fn id(&self) -> &str {
       "0x0198"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyMapproperty {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i16,
    pub atype_raw: [u8; 2],
}

impl PacketZcNotifyMapproperty {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMapproperty {
        PacketZcNotifyMapproperty {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyMapproperty {
    fn id(&self) -> &str {
       "0x0199"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyRanking {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub ranking: i32,
    pub ranking_raw: [u8; 4],
    pub total: i32,
    pub total_raw: [u8; 4],
}

impl PacketZcNotifyRanking {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyRanking {
        PacketZcNotifyRanking {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            ranking: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            ranking_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            total: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            total_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.ranking).unwrap();
        self.ranking_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.total).unwrap();
        self.total_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyRanking {
    fn id(&self) -> &str {
       "0x019a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyEffect {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub effect_id: i32,
    pub effect_id_raw: [u8; 4],
}

impl PacketZcNotifyEffect {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyEffect {
        PacketZcNotifyEffect {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            effect_id: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            effect_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_id).unwrap();
        self.effect_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyEffect {
    fn id(&self) -> &str {
       "0x019b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzChangeEffectstate {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub effect_state: i32,
    pub effect_state_raw: [u8; 4],
}

impl PacketCzChangeEffectstate {
    pub fn from(buffer: &[u8]) -> PacketCzChangeEffectstate {
        PacketCzChangeEffectstate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzChangeEffectstate {
    fn id(&self) -> &str {
       "0x019d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcStartCapture {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketZcStartCapture {
    pub fn from(buffer: &[u8]) -> PacketZcStartCapture {
        PacketZcStartCapture {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcStartCapture {
    fn id(&self) -> &str {
       "0x019e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzTrycaptureMonster {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub target_aid: u32,
    pub target_aid_raw: [u8; 4],
}

impl PacketCzTrycaptureMonster {
    pub fn from(buffer: &[u8]) -> PacketCzTrycaptureMonster {
        PacketCzTrycaptureMonster {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            target_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            target_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_aid).unwrap();
        self.target_aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzTrycaptureMonster {
    fn id(&self) -> &str {
       "0x019f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcTrycaptureMonster {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcTrycaptureMonster {
    pub fn from(buffer: &[u8]) -> PacketZcTrycaptureMonster {
        PacketZcTrycaptureMonster {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcTrycaptureMonster {
    fn id(&self) -> &str {
       "0x01a0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzCommandPet {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub c_sub: i8,
    pub c_sub_raw: [u8; 1],
}

impl PacketCzCommandPet {
    pub fn from(buffer: &[u8]) -> PacketCzCommandPet {
        PacketCzCommandPet {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            c_sub: i8::from_le_bytes([buffer[2]]),
            c_sub_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.c_sub).unwrap();
        self.c_sub_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzCommandPet {
    fn id(&self) -> &str {
       "0x01a1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPropertyPet {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub sz_name: [char; 24],
    pub sz_name_raw: [u8; 24],
    pub b_modified: u8,
    pub b_modified_raw: [u8; 1],
    pub n_level: i16,
    pub n_level_raw: [u8; 2],
    pub n_fullness: i16,
    pub n_fullness_raw: [u8; 2],
    pub n_relationship: i16,
    pub n_relationship_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub job: i16,
    pub job_raw: [u8; 2],
}

impl PacketZcPropertyPet {
    pub fn from(buffer: &[u8]) -> PacketZcPropertyPet {
        PacketZcPropertyPet {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            sz_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            sz_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            b_modified: u8::from_le_bytes([buffer[26]]),
            b_modified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[26..27]);
                dst
            },
            n_level: i16::from_le_bytes([buffer[27], buffer[28]]),
            n_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[27..29]);
                dst
            },
            n_fullness: i16::from_le_bytes([buffer[29], buffer[30]]),
            n_fullness_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[29..31]);
                dst
            },
            n_relationship: i16::from_le_bytes([buffer[31], buffer[32]]),
            n_relationship_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[31..33]);
                dst
            },
            itid: u16::from_le_bytes([buffer[33], buffer[34]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            job: i16::from_le_bytes([buffer[35], buffer[36]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[35..37]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.b_modified).unwrap();
        self.b_modified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.n_level).unwrap();
        self.n_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.n_fullness).unwrap();
        self.n_fullness_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.n_relationship).unwrap();
        self.n_relationship_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcPropertyPet {
    fn id(&self) -> &str {
       "0x01a2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcFeedPet {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub c_ret: i8,
    pub c_ret_raw: [u8; 1],
    pub itid: u16,
    pub itid_raw: [u8; 2],
}

impl PacketZcFeedPet {
    pub fn from(buffer: &[u8]) -> PacketZcFeedPet {
        PacketZcFeedPet {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            c_ret: i8::from_le_bytes([buffer[2]]),
            c_ret_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            itid: u16::from_le_bytes([buffer[3], buffer[4]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[3..5]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.c_ret).unwrap();
        self.c_ret_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcFeedPet {
    fn id(&self) -> &str {
       "0x01a3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcChangestatePet {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i8,
    pub atype_raw: [u8; 1],
    pub gid: i32,
    pub gid_raw: [u8; 4],
    pub data: i32,
    pub data_raw: [u8; 4],
}

impl PacketZcChangestatePet {
    pub fn from(buffer: &[u8]) -> PacketZcChangestatePet {
        PacketZcChangestatePet {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            gid: i32::from_le_bytes([buffer[3], buffer[4], buffer[5], buffer[6]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[3..7]);
                dst
            },
            data: i32::from_le_bytes([buffer[7], buffer[8], buffer[9], buffer[10]]),
            data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[7..11]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.data).unwrap();
        self.data_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcChangestatePet {
    fn id(&self) -> &str {
       "0x01a4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRenamePet {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub sz_name: [char; 24],
    pub sz_name_raw: [u8; 24],
}

impl PacketCzRenamePet {
    pub fn from(buffer: &[u8]) -> PacketCzRenamePet {
        PacketCzRenamePet {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            sz_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            sz_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzRenamePet {
    fn id(&self) -> &str {
       "0x01a5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPeteggList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub egg_list: Vec<PeteggitemInfo>,
    pub egg_list_raw: Vec<Vec<u8>>,
}

impl PacketZcPeteggList {
    pub fn from(buffer: &[u8]) -> PacketZcPeteggList {
        let iter_count = &buffer.len() / 2;
        let mut vec_field: Vec<PeteggitemInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 6 * i;
            vec_field.push(PeteggitemInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPeteggList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            egg_list: vec_field.clone(),
            egg_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.egg_list_raw = {
            self.egg_list.iter_mut().for_each(|item| item.serialize());
            self.egg_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcPeteggList {
    fn id(&self) -> &str {
       "0x01a6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzSelectPetegg {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
}

impl PacketCzSelectPetegg {
    pub fn from(buffer: &[u8]) -> PacketCzSelectPetegg {
        PacketCzSelectPetegg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzSelectPetegg {
    fn id(&self) -> &str {
       "0x01a7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzPeteggInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
}

impl PacketCzPeteggInfo {
    pub fn from(buffer: &[u8]) -> PacketCzPeteggInfo {
        PacketCzPeteggInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzPeteggInfo {
    fn id(&self) -> &str {
       "0x01a8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzPetAct {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub data: i32,
    pub data_raw: [u8; 4],
}

impl PacketCzPetAct {
    pub fn from(buffer: &[u8]) -> PacketCzPetAct {
        PacketCzPetAct {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            data: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.data).unwrap();
        self.data_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzPetAct {
    fn id(&self) -> &str {
       "0x01a9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPetAct {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: i32,
    pub gid_raw: [u8; 4],
    pub data: i32,
    pub data_raw: [u8; 4],
}

impl PacketZcPetAct {
    pub fn from(buffer: &[u8]) -> PacketZcPetAct {
        PacketZcPetAct {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            data: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.data).unwrap();
        self.data_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcPetAct {
    fn id(&self) -> &str {
       "0x01aa"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcParChangeUser {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub var_id: u16,
    pub var_id_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
}

impl PacketZcParChangeUser {
    pub fn from(buffer: &[u8]) -> PacketZcParChangeUser {
        PacketZcParChangeUser {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            var_id: u16::from_le_bytes([buffer[6], buffer[7]]),
            var_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            count: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var_id).unwrap();
        self.var_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcParChangeUser {
    fn id(&self) -> &str {
       "0x01ab"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSkillUpdate {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketZcSkillUpdate {
    pub fn from(buffer: &[u8]) -> PacketZcSkillUpdate {
        PacketZcSkillUpdate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSkillUpdate {
    fn id(&self) -> &str {
       "0x01ac"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMakingarrowList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub arrow_list: Vec<ArrowitemInfo>,
    pub arrow_list_raw: Vec<Vec<u8>>,
}

impl PacketZcMakingarrowList {
    pub fn from(buffer: &[u8]) -> PacketZcMakingarrowList {
        let iter_count = &buffer.len() / 2;
        let mut vec_field: Vec<ArrowitemInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 6 * i;
            vec_field.push(ArrowitemInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcMakingarrowList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            arrow_list: vec_field.clone(),
            arrow_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.arrow_list_raw = {
            self.arrow_list.iter_mut().for_each(|item| item.serialize());
            self.arrow_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcMakingarrowList {
    fn id(&self) -> &str {
       "0x01ad"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqMakingarrow {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub id: u16,
    pub id_raw: [u8; 2],
}

impl PacketCzReqMakingarrow {
    pub fn from(buffer: &[u8]) -> PacketCzReqMakingarrow {
        PacketCzReqMakingarrow {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            id: u16::from_le_bytes([buffer[2], buffer[3]]),
            id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.id).unwrap();
        self.id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqMakingarrow {
    fn id(&self) -> &str {
       "0x01ae"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqChangecart {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub num: i16,
    pub num_raw: [u8; 2],
}

impl PacketCzReqChangecart {
    pub fn from(buffer: &[u8]) -> PacketCzReqChangecart {
        PacketCzReqChangecart {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            num: i16::from_le_bytes([buffer[2], buffer[3]]),
            num_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.num).unwrap();
        self.num_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqChangecart {
    fn id(&self) -> &str {
       "0x01af"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNpcspriteChange {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub value: u32,
    pub value_raw: [u8; 4],
}

impl PacketZcNpcspriteChange {
    pub fn from(buffer: &[u8]) -> PacketZcNpcspriteChange {
        PacketZcNpcspriteChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            value: u32::from_le_bytes([buffer[7], buffer[8], buffer[9], buffer[10]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[7..11]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNpcspriteChange {
    fn id(&self) -> &str {
       "0x01b0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcShowdigit {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub value: i32,
    pub value_raw: [u8; 4],
}

impl PacketZcShowdigit {
    pub fn from(buffer: &[u8]) -> PacketZcShowdigit {
        PacketZcShowdigit {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: u8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            value: i32::from_le_bytes([buffer[3], buffer[4], buffer[5], buffer[6]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[3..7]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcShowdigit {
    fn id(&self) -> &str {
       "0x01b1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqOpenstore2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub store_name: [char; 80],
    pub store_name_raw: [u8; 80],
    pub result: bool,
    pub result_raw: [u8; 1],
    pub store_list: Vec<StoreItem>,
    pub store_list_raw: Vec<Vec<u8>>,
}

impl PacketCzReqOpenstore2 {
    pub fn from(buffer: &[u8]) -> PacketCzReqOpenstore2 {
        let iter_count = &buffer.len() / 8;
        let mut vec_field: Vec<StoreItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 85 * i;
            let end_pos = 93 * i;
            vec_field.push(StoreItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzReqOpenstore2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            store_name:  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[4..84].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            store_name_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[4..84]);
                dst
            },
            result: buffer[84] == 1,
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[84..85]);
                dst
            },
            store_list: vec_field.clone(),
            store_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.store_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.store_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        self.store_list_raw = {
            self.store_list.iter_mut().for_each(|item| item.serialize());
            self.store_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketCzReqOpenstore2 {
    fn id(&self) -> &str {
       "0x01b2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcShowImage2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub image_name: [char; 64],
    pub image_name_raw: [u8; 64],
    pub atype: u8,
    pub atype_raw: [u8; 1],
}

impl PacketZcShowImage2 {
    pub fn from(buffer: &[u8]) -> PacketZcShowImage2 {
        PacketZcShowImage2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            image_name:  {
                let mut dst: [char; 64] = [0 as char; 64];
                for (index, byte) in buffer[2..66].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            image_name_raw: {
                let mut dst: [u8; 64] = [0u8; 64];
                dst.clone_from_slice(&buffer[2..66]);
                dst
            },
            atype: u8::from_le_bytes([buffer[66]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[66..67]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.image_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.image_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcShowImage2 {
    fn id(&self) -> &str {
       "0x01b3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcChangeGuild {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub gdid: u32,
    pub gdid_raw: [u8; 4],
    pub emblem_version: i16,
    pub emblem_version_raw: [u8; 2],
}

impl PacketZcChangeGuild {
    pub fn from(buffer: &[u8]) -> PacketZcChangeGuild {
        PacketZcChangeGuild {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gdid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            emblem_version: i16::from_le_bytes([buffer[10], buffer[11]]),
            emblem_version_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.emblem_version).unwrap();
        self.emblem_version_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcChangeGuild {
    fn id(&self) -> &str {
       "0x01b4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketScBillingInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub dw_amount_remain: u32,
    pub dw_amount_remain_raw: [u8; 4],
    pub dw_quantity_remain: u32,
    pub dw_quantity_remain_raw: [u8; 4],
    pub dw_reserved1: u32,
    pub dw_reserved1_raw: [u8; 4],
    pub dw_reserved2: u32,
    pub dw_reserved2_raw: [u8; 4],
}

impl PacketScBillingInfo {
    pub fn from(buffer: &[u8]) -> PacketScBillingInfo {
        PacketScBillingInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            dw_amount_remain: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            dw_amount_remain_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            dw_quantity_remain: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            dw_quantity_remain_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            dw_reserved1: u32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            dw_reserved1_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            dw_reserved2: u32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            dw_reserved2_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_amount_remain).unwrap();
        self.dw_amount_remain_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_quantity_remain).unwrap();
        self.dw_quantity_remain_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_reserved1).unwrap();
        self.dw_reserved1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_reserved2).unwrap();
        self.dw_reserved2_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketScBillingInfo {
    fn id(&self) -> &str {
       "0x01b5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcGuildInfo2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gdid: i32,
    pub gdid_raw: [u8; 4],
    pub level: i32,
    pub level_raw: [u8; 4],
    pub user_num: i32,
    pub user_num_raw: [u8; 4],
    pub max_user_num: i32,
    pub max_user_num_raw: [u8; 4],
    pub user_average_level: i32,
    pub user_average_level_raw: [u8; 4],
    pub exp: i32,
    pub exp_raw: [u8; 4],
    pub max_exp: i32,
    pub max_exp_raw: [u8; 4],
    pub point: i32,
    pub point_raw: [u8; 4],
    pub honor: i32,
    pub honor_raw: [u8; 4],
    pub virtue: i32,
    pub virtue_raw: [u8; 4],
    pub emblem_version: i32,
    pub emblem_version_raw: [u8; 4],
    pub guildname: [char; 24],
    pub guildname_raw: [u8; 24],
    pub master_name: [char; 24],
    pub master_name_raw: [u8; 24],
    pub manage_land: [char; 16],
    pub manage_land_raw: [u8; 16],
    pub zeny: i32,
    pub zeny_raw: [u8; 4],
}

impl PacketZcGuildInfo2 {
    pub fn from(buffer: &[u8]) -> PacketZcGuildInfo2 {
        PacketZcGuildInfo2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            level: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            user_num: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            user_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            max_user_num: i32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            max_user_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
            user_average_level: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            user_average_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
            exp: i32::from_le_bytes([buffer[22], buffer[23], buffer[24], buffer[25]]),
            exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[22..26]);
                dst
            },
            max_exp: i32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            max_exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
            point: i32::from_le_bytes([buffer[30], buffer[31], buffer[32], buffer[33]]),
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[30..34]);
                dst
            },
            honor: i32::from_le_bytes([buffer[34], buffer[35], buffer[36], buffer[37]]),
            honor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[34..38]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[38], buffer[39], buffer[40], buffer[41]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[38..42]);
                dst
            },
            emblem_version: i32::from_le_bytes([buffer[42], buffer[43], buffer[44], buffer[45]]),
            emblem_version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[42..46]);
                dst
            },
            guildname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[46..70].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            guildname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[46..70]);
                dst
            },
            master_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[70..94].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            master_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[70..94]);
                dst
            },
            manage_land:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[94..110].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            manage_land_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[94..110]);
                dst
            },
            zeny: i32::from_le_bytes([buffer[110], buffer[111], buffer[112], buffer[113]]),
            zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[110..114]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.user_num).unwrap();
        self.user_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_user_num).unwrap();
        self.max_user_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.user_average_level).unwrap();
        self.user_average_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.exp).unwrap();
        self.exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_exp).unwrap();
        self.max_exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.emblem_version).unwrap();
        self.emblem_version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.guildname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guildname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.master_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.master_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.manage_land {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.manage_land_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.zeny).unwrap();
        self.zeny_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcGuildInfo2 {
    fn id(&self) -> &str {
       "0x01b6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzGuildZeny {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub zeny: i32,
    pub zeny_raw: [u8; 4],
}

impl PacketCzGuildZeny {
    pub fn from(buffer: &[u8]) -> PacketCzGuildZeny {
        PacketCzGuildZeny {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            zeny: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.zeny).unwrap();
        self.zeny_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzGuildZeny {
    fn id(&self) -> &str {
       "0x01b7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcGuildZenyAck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub ret: u8,
    pub ret_raw: [u8; 1],
}

impl PacketZcGuildZenyAck {
    pub fn from(buffer: &[u8]) -> PacketZcGuildZenyAck {
        PacketZcGuildZenyAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            ret: u8::from_le_bytes([buffer[2]]),
            ret_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.ret).unwrap();
        self.ret_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcGuildZenyAck {
    fn id(&self) -> &str {
       "0x01b8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcDispel {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketZcDispel {
    pub fn from(buffer: &[u8]) -> PacketZcDispel {
        PacketZcDispel {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcDispel {
    fn id(&self) -> &str {
       "0x01b9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRemoveAid {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub account_name: [char; 24],
    pub account_name_raw: [u8; 24],
}

impl PacketCzRemoveAid {
    pub fn from(buffer: &[u8]) -> PacketCzRemoveAid {
        PacketCzRemoveAid {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            account_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            account_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.account_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.account_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzRemoveAid {
    fn id(&self) -> &str {
       "0x01ba"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzShift {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub character_name: [char; 24],
    pub character_name_raw: [u8; 24],
}

impl PacketCzShift {
    pub fn from(buffer: &[u8]) -> PacketCzShift {
        PacketCzShift {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzShift {
    fn id(&self) -> &str {
       "0x01bb"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRecall {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub account_name: [char; 24],
    pub account_name_raw: [u8; 24],
}

impl PacketCzRecall {
    pub fn from(buffer: &[u8]) -> PacketCzRecall {
        PacketCzRecall {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            account_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            account_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.account_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.account_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzRecall {
    fn id(&self) -> &str {
       "0x01bc"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRecallGid {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub character_name: [char; 24],
    pub character_name_raw: [u8; 24],
}

impl PacketCzRecallGid {
    pub fn from(buffer: &[u8]) -> PacketCzRecallGid {
        PacketCzRecallGid {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzRecallGid {
    fn id(&self) -> &str {
       "0x01bd"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcAskPngameroom {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketAcAskPngameroom {
    pub fn from(buffer: &[u8]) -> PacketAcAskPngameroom {
        PacketAcAskPngameroom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcAskPngameroom {
    fn id(&self) -> &str {
       "0x01be"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCaReplyPngameroom {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub permission: u8,
    pub permission_raw: [u8; 1],
}

impl PacketCaReplyPngameroom {
    pub fn from(buffer: &[u8]) -> PacketCaReplyPngameroom {
        PacketCaReplyPngameroom {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            permission: u8::from_le_bytes([buffer[2]]),
            permission_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.permission).unwrap();
        self.permission_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCaReplyPngameroom {
    fn id(&self) -> &str {
       "0x01bf"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqRemaintime {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzReqRemaintime {
    pub fn from(buffer: &[u8]) -> PacketCzReqRemaintime {
        PacketCzReqRemaintime {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqRemaintime {
    fn id(&self) -> &str {
       "0x01c0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcReplyRemaintime {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: i32,
    pub result_raw: [u8; 4],
    pub expiration_date: i32,
    pub expiration_date_raw: [u8; 4],
    pub remain_time: i32,
    pub remain_time_raw: [u8; 4],
}

impl PacketZcReplyRemaintime {
    pub fn from(buffer: &[u8]) -> PacketZcReplyRemaintime {
        PacketZcReplyRemaintime {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            expiration_date: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            expiration_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            remain_time: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            remain_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.expiration_date).unwrap();
        self.expiration_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.remain_time).unwrap();
        self.remain_time_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcReplyRemaintime {
    fn id(&self) -> &str {
       "0x01c1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcInfoRemaintime {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i32,
    pub atype_raw: [u8; 4],
    pub remain_time: i32,
    pub remain_time_raw: [u8; 4],
}

impl PacketZcInfoRemaintime {
    pub fn from(buffer: &[u8]) -> PacketZcInfoRemaintime {
        PacketZcInfoRemaintime {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            remain_time: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            remain_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.remain_time).unwrap();
        self.remain_time_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcInfoRemaintime {
    fn id(&self) -> &str {
       "0x01c2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcBroadcast2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub font_color: u32,
    pub font_color_raw: [u8; 4],
    pub font_type: i16,
    pub font_type_raw: [u8; 2],
    pub font_size: i16,
    pub font_size_raw: [u8; 2],
    pub font_align: i16,
    pub font_align_raw: [u8; 2],
    pub font_y: i16,
    pub font_y_raw: [u8; 2],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketZcBroadcast2 {
    pub fn from(buffer: &[u8]) -> PacketZcBroadcast2 {
        PacketZcBroadcast2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            font_color: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            font_color_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            font_type: i16::from_le_bytes([buffer[8], buffer[9]]),
            font_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            font_size: i16::from_le_bytes([buffer[10], buffer[11]]),
            font_size_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            font_align: i16::from_le_bytes([buffer[12], buffer[13]]),
            font_align_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            font_y: i16::from_le_bytes([buffer[14], buffer[15]]),
            font_y_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[16..buffer.len()]).to_string(),
            msg_raw: buffer[16..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.font_color).unwrap();
        self.font_color_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font_type).unwrap();
        self.font_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font_size).unwrap();
        self.font_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font_align).unwrap();
        self.font_align_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font_y).unwrap();
        self.font_y_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketZcBroadcast2 {
    fn id(&self) -> &str {
       "0x01c3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAddItemToStore2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub is_damaged: bool,
    pub is_damaged_raw: [u8; 1],
    pub refining_level: u8,
    pub refining_level_raw: [u8; 1],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
}

impl PacketZcAddItemToStore2 {
    pub fn from(buffer: &[u8]) -> PacketZcAddItemToStore2 {
        PacketZcAddItemToStore2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            itid: u16::from_le_bytes([buffer[8], buffer[9]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            atype: u8::from_le_bytes([buffer[10]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            is_identified: buffer[11] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            is_damaged: buffer[12] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[13]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[13..14]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[14..22]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[14..22]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcAddItemToStore2 {
    fn id(&self) -> &str {
       "0x01c4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAddItemToCart2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub is_damaged: bool,
    pub is_damaged_raw: [u8; 1],
    pub refining_level: u8,
    pub refining_level_raw: [u8; 1],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
}

impl PacketZcAddItemToCart2 {
    pub fn from(buffer: &[u8]) -> PacketZcAddItemToCart2 {
        PacketZcAddItemToCart2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            itid: u16::from_le_bytes([buffer[8], buffer[9]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            atype: u8::from_le_bytes([buffer[10]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            is_identified: buffer[11] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            is_damaged: buffer[12] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[13]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[13..14]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[14..22]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[14..22]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcAddItemToCart2 {
    fn id(&self) -> &str {
       "0x01c5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCsReqEncryption {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub enc_count: i8,
    pub enc_count_raw: [u8; 1],
    pub dec_count: i8,
    pub dec_count_raw: [u8; 1],
}

impl PacketCsReqEncryption {
    pub fn from(buffer: &[u8]) -> PacketCsReqEncryption {
        PacketCsReqEncryption {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            enc_count: i8::from_le_bytes([buffer[2]]),
            enc_count_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            dec_count: i8::from_le_bytes([buffer[3]]),
            dec_count_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[3..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.enc_count).unwrap();
        self.enc_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.dec_count).unwrap();
        self.dec_count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCsReqEncryption {
    fn id(&self) -> &str {
       "0x01c6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketScAckEncryption {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketScAckEncryption {
    pub fn from(buffer: &[u8]) -> PacketScAckEncryption {
        PacketScAckEncryption {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketScAckEncryption {
    fn id(&self) -> &str {
       "0x01c7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcUseItemAck2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: u16,
    pub index_raw: [u8; 2],
    pub id: u16,
    pub id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub result: bool,
    pub result_raw: [u8; 1],
}

impl PacketZcUseItemAck2 {
    pub fn from(buffer: &[u8]) -> PacketZcUseItemAck2 {
        PacketZcUseItemAck2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            id: u16::from_le_bytes([buffer[4], buffer[5]]),
            id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            aid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            count: i16::from_le_bytes([buffer[10], buffer[11]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            result: buffer[12] == 1,
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.id).unwrap();
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcUseItemAck2 {
    fn id(&self) -> &str {
       "0x01c8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSkillEntry2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub creator_aid: u32,
    pub creator_aid_raw: [u8; 4],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
    pub job: u8,
    pub job_raw: [u8; 1],
    pub is_visible: bool,
    pub is_visible_raw: [u8; 1],
    pub is_contens: bool,
    pub is_contens_raw: [u8; 1],
    pub msg: [char; 80],
    pub msg_raw: [u8; 80],
}

impl PacketZcSkillEntry2 {
    pub fn from(buffer: &[u8]) -> PacketZcSkillEntry2 {
        PacketZcSkillEntry2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            creator_aid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            creator_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[10], buffer[11]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[12], buffer[13]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: u8::from_le_bytes([buffer[14]]),
            job_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
            is_visible: buffer[15] == 1,
            is_visible_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[15..16]);
                dst
            },
            is_contens: buffer[16] == 1,
            is_contens_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[16..17]);
                dst
            },
            msg:  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[17..97].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            msg_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[17..97]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.creator_aid).unwrap();
        self.creator_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_visible as u8).unwrap();
        self.is_visible_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_contens as u8).unwrap();
        self.is_contens_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.msg {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.msg_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSkillEntry2 {
    fn id(&self) -> &str {
       "0x01c9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqmakinghomun {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: bool,
    pub result_raw: [u8; 1],
}

impl PacketCzReqmakinghomun {
    pub fn from(buffer: &[u8]) -> PacketCzReqmakinghomun {
        PacketCzReqmakinghomun {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: buffer[2] == 1,
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqmakinghomun {
    fn id(&self) -> &str {
       "0x01ca"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzMonsterTalk {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub state_id: u8,
    pub state_id_raw: [u8; 1],
    pub skill_id: u8,
    pub skill_id_raw: [u8; 1],
    pub arg1: u8,
    pub arg1_raw: [u8; 1],
}

impl PacketCzMonsterTalk {
    pub fn from(buffer: &[u8]) -> PacketCzMonsterTalk {
        PacketCzMonsterTalk {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            state_id: u8::from_le_bytes([buffer[6]]),
            state_id_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            skill_id: u8::from_le_bytes([buffer[7]]),
            skill_id_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[7..8]);
                dst
            },
            arg1: u8::from_le_bytes([buffer[8]]),
            arg1_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state_id).unwrap();
        self.state_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.skill_id).unwrap();
        self.skill_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.arg1).unwrap();
        self.arg1_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzMonsterTalk {
    fn id(&self) -> &str {
       "0x01cb"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMonsterTalk {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub state_id: u8,
    pub state_id_raw: [u8; 1],
    pub skill_id: u8,
    pub skill_id_raw: [u8; 1],
    pub arg1: u8,
    pub arg1_raw: [u8; 1],
}

impl PacketZcMonsterTalk {
    pub fn from(buffer: &[u8]) -> PacketZcMonsterTalk {
        PacketZcMonsterTalk {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            state_id: u8::from_le_bytes([buffer[6]]),
            state_id_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            skill_id: u8::from_le_bytes([buffer[7]]),
            skill_id_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[7..8]);
                dst
            },
            arg1: u8::from_le_bytes([buffer[8]]),
            arg1_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state_id).unwrap();
        self.state_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.skill_id).unwrap();
        self.skill_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.arg1).unwrap();
        self.arg1_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMonsterTalk {
    fn id(&self) -> &str {
       "0x01cc"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAutospelllist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub skid: [i32; 7],
    pub skid_raw: [u8; 7],
}

impl PacketZcAutospelllist {
    pub fn from(buffer: &[u8]) -> PacketZcAutospelllist {
        PacketZcAutospelllist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid:  {
                let mut dst: [i32; 7] = [0 as i32; 7];
                for (index, byte) in buffer[2..9].iter().enumerate() {
                    dst[index] = *byte as i32;
                }
                dst
            },
            skid_raw: {
                let mut dst: [u8; 7] = [0u8; 7];
                dst.clone_from_slice(&buffer[2..9]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.skid {
            wtr.write_i32::<LittleEndian>(item).unwrap();
        }
        self.skid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAutospelllist {
    fn id(&self) -> &str {
       "0x01cd"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzSelectautospell {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub skid: i32,
    pub skid_raw: [u8; 4],
}

impl PacketCzSelectautospell {
    pub fn from(buffer: &[u8]) -> PacketCzSelectautospell {
        PacketCzSelectautospell {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            skid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzSelectautospell {
    fn id(&self) -> &str {
       "0x01ce"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcDevotionlist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub my_aid: u32,
    pub my_aid_raw: [u8; 4],
    pub aid: [u32; 5],
    pub aid_raw: [u8; 5],
    pub range: i16,
    pub range_raw: [u8; 2],
}

impl PacketZcDevotionlist {
    pub fn from(buffer: &[u8]) -> PacketZcDevotionlist {
        PacketZcDevotionlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            my_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            my_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            aid:  {
                let mut dst: [u32; 5] = [0 as u32; 5];
                for (index, byte) in buffer[6..11].iter().enumerate() {
                    dst[index] = *byte as u32;
                }
                dst
            },
            aid_raw: {
                let mut dst: [u8; 5] = [0u8; 5];
                dst.clone_from_slice(&buffer[6..11]);
                dst
            },
            range: i16::from_le_bytes([buffer[26], buffer[27]]),
            range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.my_aid).unwrap();
        self.my_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.aid {
            wtr.write_u32::<LittleEndian>(item).unwrap();
        }
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.range).unwrap();
        self.range_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcDevotionlist {
    fn id(&self) -> &str {
       "0x01cf"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSpirits {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub num: i16,
    pub num_raw: [u8; 2],
}

impl PacketZcSpirits {
    pub fn from(buffer: &[u8]) -> PacketZcSpirits {
        PacketZcSpirits {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            num: i16::from_le_bytes([buffer[6], buffer[7]]),
            num_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.num).unwrap();
        self.num_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSpirits {
    fn id(&self) -> &str {
       "0x01d0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcBladestop {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub src_aid: u32,
    pub src_aid_raw: [u8; 4],
    pub dest_aid: u32,
    pub dest_aid_raw: [u8; 4],
    pub flag: i32,
    pub flag_raw: [u8; 4],
}

impl PacketZcBladestop {
    pub fn from(buffer: &[u8]) -> PacketZcBladestop {
        PacketZcBladestop {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            src_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            src_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            dest_aid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            dest_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            flag: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            flag_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.src_aid).unwrap();
        self.src_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dest_aid).unwrap();
        self.dest_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.flag).unwrap();
        self.flag_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcBladestop {
    fn id(&self) -> &str {
       "0x01d1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcCombodelay {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub delay_time: u32,
    pub delay_time_raw: [u8; 4],
}

impl PacketZcCombodelay {
    pub fn from(buffer: &[u8]) -> PacketZcCombodelay {
        PacketZcCombodelay {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            delay_time: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            delay_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.delay_time).unwrap();
        self.delay_time_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcCombodelay {
    fn id(&self) -> &str {
       "0x01d2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSound {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub file_name: [char; 24],
    pub file_name_raw: [u8; 24],
    pub act: u8,
    pub act_raw: [u8; 1],
    pub term: u32,
    pub term_raw: [u8; 4],
    pub naid: u32,
    pub naid_raw: [u8; 4],
}

impl PacketZcSound {
    pub fn from(buffer: &[u8]) -> PacketZcSound {
        PacketZcSound {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            file_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            file_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            act: u8::from_le_bytes([buffer[26]]),
            act_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[26..27]);
                dst
            },
            term: u32::from_le_bytes([buffer[27], buffer[28], buffer[29], buffer[30]]),
            term_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[27..31]);
                dst
            },
            naid: u32::from_le_bytes([buffer[31], buffer[32], buffer[33], buffer[34]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[31..35]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.file_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.file_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.act).unwrap();
        self.act_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.term).unwrap();
        self.term_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSound {
    fn id(&self) -> &str {
       "0x01d3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcOpenEditdlgstr {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub naid: u32,
    pub naid_raw: [u8; 4],
}

impl PacketZcOpenEditdlgstr {
    pub fn from(buffer: &[u8]) -> PacketZcOpenEditdlgstr {
        PacketZcOpenEditdlgstr {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            naid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcOpenEditdlgstr {
    fn id(&self) -> &str {
       "0x01d4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzInputEditdlgstr {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub naid: u32,
    pub naid_raw: [u8; 4],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketCzInputEditdlgstr {
    pub fn from(buffer: &[u8]) -> PacketCzInputEditdlgstr {
        PacketCzInputEditdlgstr {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            naid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[8..buffer.len()]).to_string(),
            msg_raw: buffer[8..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketCzInputEditdlgstr {
    fn id(&self) -> &str {
       "0x01d5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyMapproperty2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i16,
    pub atype_raw: [u8; 2],
}

impl PacketZcNotifyMapproperty2 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMapproperty2 {
        PacketZcNotifyMapproperty2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyMapproperty2 {
    fn id(&self) -> &str {
       "0x01d6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSpriteChange2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub value: i32,
    pub value_raw: [u8; 4],
}

impl PacketZcSpriteChange2 {
    pub fn from(buffer: &[u8]) -> PacketZcSpriteChange2 {
        PacketZcSpriteChange2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            value: i32::from_le_bytes([buffer[7], buffer[8], buffer[9], buffer[10]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[7..11]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSpriteChange2 {
    fn id(&self) -> &str {
       "0x01d7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyStandentry2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub speed: i16,
    pub speed_raw: [u8; 2],
    pub body_state: i16,
    pub body_state_raw: [u8; 2],
    pub health_state: i16,
    pub health_state_raw: [u8; 2],
    pub effect_state: i16,
    pub effect_state_raw: [u8; 2],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub weapon: i32,
    pub weapon_raw: [u8; 4],
    pub accessory: i16,
    pub accessory_raw: [u8; 2],
    pub accessory2: i16,
    pub accessory2_raw: [u8; 2],
    pub accessory3: i16,
    pub accessory3_raw: [u8; 2],
    pub headpalette: i16,
    pub headpalette_raw: [u8; 2],
    pub bodypalette: i16,
    pub bodypalette_raw: [u8; 2],
    pub head_dir: i16,
    pub head_dir_raw: [u8; 2],
    pub guid: u32,
    pub guid_raw: [u8; 4],
    pub gemblem_ver: i16,
    pub gemblem_ver_raw: [u8; 2],
    pub honor: i16,
    pub honor_raw: [u8; 2],
    pub virtue: i16,
    pub virtue_raw: [u8; 2],
    pub is_pkmode_on: bool,
    pub is_pkmode_on_raw: [u8; 1],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub pos_dir: [char; 3],
    pub pos_dir_raw: [u8; 3],
    pub x_size: u8,
    pub x_size_raw: [u8; 1],
    pub y_size: u8,
    pub y_size_raw: [u8; 1],
    pub state: u8,
    pub state_raw: [u8; 1],
    pub clevel: i16,
    pub clevel_raw: [u8; 2],
}

impl PacketZcNotifyStandentry2 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyStandentry2 {
        PacketZcNotifyStandentry2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i16::from_le_bytes([buffer[12], buffer[13]]),
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: i16::from_le_bytes([buffer[14], buffer[15]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            head: i16::from_le_bytes([buffer[16], buffer[17]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[22], buffer[23]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[22..24]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[24], buffer[25]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[26], buffer[27]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[28], buffer[29]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[30], buffer[31]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[32], buffer[33]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            guid: u32::from_le_bytes([buffer[34], buffer[35], buffer[36], buffer[37]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[34..38]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[38], buffer[39]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[38..40]);
                dst
            },
            honor: i16::from_le_bytes([buffer[40], buffer[41]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            virtue: i16::from_le_bytes([buffer[42], buffer[43]]),
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            is_pkmode_on: buffer[44] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[44..45]);
                dst
            },
            sex: u8::from_le_bytes([buffer[45]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[45..46]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[46..49].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[46..49]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[49]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[50]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[50..51]);
                dst
            },
            state: u8::from_le_bytes([buffer[51]]),
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[51..52]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[52], buffer[53]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[52..54]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyStandentry2 {
    fn id(&self) -> &str {
       "0x01d8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyNewentry2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub speed: i16,
    pub speed_raw: [u8; 2],
    pub body_state: i16,
    pub body_state_raw: [u8; 2],
    pub health_state: i16,
    pub health_state_raw: [u8; 2],
    pub effect_state: i16,
    pub effect_state_raw: [u8; 2],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub weapon: i32,
    pub weapon_raw: [u8; 4],
    pub accessory: i16,
    pub accessory_raw: [u8; 2],
    pub accessory2: i16,
    pub accessory2_raw: [u8; 2],
    pub accessory3: i16,
    pub accessory3_raw: [u8; 2],
    pub headpalette: i16,
    pub headpalette_raw: [u8; 2],
    pub bodypalette: i16,
    pub bodypalette_raw: [u8; 2],
    pub head_dir: i16,
    pub head_dir_raw: [u8; 2],
    pub guid: u32,
    pub guid_raw: [u8; 4],
    pub gemblem_ver: i16,
    pub gemblem_ver_raw: [u8; 2],
    pub honor: i16,
    pub honor_raw: [u8; 2],
    pub virtue: i16,
    pub virtue_raw: [u8; 2],
    pub is_pkmode_on: bool,
    pub is_pkmode_on_raw: [u8; 1],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub pos_dir: [char; 3],
    pub pos_dir_raw: [u8; 3],
    pub x_size: u8,
    pub x_size_raw: [u8; 1],
    pub y_size: u8,
    pub y_size_raw: [u8; 1],
    pub clevel: i16,
    pub clevel_raw: [u8; 2],
}

impl PacketZcNotifyNewentry2 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyNewentry2 {
        PacketZcNotifyNewentry2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i16::from_le_bytes([buffer[12], buffer[13]]),
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: i16::from_le_bytes([buffer[14], buffer[15]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            head: i16::from_le_bytes([buffer[16], buffer[17]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[22], buffer[23]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[22..24]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[24], buffer[25]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[26], buffer[27]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[28], buffer[29]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[30], buffer[31]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[32], buffer[33]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            guid: u32::from_le_bytes([buffer[34], buffer[35], buffer[36], buffer[37]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[34..38]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[38], buffer[39]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[38..40]);
                dst
            },
            honor: i16::from_le_bytes([buffer[40], buffer[41]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            virtue: i16::from_le_bytes([buffer[42], buffer[43]]),
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            is_pkmode_on: buffer[44] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[44..45]);
                dst
            },
            sex: u8::from_le_bytes([buffer[45]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[45..46]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[46..49].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[46..49]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[49]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[50]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[50..51]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[51], buffer[52]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[51..53]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyNewentry2 {
    fn id(&self) -> &str {
       "0x01d9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyMoveentry2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub speed: i16,
    pub speed_raw: [u8; 2],
    pub body_state: i16,
    pub body_state_raw: [u8; 2],
    pub health_state: i16,
    pub health_state_raw: [u8; 2],
    pub effect_state: i16,
    pub effect_state_raw: [u8; 2],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub weapon: i32,
    pub weapon_raw: [u8; 4],
    pub accessory: i16,
    pub accessory_raw: [u8; 2],
    pub move_start_time: u32,
    pub move_start_time_raw: [u8; 4],
    pub accessory2: i16,
    pub accessory2_raw: [u8; 2],
    pub accessory3: i16,
    pub accessory3_raw: [u8; 2],
    pub headpalette: i16,
    pub headpalette_raw: [u8; 2],
    pub bodypalette: i16,
    pub bodypalette_raw: [u8; 2],
    pub head_dir: i16,
    pub head_dir_raw: [u8; 2],
    pub guid: u32,
    pub guid_raw: [u8; 4],
    pub gemblem_ver: i16,
    pub gemblem_ver_raw: [u8; 2],
    pub honor: i16,
    pub honor_raw: [u8; 2],
    pub virtue: i16,
    pub virtue_raw: [u8; 2],
    pub is_pkmode_on: bool,
    pub is_pkmode_on_raw: [u8; 1],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub move_data: [u16; 6],
    pub move_data_raw: [u8; 6],
    pub x_size: u8,
    pub x_size_raw: [u8; 1],
    pub y_size: u8,
    pub y_size_raw: [u8; 1],
    pub clevel: i16,
    pub clevel_raw: [u8; 2],
}

impl PacketZcNotifyMoveentry2 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMoveentry2 {
        PacketZcNotifyMoveentry2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i16::from_le_bytes([buffer[12], buffer[13]]),
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: i16::from_le_bytes([buffer[14], buffer[15]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            head: i16::from_le_bytes([buffer[16], buffer[17]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[22], buffer[23]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[22..24]);
                dst
            },
            move_start_time: u32::from_le_bytes([buffer[24], buffer[25], buffer[26], buffer[27]]),
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[24..28]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[28], buffer[29]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[30], buffer[31]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[32], buffer[33]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[34], buffer[35]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[36], buffer[37]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[36..38]);
                dst
            },
            guid: u32::from_le_bytes([buffer[38], buffer[39], buffer[40], buffer[41]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[38..42]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[42], buffer[43]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            honor: i16::from_le_bytes([buffer[44], buffer[45]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[44..46]);
                dst
            },
            virtue: i16::from_le_bytes([buffer[46], buffer[47]]),
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[46..48]);
                dst
            },
            is_pkmode_on: buffer[48] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[48..49]);
                dst
            },
            sex: u8::from_le_bytes([buffer[49]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            move_data:  {
                let mut dst: [u16; 6] = [0 as u16; 6];
                for (index, byte) in buffer[50..56].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            },
            move_data_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[50..56]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[56]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[56..57]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[57]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[57..58]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[58], buffer[59]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[58..60]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyMoveentry2 {
    fn id(&self) -> &str {
       "0x01da"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCaReqHash {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCaReqHash {
    pub fn from(buffer: &[u8]) -> PacketCaReqHash {
        PacketCaReqHash {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCaReqHash {
    fn id(&self) -> &str {
       "0x01db"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcAckHash {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub secret: String,
    pub secret_raw: Vec<u8>,
}

impl PacketAcAckHash {
    pub fn from(buffer: &[u8]) -> PacketAcAckHash {
        PacketAcAckHash {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            secret: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            secret_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.secret_raw = self.secret.as_bytes().to_vec()
    }
}

impl Packet for PacketAcAckHash {
    fn id(&self) -> &str {
       "0x01dc"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCaLogin2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub version: u32,
    pub version_raw: [u8; 4],
    pub id: [char; 24],
    pub id_raw: [u8; 24],
    pub passwd_md5: [char; 16],
    pub passwd_md5_raw: [u8; 16],
    pub clienttype: u8,
    pub clienttype_raw: [u8; 1],
}

impl PacketCaLogin2 {
    pub fn from(buffer: &[u8]) -> PacketCaLogin2 {
        PacketCaLogin2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            version: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            id:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            passwd_md5:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[30..46].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_md5_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[30..46]);
                dst
            },
            clienttype: u8::from_le_bytes([buffer[46]]),
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[46..47]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd_md5 {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_md5_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCaLogin2 {
    fn id(&self) -> &str {
       "0x01dd"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifySkill2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub target_id: u32,
    pub target_id_raw: [u8; 4],
    pub start_time: u32,
    pub start_time_raw: [u8; 4],
    pub attack_mt: i32,
    pub attack_mt_raw: [u8; 4],
    pub attacked_mt: i32,
    pub attacked_mt_raw: [u8; 4],
    pub damage: i32,
    pub damage_raw: [u8; 4],
    pub level: i16,
    pub level_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub action: u8,
    pub action_raw: [u8; 1],
}

impl PacketZcNotifySkill2 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifySkill2 {
        PacketZcNotifySkill2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            target_id: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            start_time: u32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            attack_mt: i32::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19]]),
            attack_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[16..20]);
                dst
            },
            attacked_mt: i32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            attacked_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
            damage: i32::from_le_bytes([buffer[24], buffer[25], buffer[26], buffer[27]]),
            damage_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[24..28]);
                dst
            },
            level: i16::from_le_bytes([buffer[28], buffer[29]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            count: i16::from_le_bytes([buffer[30], buffer[31]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            action: u8::from_le_bytes([buffer[32]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[32..33]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attack_mt).unwrap();
        self.attack_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attacked_mt).unwrap();
        self.attacked_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.damage).unwrap();
        self.damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifySkill2 {
    fn id(&self) -> &str {
       "0x01de"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqAccountname {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketCzReqAccountname {
    pub fn from(buffer: &[u8]) -> PacketCzReqAccountname {
        PacketCzReqAccountname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqAccountname {
    fn id(&self) -> &str {
       "0x01df"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckAccountname {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
}

impl PacketZcAckAccountname {
    pub fn from(buffer: &[u8]) -> PacketZcAckAccountname {
        PacketZcAckAccountname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckAccountname {
    fn id(&self) -> &str {
       "0x01e0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSpirits2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub num: i16,
    pub num_raw: [u8; 2],
}

impl PacketZcSpirits2 {
    pub fn from(buffer: &[u8]) -> PacketZcSpirits2 {
        PacketZcSpirits2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            num: i16::from_le_bytes([buffer[6], buffer[7]]),
            num_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.num).unwrap();
        self.num_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSpirits2 {
    fn id(&self) -> &str {
       "0x01e1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcReqCouple {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
}

impl PacketZcReqCouple {
    pub fn from(buffer: &[u8]) -> PacketZcReqCouple {
        PacketZcReqCouple {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[10..34].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[10..34]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcReqCouple {
    fn id(&self) -> &str {
       "0x01e2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzJoinCouple {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub answer: i32,
    pub answer_raw: [u8; 4],
}

impl PacketCzJoinCouple {
    pub fn from(buffer: &[u8]) -> PacketCzJoinCouple {
        PacketCzJoinCouple {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            answer: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            answer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzJoinCouple {
    fn id(&self) -> &str {
       "0x01e3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcStartCouple {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketZcStartCouple {
    pub fn from(buffer: &[u8]) -> PacketZcStartCouple {
        PacketZcStartCouple {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcStartCouple {
    fn id(&self) -> &str {
       "0x01e4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqJoinCouple {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketCzReqJoinCouple {
    pub fn from(buffer: &[u8]) -> PacketCzReqJoinCouple {
        PacketCzReqJoinCouple {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqJoinCouple {
    fn id(&self) -> &str {
       "0x01e5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcCouplename {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub couple_name: [char; 24],
    pub couple_name_raw: [u8; 24],
}

impl PacketZcCouplename {
    pub fn from(buffer: &[u8]) -> PacketZcCouplename {
        PacketZcCouplename {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            couple_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            couple_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.couple_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.couple_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcCouplename {
    fn id(&self) -> &str {
       "0x01e6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzDoridori {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzDoridori {
    pub fn from(buffer: &[u8]) -> PacketCzDoridori {
        PacketCzDoridori {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzDoridori {
    fn id(&self) -> &str {
       "0x01e7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzMakeGroup2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub group_name: [char; 24],
    pub group_name_raw: [u8; 24],
    pub item_pickup_rule: u8,
    pub item_pickup_rule_raw: [u8; 1],
    pub item_division_rule: u8,
    pub item_division_rule_raw: [u8; 1],
}

impl PacketCzMakeGroup2 {
    pub fn from(buffer: &[u8]) -> PacketCzMakeGroup2 {
        PacketCzMakeGroup2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            group_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            item_pickup_rule: u8::from_le_bytes([buffer[26]]),
            item_pickup_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[26..27]);
                dst
            },
            item_division_rule: u8::from_le_bytes([buffer[27]]),
            item_division_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[27..28]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_pickup_rule).unwrap();
        self.item_pickup_rule_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_division_rule).unwrap();
        self.item_division_rule_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzMakeGroup2 {
    fn id(&self) -> &str {
       "0x01e8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAddMemberToGroup2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub role: u32,
    pub role_raw: [u8; 4],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
    pub state: u8,
    pub state_raw: [u8; 1],
    pub group_name: [char; 24],
    pub group_name_raw: [u8; 24],
    pub character_name: [char; 24],
    pub character_name_raw: [u8; 24],
    pub map_name: [char; 16],
    pub map_name_raw: [u8; 16],
    pub item_pickup_rule: u8,
    pub item_pickup_rule_raw: [u8; 1],
    pub item_division_rule: u8,
    pub item_division_rule_raw: [u8; 1],
}

impl PacketZcAddMemberToGroup2 {
    pub fn from(buffer: &[u8]) -> PacketZcAddMemberToGroup2 {
        PacketZcAddMemberToGroup2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            role: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            role_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[10], buffer[11]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[12], buffer[13]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            state: u8::from_le_bytes([buffer[14]]),
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
            group_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[15..39].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[15..39]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[39..63].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[39..63]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[63..79].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[63..79]);
                dst
            },
            item_pickup_rule: u8::from_le_bytes([buffer[79]]),
            item_pickup_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[79..80]);
                dst
            },
            item_division_rule: u8::from_le_bytes([buffer[80]]),
            item_division_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[80..81]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.role).unwrap();
        self.role_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_pickup_rule).unwrap();
        self.item_pickup_rule_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_division_rule).unwrap();
        self.item_division_rule_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAddMemberToGroup2 {
    fn id(&self) -> &str {
       "0x01e9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcCongratulation {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketZcCongratulation {
    pub fn from(buffer: &[u8]) -> PacketZcCongratulation {
        PacketZcCongratulation {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcCongratulation {
    fn id(&self) -> &str {
       "0x01ea"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyPositionToGuildm {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
}

impl PacketZcNotifyPositionToGuildm {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyPositionToGuildm {
        PacketZcNotifyPositionToGuildm {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[6], buffer[7]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[8], buffer[9]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyPositionToGuildm {
    fn id(&self) -> &str {
       "0x01eb"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcGuildMemberMapChange {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gdid: u32,
    pub gdid_raw: [u8; 4],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub map_name: [char; 16],
    pub map_name_raw: [u8; 16],
}

impl PacketZcGuildMemberMapChange {
    pub fn from(buffer: &[u8]) -> PacketZcGuildMemberMapChange {
        PacketZcGuildMemberMapChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gdid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            aid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[10..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[10..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcGuildMemberMapChange {
    fn id(&self) -> &str {
       "0x01ec"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzChopokgi {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzChopokgi {
    pub fn from(buffer: &[u8]) -> PacketCzChopokgi {
        PacketCzChopokgi {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzChopokgi {
    fn id(&self) -> &str {
       "0x01ed"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNormalItemlist2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_info: Vec<NormalitemExtrainfo2>,
    pub item_info_raw: Vec<Vec<u8>>,
}

impl PacketZcNormalItemlist2 {
    pub fn from(buffer: &[u8]) -> PacketZcNormalItemlist2 {
        let iter_count = &buffer.len() / 18;
        let mut vec_field: Vec<NormalitemExtrainfo2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 22 * i;
            vec_field.push(NormalitemExtrainfo2::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcNormalItemlist2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.serialize());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcNormalItemlist2 {
    fn id(&self) -> &str {
       "0x01ee"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcCartNormalItemlist2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_info: Vec<NormalitemExtrainfo2>,
    pub item_info_raw: Vec<Vec<u8>>,
}

impl PacketZcCartNormalItemlist2 {
    pub fn from(buffer: &[u8]) -> PacketZcCartNormalItemlist2 {
        let iter_count = &buffer.len() / 18;
        let mut vec_field: Vec<NormalitemExtrainfo2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 22 * i;
            vec_field.push(NormalitemExtrainfo2::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcCartNormalItemlist2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.serialize());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcCartNormalItemlist2 {
    fn id(&self) -> &str {
       "0x01ef"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcStoreNormalItemlist2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_info: Vec<NormalitemExtrainfo2>,
    pub item_info_raw: Vec<Vec<u8>>,
}

impl PacketZcStoreNormalItemlist2 {
    pub fn from(buffer: &[u8]) -> PacketZcStoreNormalItemlist2 {
        let iter_count = &buffer.len() / 18;
        let mut vec_field: Vec<NormalitemExtrainfo2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 22 * i;
            vec_field.push(NormalitemExtrainfo2::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcStoreNormalItemlist2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.serialize());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcStoreNormalItemlist2 {
    fn id(&self) -> &str {
       "0x01f0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcNotifyError {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketAcNotifyError {
    pub fn from(buffer: &[u8]) -> PacketAcNotifyError {
        PacketAcNotifyError {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            msg_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketAcNotifyError {
    fn id(&self) -> &str {
       "0x01f1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcUpdateCharstat2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub status: i32,
    pub status_raw: [u8; 4],
    pub sex: i16,
    pub sex_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub head_palette: i16,
    pub head_palette_raw: [u8; 2],
}

impl PacketZcUpdateCharstat2 {
    pub fn from(buffer: &[u8]) -> PacketZcUpdateCharstat2 {
        PacketZcUpdateCharstat2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            status: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            status_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            sex: i16::from_le_bytes([buffer[14], buffer[15]]),
            sex_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            head: i16::from_le_bytes([buffer[16], buffer[17]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            head_palette: i16::from_le_bytes([buffer[18], buffer[19]]),
            head_palette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.status).unwrap();
        self.status_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_palette).unwrap();
        self.head_palette_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcUpdateCharstat2 {
    fn id(&self) -> &str {
       "0x01f2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyEffect2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub effect_id: i32,
    pub effect_id_raw: [u8; 4],
}

impl PacketZcNotifyEffect2 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyEffect2 {
        PacketZcNotifyEffect2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            effect_id: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            effect_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_id).unwrap();
        self.effect_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyEffect2 {
    fn id(&self) -> &str {
       "0x01f3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcReqExchangeItem2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub level: i16,
    pub level_raw: [u8; 2],
}

impl PacketZcReqExchangeItem2 {
    pub fn from(buffer: &[u8]) -> PacketZcReqExchangeItem2 {
        PacketZcReqExchangeItem2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            gid: u32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
            level: i16::from_le_bytes([buffer[30], buffer[31]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcReqExchangeItem2 {
    fn id(&self) -> &str {
       "0x01f4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckExchangeItem2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub level: i16,
    pub level_raw: [u8; 2],
}

impl PacketZcAckExchangeItem2 {
    pub fn from(buffer: &[u8]) -> PacketZcAckExchangeItem2 {
        PacketZcAckExchangeItem2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            gid: u32::from_le_bytes([buffer[3], buffer[4], buffer[5], buffer[6]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[3..7]);
                dst
            },
            level: i16::from_le_bytes([buffer[7], buffer[8]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[7..9]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckExchangeItem2 {
    fn id(&self) -> &str {
       "0x01f5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcReqBaby {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
}

impl PacketZcReqBaby {
    pub fn from(buffer: &[u8]) -> PacketZcReqBaby {
        PacketZcReqBaby {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[10..34].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[10..34]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcReqBaby {
    fn id(&self) -> &str {
       "0x01f6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzJoinBaby {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub answer: i32,
    pub answer_raw: [u8; 4],
}

impl PacketCzJoinBaby {
    pub fn from(buffer: &[u8]) -> PacketCzJoinBaby {
        PacketCzJoinBaby {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            answer: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            answer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzJoinBaby {
    fn id(&self) -> &str {
       "0x01f7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcStartBaby {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketZcStartBaby {
    pub fn from(buffer: &[u8]) -> PacketZcStartBaby {
        PacketZcStartBaby {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcStartBaby {
    fn id(&self) -> &str {
       "0x01f8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqJoinBaby {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketCzReqJoinBaby {
    pub fn from(buffer: &[u8]) -> PacketCzReqJoinBaby {
        PacketCzReqJoinBaby {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqJoinBaby {
    fn id(&self) -> &str {
       "0x01f9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCaLogin3 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub version: u32,
    pub version_raw: [u8; 4],
    pub id: [char; 24],
    pub id_raw: [u8; 24],
    pub passwd_md5: [char; 16],
    pub passwd_md5_raw: [u8; 16],
    pub clienttype: u8,
    pub clienttype_raw: [u8; 1],
    pub client_info: u8,
    pub client_info_raw: [u8; 1],
}

impl PacketCaLogin3 {
    pub fn from(buffer: &[u8]) -> PacketCaLogin3 {
        PacketCaLogin3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            version: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            id:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            passwd_md5:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[30..46].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_md5_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[30..46]);
                dst
            },
            clienttype: u8::from_le_bytes([buffer[46]]),
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[46..47]);
                dst
            },
            client_info: u8::from_le_bytes([buffer[47]]),
            client_info_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[47..48]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd_md5 {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_md5_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.client_info).unwrap();
        self.client_info_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCaLogin3 {
    fn id(&self) -> &str {
       "0x01fa"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketChDeleteChar2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub key: [char; 50],
    pub key_raw: [u8; 50],
}

impl PacketChDeleteChar2 {
    pub fn from(buffer: &[u8]) -> PacketChDeleteChar2 {
        PacketChDeleteChar2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            key:  {
                let mut dst: [char; 50] = [0 as char; 50];
                for (index, byte) in buffer[6..56].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            key_raw: {
                let mut dst: [u8; 50] = [0u8; 50];
                dst.clone_from_slice(&buffer[6..56]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.key {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.key_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketChDeleteChar2 {
    fn id(&self) -> &str {
       "0x01fb"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcRepairitemlist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_list: Vec<RepairitemInfo>,
    pub item_list_raw: Vec<Vec<u8>>,
}

impl PacketZcRepairitemlist {
    pub fn from(buffer: &[u8]) -> PacketZcRepairitemlist {
        let iter_count = &buffer.len() / 13;
        let mut vec_field: Vec<RepairitemInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 17 * i;
            vec_field.push(RepairitemInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcRepairitemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.serialize());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcRepairitemlist {
    fn id(&self) -> &str {
       "0x01fc"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqItemrepair {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub target_item_info: RepairitemInfo,
    pub target_item_info_raw: Vec<u8>,
}

impl PacketCzReqItemrepair {
    pub fn from(buffer: &[u8]) -> PacketCzReqItemrepair {
        PacketCzReqItemrepair {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            target_item_info: RepairitemInfo::from(&buffer[2..buffer.len()]),
            target_item_info_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketCzReqItemrepair {
    fn id(&self) -> &str {
       "0x01fd"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckItemrepair {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcAckItemrepair {
    pub fn from(buffer: &[u8]) -> PacketZcAckItemrepair {
        PacketZcAckItemrepair {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            result: u8::from_le_bytes([buffer[4]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckItemrepair {
    fn id(&self) -> &str {
       "0x01fe"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcHighjump {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
}

impl PacketZcHighjump {
    pub fn from(buffer: &[u8]) -> PacketZcHighjump {
        PacketZcHighjump {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[6], buffer[7]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[8], buffer[9]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcHighjump {
    fn id(&self) -> &str {
       "0x01ff"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCaConnectInfoChanged {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub id: [char; 24],
    pub id_raw: [u8; 24],
}

impl PacketCaConnectInfoChanged {
    pub fn from(buffer: &[u8]) -> PacketCaConnectInfoChanged {
        PacketCaConnectInfoChanged {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            id:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCaConnectInfoChanged {
    fn id(&self) -> &str {
       "0x0200"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcFriendsList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub friend_list: Vec<StructFriend>,
    pub friend_list_raw: Vec<Vec<u8>>,
}

impl PacketZcFriendsList {
    pub fn from(buffer: &[u8]) -> PacketZcFriendsList {
        let iter_count = &buffer.len() / 32;
        let mut vec_field: Vec<StructFriend> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 36 * i;
            vec_field.push(StructFriend::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcFriendsList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            friend_list: vec_field.clone(),
            friend_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.friend_list_raw = {
            self.friend_list.iter_mut().for_each(|item| item.serialize());
            self.friend_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcFriendsList {
    fn id(&self) -> &str {
       "0x0201"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzAddFriends {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
}

impl PacketCzAddFriends {
    pub fn from(buffer: &[u8]) -> PacketCzAddFriends {
        PacketCzAddFriends {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzAddFriends {
    fn id(&self) -> &str {
       "0x0202"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzDeleteFriends {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub gid: u32,
    pub gid_raw: [u8; 4],
}

impl PacketCzDeleteFriends {
    pub fn from(buffer: &[u8]) -> PacketCzDeleteFriends {
        PacketCzDeleteFriends {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzDeleteFriends {
    fn id(&self) -> &str {
       "0x0203"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCaExeHashcheck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub hash_value: [char; 16],
    pub hash_value_raw: [u8; 16],
}

impl PacketCaExeHashcheck {
    pub fn from(buffer: &[u8]) -> PacketCaExeHashcheck {
        PacketCaExeHashcheck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            hash_value:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[2..18].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            hash_value_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[2..18]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.hash_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.hash_value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCaExeHashcheck {
    fn id(&self) -> &str {
       "0x0204"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcDivorce {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
}

impl PacketZcDivorce {
    pub fn from(buffer: &[u8]) -> PacketZcDivorce {
        PacketZcDivorce {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcDivorce {
    fn id(&self) -> &str {
       "0x0205"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcFriendsState {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub state: bool,
    pub state_raw: [u8; 1],
}

impl PacketZcFriendsState {
    pub fn from(buffer: &[u8]) -> PacketZcFriendsState {
        PacketZcFriendsState {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            state: buffer[10] == 1,
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state as u8).unwrap();
        self.state_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcFriendsState {
    fn id(&self) -> &str {
       "0x0206"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcReqAddFriends {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub req_aid: u32,
    pub req_aid_raw: [u8; 4],
    pub req_gid: u32,
    pub req_gid_raw: [u8; 4],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
}

impl PacketZcReqAddFriends {
    pub fn from(buffer: &[u8]) -> PacketZcReqAddFriends {
        PacketZcReqAddFriends {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            req_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            req_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            req_gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            req_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[10..34].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[10..34]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.req_aid).unwrap();
        self.req_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.req_gid).unwrap();
        self.req_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcReqAddFriends {
    fn id(&self) -> &str {
       "0x0207"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzAckReqAddFriends {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub req_aid: u32,
    pub req_aid_raw: [u8; 4],
    pub req_gid: u32,
    pub req_gid_raw: [u8; 4],
    pub result: i32,
    pub result_raw: [u8; 4],
}

impl PacketCzAckReqAddFriends {
    pub fn from(buffer: &[u8]) -> PacketCzAckReqAddFriends {
        PacketCzAckReqAddFriends {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            req_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            req_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            req_gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            req_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            result: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.req_aid).unwrap();
        self.req_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.req_gid).unwrap();
        self.req_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzAckReqAddFriends {
    fn id(&self) -> &str {
       "0x0208"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAddFriendsList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: i16,
    pub result_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
}

impl PacketZcAddFriendsList {
    pub fn from(buffer: &[u8]) -> PacketZcAddFriendsList {
        PacketZcAddFriendsList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            gid: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[12..36].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[12..36]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAddFriendsList {
    fn id(&self) -> &str {
       "0x0209"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcDeleteFriends {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub gid: u32,
    pub gid_raw: [u8; 4],
}

impl PacketZcDeleteFriends {
    pub fn from(buffer: &[u8]) -> PacketZcDeleteFriends {
        PacketZcDeleteFriends {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcDeleteFriends {
    fn id(&self) -> &str {
       "0x020a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketChExeHashcheck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub client_type: u8,
    pub client_type_raw: [u8; 1],
    pub hash_value: [char; 16],
    pub hash_value_raw: [u8; 16],
}

impl PacketChExeHashcheck {
    pub fn from(buffer: &[u8]) -> PacketChExeHashcheck {
        PacketChExeHashcheck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            client_type: u8::from_le_bytes([buffer[2]]),
            client_type_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            hash_value:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[3..19].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            hash_value_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[3..19]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.client_type).unwrap();
        self.client_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.hash_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.hash_value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketChExeHashcheck {
    fn id(&self) -> &str {
       "0x020b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzExeHashcheck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub client_type: u8,
    pub client_type_raw: [u8; 1],
    pub hash_value: [char; 16],
    pub hash_value_raw: [u8; 16],
}

impl PacketCzExeHashcheck {
    pub fn from(buffer: &[u8]) -> PacketCzExeHashcheck {
        PacketCzExeHashcheck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            client_type: u8::from_le_bytes([buffer[2]]),
            client_type_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            hash_value:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[3..19].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            hash_value_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[3..19]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.client_type).unwrap();
        self.client_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.hash_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.hash_value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzExeHashcheck {
    fn id(&self) -> &str {
       "0x020c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketHcBlockCharacter {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub character_list: Vec<TagCharacterBlockInfo>,
    pub character_list_raw: Vec<Vec<u8>>,
}

impl PacketHcBlockCharacter {
    pub fn from(buffer: &[u8]) -> PacketHcBlockCharacter {
        let iter_count = &buffer.len() / 24;
        let mut vec_field: Vec<TagCharacterBlockInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 28 * i;
            vec_field.push(TagCharacterBlockInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketHcBlockCharacter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            character_list: vec_field.clone(),
            character_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.character_list_raw = {
            self.character_list.iter_mut().for_each(|item| item.serialize());
            self.character_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketHcBlockCharacter {
    fn id(&self) -> &str {
       "0x020d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcStarskill {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub map_name: [char; 24],
    pub map_name_raw: [u8; 24],
    pub monster_id: i32,
    pub monster_id_raw: [u8; 4],
    pub star: u8,
    pub star_raw: [u8; 1],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcStarskill {
    pub fn from(buffer: &[u8]) -> PacketZcStarskill {
        PacketZcStarskill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            map_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            monster_id: i32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            monster_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
            star: u8::from_le_bytes([buffer[30]]),
            star_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[30..31]);
                dst
            },
            result: u8::from_le_bytes([buffer[31]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[31..32]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.monster_id).unwrap();
        self.monster_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.star).unwrap();
        self.star_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcStarskill {
    fn id(&self) -> &str {
       "0x020e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqPvppoint {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub gid: u32,
    pub gid_raw: [u8; 4],
}

impl PacketCzReqPvppoint {
    pub fn from(buffer: &[u8]) -> PacketCzReqPvppoint {
        PacketCzReqPvppoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqPvppoint {
    fn id(&self) -> &str {
       "0x020f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckPvppoint {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub pvp: PVPINFO,
    pub pvp_raw: Vec<u8>,
}

impl PacketZcAckPvppoint {
    pub fn from(buffer: &[u8]) -> PacketZcAckPvppoint {
        PacketZcAckPvppoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            pvp: PVPINFO::from(&buffer[10..buffer.len()]),
            pvp_raw: buffer[10..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcAckPvppoint {
    fn id(&self) -> &str {
       "0x0210"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZhMovePvpworld {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
}

impl PacketZhMovePvpworld {
    pub fn from(buffer: &[u8]) -> PacketZhMovePvpworld {
        PacketZhMovePvpworld {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZhMovePvpworld {
    fn id(&self) -> &str {
       "0x0211"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqGiveMannerByname {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub char_name: [char; 24],
    pub char_name_raw: [u8; 24],
}

impl PacketCzReqGiveMannerByname {
    pub fn from(buffer: &[u8]) -> PacketCzReqGiveMannerByname {
        PacketCzReqGiveMannerByname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            char_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqGiveMannerByname {
    fn id(&self) -> &str {
       "0x0212"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqStatusGm {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub char_name: [char; 24],
    pub char_name_raw: [u8; 24],
}

impl PacketCzReqStatusGm {
    pub fn from(buffer: &[u8]) -> PacketCzReqStatusGm {
        PacketCzReqStatusGm {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            char_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqStatusGm {
    fn id(&self) -> &str {
       "0x0213"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckStatusGm {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub str: u8,
    pub str_raw: [u8; 1],
    pub standard_str: u8,
    pub standard_str_raw: [u8; 1],
    pub agi: u8,
    pub agi_raw: [u8; 1],
    pub standard_agi: u8,
    pub standard_agi_raw: [u8; 1],
    pub vit: u8,
    pub vit_raw: [u8; 1],
    pub standard_vit: u8,
    pub standard_vit_raw: [u8; 1],
    pub int: u8,
    pub int_raw: [u8; 1],
    pub standard_int: u8,
    pub standard_int_raw: [u8; 1],
    pub dex: u8,
    pub dex_raw: [u8; 1],
    pub standard_dex: u8,
    pub standard_dex_raw: [u8; 1],
    pub luk: u8,
    pub luk_raw: [u8; 1],
    pub standard_luk: u8,
    pub standard_luk_raw: [u8; 1],
    pub att_power: i16,
    pub att_power_raw: [u8; 2],
    pub refining_power: i16,
    pub refining_power_raw: [u8; 2],
    pub max_matt_power: i16,
    pub max_matt_power_raw: [u8; 2],
    pub min_matt_power: i16,
    pub min_matt_power_raw: [u8; 2],
    pub itemdef_power: i16,
    pub itemdef_power_raw: [u8; 2],
    pub plusdef_power: i16,
    pub plusdef_power_raw: [u8; 2],
    pub mdef_power: i16,
    pub mdef_power_raw: [u8; 2],
    pub plusmdef_power: i16,
    pub plusmdef_power_raw: [u8; 2],
    pub hit_success_value: i16,
    pub hit_success_value_raw: [u8; 2],
    pub avoid_success_value: i16,
    pub avoid_success_value_raw: [u8; 2],
    pub plus_avoid_success_value: i16,
    pub plus_avoid_success_value_raw: [u8; 2],
    pub critical_success_value: i16,
    pub critical_success_value_raw: [u8; 2],
    pub aspd: i16,
    pub aspd_raw: [u8; 2],
    pub plus_aspd: i16,
    pub plus_aspd_raw: [u8; 2],
}

impl PacketZcAckStatusGm {
    pub fn from(buffer: &[u8]) -> PacketZcAckStatusGm {
        PacketZcAckStatusGm {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            str: u8::from_le_bytes([buffer[2]]),
            str_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            standard_str: u8::from_le_bytes([buffer[3]]),
            standard_str_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[3..4]);
                dst
            },
            agi: u8::from_le_bytes([buffer[4]]),
            agi_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            standard_agi: u8::from_le_bytes([buffer[5]]),
            standard_agi_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            vit: u8::from_le_bytes([buffer[6]]),
            vit_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            standard_vit: u8::from_le_bytes([buffer[7]]),
            standard_vit_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[7..8]);
                dst
            },
            int: u8::from_le_bytes([buffer[8]]),
            int_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            standard_int: u8::from_le_bytes([buffer[9]]),
            standard_int_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            dex: u8::from_le_bytes([buffer[10]]),
            dex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            standard_dex: u8::from_le_bytes([buffer[11]]),
            standard_dex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            luk: u8::from_le_bytes([buffer[12]]),
            luk_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
            standard_luk: u8::from_le_bytes([buffer[13]]),
            standard_luk_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[13..14]);
                dst
            },
            att_power: i16::from_le_bytes([buffer[14], buffer[15]]),
            att_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            refining_power: i16::from_le_bytes([buffer[16], buffer[17]]),
            refining_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            max_matt_power: i16::from_le_bytes([buffer[18], buffer[19]]),
            max_matt_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            min_matt_power: i16::from_le_bytes([buffer[20], buffer[21]]),
            min_matt_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
            itemdef_power: i16::from_le_bytes([buffer[22], buffer[23]]),
            itemdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[22..24]);
                dst
            },
            plusdef_power: i16::from_le_bytes([buffer[24], buffer[25]]),
            plusdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            mdef_power: i16::from_le_bytes([buffer[26], buffer[27]]),
            mdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            plusmdef_power: i16::from_le_bytes([buffer[28], buffer[29]]),
            plusmdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            hit_success_value: i16::from_le_bytes([buffer[30], buffer[31]]),
            hit_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            avoid_success_value: i16::from_le_bytes([buffer[32], buffer[33]]),
            avoid_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            plus_avoid_success_value: i16::from_le_bytes([buffer[34], buffer[35]]),
            plus_avoid_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            critical_success_value: i16::from_le_bytes([buffer[36], buffer[37]]),
            critical_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[36..38]);
                dst
            },
            aspd: i16::from_le_bytes([buffer[38], buffer[39]]),
            aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[38..40]);
                dst
            },
            plus_aspd: i16::from_le_bytes([buffer[40], buffer[41]]),
            plus_aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.str).unwrap();
        self.str_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_str).unwrap();
        self.standard_str_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.agi).unwrap();
        self.agi_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_agi).unwrap();
        self.standard_agi_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.vit).unwrap();
        self.vit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_vit).unwrap();
        self.standard_vit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.int).unwrap();
        self.int_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_int).unwrap();
        self.standard_int_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dex).unwrap();
        self.dex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_dex).unwrap();
        self.standard_dex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.luk).unwrap();
        self.luk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_luk).unwrap();
        self.standard_luk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.att_power).unwrap();
        self.att_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.refining_power).unwrap();
        self.refining_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_matt_power).unwrap();
        self.max_matt_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.min_matt_power).unwrap();
        self.min_matt_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.itemdef_power).unwrap();
        self.itemdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plusdef_power).unwrap();
        self.plusdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef_power).unwrap();
        self.mdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plusmdef_power).unwrap();
        self.plusmdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hit_success_value).unwrap();
        self.hit_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.avoid_success_value).unwrap();
        self.avoid_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plus_avoid_success_value).unwrap();
        self.plus_avoid_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.critical_success_value).unwrap();
        self.critical_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.aspd).unwrap();
        self.aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plus_aspd).unwrap();
        self.plus_aspd_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckStatusGm {
    fn id(&self) -> &str {
       "0x0214"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSkillmsg {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub msg_no: i32,
    pub msg_no_raw: [u8; 4],
}

impl PacketZcSkillmsg {
    pub fn from(buffer: &[u8]) -> PacketZcSkillmsg {
        PacketZcSkillmsg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            msg_no: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            msg_no_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.msg_no).unwrap();
        self.msg_no_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSkillmsg {
    fn id(&self) -> &str {
       "0x0215"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcBabymsg {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub msg_no: i32,
    pub msg_no_raw: [u8; 4],
}

impl PacketZcBabymsg {
    pub fn from(buffer: &[u8]) -> PacketZcBabymsg {
        PacketZcBabymsg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            msg_no: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            msg_no_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.msg_no).unwrap();
        self.msg_no_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcBabymsg {
    fn id(&self) -> &str {
       "0x0216"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzBlacksmithRank {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzBlacksmithRank {
    pub fn from(buffer: &[u8]) -> PacketCzBlacksmithRank {
        PacketCzBlacksmithRank {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzBlacksmithRank {
    fn id(&self) -> &str {
       "0x0217"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzAlchemistRank {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzAlchemistRank {
    pub fn from(buffer: &[u8]) -> PacketCzAlchemistRank {
        PacketCzAlchemistRank {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzAlchemistRank {
    fn id(&self) -> &str {
       "0x0218"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcBlacksmithRank {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub name: [char; 10],
    pub name_raw: [u8; 10],
    pub point: [i32; 10],
    pub point_raw: [u8; 10],
}

impl PacketZcBlacksmithRank {
    pub fn from(buffer: &[u8]) -> PacketZcBlacksmithRank {
        PacketZcBlacksmithRank {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 10] = [0 as char; 10];
                for (index, byte) in buffer[2..12].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[2..12]);
                dst
            },
            point:  {
                let mut dst: [i32; 10] = [0 as i32; 10];
                for (index, byte) in buffer[242..252].iter().enumerate() {
                    dst[index] = *byte as i32;
                }
                dst
            },
            point_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[242..252]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.point {
            wtr.write_i32::<LittleEndian>(item).unwrap();
        }
        self.point_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcBlacksmithRank {
    fn id(&self) -> &str {
       "0x0219"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAlchemistRank {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub name: [char; 10],
    pub name_raw: [u8; 10],
    pub point: [i32; 10],
    pub point_raw: [u8; 10],
}

impl PacketZcAlchemistRank {
    pub fn from(buffer: &[u8]) -> PacketZcAlchemistRank {
        PacketZcAlchemistRank {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 10] = [0 as char; 10];
                for (index, byte) in buffer[2..12].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[2..12]);
                dst
            },
            point:  {
                let mut dst: [i32; 10] = [0 as i32; 10];
                for (index, byte) in buffer[242..252].iter().enumerate() {
                    dst[index] = *byte as i32;
                }
                dst
            },
            point_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[242..252]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.point {
            wtr.write_i32::<LittleEndian>(item).unwrap();
        }
        self.point_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAlchemistRank {
    fn id(&self) -> &str {
       "0x021a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcBlacksmithPoint {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub point: i32,
    pub point_raw: [u8; 4],
    pub total_point: i32,
    pub total_point_raw: [u8; 4],
}

impl PacketZcBlacksmithPoint {
    pub fn from(buffer: &[u8]) -> PacketZcBlacksmithPoint {
        PacketZcBlacksmithPoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            point: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            total_point: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            total_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.total_point).unwrap();
        self.total_point_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcBlacksmithPoint {
    fn id(&self) -> &str {
       "0x021b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAlchemistPoint {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub point: i32,
    pub point_raw: [u8; 4],
    pub total_point: i32,
    pub total_point_raw: [u8; 4],
}

impl PacketZcAlchemistPoint {
    pub fn from(buffer: &[u8]) -> PacketZcAlchemistPoint {
        PacketZcAlchemistPoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            point: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            total_point: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            total_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.total_point).unwrap();
        self.total_point_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAlchemistPoint {
    fn id(&self) -> &str {
       "0x021c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzLesseffect {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub is_less: i32,
    pub is_less_raw: [u8; 4],
}

impl PacketCzLesseffect {
    pub fn from(buffer: &[u8]) -> PacketCzLesseffect {
        PacketCzLesseffect {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            is_less: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            is_less_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.is_less).unwrap();
        self.is_less_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzLesseffect {
    fn id(&self) -> &str {
       "0x021d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcLesseffect {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub is_less: i32,
    pub is_less_raw: [u8; 4],
}

impl PacketZcLesseffect {
    pub fn from(buffer: &[u8]) -> PacketZcLesseffect {
        PacketZcLesseffect {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            is_less: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            is_less_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.is_less).unwrap();
        self.is_less_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcLesseffect {
    fn id(&self) -> &str {
       "0x021e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyPkinfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub win_point: i32,
    pub win_point_raw: [u8; 4],
    pub lose_point: i32,
    pub lose_point_raw: [u8; 4],
    pub kill_name: [char; 24],
    pub kill_name_raw: [u8; 24],
    pub killed_name: [char; 24],
    pub killed_name_raw: [u8; 24],
    pub expire_time: Filetime,
    pub expire_time_raw: Vec<u8>,
}

impl PacketZcNotifyPkinfo {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyPkinfo {
        PacketZcNotifyPkinfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            win_point: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            win_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            lose_point: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            lose_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            kill_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[10..34].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            kill_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[10..34]);
                dst
            },
            killed_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[34..58].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            killed_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[34..58]);
                dst
            },
            expire_time: Filetime::from(&buffer[58..buffer.len()]),
            expire_time_raw: buffer[58..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.win_point).unwrap();
        self.win_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.lose_point).unwrap();
        self.lose_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.kill_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.kill_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.killed_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.killed_name_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcNotifyPkinfo {
    fn id(&self) -> &str {
       "0x021f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyCrazykiller {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub is_crazy_killer: i32,
    pub is_crazy_killer_raw: [u8; 4],
}

impl PacketZcNotifyCrazykiller {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyCrazykiller {
        PacketZcNotifyCrazykiller {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            is_crazy_killer: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            is_crazy_killer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.is_crazy_killer).unwrap();
        self.is_crazy_killer_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyCrazykiller {
    fn id(&self) -> &str {
       "0x0220"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyWeaponitemlist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_list: Vec<RepairitemInfo>,
    pub item_list_raw: Vec<Vec<u8>>,
}

impl PacketZcNotifyWeaponitemlist {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyWeaponitemlist {
        let iter_count = &buffer.len() / 13;
        let mut vec_field: Vec<RepairitemInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 17 * i;
            vec_field.push(RepairitemInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcNotifyWeaponitemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.serialize());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcNotifyWeaponitemlist {
    fn id(&self) -> &str {
       "0x0221"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqWeaponrefine {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i32,
    pub index_raw: [u8; 4],
}

impl PacketCzReqWeaponrefine {
    pub fn from(buffer: &[u8]) -> PacketCzReqWeaponrefine {
        PacketCzReqWeaponrefine {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            index_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqWeaponrefine {
    fn id(&self) -> &str {
       "0x0222"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckWeaponrefine {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub msg: i32,
    pub msg_raw: [u8; 4],
    pub itid: u16,
    pub itid_raw: [u8; 2],
}

impl PacketZcAckWeaponrefine {
    pub fn from(buffer: &[u8]) -> PacketZcAckWeaponrefine {
        PacketZcAckWeaponrefine {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            msg: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            msg_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            itid: u16::from_le_bytes([buffer[6], buffer[7]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.msg).unwrap();
        self.msg_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckWeaponrefine {
    fn id(&self) -> &str {
       "0x0223"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcTaekwonPoint {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub point: i32,
    pub point_raw: [u8; 4],
    pub total_point: i32,
    pub total_point_raw: [u8; 4],
}

impl PacketZcTaekwonPoint {
    pub fn from(buffer: &[u8]) -> PacketZcTaekwonPoint {
        PacketZcTaekwonPoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            point: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            total_point: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            total_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.total_point).unwrap();
        self.total_point_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcTaekwonPoint {
    fn id(&self) -> &str {
       "0x0224"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzTaekwonRank {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzTaekwonRank {
    pub fn from(buffer: &[u8]) -> PacketCzTaekwonRank {
        PacketCzTaekwonRank {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzTaekwonRank {
    fn id(&self) -> &str {
       "0x0225"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcTaekwonRank {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub name: [char; 10],
    pub name_raw: [u8; 10],
    pub point: [i32; 10],
    pub point_raw: [u8; 10],
}

impl PacketZcTaekwonRank {
    pub fn from(buffer: &[u8]) -> PacketZcTaekwonRank {
        PacketZcTaekwonRank {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 10] = [0 as char; 10];
                for (index, byte) in buffer[2..12].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[2..12]);
                dst
            },
            point:  {
                let mut dst: [i32; 10] = [0 as i32; 10];
                for (index, byte) in buffer[242..252].iter().enumerate() {
                    dst[index] = *byte as i32;
                }
                dst
            },
            point_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[242..252]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.point {
            wtr.write_i32::<LittleEndian>(item).unwrap();
        }
        self.point_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcTaekwonRank {
    fn id(&self) -> &str {
       "0x0226"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcGameGuard {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub auth_data: [u32; 4],
    pub auth_data_raw: [u8; 4],
}

impl PacketZcGameGuard {
    pub fn from(buffer: &[u8]) -> PacketZcGameGuard {
        PacketZcGameGuard {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            auth_data:  {
                let mut dst: [u32; 4] = [0 as u32; 4];
                for (index, byte) in buffer[2..6].iter().enumerate() {
                    dst[index] = *byte as u32;
                }
                dst
            },
            auth_data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.auth_data {
            wtr.write_u32::<LittleEndian>(item).unwrap();
        }
        self.auth_data_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcGameGuard {
    fn id(&self) -> &str {
       "0x0227"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzAckGameGuard {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub auth_data: [u32; 4],
    pub auth_data_raw: [u8; 4],
}

impl PacketCzAckGameGuard {
    pub fn from(buffer: &[u8]) -> PacketCzAckGameGuard {
        PacketCzAckGameGuard {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            auth_data:  {
                let mut dst: [u32; 4] = [0 as u32; 4];
                for (index, byte) in buffer[2..6].iter().enumerate() {
                    dst[index] = *byte as u32;
                }
                dst
            },
            auth_data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.auth_data {
            wtr.write_u32::<LittleEndian>(item).unwrap();
        }
        self.auth_data_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzAckGameGuard {
    fn id(&self) -> &str {
       "0x0228"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcStateChange3 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub body_state: i16,
    pub body_state_raw: [u8; 2],
    pub health_state: i16,
    pub health_state_raw: [u8; 2],
    pub effect_state: i32,
    pub effect_state_raw: [u8; 4],
    pub is_pkmode_on: bool,
    pub is_pkmode_on_raw: [u8; 1],
}

impl PacketZcStateChange3 {
    pub fn from(buffer: &[u8]) -> PacketZcStateChange3 {
        PacketZcStateChange3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[6], buffer[7]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            is_pkmode_on: buffer[14] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcStateChange3 {
    fn id(&self) -> &str {
       "0x0229"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyStandentry3 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub speed: i16,
    pub speed_raw: [u8; 2],
    pub body_state: i16,
    pub body_state_raw: [u8; 2],
    pub health_state: i16,
    pub health_state_raw: [u8; 2],
    pub effect_state: i32,
    pub effect_state_raw: [u8; 4],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub weapon: i32,
    pub weapon_raw: [u8; 4],
    pub accessory: i16,
    pub accessory_raw: [u8; 2],
    pub accessory2: i16,
    pub accessory2_raw: [u8; 2],
    pub accessory3: i16,
    pub accessory3_raw: [u8; 2],
    pub headpalette: i16,
    pub headpalette_raw: [u8; 2],
    pub bodypalette: i16,
    pub bodypalette_raw: [u8; 2],
    pub head_dir: i16,
    pub head_dir_raw: [u8; 2],
    pub guid: u32,
    pub guid_raw: [u8; 4],
    pub gemblem_ver: i16,
    pub gemblem_ver_raw: [u8; 2],
    pub honor: i16,
    pub honor_raw: [u8; 2],
    pub virtue: i32,
    pub virtue_raw: [u8; 4],
    pub is_pkmode_on: bool,
    pub is_pkmode_on_raw: [u8; 1],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub pos_dir: [char; 3],
    pub pos_dir_raw: [u8; 3],
    pub x_size: u8,
    pub x_size_raw: [u8; 1],
    pub y_size: u8,
    pub y_size_raw: [u8; 1],
    pub state: u8,
    pub state_raw: [u8; 1],
    pub clevel: i16,
    pub clevel_raw: [u8; 2],
}

impl PacketZcNotifyStandentry3 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyStandentry3 {
        PacketZcNotifyStandentry3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            job: i16::from_le_bytes([buffer[16], buffer[17]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            head: i16::from_le_bytes([buffer[18], buffer[19]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[24], buffer[25]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[26], buffer[27]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[28], buffer[29]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[30], buffer[31]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[32], buffer[33]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[34], buffer[35]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            guid: u32::from_le_bytes([buffer[36], buffer[37], buffer[38], buffer[39]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[36..40]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[40], buffer[41]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            honor: i16::from_le_bytes([buffer[42], buffer[43]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[44], buffer[45], buffer[46], buffer[47]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[44..48]);
                dst
            },
            is_pkmode_on: buffer[48] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[48..49]);
                dst
            },
            sex: u8::from_le_bytes([buffer[49]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[50..53].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[50..53]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[53]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[53..54]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[54]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[54..55]);
                dst
            },
            state: u8::from_le_bytes([buffer[55]]),
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[55..56]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[56], buffer[57]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[56..58]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyStandentry3 {
    fn id(&self) -> &str {
       "0x022a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyNewentry3 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub speed: i16,
    pub speed_raw: [u8; 2],
    pub body_state: i16,
    pub body_state_raw: [u8; 2],
    pub health_state: i16,
    pub health_state_raw: [u8; 2],
    pub effect_state: i32,
    pub effect_state_raw: [u8; 4],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub weapon: i32,
    pub weapon_raw: [u8; 4],
    pub accessory: i16,
    pub accessory_raw: [u8; 2],
    pub accessory2: i16,
    pub accessory2_raw: [u8; 2],
    pub accessory3: i16,
    pub accessory3_raw: [u8; 2],
    pub headpalette: i16,
    pub headpalette_raw: [u8; 2],
    pub bodypalette: i16,
    pub bodypalette_raw: [u8; 2],
    pub head_dir: i16,
    pub head_dir_raw: [u8; 2],
    pub guid: u32,
    pub guid_raw: [u8; 4],
    pub gemblem_ver: i16,
    pub gemblem_ver_raw: [u8; 2],
    pub honor: i16,
    pub honor_raw: [u8; 2],
    pub virtue: i32,
    pub virtue_raw: [u8; 4],
    pub is_pkmode_on: bool,
    pub is_pkmode_on_raw: [u8; 1],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub pos_dir: [char; 3],
    pub pos_dir_raw: [u8; 3],
    pub x_size: u8,
    pub x_size_raw: [u8; 1],
    pub y_size: u8,
    pub y_size_raw: [u8; 1],
    pub clevel: i16,
    pub clevel_raw: [u8; 2],
}

impl PacketZcNotifyNewentry3 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyNewentry3 {
        PacketZcNotifyNewentry3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            job: i16::from_le_bytes([buffer[16], buffer[17]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            head: i16::from_le_bytes([buffer[18], buffer[19]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[24], buffer[25]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[26], buffer[27]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[28], buffer[29]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[30], buffer[31]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[32], buffer[33]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[34], buffer[35]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            guid: u32::from_le_bytes([buffer[36], buffer[37], buffer[38], buffer[39]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[36..40]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[40], buffer[41]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            honor: i16::from_le_bytes([buffer[42], buffer[43]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[44], buffer[45], buffer[46], buffer[47]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[44..48]);
                dst
            },
            is_pkmode_on: buffer[48] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[48..49]);
                dst
            },
            sex: u8::from_le_bytes([buffer[49]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[50..53].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[50..53]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[53]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[53..54]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[54]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[54..55]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[55], buffer[56]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[55..57]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyNewentry3 {
    fn id(&self) -> &str {
       "0x022b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyMoveentry3 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub objecttype: u8,
    pub objecttype_raw: [u8; 1],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub speed: i16,
    pub speed_raw: [u8; 2],
    pub body_state: i16,
    pub body_state_raw: [u8; 2],
    pub health_state: i16,
    pub health_state_raw: [u8; 2],
    pub effect_state: i32,
    pub effect_state_raw: [u8; 4],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub weapon: i32,
    pub weapon_raw: [u8; 4],
    pub accessory: i16,
    pub accessory_raw: [u8; 2],
    pub move_start_time: u32,
    pub move_start_time_raw: [u8; 4],
    pub accessory2: i16,
    pub accessory2_raw: [u8; 2],
    pub accessory3: i16,
    pub accessory3_raw: [u8; 2],
    pub headpalette: i16,
    pub headpalette_raw: [u8; 2],
    pub bodypalette: i16,
    pub bodypalette_raw: [u8; 2],
    pub head_dir: i16,
    pub head_dir_raw: [u8; 2],
    pub guid: u32,
    pub guid_raw: [u8; 4],
    pub gemblem_ver: i16,
    pub gemblem_ver_raw: [u8; 2],
    pub honor: i16,
    pub honor_raw: [u8; 2],
    pub virtue: i32,
    pub virtue_raw: [u8; 4],
    pub is_pkmode_on: bool,
    pub is_pkmode_on_raw: [u8; 1],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub move_data: [u16; 6],
    pub move_data_raw: [u8; 6],
    pub x_size: u8,
    pub x_size_raw: [u8; 1],
    pub y_size: u8,
    pub y_size_raw: [u8; 1],
    pub clevel: i16,
    pub clevel_raw: [u8; 2],
}

impl PacketZcNotifyMoveentry3 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMoveentry3 {
        PacketZcNotifyMoveentry3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            objecttype: u8::from_le_bytes([buffer[2]]),
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            gid: u32::from_le_bytes([buffer[3], buffer[4], buffer[5], buffer[6]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[3..7]);
                dst
            },
            speed: i16::from_le_bytes([buffer[7], buffer[8]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[7..9]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[9], buffer[10]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[11], buffer[12]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[13], buffer[14], buffer[15], buffer[16]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[13..17]);
                dst
            },
            job: i16::from_le_bytes([buffer[17], buffer[18]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[17..19]);
                dst
            },
            head: i16::from_le_bytes([buffer[19], buffer[20]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[21], buffer[22], buffer[23], buffer[24]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[21..25]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[25], buffer[26]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[25..27]);
                dst
            },
            move_start_time: u32::from_le_bytes([buffer[27], buffer[28], buffer[29], buffer[30]]),
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[27..31]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[31], buffer[32]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[31..33]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[33], buffer[34]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[35], buffer[36]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[35..37]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[37], buffer[38]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[37..39]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[39], buffer[40]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[39..41]);
                dst
            },
            guid: u32::from_le_bytes([buffer[41], buffer[42], buffer[43], buffer[44]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[41..45]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[45], buffer[46]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[45..47]);
                dst
            },
            honor: i16::from_le_bytes([buffer[47], buffer[48]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[47..49]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[49], buffer[50], buffer[51], buffer[52]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[49..53]);
                dst
            },
            is_pkmode_on: buffer[53] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[53..54]);
                dst
            },
            sex: u8::from_le_bytes([buffer[54]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[54..55]);
                dst
            },
            move_data:  {
                let mut dst: [u16; 6] = [0 as u16; 6];
                for (index, byte) in buffer[55..61].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            },
            move_data_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[55..61]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[61]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[61..62]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[62]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[62..63]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[63], buffer[64]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[63..65]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyMoveentry3 {
    fn id(&self) -> &str {
       "0x022c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzCommandMer {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i16,
    pub atype_raw: [u8; 2],
    pub command: i8,
    pub command_raw: [u8; 1],
}

impl PacketCzCommandMer {
    pub fn from(buffer: &[u8]) -> PacketCzCommandMer {
        PacketCzCommandMer {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            command: i8::from_le_bytes([buffer[4]]),
            command_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.command).unwrap();
        self.command_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzCommandMer {
    fn id(&self) -> &str {
       "0x022d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPropertyHomun {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub sz_name: [char; 24],
    pub sz_name_raw: [u8; 24],
    pub b_modified: u8,
    pub b_modified_raw: [u8; 1],
    pub n_level: i16,
    pub n_level_raw: [u8; 2],
    pub n_fullness: i16,
    pub n_fullness_raw: [u8; 2],
    pub n_relationship: i16,
    pub n_relationship_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub atk: i16,
    pub atk_raw: [u8; 2],
    pub matk: i16,
    pub matk_raw: [u8; 2],
    pub hit: i16,
    pub hit_raw: [u8; 2],
    pub critical: i16,
    pub critical_raw: [u8; 2],
    pub def: i16,
    pub def_raw: [u8; 2],
    pub mdef: i16,
    pub mdef_raw: [u8; 2],
    pub flee: i16,
    pub flee_raw: [u8; 2],
    pub aspd: i16,
    pub aspd_raw: [u8; 2],
    pub hp: i16,
    pub hp_raw: [u8; 2],
    pub max_hp: i16,
    pub max_hp_raw: [u8; 2],
    pub sp: i16,
    pub sp_raw: [u8; 2],
    pub max_sp: i16,
    pub max_sp_raw: [u8; 2],
    pub exp: i32,
    pub exp_raw: [u8; 4],
    pub max_exp: i32,
    pub max_exp_raw: [u8; 4],
    pub skpoint: i16,
    pub skpoint_raw: [u8; 2],
    pub atkrange: i16,
    pub atkrange_raw: [u8; 2],
}

impl PacketZcPropertyHomun {
    pub fn from(buffer: &[u8]) -> PacketZcPropertyHomun {
        PacketZcPropertyHomun {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            sz_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            sz_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            b_modified: u8::from_le_bytes([buffer[26]]),
            b_modified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[26..27]);
                dst
            },
            n_level: i16::from_le_bytes([buffer[27], buffer[28]]),
            n_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[27..29]);
                dst
            },
            n_fullness: i16::from_le_bytes([buffer[29], buffer[30]]),
            n_fullness_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[29..31]);
                dst
            },
            n_relationship: i16::from_le_bytes([buffer[31], buffer[32]]),
            n_relationship_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[31..33]);
                dst
            },
            itid: u16::from_le_bytes([buffer[33], buffer[34]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            atk: i16::from_le_bytes([buffer[35], buffer[36]]),
            atk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[35..37]);
                dst
            },
            matk: i16::from_le_bytes([buffer[37], buffer[38]]),
            matk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[37..39]);
                dst
            },
            hit: i16::from_le_bytes([buffer[39], buffer[40]]),
            hit_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[39..41]);
                dst
            },
            critical: i16::from_le_bytes([buffer[41], buffer[42]]),
            critical_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[41..43]);
                dst
            },
            def: i16::from_le_bytes([buffer[43], buffer[44]]),
            def_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[43..45]);
                dst
            },
            mdef: i16::from_le_bytes([buffer[45], buffer[46]]),
            mdef_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[45..47]);
                dst
            },
            flee: i16::from_le_bytes([buffer[47], buffer[48]]),
            flee_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[47..49]);
                dst
            },
            aspd: i16::from_le_bytes([buffer[49], buffer[50]]),
            aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[49..51]);
                dst
            },
            hp: i16::from_le_bytes([buffer[51], buffer[52]]),
            hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[51..53]);
                dst
            },
            max_hp: i16::from_le_bytes([buffer[53], buffer[54]]),
            max_hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[53..55]);
                dst
            },
            sp: i16::from_le_bytes([buffer[55], buffer[56]]),
            sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[55..57]);
                dst
            },
            max_sp: i16::from_le_bytes([buffer[57], buffer[58]]),
            max_sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[57..59]);
                dst
            },
            exp: i32::from_le_bytes([buffer[59], buffer[60], buffer[61], buffer[62]]),
            exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[59..63]);
                dst
            },
            max_exp: i32::from_le_bytes([buffer[63], buffer[64], buffer[65], buffer[66]]),
            max_exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[63..67]);
                dst
            },
            skpoint: i16::from_le_bytes([buffer[67], buffer[68]]),
            skpoint_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[67..69]);
                dst
            },
            atkrange: i16::from_le_bytes([buffer[69], buffer[70]]),
            atkrange_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[69..71]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.b_modified).unwrap();
        self.b_modified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.n_level).unwrap();
        self.n_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.n_fullness).unwrap();
        self.n_fullness_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.n_relationship).unwrap();
        self.n_relationship_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atk).unwrap();
        self.atk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.matk).unwrap();
        self.matk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hit).unwrap();
        self.hit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.critical).unwrap();
        self.critical_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.def).unwrap();
        self.def_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef).unwrap();
        self.mdef_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.flee).unwrap();
        self.flee_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.aspd).unwrap();
        self.aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sp).unwrap();
        self.sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_sp).unwrap();
        self.max_sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.exp).unwrap();
        self.exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_exp).unwrap();
        self.max_exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.skpoint).unwrap();
        self.skpoint_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atkrange).unwrap();
        self.atkrange_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcPropertyHomun {
    fn id(&self) -> &str {
       "0x022e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcChangestateMer {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i8,
    pub atype_raw: [u8; 1],
    pub state: i8,
    pub state_raw: [u8; 1],
    pub gid: i32,
    pub gid_raw: [u8; 4],
    pub data: i32,
    pub data_raw: [u8; 4],
}

impl PacketZcChangestateMer {
    pub fn from(buffer: &[u8]) -> PacketZcChangestateMer {
        PacketZcChangestateMer {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i8::from_le_bytes([buffer[2]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            state: i8::from_le_bytes([buffer[3]]),
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[3..4]);
                dst
            },
            gid: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            data: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.data).unwrap();
        self.data_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcChangestateMer {
    fn id(&self) -> &str {
       "0x0230"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRenameMer {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
}

impl PacketCzRenameMer {
    pub fn from(buffer: &[u8]) -> PacketCzRenameMer {
        PacketCzRenameMer {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzRenameMer {
    fn id(&self) -> &str {
       "0x0231"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRequestMovenpc {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub dest: [char; 3],
    pub dest_raw: [u8; 3],
}

impl PacketCzRequestMovenpc {
    pub fn from(buffer: &[u8]) -> PacketCzRequestMovenpc {
        PacketCzRequestMovenpc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            dest:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[6..9].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            dest_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[6..9]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.dest {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.dest_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzRequestMovenpc {
    fn id(&self) -> &str {
       "0x0232"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRequestActnpc {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub target_gid: u32,
    pub target_gid_raw: [u8; 4],
    pub action: u8,
    pub action_raw: [u8; 1],
}

impl PacketCzRequestActnpc {
    pub fn from(buffer: &[u8]) -> PacketCzRequestActnpc {
        PacketCzRequestActnpc {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            target_gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            action: u8::from_le_bytes([buffer[10]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_gid).unwrap();
        self.target_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzRequestActnpc {
    fn id(&self) -> &str {
       "0x0233"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRequestMovetoowner {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
}

impl PacketCzRequestMovetoowner {
    pub fn from(buffer: &[u8]) -> PacketCzRequestMovetoowner {
        PacketCzRequestMovetoowner {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzRequestMovetoowner {
    fn id(&self) -> &str {
       "0x0234"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcReqStorePassword {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub info: i16,
    pub info_raw: [u8; 2],
}

impl PacketZcReqStorePassword {
    pub fn from(buffer: &[u8]) -> PacketZcReqStorePassword {
        PacketZcReqStorePassword {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            info: i16::from_le_bytes([buffer[2], buffer[3]]),
            info_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.info).unwrap();
        self.info_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcReqStorePassword {
    fn id(&self) -> &str {
       "0x023a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzAckStorePassword {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i16,
    pub atype_raw: [u8; 2],
    pub password: [char; 16],
    pub password_raw: [u8; 16],
    pub new_password: [char; 16],
    pub new_password_raw: [u8; 16],
}

impl PacketCzAckStorePassword {
    pub fn from(buffer: &[u8]) -> PacketCzAckStorePassword {
        PacketCzAckStorePassword {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            password:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[4..20].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            password_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[4..20]);
                dst
            },
            new_password:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[20..36].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            new_password_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[20..36]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.password {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.password_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.new_password {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.new_password_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzAckStorePassword {
    fn id(&self) -> &str {
       "0x023b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcResultStorePassword {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: i16,
    pub result_raw: [u8; 2],
    pub error_count: i16,
    pub error_count_raw: [u8; 2],
}

impl PacketZcResultStorePassword {
    pub fn from(buffer: &[u8]) -> PacketZcResultStorePassword {
        PacketZcResultStorePassword {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            error_count: i16::from_le_bytes([buffer[4], buffer[5]]),
            error_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_count).unwrap();
        self.error_count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcResultStorePassword {
    fn id(&self) -> &str {
       "0x023c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcEventResult {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub event_item_count: u32,
    pub event_item_count_raw: [u8; 4],
}

impl PacketAcEventResult {
    pub fn from(buffer: &[u8]) -> PacketAcEventResult {
        PacketAcEventResult {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            event_item_count: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            event_item_count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.event_item_count).unwrap();
        self.event_item_count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcEventResult {
    fn id(&self) -> &str {
       "0x023d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketHcRequestCharacterPassword {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: i16,
    pub result_raw: [u8; 2],
    pub dummy_value: u32,
    pub dummy_value_raw: [u8; 4],
}

impl PacketHcRequestCharacterPassword {
    pub fn from(buffer: &[u8]) -> PacketHcRequestCharacterPassword {
        PacketHcRequestCharacterPassword {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            dummy_value: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            dummy_value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dummy_value).unwrap();
        self.dummy_value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketHcRequestCharacterPassword {
    fn id(&self) -> &str {
       "0x023e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzMailGetList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzMailGetList {
    pub fn from(buffer: &[u8]) -> PacketCzMailGetList {
        PacketCzMailGetList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzMailGetList {
    fn id(&self) -> &str {
       "0x023f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMailReqGetList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub mail_number: i32,
    pub mail_number_raw: [u8; 4],
    pub mail_list: Vec<MailList>,
    pub mail_list_raw: Vec<Vec<u8>>,
}

impl PacketZcMailReqGetList {
    pub fn from(buffer: &[u8]) -> PacketZcMailReqGetList {
        let iter_count = &buffer.len() / 73;
        let mut vec_field: Vec<MailList> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 * i;
            let end_pos = 81 * i;
            vec_field.push(MailList::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcMailReqGetList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            mail_number: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            mail_number_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            mail_list: vec_field.clone(),
            mail_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_number).unwrap();
        self.mail_number_raw = wtr.try_into().unwrap();
        self.mail_list_raw = {
            self.mail_list.iter_mut().for_each(|item| item.serialize());
            self.mail_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcMailReqGetList {
    fn id(&self) -> &str {
       "0x0240"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzMailOpen {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub mail_id: i32,
    pub mail_id_raw: [u8; 4],
}

impl PacketCzMailOpen {
    pub fn from(buffer: &[u8]) -> PacketCzMailOpen {
        PacketCzMailOpen {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            mail_id: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzMailOpen {
    fn id(&self) -> &str {
       "0x0241"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMailReqOpen {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub mail_id: i32,
    pub mail_id_raw: [u8; 4],
    pub header: [char; 40],
    pub header_raw: [u8; 40],
    pub from_name: [char; 24],
    pub from_name_raw: [u8; 24],
    pub delete_time: i32,
    pub delete_time_raw: [u8; 4],
    pub money: u32,
    pub money_raw: [u8; 4],
    pub count: i32,
    pub count_raw: [u8; 4],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub atype: u16,
    pub atype_raw: [u8; 2],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub is_damaged: bool,
    pub is_damaged_raw: [u8; 1],
    pub refining_level: u8,
    pub refining_level_raw: [u8; 1],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
    pub msg_len: u8,
    pub msg_len_raw: [u8; 1],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketZcMailReqOpen {
    pub fn from(buffer: &[u8]) -> PacketZcMailReqOpen {
        PacketZcMailReqOpen {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            mail_id: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            header:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[8..48].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            header_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[8..48]);
                dst
            },
            from_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[48..72].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            from_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[48..72]);
                dst
            },
            delete_time: i32::from_le_bytes([buffer[72], buffer[73], buffer[74], buffer[75]]),
            delete_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[72..76]);
                dst
            },
            money: u32::from_le_bytes([buffer[76], buffer[77], buffer[78], buffer[79]]),
            money_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[76..80]);
                dst
            },
            count: i32::from_le_bytes([buffer[80], buffer[81], buffer[82], buffer[83]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[80..84]);
                dst
            },
            itid: u16::from_le_bytes([buffer[84], buffer[85]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[84..86]);
                dst
            },
            atype: u16::from_le_bytes([buffer[86], buffer[87]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[86..88]);
                dst
            },
            is_identified: buffer[88] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[88..89]);
                dst
            },
            is_damaged: buffer[89] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[89..90]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[90]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[90..91]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[91..99]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[91..99]);
                dst
            },
            msg_len: u8::from_le_bytes([buffer[99]]),
            msg_len_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[99..100]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[100..buffer.len()]).to_string(),
            msg_raw: buffer[100..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.header {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.header_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.from_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.from_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.delete_time).unwrap();
        self.delete_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.money).unwrap();
        self.money_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.write_u8(self.msg_len).unwrap();
        self.msg_len_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketZcMailReqOpen {
    fn id(&self) -> &str {
       "0x0242"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzMailDelete {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub mail_id: i32,
    pub mail_id_raw: [u8; 4],
}

impl PacketCzMailDelete {
    pub fn from(buffer: &[u8]) -> PacketCzMailDelete {
        PacketCzMailDelete {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            mail_id: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzMailDelete {
    fn id(&self) -> &str {
       "0x0243"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzMailGetItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub mail_id: i32,
    pub mail_id_raw: [u8; 4],
}

impl PacketCzMailGetItem {
    pub fn from(buffer: &[u8]) -> PacketCzMailGetItem {
        PacketCzMailGetItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            mail_id: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzMailGetItem {
    fn id(&self) -> &str {
       "0x0244"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMailReqGetItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: i8,
    pub result_raw: [u8; 1],
}

impl PacketZcMailReqGetItem {
    pub fn from(buffer: &[u8]) -> PacketZcMailReqGetItem {
        PacketZcMailReqGetItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMailReqGetItem {
    fn id(&self) -> &str {
       "0x0245"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzMailResetItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i16,
    pub atype_raw: [u8; 2],
}

impl PacketCzMailResetItem {
    pub fn from(buffer: &[u8]) -> PacketCzMailResetItem {
        PacketCzMailResetItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzMailResetItem {
    fn id(&self) -> &str {
       "0x0246"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzMailAddItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
}

impl PacketCzMailAddItem {
    pub fn from(buffer: &[u8]) -> PacketCzMailAddItem {
        PacketCzMailAddItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzMailAddItem {
    fn id(&self) -> &str {
       "0x0247"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzMailSend {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub receive_name: [char; 24],
    pub receive_name_raw: [u8; 24],
    pub header: [char; 40],
    pub header_raw: [u8; 40],
    pub msg_len: u32,
    pub msg_len_raw: [u8; 4],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketCzMailSend {
    pub fn from(buffer: &[u8]) -> PacketCzMailSend {
        PacketCzMailSend {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            receive_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            receive_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
            header:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[28..68].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            header_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[28..68]);
                dst
            },
            msg_len: u32::from_le_bytes([buffer[68], buffer[69], buffer[70], buffer[71]]),
            msg_len_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[68..72]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[72..buffer.len()]).to_string(),
            msg_raw: buffer[72..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.receive_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.receive_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.header {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.header_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.msg_len).unwrap();
        self.msg_len_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketCzMailSend {
    fn id(&self) -> &str {
       "0x0248"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMailReqSend {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: i8,
    pub result_raw: [u8; 1],
}

impl PacketZcMailReqSend {
    pub fn from(buffer: &[u8]) -> PacketZcMailReqSend {
        PacketZcMailReqSend {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMailReqSend {
    fn id(&self) -> &str {
       "0x0249"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMailReceive {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub mail_id: u32,
    pub mail_id_raw: [u8; 4],
    pub header: [char; 40],
    pub header_raw: [u8; 40],
    pub from_name: [char; 24],
    pub from_name_raw: [u8; 24],
}

impl PacketZcMailReceive {
    pub fn from(buffer: &[u8]) -> PacketZcMailReceive {
        PacketZcMailReceive {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            mail_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            header:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[6..46].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            header_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[6..46]);
                dst
            },
            from_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[46..70].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            from_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[46..70]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.header {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.header_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.from_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.from_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMailReceive {
    fn id(&self) -> &str {
       "0x024a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzAuctionCreate {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i16,
    pub atype_raw: [u8; 2],
}

impl PacketCzAuctionCreate {
    pub fn from(buffer: &[u8]) -> PacketCzAuctionCreate {
        PacketCzAuctionCreate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzAuctionCreate {
    fn id(&self) -> &str {
       "0x024b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzAuctionAddItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
}

impl PacketCzAuctionAddItem {
    pub fn from(buffer: &[u8]) -> PacketCzAuctionAddItem {
        PacketCzAuctionAddItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzAuctionAddItem {
    fn id(&self) -> &str {
       "0x024c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzAuctionAdd {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub now_money: u32,
    pub now_money_raw: [u8; 4],
    pub max_money: u32,
    pub max_money_raw: [u8; 4],
    pub delete_hour: i16,
    pub delete_hour_raw: [u8; 2],
}

impl PacketCzAuctionAdd {
    pub fn from(buffer: &[u8]) -> PacketCzAuctionAdd {
        PacketCzAuctionAdd {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            now_money: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            now_money_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            max_money: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            max_money_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            delete_hour: i16::from_le_bytes([buffer[10], buffer[11]]),
            delete_hour_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.now_money).unwrap();
        self.now_money_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.max_money).unwrap();
        self.max_money_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.delete_hour).unwrap();
        self.delete_hour_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzAuctionAdd {
    fn id(&self) -> &str {
       "0x024d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzAuctionAddCancel {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub auction_id: u32,
    pub auction_id_raw: [u8; 4],
}

impl PacketCzAuctionAddCancel {
    pub fn from(buffer: &[u8]) -> PacketCzAuctionAddCancel {
        PacketCzAuctionAddCancel {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            auction_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            auction_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.auction_id).unwrap();
        self.auction_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzAuctionAddCancel {
    fn id(&self) -> &str {
       "0x024e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzAuctionBuy {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub auction_id: u32,
    pub auction_id_raw: [u8; 4],
    pub money: u32,
    pub money_raw: [u8; 4],
}

impl PacketCzAuctionBuy {
    pub fn from(buffer: &[u8]) -> PacketCzAuctionBuy {
        PacketCzAuctionBuy {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            auction_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            auction_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            money: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            money_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.auction_id).unwrap();
        self.auction_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.money).unwrap();
        self.money_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzAuctionBuy {
    fn id(&self) -> &str {
       "0x024f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAuctionResult {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: i8,
    pub result_raw: [u8; 1],
}

impl PacketZcAuctionResult {
    pub fn from(buffer: &[u8]) -> PacketZcAuctionResult {
        PacketZcAuctionResult {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i8::from_le_bytes([buffer[2]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAuctionResult {
    fn id(&self) -> &str {
       "0x0250"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzAuctionItemSearch {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i16,
    pub atype_raw: [u8; 2],
    pub auction_id: u32,
    pub auction_id_raw: [u8; 4],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
    pub page: u16,
    pub page_raw: [u8; 2],
}

impl PacketCzAuctionItemSearch {
    pub fn from(buffer: &[u8]) -> PacketCzAuctionItemSearch {
        PacketCzAuctionItemSearch {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            auction_id: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            auction_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[8..32].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[8..32]);
                dst
            },
            page: u16::from_le_bytes([buffer[32], buffer[33]]),
            page_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.auction_id).unwrap();
        self.auction_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.page).unwrap();
        self.page_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzAuctionItemSearch {
    fn id(&self) -> &str {
       "0x0251"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAuctionItemReqSearch {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub max_page: i32,
    pub max_page_raw: [u8; 4],
    pub number: i32,
    pub number_raw: [u8; 4],
    pub auction_item_list: Vec<AuctionItemSearchInfo>,
    pub auction_item_list_raw: Vec<Vec<u8>>,
}

impl PacketZcAuctionItemReqSearch {
    pub fn from(buffer: &[u8]) -> PacketZcAuctionItemReqSearch {
        let iter_count = &buffer.len() / 83;
        let mut vec_field: Vec<AuctionItemSearchInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 12 * i;
            let end_pos = 95 * i;
            vec_field.push(AuctionItemSearchInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcAuctionItemReqSearch {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            max_page: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            max_page_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            number: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            number_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            auction_item_list: vec_field.clone(),
            auction_item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_page).unwrap();
        self.max_page_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.number).unwrap();
        self.number_raw = wtr.try_into().unwrap();
        self.auction_item_list_raw = {
            self.auction_item_list.iter_mut().for_each(|item| item.serialize());
            self.auction_item_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcAuctionItemReqSearch {
    fn id(&self) -> &str {
       "0x0252"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcStarplace {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub which: i8,
    pub which_raw: [u8; 1],
}

impl PacketZcStarplace {
    pub fn from(buffer: &[u8]) -> PacketZcStarplace {
        PacketZcStarplace {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            which: i8::from_le_bytes([buffer[2]]),
            which_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.which).unwrap();
        self.which_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcStarplace {
    fn id(&self) -> &str {
       "0x0253"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzAgreeStarplace {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub which: i8,
    pub which_raw: [u8; 1],
}

impl PacketCzAgreeStarplace {
    pub fn from(buffer: &[u8]) -> PacketCzAgreeStarplace {
        PacketCzAgreeStarplace {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            which: i8::from_le_bytes([buffer[2]]),
            which_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.which).unwrap();
        self.which_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzAgreeStarplace {
    fn id(&self) -> &str {
       "0x0254"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckMailAddItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcAckMailAddItem {
    pub fn from(buffer: &[u8]) -> PacketZcAckMailAddItem {
        PacketZcAckMailAddItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            result: u8::from_le_bytes([buffer[4]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckMailAddItem {
    fn id(&self) -> &str {
       "0x0255"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckAuctionAddItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketZcAckAuctionAddItem {
    pub fn from(buffer: &[u8]) -> PacketZcAckAuctionAddItem {
        PacketZcAckAuctionAddItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            result: u8::from_le_bytes([buffer[4]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckAuctionAddItem {
    fn id(&self) -> &str {
       "0x0256"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckMailDelete {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub mail_id: i32,
    pub mail_id_raw: [u8; 4],
    pub result: u16,
    pub result_raw: [u8; 2],
}

impl PacketZcAckMailDelete {
    pub fn from(buffer: &[u8]) -> PacketZcAckMailDelete {
        PacketZcAckMailDelete {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            mail_id: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            result: u16::from_le_bytes([buffer[6], buffer[7]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckMailDelete {
    fn id(&self) -> &str {
       "0x0257"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCaReqGameGuardCheck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCaReqGameGuardCheck {
    pub fn from(buffer: &[u8]) -> PacketCaReqGameGuardCheck {
        PacketCaReqGameGuardCheck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCaReqGameGuardCheck {
    fn id(&self) -> &str {
       "0x0258"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcAckGameGuard {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub uc_answer: u8,
    pub uc_answer_raw: [u8; 1],
}

impl PacketAcAckGameGuard {
    pub fn from(buffer: &[u8]) -> PacketAcAckGameGuard {
        PacketAcAckGameGuard {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            uc_answer: u8::from_le_bytes([buffer[2]]),
            uc_answer_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.uc_answer).unwrap();
        self.uc_answer_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcAckGameGuard {
    fn id(&self) -> &str {
       "0x0259"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMakingitemList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub id_list: Vec<u8>,
    pub id_list_raw: Vec<u8>,
}

impl PacketZcMakingitemList {
    pub fn from(buffer: &[u8]) -> PacketZcMakingitemList {
        PacketZcMakingitemList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            id_list:  {
                let dst: Vec<u8> = buffer[4..buffer.len()].to_vec();
                dst
            },
            id_list_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcMakingitemList {
    fn id(&self) -> &str {
       "0x025a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqMakingitem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub mk_type: i16,
    pub mk_type_raw: [u8; 2],
    pub id: u16,
    pub id_raw: [u8; 2],
}

impl PacketCzReqMakingitem {
    pub fn from(buffer: &[u8]) -> PacketCzReqMakingitem {
        PacketCzReqMakingitem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            mk_type: i16::from_le_bytes([buffer[2], buffer[3]]),
            mk_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            id: u16::from_le_bytes([buffer[4], buffer[5]]),
            id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mk_type).unwrap();
        self.mk_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.id).unwrap();
        self.id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqMakingitem {
    fn id(&self) -> &str {
       "0x025b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzAuctionReqMyInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i16,
    pub atype_raw: [u8; 2],
}

impl PacketCzAuctionReqMyInfo {
    pub fn from(buffer: &[u8]) -> PacketCzAuctionReqMyInfo {
        PacketCzAuctionReqMyInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzAuctionReqMyInfo {
    fn id(&self) -> &str {
       "0x025c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzAuctionReqMySellStop {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub auction_id: u32,
    pub auction_id_raw: [u8; 4],
}

impl PacketCzAuctionReqMySellStop {
    pub fn from(buffer: &[u8]) -> PacketCzAuctionReqMySellStop {
        PacketCzAuctionReqMySellStop {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            auction_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            auction_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.auction_id).unwrap();
        self.auction_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzAuctionReqMySellStop {
    fn id(&self) -> &str {
       "0x025d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAuctionAckMySellStop {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: i16,
    pub result_raw: [u8; 2],
}

impl PacketZcAuctionAckMySellStop {
    pub fn from(buffer: &[u8]) -> PacketZcAuctionAckMySellStop {
        PacketZcAuctionAckMySellStop {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAuctionAckMySellStop {
    fn id(&self) -> &str {
       "0x025e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAuctionWindows {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i32,
    pub atype_raw: [u8; 4],
}

impl PacketZcAuctionWindows {
    pub fn from(buffer: &[u8]) -> PacketZcAuctionWindows {
        PacketZcAuctionWindows {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAuctionWindows {
    fn id(&self) -> &str {
       "0x025f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMailWindows {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i32,
    pub atype_raw: [u8; 4],
}

impl PacketZcMailWindows {
    pub fn from(buffer: &[u8]) -> PacketZcMailWindows {
        PacketZcMailWindows {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMailWindows {
    fn id(&self) -> &str {
       "0x0260"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcReqLoginOldekey {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub m_seed_value: [char; 9],
    pub m_seed_value_raw: [u8; 9],
}

impl PacketAcReqLoginOldekey {
    pub fn from(buffer: &[u8]) -> PacketAcReqLoginOldekey {
        PacketAcReqLoginOldekey {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            m_seed_value:  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[2..11].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            m_seed_value_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[2..11]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_seed_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_seed_value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcReqLoginOldekey {
    fn id(&self) -> &str {
       "0x0261"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcReqLoginNewekey {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub m_seed_value: [char; 9],
    pub m_seed_value_raw: [u8; 9],
}

impl PacketAcReqLoginNewekey {
    pub fn from(buffer: &[u8]) -> PacketAcReqLoginNewekey {
        PacketAcReqLoginNewekey {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            m_seed_value:  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[2..11].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            m_seed_value_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[2..11]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_seed_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_seed_value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcReqLoginNewekey {
    fn id(&self) -> &str {
       "0x0262"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcReqLoginCardpass {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub m_seed_value: [char; 9],
    pub m_seed_value_raw: [u8; 9],
}

impl PacketAcReqLoginCardpass {
    pub fn from(buffer: &[u8]) -> PacketAcReqLoginCardpass {
        PacketAcReqLoginCardpass {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            m_seed_value:  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[2..11].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            m_seed_value_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[2..11]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_seed_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_seed_value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcReqLoginCardpass {
    fn id(&self) -> &str {
       "0x0263"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCaAckLoginOldekey {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub m_seed_value: [char; 9],
    pub m_seed_value_raw: [u8; 9],
    pub m_ekey: [char; 9],
    pub m_ekey_raw: [u8; 9],
}

impl PacketCaAckLoginOldekey {
    pub fn from(buffer: &[u8]) -> PacketCaAckLoginOldekey {
        PacketCaAckLoginOldekey {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            m_seed_value:  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[2..11].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            m_seed_value_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[2..11]);
                dst
            },
            m_ekey:  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[11..20].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            m_ekey_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[11..20]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_seed_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_seed_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_ekey {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_ekey_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCaAckLoginOldekey {
    fn id(&self) -> &str {
       "0x0264"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCaAckLoginNewekey {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub m_seed_value: [char; 9],
    pub m_seed_value_raw: [u8; 9],
    pub m_ekey: [char; 9],
    pub m_ekey_raw: [u8; 9],
}

impl PacketCaAckLoginNewekey {
    pub fn from(buffer: &[u8]) -> PacketCaAckLoginNewekey {
        PacketCaAckLoginNewekey {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            m_seed_value:  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[2..11].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            m_seed_value_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[2..11]);
                dst
            },
            m_ekey:  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[11..20].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            m_ekey_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[11..20]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_seed_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_seed_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_ekey {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_ekey_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCaAckLoginNewekey {
    fn id(&self) -> &str {
       "0x0265"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCaAckLoginCardpass {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub mcard_pass: [char; 28],
    pub mcard_pass_raw: [u8; 28],
}

impl PacketCaAckLoginCardpass {
    pub fn from(buffer: &[u8]) -> PacketCaAckLoginCardpass {
        PacketCaAckLoginCardpass {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            mcard_pass:  {
                let mut dst: [char; 28] = [0 as char; 28];
                for (index, byte) in buffer[2..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            mcard_pass_raw: {
                let mut dst: [u8; 28] = [0u8; 28];
                dst.clone_from_slice(&buffer[2..30]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mcard_pass {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mcard_pass_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCaAckLoginCardpass {
    fn id(&self) -> &str {
       "0x0266"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcAckEkeyFailNotexist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub error_code: i16,
    pub error_code_raw: [u8; 2],
}

impl PacketAcAckEkeyFailNotexist {
    pub fn from(buffer: &[u8]) -> PacketAcAckEkeyFailNotexist {
        PacketAcAckEkeyFailNotexist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcAckEkeyFailNotexist {
    fn id(&self) -> &str {
       "0x0267"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcAckEkeyFailNotusesekey {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub error_code: i16,
    pub error_code_raw: [u8; 2],
}

impl PacketAcAckEkeyFailNotusesekey {
    pub fn from(buffer: &[u8]) -> PacketAcAckEkeyFailNotusesekey {
        PacketAcAckEkeyFailNotusesekey {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcAckEkeyFailNotusesekey {
    fn id(&self) -> &str {
       "0x0268"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcAckEkeyFailNotusedekey {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub error_code: i16,
    pub error_code_raw: [u8; 2],
}

impl PacketAcAckEkeyFailNotusedekey {
    pub fn from(buffer: &[u8]) -> PacketAcAckEkeyFailNotusedekey {
        PacketAcAckEkeyFailNotusedekey {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcAckEkeyFailNotusedekey {
    fn id(&self) -> &str {
       "0x0269"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcAckEkeyFailAuthrefuse {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub error_code: i16,
    pub error_code_raw: [u8; 2],
}

impl PacketAcAckEkeyFailAuthrefuse {
    pub fn from(buffer: &[u8]) -> PacketAcAckEkeyFailAuthrefuse {
        PacketAcAckEkeyFailAuthrefuse {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcAckEkeyFailAuthrefuse {
    fn id(&self) -> &str {
       "0x026a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcAckEkeyFailInputekey {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub error_code: i16,
    pub error_code_raw: [u8; 2],
}

impl PacketAcAckEkeyFailInputekey {
    pub fn from(buffer: &[u8]) -> PacketAcAckEkeyFailInputekey {
        PacketAcAckEkeyFailInputekey {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcAckEkeyFailInputekey {
    fn id(&self) -> &str {
       "0x026b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcAckEkeyFailNotice {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub error_code: i16,
    pub error_code_raw: [u8; 2],
}

impl PacketAcAckEkeyFailNotice {
    pub fn from(buffer: &[u8]) -> PacketAcAckEkeyFailNotice {
        PacketAcAckEkeyFailNotice {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcAckEkeyFailNotice {
    fn id(&self) -> &str {
       "0x026c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcAckEkeyFailNeedcardpass {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub error_code: i16,
    pub error_code_raw: [u8; 2],
}

impl PacketAcAckEkeyFailNeedcardpass {
    pub fn from(buffer: &[u8]) -> PacketAcAckEkeyFailNeedcardpass {
        PacketAcAckEkeyFailNeedcardpass {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcAckEkeyFailNeedcardpass {
    fn id(&self) -> &str {
       "0x026d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcAckAuthekeyFailNotmatchcardpass {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub error_code: i16,
    pub error_code_raw: [u8; 2],
}

impl PacketAcAckAuthekeyFailNotmatchcardpass {
    pub fn from(buffer: &[u8]) -> PacketAcAckAuthekeyFailNotmatchcardpass {
        PacketAcAckAuthekeyFailNotmatchcardpass {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcAckAuthekeyFailNotmatchcardpass {
    fn id(&self) -> &str {
       "0x026e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcAckFirstLogin {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketAcAckFirstLogin {
    pub fn from(buffer: &[u8]) -> PacketAcAckFirstLogin {
        PacketAcAckFirstLogin {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcAckFirstLogin {
    fn id(&self) -> &str {
       "0x026f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcReqLoginAccountInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketAcReqLoginAccountInfo {
    pub fn from(buffer: &[u8]) -> PacketAcReqLoginAccountInfo {
        PacketAcReqLoginAccountInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcReqLoginAccountInfo {
    fn id(&self) -> &str {
       "0x0270"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCaAckLoginAccountInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub sex: i16,
    pub sex_raw: [u8; 2],
    pub b_point: i16,
    pub b_point_raw: [u8; 2],
    pub email: [char; 34],
    pub email_raw: [u8; 34],
}

impl PacketCaAckLoginAccountInfo {
    pub fn from(buffer: &[u8]) -> PacketCaAckLoginAccountInfo {
        PacketCaAckLoginAccountInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            sex: i16::from_le_bytes([buffer[2], buffer[3]]),
            sex_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            b_point: i16::from_le_bytes([buffer[4], buffer[5]]),
            b_point_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            email:  {
                let mut dst: [char; 34] = [0 as char; 34];
                for (index, byte) in buffer[6..40].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            email_raw: {
                let mut dst: [u8; 34] = [0u8; 34];
                dst.clone_from_slice(&buffer[6..40]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.b_point).unwrap();
        self.b_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.email {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.email_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCaAckLoginAccountInfo {
    fn id(&self) -> &str {
       "0x0271"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcAckPtIdInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub sz_ptid: [char; 21],
    pub sz_ptid_raw: [u8; 21],
    pub sz_ptnum_id: [char; 21],
    pub sz_ptnum_id_raw: [u8; 21],
}

impl PacketAcAckPtIdInfo {
    pub fn from(buffer: &[u8]) -> PacketAcAckPtIdInfo {
        PacketAcAckPtIdInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            sz_ptid:  {
                let mut dst: [char; 21] = [0 as char; 21];
                for (index, byte) in buffer[2..23].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            sz_ptid_raw: {
                let mut dst: [u8; 21] = [0u8; 21];
                dst.clone_from_slice(&buffer[2..23]);
                dst
            },
            sz_ptnum_id:  {
                let mut dst: [char; 21] = [0 as char; 21];
                for (index, byte) in buffer[23..44].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            sz_ptnum_id_raw: {
                let mut dst: [u8; 21] = [0u8; 21];
                dst.clone_from_slice(&buffer[23..44]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_ptid {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_ptid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_ptnum_id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_ptnum_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcAckPtIdInfo {
    fn id(&self) -> &str {
       "0x0272"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqMailReturn {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub mail_id: i32,
    pub mail_id_raw: [u8; 4],
    pub receive_name: [char; 24],
    pub receive_name_raw: [u8; 24],
}

impl PacketCzReqMailReturn {
    pub fn from(buffer: &[u8]) -> PacketCzReqMailReturn {
        PacketCzReqMailReturn {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            mail_id: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            receive_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            receive_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.receive_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.receive_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqMailReturn {
    fn id(&self) -> &str {
       "0x0273"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckMailReturn {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub mail_id: i32,
    pub mail_id_raw: [u8; 4],
    pub result: i16,
    pub result_raw: [u8; 2],
}

impl PacketZcAckMailReturn {
    pub fn from(buffer: &[u8]) -> PacketZcAckMailReturn {
        PacketZcAckMailReturn {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            mail_id: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            result: i16::from_le_bytes([buffer[6], buffer[7]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckMailReturn {
    fn id(&self) -> &str {
       "0x0274"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketChEnter2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub auth_code: i32,
    pub auth_code_raw: [u8; 4],
    pub user_level: u32,
    pub user_level_raw: [u8; 4],
    pub client_type: u16,
    pub client_type_raw: [u8; 2],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub mac_data: [char; 16],
    pub mac_data_raw: [u8; 16],
    pub i_account_sid: i32,
    pub i_account_sid_raw: [u8; 4],
}

impl PacketChEnter2 {
    pub fn from(buffer: &[u8]) -> PacketChEnter2 {
        PacketChEnter2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            auth_code: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            user_level: u32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            user_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            client_type: u16::from_le_bytes([buffer[14], buffer[15]]),
            client_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            sex: u8::from_le_bytes([buffer[16]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[16..17]);
                dst
            },
            mac_data:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[17..33].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            mac_data_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[17..33]);
                dst
            },
            i_account_sid: i32::from_le_bytes([buffer[33], buffer[34], buffer[35], buffer[36]]),
            i_account_sid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[33..37]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.user_level).unwrap();
        self.user_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.client_type).unwrap();
        self.client_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mac_data {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mac_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.i_account_sid).unwrap();
        self.i_account_sid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketChEnter2 {
    fn id(&self) -> &str {
       "0x0275"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCaAcceptLogin2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub auth_code: i32,
    pub auth_code_raw: [u8; 4],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub user_level: u32,
    pub user_level_raw: [u8; 4],
    pub last_login_ip: u32,
    pub last_login_ip_raw: [u8; 4],
    pub last_login_time: [char; 26],
    pub last_login_time_raw: [u8; 26],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub i_account_sid: i32,
    pub i_account_sid_raw: [u8; 4],
}

impl PacketCaAcceptLogin2 {
    pub fn from(buffer: &[u8]) -> PacketCaAcceptLogin2 {
        PacketCaAcceptLogin2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            auth_code: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            aid: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            user_level: u32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            user_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            last_login_ip: u32::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19]]),
            last_login_ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[16..20]);
                dst
            },
            last_login_time:  {
                let mut dst: [char; 26] = [0 as char; 26];
                for (index, byte) in buffer[20..46].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            last_login_time_raw: {
                let mut dst: [u8; 26] = [0u8; 26];
                dst.clone_from_slice(&buffer[20..46]);
                dst
            },
            sex: u8::from_le_bytes([buffer[46]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[46..47]);
                dst
            },
            i_account_sid: i32::from_le_bytes([buffer[47], buffer[48], buffer[49], buffer[50]]),
            i_account_sid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[47..51]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.user_level).unwrap();
        self.user_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.last_login_ip).unwrap();
        self.last_login_ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.last_login_time {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.last_login_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.i_account_sid).unwrap();
        self.i_account_sid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCaAcceptLogin2 {
    fn id(&self) -> &str {
       "0x0276"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCaLoginPcbang {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub version: u32,
    pub version_raw: [u8; 4],
    pub id: [char; 24],
    pub id_raw: [u8; 24],
    pub passwd: [char; 24],
    pub passwd_raw: [u8; 24],
    pub clienttype: u8,
    pub clienttype_raw: [u8; 1],
    pub ip: [char; 16],
    pub ip_raw: [u8; 16],
    pub mac_adress: [char; 13],
    pub mac_adress_raw: [u8; 13],
}

impl PacketCaLoginPcbang {
    pub fn from(buffer: &[u8]) -> PacketCaLoginPcbang {
        PacketCaLoginPcbang {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            version: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            id:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            passwd:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[30..54].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[30..54]);
                dst
            },
            clienttype: u8::from_le_bytes([buffer[54]]),
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[54..55]);
                dst
            },
            ip:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[55..71].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            ip_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[55..71]);
                dst
            },
            mac_adress:  {
                let mut dst: [char; 13] = [0 as char; 13];
                for (index, byte) in buffer[71..84].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            mac_adress_raw: {
                let mut dst: [u8; 13] = [0u8; 13];
                dst.clone_from_slice(&buffer[71..84]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.ip {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mac_adress {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mac_adress_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCaLoginPcbang {
    fn id(&self) -> &str {
       "0x0277"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyPcbang {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketZcNotifyPcbang {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyPcbang {
        PacketZcNotifyPcbang {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyPcbang {
    fn id(&self) -> &str {
       "0x0278"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzHuntinglist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzHuntinglist {
    pub fn from(buffer: &[u8]) -> PacketCzHuntinglist {
        PacketCzHuntinglist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzHuntinglist {
    fn id(&self) -> &str {
       "0x0279"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcHuntinglist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub hunting_list: Vec<PacketMobHunting>,
    pub hunting_list_raw: Vec<Vec<u8>>,
}

impl PacketZcHuntinglist {
    pub fn from(buffer: &[u8]) -> PacketZcHuntinglist {
        let iter_count = &buffer.len() / 12;
        let mut vec_field: Vec<PacketMobHunting> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 16 * i;
            vec_field.push(PacketMobHunting::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcHuntinglist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            hunting_list: vec_field.clone(),
            hunting_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.hunting_list_raw = {
            self.hunting_list.iter_mut().for_each(|item| item.serialize());
            self.hunting_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcHuntinglist {
    fn id(&self) -> &str {
       "0x027a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPcbangEffect {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub exp_factor: i32,
    pub exp_factor_raw: [u8; 4],
    pub exp_factor2: i32,
    pub exp_factor2_raw: [u8; 4],
    pub drop_factor: i32,
    pub drop_factor_raw: [u8; 4],
}

impl PacketZcPcbangEffect {
    pub fn from(buffer: &[u8]) -> PacketZcPcbangEffect {
        PacketZcPcbangEffect {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            exp_factor: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            exp_factor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            exp_factor2: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            exp_factor2_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            drop_factor: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            drop_factor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.exp_factor).unwrap();
        self.exp_factor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.exp_factor2).unwrap();
        self.exp_factor2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.drop_factor).unwrap();
        self.drop_factor_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcPcbangEffect {
    fn id(&self) -> &str {
       "0x027b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCaLogin4 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub version: u32,
    pub version_raw: [u8; 4],
    pub id: [char; 24],
    pub id_raw: [u8; 24],
    pub passwd_md5: [char; 16],
    pub passwd_md5_raw: [u8; 16],
    pub clienttype: u8,
    pub clienttype_raw: [u8; 1],
    pub mac_data: [char; 13],
    pub mac_data_raw: [u8; 13],
}

impl PacketCaLogin4 {
    pub fn from(buffer: &[u8]) -> PacketCaLogin4 {
        PacketCaLogin4 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            version: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            id:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            passwd_md5:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[30..46].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_md5_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[30..46]);
                dst
            },
            clienttype: u8::from_le_bytes([buffer[46]]),
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[46..47]);
                dst
            },
            mac_data:  {
                let mut dst: [char; 13] = [0 as char; 13];
                for (index, byte) in buffer[47..60].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            mac_data_raw: {
                let mut dst: [u8; 13] = [0u8; 13];
                dst.clone_from_slice(&buffer[47..60]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd_md5 {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_md5_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mac_data {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mac_data_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCaLogin4 {
    fn id(&self) -> &str {
       "0x027c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPropertyMerce {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
    pub level: i16,
    pub level_raw: [u8; 2],
    pub faith: i16,
    pub faith_raw: [u8; 2],
    pub summon_count: i16,
    pub summon_count_raw: [u8; 2],
    pub atk: i16,
    pub atk_raw: [u8; 2],
    pub matk: i16,
    pub matk_raw: [u8; 2],
    pub hit: i16,
    pub hit_raw: [u8; 2],
    pub critical: i16,
    pub critical_raw: [u8; 2],
    pub def: i16,
    pub def_raw: [u8; 2],
    pub mdef: i16,
    pub mdef_raw: [u8; 2],
    pub flee: i16,
    pub flee_raw: [u8; 2],
    pub aspd: i16,
    pub aspd_raw: [u8; 2],
    pub hp: i16,
    pub hp_raw: [u8; 2],
    pub max_hp: i16,
    pub max_hp_raw: [u8; 2],
    pub sp: i16,
    pub sp_raw: [u8; 2],
    pub max_sp: i16,
    pub max_sp_raw: [u8; 2],
    pub atkrange: i16,
    pub atkrange_raw: [u8; 2],
    pub exp: i32,
    pub exp_raw: [u8; 4],
}

impl PacketZcPropertyMerce {
    pub fn from(buffer: &[u8]) -> PacketZcPropertyMerce {
        PacketZcPropertyMerce {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            level: i16::from_le_bytes([buffer[26], buffer[27]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            faith: i16::from_le_bytes([buffer[28], buffer[29]]),
            faith_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            summon_count: i16::from_le_bytes([buffer[30], buffer[31]]),
            summon_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            atk: i16::from_le_bytes([buffer[32], buffer[33]]),
            atk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            matk: i16::from_le_bytes([buffer[34], buffer[35]]),
            matk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            hit: i16::from_le_bytes([buffer[36], buffer[37]]),
            hit_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[36..38]);
                dst
            },
            critical: i16::from_le_bytes([buffer[38], buffer[39]]),
            critical_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[38..40]);
                dst
            },
            def: i16::from_le_bytes([buffer[40], buffer[41]]),
            def_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            mdef: i16::from_le_bytes([buffer[42], buffer[43]]),
            mdef_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            flee: i16::from_le_bytes([buffer[44], buffer[45]]),
            flee_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[44..46]);
                dst
            },
            aspd: i16::from_le_bytes([buffer[46], buffer[47]]),
            aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[46..48]);
                dst
            },
            hp: i16::from_le_bytes([buffer[48], buffer[49]]),
            hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[48..50]);
                dst
            },
            max_hp: i16::from_le_bytes([buffer[50], buffer[51]]),
            max_hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[50..52]);
                dst
            },
            sp: i16::from_le_bytes([buffer[52], buffer[53]]),
            sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[52..54]);
                dst
            },
            max_sp: i16::from_le_bytes([buffer[54], buffer[55]]),
            max_sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[54..56]);
                dst
            },
            atkrange: i16::from_le_bytes([buffer[56], buffer[57]]),
            atkrange_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[56..58]);
                dst
            },
            exp: i32::from_le_bytes([buffer[58], buffer[59], buffer[60], buffer[61]]),
            exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[58..62]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.faith).unwrap();
        self.faith_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.summon_count).unwrap();
        self.summon_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atk).unwrap();
        self.atk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.matk).unwrap();
        self.matk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hit).unwrap();
        self.hit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.critical).unwrap();
        self.critical_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.def).unwrap();
        self.def_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef).unwrap();
        self.mdef_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.flee).unwrap();
        self.flee_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.aspd).unwrap();
        self.aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sp).unwrap();
        self.sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_sp).unwrap();
        self.max_sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atkrange).unwrap();
        self.atkrange_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.exp).unwrap();
        self.exp_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcPropertyMerce {
    fn id(&self) -> &str {
       "0x027d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcShandaProtect {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub code_len: i16,
    pub code_len_raw: [u8; 2],
    pub code: String,
    pub code_raw: Vec<u8>,
}

impl PacketZcShandaProtect {
    pub fn from(buffer: &[u8]) -> PacketZcShandaProtect {
        PacketZcShandaProtect {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            code_len: i16::from_le_bytes([buffer[4], buffer[5]]),
            code_len_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            code: String::from_utf8_lossy(&buffer[6..buffer.len()]).to_string(),
            code_raw: buffer[6..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.code_len).unwrap();
        self.code_len_raw = wtr.try_into().unwrap();
        self.code_raw = self.code.as_bytes().to_vec()
    }
}

impl Packet for PacketZcShandaProtect {
    fn id(&self) -> &str {
       "0x027e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCaClientType {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub client_type: i16,
    pub client_type_raw: [u8; 2],
    pub n_ver: i32,
    pub n_ver_raw: [u8; 4],
}

impl PacketCaClientType {
    pub fn from(buffer: &[u8]) -> PacketCaClientType {
        PacketCaClientType {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            client_type: i16::from_le_bytes([buffer[2], buffer[3]]),
            client_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            n_ver: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            n_ver_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.client_type).unwrap();
        self.client_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.n_ver).unwrap();
        self.n_ver_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCaClientType {
    fn id(&self) -> &str {
       "0x027f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcGangsiPoint {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub point: i32,
    pub point_raw: [u8; 4],
    pub total_point: i32,
    pub total_point_raw: [u8; 4],
    pub packet_switch: i16,
    pub packet_switch_raw: [u8; 2],
}

impl PacketZcGangsiPoint {
    pub fn from(buffer: &[u8]) -> PacketZcGangsiPoint {
        PacketZcGangsiPoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            point: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            total_point: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            total_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            packet_switch: i16::from_le_bytes([buffer[10], buffer[11]]),
            packet_switch_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.total_point).unwrap();
        self.total_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_switch).unwrap();
        self.packet_switch_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcGangsiPoint {
    fn id(&self) -> &str {
       "0x0280"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzGangsiRank {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_switch: i16,
    pub packet_switch_raw: [u8; 2],
}

impl PacketCzGangsiRank {
    pub fn from(buffer: &[u8]) -> PacketCzGangsiRank {
        PacketCzGangsiRank {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_switch: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_switch_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_switch).unwrap();
        self.packet_switch_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzGangsiRank {
    fn id(&self) -> &str {
       "0x0281"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcGangsiRank {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub name: [char; 10],
    pub name_raw: [u8; 10],
    pub point: [i32; 10],
    pub point_raw: [u8; 10],
    pub packet_switch: i16,
    pub packet_switch_raw: [u8; 2],
}

impl PacketZcGangsiRank {
    pub fn from(buffer: &[u8]) -> PacketZcGangsiRank {
        PacketZcGangsiRank {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 10] = [0 as char; 10];
                for (index, byte) in buffer[2..12].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[2..12]);
                dst
            },
            point:  {
                let mut dst: [i32; 10] = [0 as i32; 10];
                for (index, byte) in buffer[242..252].iter().enumerate() {
                    dst[index] = *byte as i32;
                }
                dst
            },
            point_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[242..252]);
                dst
            },
            packet_switch: i16::from_le_bytes([buffer[282], buffer[283]]),
            packet_switch_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[282..284]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.point {
            wtr.write_i32::<LittleEndian>(item).unwrap();
        }
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_switch).unwrap();
        self.packet_switch_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcGangsiRank {
    fn id(&self) -> &str {
       "0x0282"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAid {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketZcAid {
    pub fn from(buffer: &[u8]) -> PacketZcAid {
        PacketZcAid {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAid {
    fn id(&self) -> &str {
       "0x0283"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyEffect3 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub effect_id: i32,
    pub effect_id_raw: [u8; 4],
    pub numdata: i32,
    pub numdata_raw: [u8; 4],
}

impl PacketZcNotifyEffect3 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyEffect3 {
        PacketZcNotifyEffect3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            effect_id: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            effect_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            numdata: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            numdata_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_id).unwrap();
        self.effect_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.numdata).unwrap();
        self.numdata_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyEffect3 {
    fn id(&self) -> &str {
       "0x0284"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcDeathQuestion {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub qcategory: i16,
    pub qcategory_raw: [u8; 2],
    pub qnum: i16,
    pub qnum_raw: [u8; 2],
}

impl PacketZcDeathQuestion {
    pub fn from(buffer: &[u8]) -> PacketZcDeathQuestion {
        PacketZcDeathQuestion {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            qcategory: i16::from_le_bytes([buffer[2], buffer[3]]),
            qcategory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            qnum: i16::from_le_bytes([buffer[4], buffer[5]]),
            qnum_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.qcategory).unwrap();
        self.qcategory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.qnum).unwrap();
        self.qnum_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcDeathQuestion {
    fn id(&self) -> &str {
       "0x0285"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzDeathQuestion {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub qanswer: i16,
    pub qanswer_raw: [u8; 2],
}

impl PacketCzDeathQuestion {
    pub fn from(buffer: &[u8]) -> PacketCzDeathQuestion {
        PacketCzDeathQuestion {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            qanswer: i16::from_le_bytes([buffer[2], buffer[3]]),
            qanswer_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.qanswer).unwrap();
        self.qanswer_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzDeathQuestion {
    fn id(&self) -> &str {
       "0x0286"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPcCashPointItemlist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub cash_point: u32,
    pub cash_point_raw: [u8; 4],
    pub item_list: Vec<PurchaseItem>,
    pub item_list_raw: Vec<Vec<u8>>,
}

impl PacketZcPcCashPointItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcPcCashPointItemlist {
        let iter_count = &buffer.len() / 11;
        let mut vec_field: Vec<PurchaseItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 * i;
            let end_pos = 19 * i;
            vec_field.push(PurchaseItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPcCashPointItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            cash_point: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            cash_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.cash_point).unwrap();
        self.cash_point_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.serialize());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcPcCashPointItemlist {
    fn id(&self) -> &str {
       "0x0287"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzPcBuyCashPointItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
}

impl PacketCzPcBuyCashPointItem {
    pub fn from(buffer: &[u8]) -> PacketCzPcBuyCashPointItem {
        PacketCzPcBuyCashPointItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzPcBuyCashPointItem {
    fn id(&self) -> &str {
       "0x0288"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPcCashPointUpdate {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub cash_point: u32,
    pub cash_point_raw: [u8; 4],
    pub error: i16,
    pub error_raw: [u8; 2],
}

impl PacketZcPcCashPointUpdate {
    pub fn from(buffer: &[u8]) -> PacketZcPcCashPointUpdate {
        PacketZcPcCashPointUpdate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            cash_point: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            cash_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            error: i16::from_le_bytes([buffer[6], buffer[7]]),
            error_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.cash_point).unwrap();
        self.cash_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error).unwrap();
        self.error_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcPcCashPointUpdate {
    fn id(&self) -> &str {
       "0x0289"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNpcShowefstUpdate {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub effect_state: i32,
    pub effect_state_raw: [u8; 4],
    pub clevel: i32,
    pub clevel_raw: [u8; 4],
    pub show_efst: i32,
    pub show_efst_raw: [u8; 4],
}

impl PacketZcNpcShowefstUpdate {
    pub fn from(buffer: &[u8]) -> PacketZcNpcShowefstUpdate {
        PacketZcNpcShowefstUpdate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            clevel: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            clevel_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            show_efst: i32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            show_efst_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.show_efst).unwrap();
        self.show_efst_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNpcShowefstUpdate {
    fn id(&self) -> &str {
       "0x028a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketChSelectCharGoingtobeused {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub dw_aid: u32,
    pub dw_aid_raw: [u8; 4],
    pub n_count_selected_char: i32,
    pub n_count_selected_char_raw: [u8; 4],
    pub ardw_selected_gid: [u32; 9],
    pub ardw_selected_gid_raw: [u8; 9],
}

impl PacketChSelectCharGoingtobeused {
    pub fn from(buffer: &[u8]) -> PacketChSelectCharGoingtobeused {
        PacketChSelectCharGoingtobeused {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            dw_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            dw_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            n_count_selected_char: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            n_count_selected_char_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            ardw_selected_gid:  {
                let mut dst: [u32; 9] = [0 as u32; 9];
                for (index, byte) in buffer[10..19].iter().enumerate() {
                    dst[index] = *byte as u32;
                }
                dst
            },
            ardw_selected_gid_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[10..19]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_aid).unwrap();
        self.dw_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.n_count_selected_char).unwrap();
        self.n_count_selected_char_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.ardw_selected_gid {
            wtr.write_u32::<LittleEndian>(item).unwrap();
        }
        self.ardw_selected_gid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketChSelectCharGoingtobeused {
    fn id(&self) -> &str {
       "0x028c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketChReqIsValidCharname {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub dw_aid: u32,
    pub dw_aid_raw: [u8; 4],
    pub dw_gid: u32,
    pub dw_gid_raw: [u8; 4],
    pub sz_char_name: [char; 24],
    pub sz_char_name_raw: [u8; 24],
}

impl PacketChReqIsValidCharname {
    pub fn from(buffer: &[u8]) -> PacketChReqIsValidCharname {
        PacketChReqIsValidCharname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            dw_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            dw_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            dw_gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            dw_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            sz_char_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[10..34].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            sz_char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[10..34]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_aid).unwrap();
        self.dw_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_gid).unwrap();
        self.dw_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_char_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketChReqIsValidCharname {
    fn id(&self) -> &str {
       "0x028d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketHcAckIsValidCharname {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub s_result: i16,
    pub s_result_raw: [u8; 2],
}

impl PacketHcAckIsValidCharname {
    pub fn from(buffer: &[u8]) -> PacketHcAckIsValidCharname {
        PacketHcAckIsValidCharname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            s_result: i16::from_le_bytes([buffer[2], buffer[3]]),
            s_result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.s_result).unwrap();
        self.s_result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketHcAckIsValidCharname {
    fn id(&self) -> &str {
       "0x028e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketChReqChangeCharname {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub dw_gid: u32,
    pub dw_gid_raw: [u8; 4],
}

impl PacketChReqChangeCharname {
    pub fn from(buffer: &[u8]) -> PacketChReqChangeCharname {
        PacketChReqChangeCharname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            dw_gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            dw_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_gid).unwrap();
        self.dw_gid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketChReqChangeCharname {
    fn id(&self) -> &str {
       "0x028f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketHcAckChangeCharname {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub s_result: i16,
    pub s_result_raw: [u8; 2],
}

impl PacketHcAckChangeCharname {
    pub fn from(buffer: &[u8]) -> PacketHcAckChangeCharname {
        PacketHcAckChangeCharname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            s_result: i16::from_le_bytes([buffer[2], buffer[3]]),
            s_result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.s_result).unwrap();
        self.s_result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketHcAckChangeCharname {
    fn id(&self) -> &str {
       "0x0290"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMsg {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub msg: u16,
    pub msg_raw: [u8; 2],
}

impl PacketZcMsg {
    pub fn from(buffer: &[u8]) -> PacketZcMsg {
        PacketZcMsg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            msg: u16::from_le_bytes([buffer[2], buffer[3]]),
            msg_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.msg).unwrap();
        self.msg_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMsg {
    fn id(&self) -> &str {
       "0x0291"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzStandingResurrection {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzStandingResurrection {
    pub fn from(buffer: &[u8]) -> PacketCzStandingResurrection {
        PacketCzStandingResurrection {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzStandingResurrection {
    fn id(&self) -> &str {
       "0x0292"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcBossInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub info_type: u8,
    pub info_type_raw: [u8; 1],
    pub x_pos: i32,
    pub x_pos_raw: [u8; 4],
    pub y_pos: i32,
    pub y_pos_raw: [u8; 4],
    pub min_hour: u16,
    pub min_hour_raw: [u8; 2],
    pub min_minute: u16,
    pub min_minute_raw: [u8; 2],
    pub max_hour: u16,
    pub max_hour_raw: [u8; 2],
    pub max_minute: u16,
    pub max_minute_raw: [u8; 2],
    pub name: [char; 51],
    pub name_raw: [u8; 51],
}

impl PacketZcBossInfo {
    pub fn from(buffer: &[u8]) -> PacketZcBossInfo {
        PacketZcBossInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            info_type: u8::from_le_bytes([buffer[2]]),
            info_type_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            x_pos: i32::from_le_bytes([buffer[3], buffer[4], buffer[5], buffer[6]]),
            x_pos_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[3..7]);
                dst
            },
            y_pos: i32::from_le_bytes([buffer[7], buffer[8], buffer[9], buffer[10]]),
            y_pos_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[7..11]);
                dst
            },
            min_hour: u16::from_le_bytes([buffer[11], buffer[12]]),
            min_hour_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            min_minute: u16::from_le_bytes([buffer[13], buffer[14]]),
            min_minute_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[13..15]);
                dst
            },
            max_hour: u16::from_le_bytes([buffer[15], buffer[16]]),
            max_hour_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[15..17]);
                dst
            },
            max_minute: u16::from_le_bytes([buffer[17], buffer[18]]),
            max_minute_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[17..19]);
                dst
            },
            name:  {
                let mut dst: [char; 51] = [0 as char; 51];
                for (index, byte) in buffer[19..70].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 51] = [0u8; 51];
                dst.clone_from_slice(&buffer[19..70]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.info_type).unwrap();
        self.info_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.min_hour).unwrap();
        self.min_hour_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.min_minute).unwrap();
        self.min_minute_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.max_hour).unwrap();
        self.max_hour_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.max_minute).unwrap();
        self.max_minute_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcBossInfo {
    fn id(&self) -> &str {
       "0x0293"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcReadBook {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub book_id: u32,
    pub book_id_raw: [u8; 4],
    pub page: u32,
    pub page_raw: [u8; 4],
}

impl PacketZcReadBook {
    pub fn from(buffer: &[u8]) -> PacketZcReadBook {
        PacketZcReadBook {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            book_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            book_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            page: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            page_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.book_id).unwrap();
        self.book_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.page).unwrap();
        self.page_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcReadBook {
    fn id(&self) -> &str {
       "0x0294"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcEquipmentItemlist2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_info: Vec<EquipmentitemExtrainfo2>,
    pub item_info_raw: Vec<Vec<u8>>,
}

impl PacketZcEquipmentItemlist2 {
    pub fn from(buffer: &[u8]) -> PacketZcEquipmentItemlist2 {
        let iter_count = &buffer.len() / 24;
        let mut vec_field: Vec<EquipmentitemExtrainfo2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 28 * i;
            vec_field.push(EquipmentitemExtrainfo2::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcEquipmentItemlist2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.serialize());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcEquipmentItemlist2 {
    fn id(&self) -> &str {
       "0x0295"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcStoreEquipmentItemlist2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_info: Vec<EquipmentitemExtrainfo2>,
    pub item_info_raw: Vec<Vec<u8>>,
}

impl PacketZcStoreEquipmentItemlist2 {
    pub fn from(buffer: &[u8]) -> PacketZcStoreEquipmentItemlist2 {
        let iter_count = &buffer.len() / 24;
        let mut vec_field: Vec<EquipmentitemExtrainfo2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 28 * i;
            vec_field.push(EquipmentitemExtrainfo2::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcStoreEquipmentItemlist2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.serialize());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcStoreEquipmentItemlist2 {
    fn id(&self) -> &str {
       "0x0296"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcCartEquipmentItemlist2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_info: Vec<EquipmentitemExtrainfo2>,
    pub item_info_raw: Vec<Vec<u8>>,
}

impl PacketZcCartEquipmentItemlist2 {
    pub fn from(buffer: &[u8]) -> PacketZcCartEquipmentItemlist2 {
        let iter_count = &buffer.len() / 24;
        let mut vec_field: Vec<EquipmentitemExtrainfo2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 28 * i;
            vec_field.push(EquipmentitemExtrainfo2::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcCartEquipmentItemlist2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.serialize());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcCartEquipmentItemlist2 {
    fn id(&self) -> &str {
       "0x0297"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcCashTimeCounter {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub remain_second: u32,
    pub remain_second_raw: [u8; 4],
}

impl PacketZcCashTimeCounter {
    pub fn from(buffer: &[u8]) -> PacketZcCashTimeCounter {
        PacketZcCashTimeCounter {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            remain_second: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            remain_second_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.remain_second).unwrap();
        self.remain_second_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcCashTimeCounter {
    fn id(&self) -> &str {
       "0x0298"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcCashItemDelete {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
}

impl PacketZcCashItemDelete {
    pub fn from(buffer: &[u8]) -> PacketZcCashItemDelete {
        PacketZcCashItemDelete {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            itid: u16::from_le_bytes([buffer[4], buffer[5]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcCashItemDelete {
    fn id(&self) -> &str {
       "0x0299"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcItemPickupAck2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: u16,
    pub index_raw: [u8; 2],
    pub count: u16,
    pub count_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub is_damaged: bool,
    pub is_damaged_raw: [u8; 1],
    pub refining_level: u8,
    pub refining_level_raw: [u8; 1],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
    pub location: u16,
    pub location_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub result: u8,
    pub result_raw: [u8; 1],
    pub hire_expire_date: i32,
    pub hire_expire_date_raw: [u8; 4],
}

impl PacketZcItemPickupAck2 {
    pub fn from(buffer: &[u8]) -> PacketZcItemPickupAck2 {
        PacketZcItemPickupAck2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: u16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            itid: u16::from_le_bytes([buffer[6], buffer[7]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            is_identified: buffer[8] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            is_damaged: buffer[9] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[10]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[11..19]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[11..19]);
                dst
            },
            location: u16::from_le_bytes([buffer[19], buffer[20]]),
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            atype: u8::from_le_bytes([buffer[21]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[21..22]);
                dst
            },
            result: u8::from_le_bytes([buffer[22]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[22..23]);
                dst
            },
            hire_expire_date: i32::from_le_bytes([buffer[23], buffer[24], buffer[25], buffer[26]]),
            hire_expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[23..27]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hire_expire_date).unwrap();
        self.hire_expire_date_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcItemPickupAck2 {
    fn id(&self) -> &str {
       "0x029a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMerInit {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: i32,
    pub aid_raw: [u8; 4],
    pub atk: i16,
    pub atk_raw: [u8; 2],
    pub matk: i16,
    pub matk_raw: [u8; 2],
    pub hit: i16,
    pub hit_raw: [u8; 2],
    pub critical: i16,
    pub critical_raw: [u8; 2],
    pub def: i16,
    pub def_raw: [u8; 2],
    pub mdef: i16,
    pub mdef_raw: [u8; 2],
    pub flee: i16,
    pub flee_raw: [u8; 2],
    pub aspd: i16,
    pub aspd_raw: [u8; 2],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
    pub level: i16,
    pub level_raw: [u8; 2],
    pub hp: i32,
    pub hp_raw: [u8; 4],
    pub max_hp: i32,
    pub max_hp_raw: [u8; 4],
    pub sp: i32,
    pub sp_raw: [u8; 4],
    pub max_sp: i32,
    pub max_sp_raw: [u8; 4],
    pub expire_date: i32,
    pub expire_date_raw: [u8; 4],
    pub faith: i16,
    pub faith_raw: [u8; 2],
    pub toal_call_num: i32,
    pub toal_call_num_raw: [u8; 4],
    pub approval_monster_kill_counter: i32,
    pub approval_monster_kill_counter_raw: [u8; 4],
    pub atkrange: i16,
    pub atkrange_raw: [u8; 2],
}

impl PacketZcMerInit {
    pub fn from(buffer: &[u8]) -> PacketZcMerInit {
        PacketZcMerInit {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atk: i16::from_le_bytes([buffer[6], buffer[7]]),
            atk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            matk: i16::from_le_bytes([buffer[8], buffer[9]]),
            matk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            hit: i16::from_le_bytes([buffer[10], buffer[11]]),
            hit_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            critical: i16::from_le_bytes([buffer[12], buffer[13]]),
            critical_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            def: i16::from_le_bytes([buffer[14], buffer[15]]),
            def_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            mdef: i16::from_le_bytes([buffer[16], buffer[17]]),
            mdef_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            flee: i16::from_le_bytes([buffer[18], buffer[19]]),
            flee_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            aspd: i16::from_le_bytes([buffer[20], buffer[21]]),
            aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[20..22]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[22..46].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[22..46]);
                dst
            },
            level: i16::from_le_bytes([buffer[46], buffer[47]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[46..48]);
                dst
            },
            hp: i32::from_le_bytes([buffer[48], buffer[49], buffer[50], buffer[51]]),
            hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[48..52]);
                dst
            },
            max_hp: i32::from_le_bytes([buffer[52], buffer[53], buffer[54], buffer[55]]),
            max_hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[52..56]);
                dst
            },
            sp: i32::from_le_bytes([buffer[56], buffer[57], buffer[58], buffer[59]]),
            sp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[56..60]);
                dst
            },
            max_sp: i32::from_le_bytes([buffer[60], buffer[61], buffer[62], buffer[63]]),
            max_sp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[60..64]);
                dst
            },
            expire_date: i32::from_le_bytes([buffer[64], buffer[65], buffer[66], buffer[67]]),
            expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[64..68]);
                dst
            },
            faith: i16::from_le_bytes([buffer[68], buffer[69]]),
            faith_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[68..70]);
                dst
            },
            toal_call_num: i32::from_le_bytes([buffer[70], buffer[71], buffer[72], buffer[73]]),
            toal_call_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[70..74]);
                dst
            },
            approval_monster_kill_counter: i32::from_le_bytes([buffer[74], buffer[75], buffer[76], buffer[77]]),
            approval_monster_kill_counter_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[74..78]);
                dst
            },
            atkrange: i16::from_le_bytes([buffer[78], buffer[79]]),
            atkrange_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[78..80]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atk).unwrap();
        self.atk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.matk).unwrap();
        self.matk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hit).unwrap();
        self.hit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.critical).unwrap();
        self.critical_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.def).unwrap();
        self.def_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef).unwrap();
        self.mdef_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.flee).unwrap();
        self.flee_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.aspd).unwrap();
        self.aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.sp).unwrap();
        self.sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_sp).unwrap();
        self.max_sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.expire_date).unwrap();
        self.expire_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.faith).unwrap();
        self.faith_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.toal_call_num).unwrap();
        self.toal_call_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.approval_monster_kill_counter).unwrap();
        self.approval_monster_kill_counter_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atkrange).unwrap();
        self.atkrange_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMerInit {
    fn id(&self) -> &str {
       "0x029b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMerProperty {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atk: i16,
    pub atk_raw: [u8; 2],
    pub matk: i16,
    pub matk_raw: [u8; 2],
    pub hit: i16,
    pub hit_raw: [u8; 2],
    pub critical: i16,
    pub critical_raw: [u8; 2],
    pub def: i16,
    pub def_raw: [u8; 2],
    pub mdef: i16,
    pub mdef_raw: [u8; 2],
    pub flee: i16,
    pub flee_raw: [u8; 2],
    pub aspd: i16,
    pub aspd_raw: [u8; 2],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
    pub level: i16,
    pub level_raw: [u8; 2],
    pub hp: i16,
    pub hp_raw: [u8; 2],
    pub max_hp: i16,
    pub max_hp_raw: [u8; 2],
    pub sp: i16,
    pub sp_raw: [u8; 2],
    pub max_sp: i16,
    pub max_sp_raw: [u8; 2],
    pub expire_date: i32,
    pub expire_date_raw: [u8; 4],
    pub faith: i16,
    pub faith_raw: [u8; 2],
    pub toal_call_num: i32,
    pub toal_call_num_raw: [u8; 4],
    pub approval_monster_kill_counter: i32,
    pub approval_monster_kill_counter_raw: [u8; 4],
}

impl PacketZcMerProperty {
    pub fn from(buffer: &[u8]) -> PacketZcMerProperty {
        PacketZcMerProperty {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atk: i16::from_le_bytes([buffer[2], buffer[3]]),
            atk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            matk: i16::from_le_bytes([buffer[4], buffer[5]]),
            matk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            hit: i16::from_le_bytes([buffer[6], buffer[7]]),
            hit_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            critical: i16::from_le_bytes([buffer[8], buffer[9]]),
            critical_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            def: i16::from_le_bytes([buffer[10], buffer[11]]),
            def_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            mdef: i16::from_le_bytes([buffer[12], buffer[13]]),
            mdef_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            flee: i16::from_le_bytes([buffer[14], buffer[15]]),
            flee_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            aspd: i16::from_le_bytes([buffer[16], buffer[17]]),
            aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[18..42].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[18..42]);
                dst
            },
            level: i16::from_le_bytes([buffer[42], buffer[43]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            hp: i16::from_le_bytes([buffer[44], buffer[45]]),
            hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[44..46]);
                dst
            },
            max_hp: i16::from_le_bytes([buffer[46], buffer[47]]),
            max_hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[46..48]);
                dst
            },
            sp: i16::from_le_bytes([buffer[48], buffer[49]]),
            sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[48..50]);
                dst
            },
            max_sp: i16::from_le_bytes([buffer[50], buffer[51]]),
            max_sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[50..52]);
                dst
            },
            expire_date: i32::from_le_bytes([buffer[52], buffer[53], buffer[54], buffer[55]]),
            expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[52..56]);
                dst
            },
            faith: i16::from_le_bytes([buffer[56], buffer[57]]),
            faith_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[56..58]);
                dst
            },
            toal_call_num: i32::from_le_bytes([buffer[58], buffer[59], buffer[60], buffer[61]]),
            toal_call_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[58..62]);
                dst
            },
            approval_monster_kill_counter: i32::from_le_bytes([buffer[62], buffer[63], buffer[64], buffer[65]]),
            approval_monster_kill_counter_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[62..66]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atk).unwrap();
        self.atk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.matk).unwrap();
        self.matk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hit).unwrap();
        self.hit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.critical).unwrap();
        self.critical_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.def).unwrap();
        self.def_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef).unwrap();
        self.mdef_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.flee).unwrap();
        self.flee_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.aspd).unwrap();
        self.aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sp).unwrap();
        self.sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_sp).unwrap();
        self.max_sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.expire_date).unwrap();
        self.expire_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.faith).unwrap();
        self.faith_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.toal_call_num).unwrap();
        self.toal_call_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.approval_monster_kill_counter).unwrap();
        self.approval_monster_kill_counter_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMerProperty {
    fn id(&self) -> &str {
       "0x029c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMerSkillinfoList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub skill_list: Vec<SKILLINFO>,
    pub skill_list_raw: Vec<Vec<u8>>,
}

impl PacketZcMerSkillinfoList {
    pub fn from(buffer: &[u8]) -> PacketZcMerSkillinfoList {
        let iter_count = &buffer.len() / 37;
        let mut vec_field: Vec<SKILLINFO> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 41 * i;
            vec_field.push(SKILLINFO::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcMerSkillinfoList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            skill_list: vec_field.clone(),
            skill_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.skill_list_raw = {
            self.skill_list.iter_mut().for_each(|item| item.serialize());
            self.skill_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcMerSkillinfoList {
    fn id(&self) -> &str {
       "0x029d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMerSkillinfoUpdate {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub level: i16,
    pub level_raw: [u8; 2],
    pub spcost: i16,
    pub spcost_raw: [u8; 2],
    pub attack_range: i16,
    pub attack_range_raw: [u8; 2],
    pub upgradable: bool,
    pub upgradable_raw: [u8; 1],
}

impl PacketZcMerSkillinfoUpdate {
    pub fn from(buffer: &[u8]) -> PacketZcMerSkillinfoUpdate {
        PacketZcMerSkillinfoUpdate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            level: i16::from_le_bytes([buffer[4], buffer[5]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            spcost: i16::from_le_bytes([buffer[6], buffer[7]]),
            spcost_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            attack_range: i16::from_le_bytes([buffer[8], buffer[9]]),
            attack_range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            upgradable: buffer[10] == 1,
            upgradable_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.spcost).unwrap();
        self.spcost_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.attack_range).unwrap();
        self.attack_range_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.upgradable as u8).unwrap();
        self.upgradable_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMerSkillinfoUpdate {
    fn id(&self) -> &str {
       "0x029e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzMerCommand {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub command: i8,
    pub command_raw: [u8; 1],
}

impl PacketCzMerCommand {
    pub fn from(buffer: &[u8]) -> PacketCzMerCommand {
        PacketCzMerCommand {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            command: i8::from_le_bytes([buffer[2]]),
            command_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.command).unwrap();
        self.command_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzMerCommand {
    fn id(&self) -> &str {
       "0x029f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct UnusedPacketCzMerUseSkill {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub selected_level: i16,
    pub selected_level_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub target_id: u32,
    pub target_id_raw: [u8; 4],
}

impl UnusedPacketCzMerUseSkill {
    pub fn from(buffer: &[u8]) -> UnusedPacketCzMerUseSkill {
        UnusedPacketCzMerUseSkill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            selected_level: i16::from_le_bytes([buffer[2], buffer[3]]),
            selected_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            skid: u16::from_le_bytes([buffer[4], buffer[5]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            target_id: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.selected_level).unwrap();
        self.selected_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for UnusedPacketCzMerUseSkill {
    fn id(&self) -> &str {
       "0x02a0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct UnusedPacketCzMerUpgradeSkilllevel {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
}

impl UnusedPacketCzMerUpgradeSkilllevel {
    pub fn from(buffer: &[u8]) -> UnusedPacketCzMerUpgradeSkilllevel {
        UnusedPacketCzMerUpgradeSkilllevel {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for UnusedPacketCzMerUpgradeSkilllevel {
    fn id(&self) -> &str {
       "0x02a1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMerParChange {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub var: u16,
    pub var_raw: [u8; 2],
    pub value: i32,
    pub value_raw: [u8; 4],
}

impl PacketZcMerParChange {
    pub fn from(buffer: &[u8]) -> PacketZcMerParChange {
        PacketZcMerParChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            var: u16::from_le_bytes([buffer[2], buffer[3]]),
            var_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            value: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var).unwrap();
        self.var_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMerParChange {
    fn id(&self) -> &str {
       "0x02a2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcGameguardLingoKey {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub lingo_key: PggLingoKeyTemp,
    pub lingo_key_raw: Vec<u8>,
}

impl PacketZcGameguardLingoKey {
    pub fn from(buffer: &[u8]) -> PacketZcGameguardLingoKey {
        PacketZcGameguardLingoKey {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            lingo_key: PggLingoKeyTemp::from(&buffer[2..buffer.len()]),
            lingo_key_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcGameguardLingoKey {
    fn id(&self) -> &str {
       "0x02a3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzKsyEvent {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
}

impl PacketCzKsyEvent {
    pub fn from(buffer: &[u8]) -> PacketCzKsyEvent {
        PacketCzKsyEvent {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzKsyEvent {
    fn id(&self) -> &str {
       "0x02a5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcReqCashPassword {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub info: i16,
    pub info_raw: [u8; 2],
}

impl PacketZcReqCashPassword {
    pub fn from(buffer: &[u8]) -> PacketZcReqCashPassword {
        PacketZcReqCashPassword {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            info: i16::from_le_bytes([buffer[2], buffer[3]]),
            info_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.info).unwrap();
        self.info_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcReqCashPassword {
    fn id(&self) -> &str {
       "0x02aa"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzAckCashPassword {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i16,
    pub atype_raw: [u8; 2],
    pub password: [char; 16],
    pub password_raw: [u8; 16],
    pub new_password: [char; 16],
    pub new_password_raw: [u8; 16],
}

impl PacketCzAckCashPassword {
    pub fn from(buffer: &[u8]) -> PacketCzAckCashPassword {
        PacketCzAckCashPassword {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i16::from_le_bytes([buffer[2], buffer[3]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            password:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[4..20].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            password_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[4..20]);
                dst
            },
            new_password:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[20..36].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            new_password_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[20..36]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.password {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.password_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.new_password {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.new_password_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzAckCashPassword {
    fn id(&self) -> &str {
       "0x02ab"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcResultCashPassword {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: i16,
    pub result_raw: [u8; 2],
    pub error_count: i16,
    pub error_count_raw: [u8; 2],
}

impl PacketZcResultCashPassword {
    pub fn from(buffer: &[u8]) -> PacketZcResultCashPassword {
        PacketZcResultCashPassword {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            error_count: i16::from_le_bytes([buffer[4], buffer[5]]),
            error_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_count).unwrap();
        self.error_count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcResultCashPassword {
    fn id(&self) -> &str {
       "0x02ac"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcRequestSecondPassword {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: i16,
    pub result_raw: [u8; 2],
    pub dw_seed: u32,
    pub dw_seed_raw: [u8; 4],
}

impl PacketAcRequestSecondPassword {
    pub fn from(buffer: &[u8]) -> PacketAcRequestSecondPassword {
        PacketAcRequestSecondPassword {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            dw_seed: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            dw_seed_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_seed).unwrap();
        self.dw_seed_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcRequestSecondPassword {
    fn id(&self) -> &str {
       "0x02ad"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCaLoginHan {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub version: u32,
    pub version_raw: [u8; 4],
    pub id: [char; 24],
    pub id_raw: [u8; 24],
    pub passwd: [char; 24],
    pub passwd_raw: [u8; 24],
    pub clienttype: u8,
    pub clienttype_raw: [u8; 1],
    pub m_sz_ip: [char; 16],
    pub m_sz_ip_raw: [u8; 16],
    pub m_sz_mac_addr: [char; 13],
    pub m_sz_mac_addr_raw: [u8; 13],
    pub is_han_game_user: u8,
    pub is_han_game_user_raw: [u8; 1],
}

impl PacketCaLoginHan {
    pub fn from(buffer: &[u8]) -> PacketCaLoginHan {
        PacketCaLoginHan {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            version: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            id:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            passwd:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[30..54].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[30..54]);
                dst
            },
            clienttype: u8::from_le_bytes([buffer[54]]),
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[54..55]);
                dst
            },
            m_sz_ip:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[55..71].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            m_sz_ip_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[55..71]);
                dst
            },
            m_sz_mac_addr:  {
                let mut dst: [char; 13] = [0 as char; 13];
                for (index, byte) in buffer[71..84].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            m_sz_mac_addr_raw: {
                let mut dst: [u8; 13] = [0u8; 13];
                dst.clone_from_slice(&buffer[71..84]);
                dst
            },
            is_han_game_user: u8::from_le_bytes([buffer[84]]),
            is_han_game_user_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[84..85]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_sz_ip {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_sz_ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_sz_mac_addr {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_sz_mac_addr_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_han_game_user).unwrap();
        self.is_han_game_user_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCaLoginHan {
    fn id(&self) -> &str {
       "0x02b0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAllQuestList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub quest_count: i32,
    pub quest_count_raw: [u8; 4],
    pub quest_list: Vec<PacketZcQuestInfo>,
    pub quest_list_raw: Vec<Vec<u8>>,
}

impl PacketZcAllQuestList {
    pub fn from(buffer: &[u8]) -> PacketZcAllQuestList {
        let iter_count = &buffer.len() / 5;
        let mut vec_field: Vec<PacketZcQuestInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 * i;
            let end_pos = 13 * i;
            vec_field.push(PacketZcQuestInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcAllQuestList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            quest_count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            quest_count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            quest_list: vec_field.clone(),
            quest_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.quest_count).unwrap();
        self.quest_count_raw = wtr.try_into().unwrap();
        self.quest_list_raw = {
            self.quest_list.iter_mut().for_each(|item| item.serialize());
            self.quest_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcAllQuestList {
    fn id(&self) -> &str {
       "0x02b1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAllQuestMission {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub count: i32,
    pub count_raw: [u8; 4],
    pub quest_mission_list: Vec<PacketZcQuestMissionInfo>,
    pub quest_mission_list_raw: Vec<Vec<u8>>,
}

impl PacketZcAllQuestMission {
    pub fn from(buffer: &[u8]) -> PacketZcAllQuestMission {
        let iter_count = &buffer.len() / 104;
        let mut vec_field: Vec<PacketZcQuestMissionInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 * i;
            let end_pos = 112 * i;
            vec_field.push(PacketZcQuestMissionInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcAllQuestMission {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            quest_mission_list: vec_field.clone(),
            quest_mission_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        self.quest_mission_list_raw = {
            self.quest_mission_list.iter_mut().for_each(|item| item.serialize());
            self.quest_mission_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcAllQuestMission {
    fn id(&self) -> &str {
       "0x02b2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAddQuest {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub quest_id: u32,
    pub quest_id_raw: [u8; 4],
    pub active: bool,
    pub active_raw: [u8; 1],
    pub quest_svr_time: i32,
    pub quest_svr_time_raw: [u8; 4],
    pub quest_end_time: i32,
    pub quest_end_time_raw: [u8; 4],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub hunt: Vec<PacketZcMissionHunt>,
    pub hunt_raw: Vec<Vec<u8>>,
}

impl PacketZcAddQuest {
    pub fn from(buffer: &[u8]) -> PacketZcAddQuest {
        let iter_count = &buffer.len() / 30;
        let mut vec_field: Vec<PacketZcMissionHunt> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 17 * i;
            let end_pos = 47 * i;
            vec_field.push(PacketZcMissionHunt::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcAddQuest {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            quest_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            active: buffer[6] == 1,
            active_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            quest_svr_time: i32::from_le_bytes([buffer[7], buffer[8], buffer[9], buffer[10]]),
            quest_svr_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[7..11]);
                dst
            },
            quest_end_time: i32::from_le_bytes([buffer[11], buffer[12], buffer[13], buffer[14]]),
            quest_end_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[11..15]);
                dst
            },
            count: i16::from_le_bytes([buffer[15], buffer[16]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[15..17]);
                dst
            },
            hunt: vec_field.clone(),
            hunt_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.active as u8).unwrap();
        self.active_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.quest_svr_time).unwrap();
        self.quest_svr_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.quest_end_time).unwrap();
        self.quest_end_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        self.hunt_raw = {
            self.hunt.iter_mut().for_each(|item| item.serialize());
            self.hunt.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcAddQuest {
    fn id(&self) -> &str {
       "0x02b3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcDelQuest {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub quest_id: u32,
    pub quest_id_raw: [u8; 4],
}

impl PacketZcDelQuest {
    pub fn from(buffer: &[u8]) -> PacketZcDelQuest {
        PacketZcDelQuest {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            quest_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcDelQuest {
    fn id(&self) -> &str {
       "0x02b4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcUpdateMissionHunt {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub mob_hunt_list: Vec<PacketMobHunting>,
    pub mob_hunt_list_raw: Vec<Vec<u8>>,
}

impl PacketZcUpdateMissionHunt {
    pub fn from(buffer: &[u8]) -> PacketZcUpdateMissionHunt {
        let iter_count = &buffer.len() / 12;
        let mut vec_field: Vec<PacketMobHunting> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 6 * i;
            let end_pos = 18 * i;
            vec_field.push(PacketMobHunting::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcUpdateMissionHunt {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            mob_hunt_list: vec_field.clone(),
            mob_hunt_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        self.mob_hunt_list_raw = {
            self.mob_hunt_list.iter_mut().for_each(|item| item.serialize());
            self.mob_hunt_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcUpdateMissionHunt {
    fn id(&self) -> &str {
       "0x02b5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzActiveQuest {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub quest_id: u32,
    pub quest_id_raw: [u8; 4],
    pub active: bool,
    pub active_raw: [u8; 1],
}

impl PacketCzActiveQuest {
    pub fn from(buffer: &[u8]) -> PacketCzActiveQuest {
        PacketCzActiveQuest {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            quest_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            active: buffer[6] == 1,
            active_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.active as u8).unwrap();
        self.active_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzActiveQuest {
    fn id(&self) -> &str {
       "0x02b6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcActiveQuest {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub quest_id: u32,
    pub quest_id_raw: [u8; 4],
    pub active: bool,
    pub active_raw: [u8; 1],
}

impl PacketZcActiveQuest {
    pub fn from(buffer: &[u8]) -> PacketZcActiveQuest {
        PacketZcActiveQuest {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            quest_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            active: buffer[6] == 1,
            active_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.active as u8).unwrap();
        self.active_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcActiveQuest {
    fn id(&self) -> &str {
       "0x02b7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcItemPickupParty {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub account_id: u32,
    pub account_id_raw: [u8; 4],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub is_damaged: bool,
    pub is_damaged_raw: [u8; 1],
    pub refining_level: u8,
    pub refining_level_raw: [u8; 1],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
    pub location: u16,
    pub location_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
}

impl PacketZcItemPickupParty {
    pub fn from(buffer: &[u8]) -> PacketZcItemPickupParty {
        PacketZcItemPickupParty {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            account_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            itid: u16::from_le_bytes([buffer[6], buffer[7]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            is_identified: buffer[8] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            is_damaged: buffer[9] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[10]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[11..19]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[11..19]);
                dst
            },
            location: u16::from_le_bytes([buffer[19], buffer[20]]),
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            atype: u8::from_le_bytes([buffer[21]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[21..22]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcItemPickupParty {
    fn id(&self) -> &str {
       "0x02b8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcShortcutKeyList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub short_cut_key: Vec<ShortCutKey>,
    pub short_cut_key_raw: Vec<Vec<u8>>,
}

impl PacketZcShortcutKeyList {
    pub fn from(buffer: &[u8]) -> PacketZcShortcutKeyList {
        let iter_count = &buffer.len() / 7;
        let mut vec_field: Vec<ShortCutKey> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 2 * i;
            let end_pos = 9 * i;
            vec_field.push(ShortCutKey::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcShortcutKeyList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            short_cut_key: vec_field.clone(),
            short_cut_key_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.short_cut_key_raw = {
            self.short_cut_key.iter_mut().for_each(|item| item.serialize());
            self.short_cut_key.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcShortcutKeyList {
    fn id(&self) -> &str {
       "0x02b9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzShortcutKeyChange {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: u16,
    pub index_raw: [u8; 2],
    pub short_cut_key: ShortCutKey,
    pub short_cut_key_raw: Vec<u8>,
}

impl PacketCzShortcutKeyChange {
    pub fn from(buffer: &[u8]) -> PacketCzShortcutKeyChange {
        PacketCzShortcutKeyChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            short_cut_key: ShortCutKey::from(&buffer[4..buffer.len()]),
            short_cut_key_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketCzShortcutKeyChange {
    fn id(&self) -> &str {
       "0x02ba"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcEquipitemDamaged {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub wear_location: u16,
    pub wear_location_raw: [u8; 2],
    pub account_id: u32,
    pub account_id_raw: [u8; 4],
}

impl PacketZcEquipitemDamaged {
    pub fn from(buffer: &[u8]) -> PacketZcEquipitemDamaged {
        PacketZcEquipitemDamaged {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            wear_location: u16::from_le_bytes([buffer[2], buffer[3]]),
            wear_location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            account_id: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_location).unwrap();
        self.wear_location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcEquipitemDamaged {
    fn id(&self) -> &str {
       "0x02bb"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyPcbangPlayingTime {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub time_minute: i32,
    pub time_minute_raw: [u8; 4],
}

impl PacketZcNotifyPcbangPlayingTime {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyPcbangPlayingTime {
        PacketZcNotifyPcbangPlayingTime {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            time_minute: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            time_minute_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.time_minute).unwrap();
        self.time_minute_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyPcbangPlayingTime {
    fn id(&self) -> &str {
       "0x02bc"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSrpacketr2Init {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub protect_factor: u16,
    pub protect_factor_raw: [u8; 2],
    pub deform_seed_factor: u32,
    pub deform_seed_factor_raw: [u8; 4],
    pub deform_add_factor: u32,
    pub deform_add_factor_raw: [u8; 4],
}

impl PacketZcSrpacketr2Init {
    pub fn from(buffer: &[u8]) -> PacketZcSrpacketr2Init {
        PacketZcSrpacketr2Init {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            protect_factor: u16::from_le_bytes([buffer[2], buffer[3]]),
            protect_factor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            deform_seed_factor: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            deform_seed_factor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            deform_add_factor: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            deform_add_factor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.protect_factor).unwrap();
        self.protect_factor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.deform_seed_factor).unwrap();
        self.deform_seed_factor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.deform_add_factor).unwrap();
        self.deform_add_factor_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSrpacketr2Init {
    fn id(&self) -> &str {
       "0x02bf"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzSrpacketr2Start {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub protect_factor: u16,
    pub protect_factor_raw: [u8; 2],
}

impl PacketCzSrpacketr2Start {
    pub fn from(buffer: &[u8]) -> PacketCzSrpacketr2Start {
        PacketCzSrpacketr2Start {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            protect_factor: u16::from_le_bytes([buffer[2], buffer[3]]),
            protect_factor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.protect_factor).unwrap();
        self.protect_factor_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzSrpacketr2Start {
    fn id(&self) -> &str {
       "0x02c0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNpcChat {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub account_id: u32,
    pub account_id_raw: [u8; 4],
    pub color: u32,
    pub color_raw: [u8; 4],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketZcNpcChat {
    pub fn from(buffer: &[u8]) -> PacketZcNpcChat {
        PacketZcNpcChat {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            account_id: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            color: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            color_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[12..buffer.len()]).to_string(),
            msg_raw: buffer[12..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.color).unwrap();
        self.color_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketZcNpcChat {
    fn id(&self) -> &str {
       "0x02c1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcFormatstringMsg {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub msg: u16,
    pub msg_raw: [u8; 2],
    pub value: String,
    pub value_raw: Vec<u8>,
}

impl PacketZcFormatstringMsg {
    pub fn from(buffer: &[u8]) -> PacketZcFormatstringMsg {
        PacketZcFormatstringMsg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: u16::from_le_bytes([buffer[4], buffer[5]]),
            msg_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            value: String::from_utf8_lossy(&buffer[6..buffer.len()]).to_string(),
            value_raw: buffer[6..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.msg).unwrap();
        self.msg_raw = wtr.try_into().unwrap();
        self.value_raw = self.value.as_bytes().to_vec()
    }
}

impl Packet for PacketZcFormatstringMsg {
    fn id(&self) -> &str {
       "0x02c2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzPartyJoinReq {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub character_name: [char; 24],
    pub character_name_raw: [u8; 24],
}

impl PacketCzPartyJoinReq {
    pub fn from(buffer: &[u8]) -> PacketCzPartyJoinReq {
        PacketCzPartyJoinReq {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzPartyJoinReq {
    fn id(&self) -> &str {
       "0x02c4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPartyJoinReqAck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub character_name: [char; 24],
    pub character_name_raw: [u8; 24],
    pub answer: i32,
    pub answer_raw: [u8; 4],
}

impl PacketZcPartyJoinReqAck {
    pub fn from(buffer: &[u8]) -> PacketZcPartyJoinReqAck {
        PacketZcPartyJoinReqAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            answer: i32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            answer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcPartyJoinReqAck {
    fn id(&self) -> &str {
       "0x02c5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPartyJoinReq {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub grid: u32,
    pub grid_raw: [u8; 4],
    pub group_name: [char; 24],
    pub group_name_raw: [u8; 24],
}

impl PacketZcPartyJoinReq {
    pub fn from(buffer: &[u8]) -> PacketZcPartyJoinReq {
        PacketZcPartyJoinReq {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            grid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            grid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            group_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.grid).unwrap();
        self.grid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcPartyJoinReq {
    fn id(&self) -> &str {
       "0x02c6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzPartyJoinReqAck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub grid: u32,
    pub grid_raw: [u8; 4],
    pub b_accept: bool,
    pub b_accept_raw: [u8; 1],
}

impl PacketCzPartyJoinReqAck {
    pub fn from(buffer: &[u8]) -> PacketCzPartyJoinReqAck {
        PacketCzPartyJoinReqAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            grid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            grid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            b_accept: buffer[6] == 1,
            b_accept_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.grid).unwrap();
        self.grid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.b_accept as u8).unwrap();
        self.b_accept_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzPartyJoinReqAck {
    fn id(&self) -> &str {
       "0x02c7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzPartyConfig {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub b_refuse_join_msg: bool,
    pub b_refuse_join_msg_raw: [u8; 1],
}

impl PacketCzPartyConfig {
    pub fn from(buffer: &[u8]) -> PacketCzPartyConfig {
        PacketCzPartyConfig {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            b_refuse_join_msg: buffer[2] == 1,
            b_refuse_join_msg_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.b_refuse_join_msg as u8).unwrap();
        self.b_refuse_join_msg_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzPartyConfig {
    fn id(&self) -> &str {
       "0x02c8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPartyConfig {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub b_refuse_join_msg: bool,
    pub b_refuse_join_msg_raw: [u8; 1],
}

impl PacketZcPartyConfig {
    pub fn from(buffer: &[u8]) -> PacketZcPartyConfig {
        PacketZcPartyConfig {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            b_refuse_join_msg: buffer[2] == 1,
            b_refuse_join_msg_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.b_refuse_join_msg as u8).unwrap();
        self.b_refuse_join_msg_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcPartyConfig {
    fn id(&self) -> &str {
       "0x02c9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketHcRefuseSelectchar {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub error_code: u8,
    pub error_code_raw: [u8; 1],
}

impl PacketHcRefuseSelectchar {
    pub fn from(buffer: &[u8]) -> PacketHcRefuseSelectchar {
        PacketHcRefuseSelectchar {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: u8::from_le_bytes([buffer[2]]),
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketHcRefuseSelectchar {
    fn id(&self) -> &str {
       "0x02ca"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMemorialdungeonSubscriptionInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub memorial_dungeon_name: [char; 61],
    pub memorial_dungeon_name_raw: [u8; 61],
    pub priority_order_num: i16,
    pub priority_order_num_raw: [u8; 2],
}

impl PacketZcMemorialdungeonSubscriptionInfo {
    pub fn from(buffer: &[u8]) -> PacketZcMemorialdungeonSubscriptionInfo {
        PacketZcMemorialdungeonSubscriptionInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            memorial_dungeon_name:  {
                let mut dst: [char; 61] = [0 as char; 61];
                for (index, byte) in buffer[2..63].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            memorial_dungeon_name_raw: {
                let mut dst: [u8; 61] = [0u8; 61];
                dst.clone_from_slice(&buffer[2..63]);
                dst
            },
            priority_order_num: i16::from_le_bytes([buffer[63], buffer[64]]),
            priority_order_num_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[63..65]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.memorial_dungeon_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.memorial_dungeon_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.priority_order_num).unwrap();
        self.priority_order_num_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMemorialdungeonSubscriptionInfo {
    fn id(&self) -> &str {
       "0x02cb"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMemorialdungeonSubscriptionNotify {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub priority_order_num: i16,
    pub priority_order_num_raw: [u8; 2],
}

impl PacketZcMemorialdungeonSubscriptionNotify {
    pub fn from(buffer: &[u8]) -> PacketZcMemorialdungeonSubscriptionNotify {
        PacketZcMemorialdungeonSubscriptionNotify {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            priority_order_num: i16::from_le_bytes([buffer[2], buffer[3]]),
            priority_order_num_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.priority_order_num).unwrap();
        self.priority_order_num_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMemorialdungeonSubscriptionNotify {
    fn id(&self) -> &str {
       "0x02cc"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMemorialdungeonInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub memorial_dungeon_name: [char; 61],
    pub memorial_dungeon_name_raw: [u8; 61],
    pub destroy_date: u32,
    pub destroy_date_raw: [u8; 4],
    pub enter_time_out_date: u32,
    pub enter_time_out_date_raw: [u8; 4],
}

impl PacketZcMemorialdungeonInfo {
    pub fn from(buffer: &[u8]) -> PacketZcMemorialdungeonInfo {
        PacketZcMemorialdungeonInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            memorial_dungeon_name:  {
                let mut dst: [char; 61] = [0 as char; 61];
                for (index, byte) in buffer[2..63].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            memorial_dungeon_name_raw: {
                let mut dst: [u8; 61] = [0u8; 61];
                dst.clone_from_slice(&buffer[2..63]);
                dst
            },
            destroy_date: u32::from_le_bytes([buffer[63], buffer[64], buffer[65], buffer[66]]),
            destroy_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[63..67]);
                dst
            },
            enter_time_out_date: u32::from_le_bytes([buffer[67], buffer[68], buffer[69], buffer[70]]),
            enter_time_out_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[67..71]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.memorial_dungeon_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.memorial_dungeon_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.destroy_date).unwrap();
        self.destroy_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.enter_time_out_date).unwrap();
        self.enter_time_out_date_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMemorialdungeonInfo {
    fn id(&self) -> &str {
       "0x02cd"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMemorialdungeonNotify {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i32,
    pub atype_raw: [u8; 4],
    pub enter_limit_date: u32,
    pub enter_limit_date_raw: [u8; 4],
}

impl PacketZcMemorialdungeonNotify {
    pub fn from(buffer: &[u8]) -> PacketZcMemorialdungeonNotify {
        PacketZcMemorialdungeonNotify {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            enter_limit_date: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            enter_limit_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.enter_limit_date).unwrap();
        self.enter_limit_date_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMemorialdungeonNotify {
    fn id(&self) -> &str {
       "0x02ce"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzMemorialdungeonCommand {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub command: i32,
    pub command_raw: [u8; 4],
}

impl PacketCzMemorialdungeonCommand {
    pub fn from(buffer: &[u8]) -> PacketCzMemorialdungeonCommand {
        PacketCzMemorialdungeonCommand {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            command: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            command_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.command).unwrap();
        self.command_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzMemorialdungeonCommand {
    fn id(&self) -> &str {
       "0x02cf"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcEquipmentItemlist3 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_info: Vec<EquipmentitemExtrainfo301>,
    pub item_info_raw: Vec<Vec<u8>>,
}

impl PacketZcEquipmentItemlist3 {
    pub fn from(buffer: &[u8]) -> PacketZcEquipmentItemlist3 {
        let iter_count = &buffer.len() / 28;
        let mut vec_field: Vec<EquipmentitemExtrainfo301> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 32 * i;
            vec_field.push(EquipmentitemExtrainfo301::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcEquipmentItemlist3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.serialize());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcEquipmentItemlist3 {
    fn id(&self) -> &str {
       "0x02d0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcStoreEquipmentItemlist3 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_info: Vec<EquipmentitemExtrainfo301>,
    pub item_info_raw: Vec<Vec<u8>>,
}

impl PacketZcStoreEquipmentItemlist3 {
    pub fn from(buffer: &[u8]) -> PacketZcStoreEquipmentItemlist3 {
        let iter_count = &buffer.len() / 28;
        let mut vec_field: Vec<EquipmentitemExtrainfo301> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 32 * i;
            vec_field.push(EquipmentitemExtrainfo301::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcStoreEquipmentItemlist3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.serialize());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcStoreEquipmentItemlist3 {
    fn id(&self) -> &str {
       "0x02d1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcCartEquipmentItemlist3 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_info: Vec<EquipmentitemExtrainfo301>,
    pub item_info_raw: Vec<Vec<u8>>,
}

impl PacketZcCartEquipmentItemlist3 {
    pub fn from(buffer: &[u8]) -> PacketZcCartEquipmentItemlist3 {
        let iter_count = &buffer.len() / 28;
        let mut vec_field: Vec<EquipmentitemExtrainfo301> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 32 * i;
            vec_field.push(EquipmentitemExtrainfo301::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcCartEquipmentItemlist3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.serialize());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcCartEquipmentItemlist3 {
    fn id(&self) -> &str {
       "0x02d2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyBindOnEquip {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: u16,
    pub index_raw: [u8; 2],
}

impl PacketZcNotifyBindOnEquip {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyBindOnEquip {
        PacketZcNotifyBindOnEquip {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyBindOnEquip {
    fn id(&self) -> &str {
       "0x02d3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcItemPickupAck3 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: u16,
    pub index_raw: [u8; 2],
    pub count: u16,
    pub count_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub is_damaged: bool,
    pub is_damaged_raw: [u8; 1],
    pub refining_level: u8,
    pub refining_level_raw: [u8; 1],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
    pub location: u16,
    pub location_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub result: u8,
    pub result_raw: [u8; 1],
    pub hire_expire_date: i32,
    pub hire_expire_date_raw: [u8; 4],
    pub bind_on_equip_type: u16,
    pub bind_on_equip_type_raw: [u8; 2],
}

impl PacketZcItemPickupAck3 {
    pub fn from(buffer: &[u8]) -> PacketZcItemPickupAck3 {
        PacketZcItemPickupAck3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: u16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            itid: u16::from_le_bytes([buffer[6], buffer[7]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            is_identified: buffer[8] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            is_damaged: buffer[9] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[10]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[11..19]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[11..19]);
                dst
            },
            location: u16::from_le_bytes([buffer[19], buffer[20]]),
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            atype: u8::from_le_bytes([buffer[21]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[21..22]);
                dst
            },
            result: u8::from_le_bytes([buffer[22]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[22..23]);
                dst
            },
            hire_expire_date: i32::from_le_bytes([buffer[23], buffer[24], buffer[25], buffer[26]]),
            hire_expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[23..27]);
                dst
            },
            bind_on_equip_type: u16::from_le_bytes([buffer[27], buffer[28]]),
            bind_on_equip_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[27..29]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hire_expire_date).unwrap();
        self.hire_expire_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.bind_on_equip_type).unwrap();
        self.bind_on_equip_type_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcItemPickupAck3 {
    fn id(&self) -> &str {
       "0x02d4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcIsvrDisconnect {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketZcIsvrDisconnect {
    pub fn from(buffer: &[u8]) -> PacketZcIsvrDisconnect {
        PacketZcIsvrDisconnect {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcIsvrDisconnect {
    fn id(&self) -> &str {
       "0x02d5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzEquipwinMicroscope {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketCzEquipwinMicroscope {
    pub fn from(buffer: &[u8]) -> PacketCzEquipwinMicroscope {
        PacketCzEquipwinMicroscope {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzEquipwinMicroscope {
    fn id(&self) -> &str {
       "0x02d6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcEquipwinMicroscope {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub character_name: [char; 24],
    pub character_name_raw: [u8; 24],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub accessory: i16,
    pub accessory_raw: [u8; 2],
    pub accessory2: i16,
    pub accessory2_raw: [u8; 2],
    pub accessory3: i16,
    pub accessory3_raw: [u8; 2],
    pub headpalette: i16,
    pub headpalette_raw: [u8; 2],
    pub bodypalette: i16,
    pub bodypalette_raw: [u8; 2],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub item_info: Vec<EquipmentitemExtrainfo301>,
    pub item_info_raw: Vec<Vec<u8>>,
}

impl PacketZcEquipwinMicroscope {
    pub fn from(buffer: &[u8]) -> PacketZcEquipwinMicroscope {
        let iter_count = &buffer.len() / 28;
        let mut vec_field: Vec<EquipmentitemExtrainfo301> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 43 * i;
            let end_pos = 71 * i;
            vec_field.push(EquipmentitemExtrainfo301::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcEquipwinMicroscope {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
            job: i16::from_le_bytes([buffer[28], buffer[29]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            head: i16::from_le_bytes([buffer[30], buffer[31]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[32], buffer[33]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[34], buffer[35]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[36], buffer[37]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[36..38]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[38], buffer[39]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[38..40]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[40], buffer[41]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            sex: u8::from_le_bytes([buffer[42]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[42..43]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.serialize());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcEquipwinMicroscope {
    fn id(&self) -> &str {
       "0x02d7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzConfig {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub config: i32,
    pub config_raw: [u8; 4],
    pub value: i32,
    pub value_raw: [u8; 4],
}

impl PacketCzConfig {
    pub fn from(buffer: &[u8]) -> PacketCzConfig {
        PacketCzConfig {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            config: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            config_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            value: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.config).unwrap();
        self.config_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzConfig {
    fn id(&self) -> &str {
       "0x02d8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcConfig {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub config: i32,
    pub config_raw: [u8; 4],
    pub value: i32,
    pub value_raw: [u8; 4],
}

impl PacketZcConfig {
    pub fn from(buffer: &[u8]) -> PacketZcConfig {
        PacketZcConfig {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            config: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            config_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            value: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.config).unwrap();
        self.config_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcConfig {
    fn id(&self) -> &str {
       "0x02d9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcConfigNotify {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub b_open_equipment_win: bool,
    pub b_open_equipment_win_raw: [u8; 1],
}

impl PacketZcConfigNotify {
    pub fn from(buffer: &[u8]) -> PacketZcConfigNotify {
        PacketZcConfigNotify {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            b_open_equipment_win: buffer[2] == 1,
            b_open_equipment_win_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.b_open_equipment_win as u8).unwrap();
        self.b_open_equipment_win_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcConfigNotify {
    fn id(&self) -> &str {
       "0x02da"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzBattlefieldChat {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketCzBattlefieldChat {
    pub fn from(buffer: &[u8]) -> PacketCzBattlefieldChat {
        PacketCzBattlefieldChat {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            msg_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketCzBattlefieldChat {
    fn id(&self) -> &str {
       "0x02db"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcBattlefieldChat {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub account_id: u32,
    pub account_id_raw: [u8; 4],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketZcBattlefieldChat {
    pub fn from(buffer: &[u8]) -> PacketZcBattlefieldChat {
        PacketZcBattlefieldChat {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            account_id: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[8..32].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[8..32]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[32..buffer.len()]).to_string(),
            msg_raw: buffer[32..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketZcBattlefieldChat {
    fn id(&self) -> &str {
       "0x02dc"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcBattlefieldNotifyCampinfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub account_id: u32,
    pub account_id_raw: [u8; 4],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
    pub camp: i16,
    pub camp_raw: [u8; 2],
}

impl PacketZcBattlefieldNotifyCampinfo {
    pub fn from(buffer: &[u8]) -> PacketZcBattlefieldNotifyCampinfo {
        PacketZcBattlefieldNotifyCampinfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            account_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            camp: i16::from_le_bytes([buffer[30], buffer[31]]),
            camp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.camp).unwrap();
        self.camp_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcBattlefieldNotifyCampinfo {
    fn id(&self) -> &str {
       "0x02dd"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcBattlefieldNotifyPoint {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub point_camp_a: i16,
    pub point_camp_a_raw: [u8; 2],
    pub point_camp_b: i16,
    pub point_camp_b_raw: [u8; 2],
}

impl PacketZcBattlefieldNotifyPoint {
    pub fn from(buffer: &[u8]) -> PacketZcBattlefieldNotifyPoint {
        PacketZcBattlefieldNotifyPoint {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            point_camp_a: i16::from_le_bytes([buffer[2], buffer[3]]),
            point_camp_a_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            point_camp_b: i16::from_le_bytes([buffer[4], buffer[5]]),
            point_camp_b_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.point_camp_a).unwrap();
        self.point_camp_a_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.point_camp_b).unwrap();
        self.point_camp_b_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcBattlefieldNotifyPoint {
    fn id(&self) -> &str {
       "0x02de"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcBattlefieldNotifyPosition {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub account_id: u32,
    pub account_id_raw: [u8; 4],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
    pub job: u16,
    pub job_raw: [u8; 2],
    pub x: i16,
    pub x_raw: [u8; 2],
    pub y: i16,
    pub y_raw: [u8; 2],
}

impl PacketZcBattlefieldNotifyPosition {
    pub fn from(buffer: &[u8]) -> PacketZcBattlefieldNotifyPosition {
        PacketZcBattlefieldNotifyPosition {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            account_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            job: u16::from_le_bytes([buffer[30], buffer[31]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            x: i16::from_le_bytes([buffer[32], buffer[33]]),
            x_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            y: i16::from_le_bytes([buffer[34], buffer[35]]),
            y_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x).unwrap();
        self.x_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y).unwrap();
        self.y_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcBattlefieldNotifyPosition {
    fn id(&self) -> &str {
       "0x02df"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcBattlefieldNotifyHp {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub account_id: u32,
    pub account_id_raw: [u8; 4],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
    pub hp: i16,
    pub hp_raw: [u8; 2],
    pub max_hp: i16,
    pub max_hp_raw: [u8; 2],
}

impl PacketZcBattlefieldNotifyHp {
    pub fn from(buffer: &[u8]) -> PacketZcBattlefieldNotifyHp {
        PacketZcBattlefieldNotifyHp {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            account_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
            hp: i16::from_le_bytes([buffer[30], buffer[31]]),
            hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            max_hp: i16::from_le_bytes([buffer[32], buffer[33]]),
            max_hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcBattlefieldNotifyHp {
    fn id(&self) -> &str {
       "0x02e0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyAct2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub target_gid: u32,
    pub target_gid_raw: [u8; 4],
    pub start_time: u32,
    pub start_time_raw: [u8; 4],
    pub attack_mt: i32,
    pub attack_mt_raw: [u8; 4],
    pub attacked_mt: i32,
    pub attacked_mt_raw: [u8; 4],
    pub damage: i32,
    pub damage_raw: [u8; 4],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub action: u8,
    pub action_raw: [u8; 1],
    pub left_damage: i32,
    pub left_damage_raw: [u8; 4],
}

impl PacketZcNotifyAct2 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyAct2 {
        PacketZcNotifyAct2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            target_gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            start_time: u32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            attack_mt: i32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            attack_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
            attacked_mt: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            attacked_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
            damage: i32::from_le_bytes([buffer[22], buffer[23], buffer[24], buffer[25]]),
            damage_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[22..26]);
                dst
            },
            count: i16::from_le_bytes([buffer[26], buffer[27]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            action: u8::from_le_bytes([buffer[28]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[28..29]);
                dst
            },
            left_damage: i32::from_le_bytes([buffer[29], buffer[30], buffer[31], buffer[32]]),
            left_damage_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[29..33]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_gid).unwrap();
        self.target_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attack_mt).unwrap();
        self.attack_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attacked_mt).unwrap();
        self.attacked_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.damage).unwrap();
        self.damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.left_damage).unwrap();
        self.left_damage_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyAct2 {
    fn id(&self) -> &str {
       "0x02e1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzBotCheck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub is_bot: i32,
    pub is_bot_raw: [u8; 4],
}

impl PacketCzBotCheck {
    pub fn from(buffer: &[u8]) -> PacketCzBotCheck {
        PacketCzBotCheck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            is_bot: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            is_bot_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.is_bot).unwrap();
        self.is_bot_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzBotCheck {
    fn id(&self) -> &str {
       "0x02e6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMapproperty {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub atype: i16,
    pub atype_raw: [u8; 2],
    pub map_info_table: Vec<u8>,
    pub map_info_table_raw: Vec<u8>,
}

impl PacketZcMapproperty {
    pub fn from(buffer: &[u8]) -> PacketZcMapproperty {
        PacketZcMapproperty {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: i16::from_le_bytes([buffer[4], buffer[5]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            map_info_table:  {
                let dst: Vec<u8> = buffer[6..buffer.len()].to_vec();
                dst
            },
            map_info_table_raw: buffer[6..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcMapproperty {
    fn id(&self) -> &str {
       "0x02e7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNormalItemlist3 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_info: Vec<NormalitemExtrainfo3>,
    pub item_info_raw: Vec<Vec<u8>>,
}

impl PacketZcNormalItemlist3 {
    pub fn from(buffer: &[u8]) -> PacketZcNormalItemlist3 {
        let iter_count = &buffer.len() / 22;
        let mut vec_field: Vec<NormalitemExtrainfo3> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 26 * i;
            vec_field.push(NormalitemExtrainfo3::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcNormalItemlist3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.serialize());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcNormalItemlist3 {
    fn id(&self) -> &str {
       "0x02e8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcCartNormalItemlist3 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_info: Vec<NormalitemExtrainfo3>,
    pub item_info_raw: Vec<Vec<u8>>,
}

impl PacketZcCartNormalItemlist3 {
    pub fn from(buffer: &[u8]) -> PacketZcCartNormalItemlist3 {
        let iter_count = &buffer.len() / 22;
        let mut vec_field: Vec<NormalitemExtrainfo3> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 26 * i;
            vec_field.push(NormalitemExtrainfo3::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcCartNormalItemlist3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.serialize());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcCartNormalItemlist3 {
    fn id(&self) -> &str {
       "0x02e9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcStoreNormalItemlist3 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub item_info: Vec<NormalitemExtrainfo3>,
    pub item_info_raw: Vec<Vec<u8>>,
}

impl PacketZcStoreNormalItemlist3 {
    pub fn from(buffer: &[u8]) -> PacketZcStoreNormalItemlist3 {
        let iter_count = &buffer.len() / 22;
        let mut vec_field: Vec<NormalitemExtrainfo3> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 26 * i;
            vec_field.push(NormalitemExtrainfo3::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcStoreNormalItemlist3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            item_info: vec_field.clone(),
            item_info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.serialize());
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcStoreNormalItemlist3 {
    fn id(&self) -> &str {
       "0x02ea"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAcceptEnter2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub start_time: u32,
    pub start_time_raw: [u8; 4],
    pub pos_dir: [char; 3],
    pub pos_dir_raw: [u8; 3],
    pub x_size: u8,
    pub x_size_raw: [u8; 1],
    pub y_size: u8,
    pub y_size_raw: [u8; 1],
    pub font: i16,
    pub font_raw: [u8; 2],
}

impl PacketZcAcceptEnter2 {
    pub fn from(buffer: &[u8]) -> PacketZcAcceptEnter2 {
        PacketZcAcceptEnter2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            start_time: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[6..9].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[6..9]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[9]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[10]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            font: i16::from_le_bytes([buffer[11], buffer[12]]),
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAcceptEnter2 {
    fn id(&self) -> &str {
       "0x02eb"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyMoveentry4 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub objecttype: u8,
    pub objecttype_raw: [u8; 1],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub speed: i16,
    pub speed_raw: [u8; 2],
    pub body_state: i16,
    pub body_state_raw: [u8; 2],
    pub health_state: i16,
    pub health_state_raw: [u8; 2],
    pub effect_state: i32,
    pub effect_state_raw: [u8; 4],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub weapon: i32,
    pub weapon_raw: [u8; 4],
    pub accessory: i16,
    pub accessory_raw: [u8; 2],
    pub move_start_time: u32,
    pub move_start_time_raw: [u8; 4],
    pub accessory2: i16,
    pub accessory2_raw: [u8; 2],
    pub accessory3: i16,
    pub accessory3_raw: [u8; 2],
    pub headpalette: i16,
    pub headpalette_raw: [u8; 2],
    pub bodypalette: i16,
    pub bodypalette_raw: [u8; 2],
    pub head_dir: i16,
    pub head_dir_raw: [u8; 2],
    pub guid: u32,
    pub guid_raw: [u8; 4],
    pub gemblem_ver: i16,
    pub gemblem_ver_raw: [u8; 2],
    pub honor: i16,
    pub honor_raw: [u8; 2],
    pub virtue: i32,
    pub virtue_raw: [u8; 4],
    pub is_pkmode_on: bool,
    pub is_pkmode_on_raw: [u8; 1],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub move_data: [u16; 6],
    pub move_data_raw: [u8; 6],
    pub x_size: u8,
    pub x_size_raw: [u8; 1],
    pub y_size: u8,
    pub y_size_raw: [u8; 1],
    pub clevel: i16,
    pub clevel_raw: [u8; 2],
    pub font: i16,
    pub font_raw: [u8; 2],
}

impl PacketZcNotifyMoveentry4 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMoveentry4 {
        PacketZcNotifyMoveentry4 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            objecttype: u8::from_le_bytes([buffer[2]]),
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            gid: u32::from_le_bytes([buffer[3], buffer[4], buffer[5], buffer[6]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[3..7]);
                dst
            },
            speed: i16::from_le_bytes([buffer[7], buffer[8]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[7..9]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[9], buffer[10]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[11], buffer[12]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[13], buffer[14], buffer[15], buffer[16]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[13..17]);
                dst
            },
            job: i16::from_le_bytes([buffer[17], buffer[18]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[17..19]);
                dst
            },
            head: i16::from_le_bytes([buffer[19], buffer[20]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[21], buffer[22], buffer[23], buffer[24]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[21..25]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[25], buffer[26]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[25..27]);
                dst
            },
            move_start_time: u32::from_le_bytes([buffer[27], buffer[28], buffer[29], buffer[30]]),
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[27..31]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[31], buffer[32]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[31..33]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[33], buffer[34]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[35], buffer[36]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[35..37]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[37], buffer[38]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[37..39]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[39], buffer[40]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[39..41]);
                dst
            },
            guid: u32::from_le_bytes([buffer[41], buffer[42], buffer[43], buffer[44]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[41..45]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[45], buffer[46]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[45..47]);
                dst
            },
            honor: i16::from_le_bytes([buffer[47], buffer[48]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[47..49]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[49], buffer[50], buffer[51], buffer[52]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[49..53]);
                dst
            },
            is_pkmode_on: buffer[53] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[53..54]);
                dst
            },
            sex: u8::from_le_bytes([buffer[54]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[54..55]);
                dst
            },
            move_data:  {
                let mut dst: [u16; 6] = [0 as u16; 6];
                for (index, byte) in buffer[55..61].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            },
            move_data_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[55..61]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[61]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[61..62]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[62]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[62..63]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[63], buffer[64]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[63..65]);
                dst
            },
            font: i16::from_le_bytes([buffer[65], buffer[66]]),
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[65..67]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyMoveentry4 {
    fn id(&self) -> &str {
       "0x02ec"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyNewentry4 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub speed: i16,
    pub speed_raw: [u8; 2],
    pub body_state: i16,
    pub body_state_raw: [u8; 2],
    pub health_state: i16,
    pub health_state_raw: [u8; 2],
    pub effect_state: i32,
    pub effect_state_raw: [u8; 4],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub weapon: i32,
    pub weapon_raw: [u8; 4],
    pub accessory: i16,
    pub accessory_raw: [u8; 2],
    pub accessory2: i16,
    pub accessory2_raw: [u8; 2],
    pub accessory3: i16,
    pub accessory3_raw: [u8; 2],
    pub headpalette: i16,
    pub headpalette_raw: [u8; 2],
    pub bodypalette: i16,
    pub bodypalette_raw: [u8; 2],
    pub head_dir: i16,
    pub head_dir_raw: [u8; 2],
    pub guid: u32,
    pub guid_raw: [u8; 4],
    pub gemblem_ver: i16,
    pub gemblem_ver_raw: [u8; 2],
    pub honor: i16,
    pub honor_raw: [u8; 2],
    pub virtue: i32,
    pub virtue_raw: [u8; 4],
    pub is_pkmode_on: bool,
    pub is_pkmode_on_raw: [u8; 1],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub pos_dir: [char; 3],
    pub pos_dir_raw: [u8; 3],
    pub x_size: u8,
    pub x_size_raw: [u8; 1],
    pub y_size: u8,
    pub y_size_raw: [u8; 1],
    pub clevel: i16,
    pub clevel_raw: [u8; 2],
    pub font: i16,
    pub font_raw: [u8; 2],
}

impl PacketZcNotifyNewentry4 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyNewentry4 {
        PacketZcNotifyNewentry4 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            job: i16::from_le_bytes([buffer[16], buffer[17]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            head: i16::from_le_bytes([buffer[18], buffer[19]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[24], buffer[25]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[26], buffer[27]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[28], buffer[29]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[30], buffer[31]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[32], buffer[33]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[34], buffer[35]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            guid: u32::from_le_bytes([buffer[36], buffer[37], buffer[38], buffer[39]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[36..40]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[40], buffer[41]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            honor: i16::from_le_bytes([buffer[42], buffer[43]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[44], buffer[45], buffer[46], buffer[47]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[44..48]);
                dst
            },
            is_pkmode_on: buffer[48] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[48..49]);
                dst
            },
            sex: u8::from_le_bytes([buffer[49]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[50..53].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[50..53]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[53]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[53..54]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[54]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[54..55]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[55], buffer[56]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[55..57]);
                dst
            },
            font: i16::from_le_bytes([buffer[57], buffer[58]]),
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[57..59]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyNewentry4 {
    fn id(&self) -> &str {
       "0x02ed"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyStandentry4 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub speed: i16,
    pub speed_raw: [u8; 2],
    pub body_state: i16,
    pub body_state_raw: [u8; 2],
    pub health_state: i16,
    pub health_state_raw: [u8; 2],
    pub effect_state: i32,
    pub effect_state_raw: [u8; 4],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub weapon: i32,
    pub weapon_raw: [u8; 4],
    pub accessory: i16,
    pub accessory_raw: [u8; 2],
    pub accessory2: i16,
    pub accessory2_raw: [u8; 2],
    pub accessory3: i16,
    pub accessory3_raw: [u8; 2],
    pub headpalette: i16,
    pub headpalette_raw: [u8; 2],
    pub bodypalette: i16,
    pub bodypalette_raw: [u8; 2],
    pub head_dir: i16,
    pub head_dir_raw: [u8; 2],
    pub guid: u32,
    pub guid_raw: [u8; 4],
    pub gemblem_ver: i16,
    pub gemblem_ver_raw: [u8; 2],
    pub honor: i16,
    pub honor_raw: [u8; 2],
    pub virtue: i32,
    pub virtue_raw: [u8; 4],
    pub is_pkmode_on: bool,
    pub is_pkmode_on_raw: [u8; 1],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub pos_dir: [char; 3],
    pub pos_dir_raw: [u8; 3],
    pub x_size: u8,
    pub x_size_raw: [u8; 1],
    pub y_size: u8,
    pub y_size_raw: [u8; 1],
    pub state: u8,
    pub state_raw: [u8; 1],
    pub clevel: i16,
    pub clevel_raw: [u8; 2],
    pub font: i16,
    pub font_raw: [u8; 2],
}

impl PacketZcNotifyStandentry4 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyStandentry4 {
        PacketZcNotifyStandentry4 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            speed: i16::from_le_bytes([buffer[6], buffer[7]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[10], buffer[11]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            job: i16::from_le_bytes([buffer[16], buffer[17]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            head: i16::from_le_bytes([buffer[18], buffer[19]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[18..20]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[24], buffer[25]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[26], buffer[27]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[28], buffer[29]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[30], buffer[31]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[32], buffer[33]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[32..34]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[34], buffer[35]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            guid: u32::from_le_bytes([buffer[36], buffer[37], buffer[38], buffer[39]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[36..40]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[40], buffer[41]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            honor: i16::from_le_bytes([buffer[42], buffer[43]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[42..44]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[44], buffer[45], buffer[46], buffer[47]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[44..48]);
                dst
            },
            is_pkmode_on: buffer[48] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[48..49]);
                dst
            },
            sex: u8::from_le_bytes([buffer[49]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[49..50]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[50..53].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[50..53]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[53]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[53..54]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[54]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[54..55]);
                dst
            },
            state: u8::from_le_bytes([buffer[55]]),
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[55..56]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[56], buffer[57]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[56..58]);
                dst
            },
            font: i16::from_le_bytes([buffer[58], buffer[59]]),
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[58..60]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyStandentry4 {
    fn id(&self) -> &str {
       "0x02ee"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyFont {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub font: i16,
    pub font_raw: [u8; 2],
}

impl PacketZcNotifyFont {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyFont {
        PacketZcNotifyFont {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            font: i16::from_le_bytes([buffer[6], buffer[7]]),
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyFont {
    fn id(&self) -> &str {
       "0x02ef"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcProgress {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub color: u32,
    pub color_raw: [u8; 4],
    pub time: u32,
    pub time_raw: [u8; 4],
}

impl PacketZcProgress {
    pub fn from(buffer: &[u8]) -> PacketZcProgress {
        PacketZcProgress {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            color: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            color_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            time: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.color).unwrap();
        self.color_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.time).unwrap();
        self.time_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcProgress {
    fn id(&self) -> &str {
       "0x02f0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzProgress {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzProgress {
    pub fn from(buffer: &[u8]) -> PacketCzProgress {
        PacketCzProgress {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzProgress {
    fn id(&self) -> &str {
       "0x02f1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcProgressCancel {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketZcProgressCancel {
    pub fn from(buffer: &[u8]) -> PacketZcProgressCancel {
        PacketZcProgressCancel {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcProgressCancel {
    fn id(&self) -> &str {
       "0x02f2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzOpenSimpleCashshopItemlist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzOpenSimpleCashshopItemlist {
    pub fn from(buffer: &[u8]) -> PacketCzOpenSimpleCashshopItemlist {
        PacketCzOpenSimpleCashshopItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzOpenSimpleCashshopItemlist {
    fn id(&self) -> &str {
       "0x035c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSimpleCashshopPointItemlist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub cash_point: u32,
    pub cash_point_raw: [u8; 4],
    pub md_itemcount: i16,
    pub md_itemcount_raw: [u8; 2],
    pub md_item_size: i16,
    pub md_item_size_raw: [u8; 2],
    pub best_itemcount: i16,
    pub best_itemcount_raw: [u8; 2],
    pub best_itemsize: i16,
    pub best_itemsize_raw: [u8; 2],
    pub item_list: Vec<PurchaseItem>,
    pub item_list_raw: Vec<Vec<u8>>,
}

impl PacketZcSimpleCashshopPointItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcSimpleCashshopPointItemlist {
        let iter_count = &buffer.len() / 11;
        let mut vec_field: Vec<PurchaseItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 16 * i;
            let end_pos = 27 * i;
            vec_field.push(PurchaseItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcSimpleCashshopPointItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            cash_point: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            cash_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            md_itemcount: i16::from_le_bytes([buffer[8], buffer[9]]),
            md_itemcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            md_item_size: i16::from_le_bytes([buffer[10], buffer[11]]),
            md_item_size_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            best_itemcount: i16::from_le_bytes([buffer[12], buffer[13]]),
            best_itemcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            best_itemsize: i16::from_le_bytes([buffer[14], buffer[15]]),
            best_itemsize_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.cash_point).unwrap();
        self.cash_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.md_itemcount).unwrap();
        self.md_itemcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.md_item_size).unwrap();
        self.md_item_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.best_itemcount).unwrap();
        self.best_itemcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.best_itemsize).unwrap();
        self.best_itemsize_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.serialize());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcSimpleCashshopPointItemlist {
    fn id(&self) -> &str {
       "0x035d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzCloseWindow {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzCloseWindow {
    pub fn from(buffer: &[u8]) -> PacketCzCloseWindow {
        PacketCzCloseWindow {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzCloseWindow {
    fn id(&self) -> &str {
       "0x035e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAhcGameGuard {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub auth_data: [u32; 4],
    pub auth_data_raw: [u8; 4],
}

impl PacketAhcGameGuard {
    pub fn from(buffer: &[u8]) -> PacketAhcGameGuard {
        PacketAhcGameGuard {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            auth_data:  {
                let mut dst: [u32; 4] = [0 as u32; 4];
                for (index, byte) in buffer[2..6].iter().enumerate() {
                    dst[index] = *byte as u32;
                }
                dst
            },
            auth_data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.auth_data {
            wtr.write_u32::<LittleEndian>(item).unwrap();
        }
        self.auth_data_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAhcGameGuard {
    fn id(&self) -> &str {
       "0x03dd"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCahAckGameGuard {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub auth_data: [u32; 4],
    pub auth_data_raw: [u8; 4],
}

impl PacketCahAckGameGuard {
    pub fn from(buffer: &[u8]) -> PacketCahAckGameGuard {
        PacketCahAckGameGuard {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            auth_data:  {
                let mut dst: [u32; 4] = [0 as u32; 4];
                for (index, byte) in buffer[2..6].iter().enumerate() {
                    dst[index] = *byte as u32;
                }
                dst
            },
            auth_data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.auth_data {
            wtr.write_u32::<LittleEndian>(item).unwrap();
        }
        self.auth_data_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCahAckGameGuard {
    fn id(&self) -> &str {
       "0x03de"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzEnter2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub auth_code: i32,
    pub auth_code_raw: [u8; 4],
    pub client_time: u32,
    pub client_time_raw: [u8; 4],
    pub sex: u8,
    pub sex_raw: [u8; 1],
}

impl PacketCzEnter2 {
    pub fn from(buffer: &[u8]) -> PacketCzEnter2 {
        PacketCzEnter2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            gid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            auth_code: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            client_time: u32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            client_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
            sex: u8::from_le_bytes([buffer[18]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[18..19]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.client_time).unwrap();
        self.client_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzEnter2 {
    fn id(&self) -> &str {
       "0x0436"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRequestAct2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub target_gid: u32,
    pub target_gid_raw: [u8; 4],
    pub action: u8,
    pub action_raw: [u8; 1],
}

impl PacketCzRequestAct2 {
    pub fn from(buffer: &[u8]) -> PacketCzRequestAct2 {
        PacketCzRequestAct2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            target_gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            target_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            action: u8::from_le_bytes([buffer[6]]),
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_gid).unwrap();
        self.target_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzRequestAct2 {
    fn id(&self) -> &str {
       "0x0437"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzUseSkill2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub selected_level: i16,
    pub selected_level_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub target_id: u32,
    pub target_id_raw: [u8; 4],
}

impl PacketCzUseSkill2 {
    pub fn from(buffer: &[u8]) -> PacketCzUseSkill2 {
        PacketCzUseSkill2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            selected_level: i16::from_le_bytes([buffer[2], buffer[3]]),
            selected_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            skid: u16::from_le_bytes([buffer[4], buffer[5]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            target_id: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.selected_level).unwrap();
        self.selected_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzUseSkill2 {
    fn id(&self) -> &str {
       "0x0438"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzUseItem2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: u16,
    pub index_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketCzUseItem2 {
    pub fn from(buffer: &[u8]) -> PacketCzUseItem2 {
        PacketCzUseItem2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzUseItem2 {
    fn id(&self) -> &str {
       "0x0439"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSkillPostdelay {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub delay_tm: u32,
    pub delay_tm_raw: [u8; 4],
}

impl PacketZcSkillPostdelay {
    pub fn from(buffer: &[u8]) -> PacketZcSkillPostdelay {
        PacketZcSkillPostdelay {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            delay_tm: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            delay_tm_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.delay_tm).unwrap();
        self.delay_tm_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSkillPostdelay {
    fn id(&self) -> &str {
       "0x043d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSkillPostdelayList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub delay_list: Vec<SkillPostdelay>,
    pub delay_list_raw: Vec<Vec<u8>>,
}

impl PacketZcSkillPostdelayList {
    pub fn from(buffer: &[u8]) -> PacketZcSkillPostdelayList {
        let iter_count = &buffer.len() / 6;
        let mut vec_field: Vec<SkillPostdelay> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 10 * i;
            vec_field.push(SkillPostdelay::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcSkillPostdelayList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            delay_list: vec_field.clone(),
            delay_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.delay_list_raw = {
            self.delay_list.iter_mut().for_each(|item| item.serialize());
            self.delay_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcSkillPostdelayList {
    fn id(&self) -> &str {
       "0x043e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMsgStateChange2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub state: bool,
    pub state_raw: [u8; 1],
    pub remain_ms: u32,
    pub remain_ms_raw: [u8; 4],
    pub val: [i32; 3],
    pub val_raw: [u8; 3],
}

impl PacketZcMsgStateChange2 {
    pub fn from(buffer: &[u8]) -> PacketZcMsgStateChange2 {
        PacketZcMsgStateChange2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            state: buffer[8] == 1,
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            remain_ms: u32::from_le_bytes([buffer[9], buffer[10], buffer[11], buffer[12]]),
            remain_ms_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[9..13]);
                dst
            },
            val:  {
                let mut dst: [i32; 3] = [0 as i32; 3];
                for (index, byte) in buffer[13..16].iter().enumerate() {
                    dst[index] = *byte as i32;
                }
                dst
            },
            val_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[13..16]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state as u8).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.remain_ms).unwrap();
        self.remain_ms_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.val {
            wtr.write_i32::<LittleEndian>(item).unwrap();
        }
        self.val_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMsgStateChange2 {
    fn id(&self) -> &str {
       "0x043f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMillenniumshield {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub num: i16,
    pub num_raw: [u8; 2],
    pub state: i16,
    pub state_raw: [u8; 2],
}

impl PacketZcMillenniumshield {
    pub fn from(buffer: &[u8]) -> PacketZcMillenniumshield {
        PacketZcMillenniumshield {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            num: i16::from_le_bytes([buffer[6], buffer[7]]),
            num_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            state: i16::from_le_bytes([buffer[8], buffer[9]]),
            state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.num).unwrap();
        self.num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMillenniumshield {
    fn id(&self) -> &str {
       "0x0440"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSkillinfoDelete {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
}

impl PacketZcSkillinfoDelete {
    pub fn from(buffer: &[u8]) -> PacketZcSkillinfoDelete {
        PacketZcSkillinfoDelete {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSkillinfoDelete {
    fn id(&self) -> &str {
       "0x0441"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSkillSelectRequest {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub why: i32,
    pub why_raw: [u8; 4],
    pub skidlist: Vec<u8>,
    pub skidlist_raw: Vec<u8>,
}

impl PacketZcSkillSelectRequest {
    pub fn from(buffer: &[u8]) -> PacketZcSkillSelectRequest {
        PacketZcSkillSelectRequest {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            why: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            why_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            skidlist:  {
                let dst: Vec<u8> = buffer[8..buffer.len()].to_vec();
                dst
            },
            skidlist_raw: buffer[8..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.why).unwrap();
        self.why_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcSkillSelectRequest {
    fn id(&self) -> &str {
       "0x0442"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzSkillSelectResponse {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub why: i32,
    pub why_raw: [u8; 4],
    pub skid: u16,
    pub skid_raw: [u8; 2],
}

impl PacketCzSkillSelectResponse {
    pub fn from(buffer: &[u8]) -> PacketCzSkillSelectResponse {
        PacketCzSkillSelectResponse {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            why: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            why_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            skid: u16::from_le_bytes([buffer[6], buffer[7]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.why).unwrap();
        self.why_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzSkillSelectResponse {
    fn id(&self) -> &str {
       "0x0443"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSimpleCashPointItemlist {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub cash_point: u32,
    pub cash_point_raw: [u8; 4],
    pub item_list: Vec<PurchaseItem>,
    pub item_list_raw: Vec<Vec<u8>>,
}

impl PacketZcSimpleCashPointItemlist {
    pub fn from(buffer: &[u8]) -> PacketZcSimpleCashPointItemlist {
        let iter_count = &buffer.len() / 11;
        let mut vec_field: Vec<PurchaseItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 * i;
            let end_pos = 19 * i;
            vec_field.push(PurchaseItem::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcSimpleCashPointItemlist {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            cash_point: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            cash_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.cash_point).unwrap();
        self.cash_point_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.serialize());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcSimpleCashPointItemlist {
    fn id(&self) -> &str {
       "0x0444"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzSimpleBuyCashPointItem {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
}

impl PacketCzSimpleBuyCashPointItem {
    pub fn from(buffer: &[u8]) -> PacketCzSimpleBuyCashPointItem {
        PacketCzSimpleBuyCashPointItem {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzSimpleBuyCashPointItem {
    fn id(&self) -> &str {
       "0x0445"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcQuestNotifyEffect {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub npc_id: u32,
    pub npc_id_raw: [u8; 4],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
    pub effect: i16,
    pub effect_raw: [u8; 2],
    pub atype: i16,
    pub atype_raw: [u8; 2],
}

impl PacketZcQuestNotifyEffect {
    pub fn from(buffer: &[u8]) -> PacketZcQuestNotifyEffect {
        PacketZcQuestNotifyEffect {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            npc_id: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            npc_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[6], buffer[7]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[8], buffer[9]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            effect: i16::from_le_bytes([buffer[10], buffer[11]]),
            effect_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            atype: i16::from_le_bytes([buffer[12], buffer[13]]),
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.npc_id).unwrap();
        self.npc_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect).unwrap();
        self.effect_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcQuestNotifyEffect {
    fn id(&self) -> &str {
       "0x0446"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzBlockingPlayCancel {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzBlockingPlayCancel {
    pub fn from(buffer: &[u8]) -> PacketCzBlockingPlayCancel {
        PacketCzBlockingPlayCancel {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzBlockingPlayCancel {
    fn id(&self) -> &str {
       "0x0447"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketHcCharacterList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub character_list: Vec<CharacterList>,
    pub character_list_raw: Vec<Vec<u8>>,
}

impl PacketHcCharacterList {
    pub fn from(buffer: &[u8]) -> PacketHcCharacterList {
        let iter_count = &buffer.len() / 5;
        let mut vec_field: Vec<CharacterList> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 * i;
            let end_pos = 9 * i;
            vec_field.push(CharacterList::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketHcCharacterList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            character_list: vec_field.clone(),
            character_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.character_list_raw = {
            self.character_list.iter_mut().for_each(|item| item.serialize());
            self.character_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketHcCharacterList {
    fn id(&self) -> &str {
       "0x0448"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcHackshErrorMsg {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub error_id: i16,
    pub error_id_raw: [u8; 2],
}

impl PacketZcHackshErrorMsg {
    pub fn from(buffer: &[u8]) -> PacketZcHackshErrorMsg {
        PacketZcHackshErrorMsg {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_id: i16::from_le_bytes([buffer[2], buffer[3]]),
            error_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_id).unwrap();
        self.error_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcHackshErrorMsg {
    fn id(&self) -> &str {
       "0x0449"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzClientVersion {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub client_ver: i32,
    pub client_ver_raw: [u8; 4],
}

impl PacketCzClientVersion {
    pub fn from(buffer: &[u8]) -> PacketCzClientVersion {
        PacketCzClientVersion {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            client_ver: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            client_ver_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.client_ver).unwrap();
        self.client_ver_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzClientVersion {
    fn id(&self) -> &str {
       "0x044a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzCloseSimplecashShop {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzCloseSimplecashShop {
    pub fn from(buffer: &[u8]) -> PacketCzCloseSimplecashShop {
        PacketCzCloseSimplecashShop {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzCloseSimplecashShop {
    fn id(&self) -> &str {
       "0x044b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcEsResult {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub es_no: i16,
    pub es_no_raw: [u8; 2],
    pub es_msg: i16,
    pub es_msg_raw: [u8; 2],
}

impl PacketZcEsResult {
    pub fn from(buffer: &[u8]) -> PacketZcEsResult {
        PacketZcEsResult {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            es_no: i16::from_le_bytes([buffer[2], buffer[3]]),
            es_no_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            es_msg: i16::from_le_bytes([buffer[4], buffer[5]]),
            es_msg_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_no).unwrap();
        self.es_no_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_msg).unwrap();
        self.es_msg_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcEsResult {
    fn id(&self) -> &str {
       "0x07d0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzEsGetList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzEsGetList {
    pub fn from(buffer: &[u8]) -> PacketCzEsGetList {
        PacketCzEsGetList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzEsGetList {
    fn id(&self) -> &str {
       "0x07d1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcEsList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
}

impl PacketZcEsList {
    pub fn from(buffer: &[u8]) -> PacketZcEsList {
        PacketZcEsList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcEsList {
    fn id(&self) -> &str {
       "0x07d2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzEsChoose {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub es_no: i16,
    pub es_no_raw: [u8; 2],
}

impl PacketCzEsChoose {
    pub fn from(buffer: &[u8]) -> PacketCzEsChoose {
        PacketCzEsChoose {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            es_no: i16::from_le_bytes([buffer[2], buffer[3]]),
            es_no_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_no).unwrap();
        self.es_no_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzEsChoose {
    fn id(&self) -> &str {
       "0x07d3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzEsCancel {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub es_no: i16,
    pub es_no_raw: [u8; 2],
}

impl PacketCzEsCancel {
    pub fn from(buffer: &[u8]) -> PacketCzEsCancel {
        PacketCzEsCancel {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            es_no: i16::from_le_bytes([buffer[2], buffer[3]]),
            es_no_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_no).unwrap();
        self.es_no_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzEsCancel {
    fn id(&self) -> &str {
       "0x07d4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcEsReady {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub es_no: i16,
    pub es_no_raw: [u8; 2],
}

impl PacketZcEsReady {
    pub fn from(buffer: &[u8]) -> PacketZcEsReady {
        PacketZcEsReady {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            es_no: i16::from_le_bytes([buffer[2], buffer[3]]),
            es_no_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_no).unwrap();
        self.es_no_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcEsReady {
    fn id(&self) -> &str {
       "0x07d5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcEsGoto {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub es_no: i16,
    pub es_no_raw: [u8; 2],
}

impl PacketZcEsGoto {
    pub fn from(buffer: &[u8]) -> PacketZcEsGoto {
        PacketZcEsGoto {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            es_no: i16::from_le_bytes([buffer[2], buffer[3]]),
            es_no_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_no).unwrap();
        self.es_no_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcEsGoto {
    fn id(&self) -> &str {
       "0x07d6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzGroupinfoChangeV2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub exp_option: u32,
    pub exp_option_raw: [u8; 4],
    pub item_pickup_rule: u8,
    pub item_pickup_rule_raw: [u8; 1],
    pub item_division_rule: u8,
    pub item_division_rule_raw: [u8; 1],
}

impl PacketCzGroupinfoChangeV2 {
    pub fn from(buffer: &[u8]) -> PacketCzGroupinfoChangeV2 {
        PacketCzGroupinfoChangeV2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            exp_option: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            exp_option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            item_pickup_rule: u8::from_le_bytes([buffer[6]]),
            item_pickup_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            item_division_rule: u8::from_le_bytes([buffer[7]]),
            item_division_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[7..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.exp_option).unwrap();
        self.exp_option_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_pickup_rule).unwrap();
        self.item_pickup_rule_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_division_rule).unwrap();
        self.item_division_rule_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzGroupinfoChangeV2 {
    fn id(&self) -> &str {
       "0x07d7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcReqGroupinfoChangeV2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub exp_option: u32,
    pub exp_option_raw: [u8; 4],
    pub item_pickup_rule: u8,
    pub item_pickup_rule_raw: [u8; 1],
    pub item_division_rule: u8,
    pub item_division_rule_raw: [u8; 1],
}

impl PacketZcReqGroupinfoChangeV2 {
    pub fn from(buffer: &[u8]) -> PacketZcReqGroupinfoChangeV2 {
        PacketZcReqGroupinfoChangeV2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            exp_option: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            exp_option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            item_pickup_rule: u8::from_le_bytes([buffer[6]]),
            item_pickup_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            item_division_rule: u8::from_le_bytes([buffer[7]]),
            item_division_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[7..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.exp_option).unwrap();
        self.exp_option_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_pickup_rule).unwrap();
        self.item_pickup_rule_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_division_rule).unwrap();
        self.item_division_rule_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcReqGroupinfoChangeV2 {
    fn id(&self) -> &str {
       "0x07d8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcShortcutKeyListV2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub short_cut_key: Vec<ShortCutKey>,
    pub short_cut_key_raw: Vec<Vec<u8>>,
}

impl PacketZcShortcutKeyListV2 {
    pub fn from(buffer: &[u8]) -> PacketZcShortcutKeyListV2 {
        let iter_count = &buffer.len() / 7;
        let mut vec_field: Vec<ShortCutKey> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 2 * i;
            let end_pos = 9 * i;
            vec_field.push(ShortCutKey::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcShortcutKeyListV2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            short_cut_key: vec_field.clone(),
            short_cut_key_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.short_cut_key_raw = {
            self.short_cut_key.iter_mut().for_each(|item| item.serialize());
            self.short_cut_key.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcShortcutKeyListV2 {
    fn id(&self) -> &str {
       "0x07d9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzChangeGroupMaster {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
}

impl PacketCzChangeGroupMaster {
    pub fn from(buffer: &[u8]) -> PacketCzChangeGroupMaster {
        PacketCzChangeGroupMaster {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzChangeGroupMaster {
    fn id(&self) -> &str {
       "0x07da"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcHoParChange {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub var: u16,
    pub var_raw: [u8; 2],
    pub value: i32,
    pub value_raw: [u8; 4],
}

impl PacketZcHoParChange {
    pub fn from(buffer: &[u8]) -> PacketZcHoParChange {
        PacketZcHoParChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            var: u16::from_le_bytes([buffer[2], buffer[3]]),
            var_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            value: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var).unwrap();
        self.var_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcHoParChange {
    fn id(&self) -> &str {
       "0x07db"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzSeekParty {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub option: u32,
    pub option_raw: [u8; 4],
}

impl PacketCzSeekParty {
    pub fn from(buffer: &[u8]) -> PacketCzSeekParty {
        PacketCzSeekParty {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            option: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.option).unwrap();
        self.option_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzSeekParty {
    fn id(&self) -> &str {
       "0x07dc"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSeekParty {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
    pub job: u32,
    pub job_raw: [u8; 4],
    pub level: u32,
    pub level_raw: [u8; 4],
    pub map_name: [char; 16],
    pub map_name_raw: [u8; 16],
    pub option: u32,
    pub option_raw: [u8; 4],
}

impl PacketZcSeekParty {
    pub fn from(buffer: &[u8]) -> PacketZcSeekParty {
        PacketZcSeekParty {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            job: u32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            job_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
            level: u32::from_le_bytes([buffer[30], buffer[31], buffer[32], buffer[33]]),
            level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[30..34]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[34..50].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[34..50]);
                dst
            },
            option: u32::from_le_bytes([buffer[50], buffer[51], buffer[52], buffer[53]]),
            option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[50..54]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.option).unwrap();
        self.option_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSeekParty {
    fn id(&self) -> &str {
       "0x07dd"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzSeekPartyMember {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub job: u32,
    pub job_raw: [u8; 4],
    pub level: u32,
    pub level_raw: [u8; 4],
    pub map_name: [char; 16],
    pub map_name_raw: [u8; 16],
    pub option: u32,
    pub option_raw: [u8; 4],
}

impl PacketCzSeekPartyMember {
    pub fn from(buffer: &[u8]) -> PacketCzSeekPartyMember {
        PacketCzSeekPartyMember {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            job: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            job_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            level: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[10..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[10..26]);
                dst
            },
            option: u32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.option).unwrap();
        self.option_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzSeekPartyMember {
    fn id(&self) -> &str {
       "0x07de"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSeekPartyMember {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
    pub job: u32,
    pub job_raw: [u8; 4],
    pub level: u32,
    pub level_raw: [u8; 4],
    pub map_name: [char; 16],
    pub map_name_raw: [u8; 16],
    pub option: u32,
    pub option_raw: [u8; 4],
}

impl PacketZcSeekPartyMember {
    pub fn from(buffer: &[u8]) -> PacketZcSeekPartyMember {
        PacketZcSeekPartyMember {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            job: u32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            job_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
            level: u32::from_le_bytes([buffer[30], buffer[31], buffer[32], buffer[33]]),
            level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[30..34]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[34..50].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[34..50]);
                dst
            },
            option: u32::from_le_bytes([buffer[50], buffer[51], buffer[52], buffer[53]]),
            option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[50..54]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.option).unwrap();
        self.option_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSeekPartyMember {
    fn id(&self) -> &str {
       "0x07df"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcEsNotiMyinfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub es_no: i16,
    pub es_no_raw: [u8; 2],
    pub esname: [char; 54],
    pub esname_raw: [u8; 54],
}

impl PacketZcEsNotiMyinfo {
    pub fn from(buffer: &[u8]) -> PacketZcEsNotiMyinfo {
        PacketZcEsNotiMyinfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            es_no: i16::from_le_bytes([buffer[2], buffer[3]]),
            es_no_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            esname:  {
                let mut dst: [char; 54] = [0 as char; 54];
                for (index, byte) in buffer[4..58].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            esname_raw: {
                let mut dst: [u8; 54] = [0u8; 54];
                dst.clone_from_slice(&buffer[4..58]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_no).unwrap();
        self.es_no_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.esname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.esname_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcEsNotiMyinfo {
    fn id(&self) -> &str {
       "0x07e0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSkillinfoUpdate2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub atype: i32,
    pub atype_raw: [u8; 4],
    pub level: i16,
    pub level_raw: [u8; 2],
    pub spcost: i16,
    pub spcost_raw: [u8; 2],
    pub attack_range: i16,
    pub attack_range_raw: [u8; 2],
    pub upgradable: bool,
    pub upgradable_raw: [u8; 1],
}

impl PacketZcSkillinfoUpdate2 {
    pub fn from(buffer: &[u8]) -> PacketZcSkillinfoUpdate2 {
        PacketZcSkillinfoUpdate2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            level: i16::from_le_bytes([buffer[8], buffer[9]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            spcost: i16::from_le_bytes([buffer[10], buffer[11]]),
            spcost_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            attack_range: i16::from_le_bytes([buffer[12], buffer[13]]),
            attack_range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            upgradable: buffer[14] == 1,
            upgradable_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.spcost).unwrap();
        self.spcost_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.attack_range).unwrap();
        self.attack_range_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.upgradable as u8).unwrap();
        self.upgradable_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSkillinfoUpdate2 {
    fn id(&self) -> &str {
       "0x07e1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMsgValue {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub msg: u16,
    pub msg_raw: [u8; 2],
    pub value: i32,
    pub value_raw: [u8; 4],
}

impl PacketZcMsgValue {
    pub fn from(buffer: &[u8]) -> PacketZcMsgValue {
        PacketZcMsgValue {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            msg: u16::from_le_bytes([buffer[2], buffer[3]]),
            msg_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            value: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.msg).unwrap();
        self.msg_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMsgValue {
    fn id(&self) -> &str {
       "0x07e2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcItemlistwinOpen {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub atype: i32,
    pub atype_raw: [u8; 4],
}

impl PacketZcItemlistwinOpen {
    pub fn from(buffer: &[u8]) -> PacketZcItemlistwinOpen {
        PacketZcItemlistwinOpen {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcItemlistwinOpen {
    fn id(&self) -> &str {
       "0x07e3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzItemlistwinRes {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub atype: i32,
    pub atype_raw: [u8; 4],
    pub action: i32,
    pub action_raw: [u8; 4],
    pub material_list: u16,
    pub material_list_raw: [u8; 2],
}

impl PacketCzItemlistwinRes {
    pub fn from(buffer: &[u8]) -> PacketCzItemlistwinRes {
        PacketCzItemlistwinRes {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            action: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            action_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            material_list: u16::from_le_bytes([buffer[12], buffer[13]]),
            material_list_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.material_list).unwrap();
        self.material_list_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzItemlistwinRes {
    fn id(&self) -> &str {
       "0x07e4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketChEnterCheckbot {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub dw_aid: u32,
    pub dw_aid_raw: [u8; 4],
    pub sz_string_info: String,
    pub sz_string_info_raw: Vec<u8>,
}

impl PacketChEnterCheckbot {
    pub fn from(buffer: &[u8]) -> PacketChEnterCheckbot {
        PacketChEnterCheckbot {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            dw_aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            dw_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            sz_string_info: String::from_utf8_lossy(&buffer[8..buffer.len()]).to_string(),
            sz_string_info_raw: buffer[8..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_aid).unwrap();
        self.dw_aid_raw = wtr.try_into().unwrap();
        self.sz_string_info_raw = self.sz_string_info.as_bytes().to_vec()
    }
}

impl Packet for PacketChEnterCheckbot {
    fn id(&self) -> &str {
       "0x07e5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMsgSkill {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub msgid: i32,
    pub msgid_raw: [u8; 4],
}

impl PacketZcMsgSkill {
    pub fn from(buffer: &[u8]) -> PacketZcMsgSkill {
        PacketZcMsgSkill {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            skid: u16::from_le_bytes([buffer[2], buffer[3]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msgid: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            msgid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.msgid).unwrap();
        self.msgid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcMsgSkill {
    fn id(&self) -> &str {
       "0x07e6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketChCheckbot {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub dw_aid: u32,
    pub dw_aid_raw: [u8; 4],
    pub sz_string_info: [char; 24],
    pub sz_string_info_raw: [u8; 24],
}

impl PacketChCheckbot {
    pub fn from(buffer: &[u8]) -> PacketChCheckbot {
        PacketChCheckbot {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            dw_aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            dw_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            sz_string_info:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[8..32].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            sz_string_info_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[8..32]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_aid).unwrap();
        self.dw_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_string_info {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_string_info_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketChCheckbot {
    fn id(&self) -> &str {
       "0x07e7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketHcCheckbot {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub img: String,
    pub img_raw: Vec<u8>,
}

impl PacketHcCheckbot {
    pub fn from(buffer: &[u8]) -> PacketHcCheckbot {
        PacketHcCheckbot {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            img: String::from_utf8_lossy(&buffer[4..buffer.len()]).to_string(),
            img_raw: buffer[4..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.img_raw = self.img.as_bytes().to_vec()
    }
}

impl Packet for PacketHcCheckbot {
    fn id(&self) -> &str {
       "0x07e8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketHcCheckbotResult {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub result: u8,
    pub result_raw: [u8; 1],
}

impl PacketHcCheckbotResult {
    pub fn from(buffer: &[u8]) -> PacketHcCheckbotResult {
        PacketHcCheckbotResult {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            result: u8::from_le_bytes([buffer[4]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketHcCheckbotResult {
    fn id(&self) -> &str {
       "0x07e9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzBattleFieldList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzBattleFieldList {
    pub fn from(buffer: &[u8]) -> PacketCzBattleFieldList {
        PacketCzBattleFieldList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzBattleFieldList {
    fn id(&self) -> &str {
       "0x07ea"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcBattleFieldList {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub ack_type: i16,
    pub ack_type_raw: [u8; 2],
    pub info_list: Vec<BattleFieldInfo>,
    pub info_list_raw: Vec<Vec<u8>>,
}

impl PacketZcBattleFieldList {
    pub fn from(buffer: &[u8]) -> PacketZcBattleFieldList {
        let iter_count = &buffer.len() / 62;
        let mut vec_field: Vec<BattleFieldInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 * i;
            let end_pos = 70 * i;
            vec_field.push(BattleFieldInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcBattleFieldList {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            ack_type: i16::from_le_bytes([buffer[6], buffer[7]]),
            ack_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            info_list: vec_field.clone(),
            info_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.ack_type).unwrap();
        self.ack_type_raw = wtr.try_into().unwrap();
        self.info_list_raw = {
            self.info_list.iter_mut().for_each(|item| item.serialize());
            self.info_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcBattleFieldList {
    fn id(&self) -> &str {
       "0x07eb"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzJoinBattleField {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub bfno: u32,
    pub bfno_raw: [u8; 4],
    pub join_team: i16,
    pub join_team_raw: [u8; 2],
}

impl PacketCzJoinBattleField {
    pub fn from(buffer: &[u8]) -> PacketCzJoinBattleField {
        PacketCzJoinBattleField {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            bfno: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            join_team: i16::from_le_bytes([buffer[6], buffer[7]]),
            join_team_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.join_team).unwrap();
        self.join_team_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzJoinBattleField {
    fn id(&self) -> &str {
       "0x07ec"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcJoinBattleField {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub bfno: u32,
    pub bfno_raw: [u8; 4],
    pub join_team: i16,
    pub join_team_raw: [u8; 2],
    pub result: i16,
    pub result_raw: [u8; 2],
}

impl PacketZcJoinBattleField {
    pub fn from(buffer: &[u8]) -> PacketZcJoinBattleField {
        PacketZcJoinBattleField {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            bfno: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            join_team: i16::from_le_bytes([buffer[6], buffer[7]]),
            join_team_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            result: i16::from_le_bytes([buffer[8], buffer[9]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.join_team).unwrap();
        self.join_team_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcJoinBattleField {
    fn id(&self) -> &str {
       "0x07ed"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzCancelBattleField {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub bfno: u32,
    pub bfno_raw: [u8; 4],
}

impl PacketCzCancelBattleField {
    pub fn from(buffer: &[u8]) -> PacketCzCancelBattleField {
        PacketCzCancelBattleField {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            bfno: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzCancelBattleField {
    fn id(&self) -> &str {
       "0x07ee"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcCancelBattleField {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub bfno: u32,
    pub bfno_raw: [u8; 4],
    pub result: i16,
    pub result_raw: [u8; 2],
}

impl PacketZcCancelBattleField {
    pub fn from(buffer: &[u8]) -> PacketZcCancelBattleField {
        PacketZcCancelBattleField {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            bfno: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            result: i16::from_le_bytes([buffer[6], buffer[7]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcCancelBattleField {
    fn id(&self) -> &str {
       "0x07ef"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqBattleStateMonitor {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub bfno: u32,
    pub bfno_raw: [u8; 4],
    pub power_switch: i16,
    pub power_switch_raw: [u8; 2],
}

impl PacketCzReqBattleStateMonitor {
    pub fn from(buffer: &[u8]) -> PacketCzReqBattleStateMonitor {
        PacketCzReqBattleStateMonitor {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            bfno: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            power_switch: i16::from_le_bytes([buffer[6], buffer[7]]),
            power_switch_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.power_switch).unwrap();
        self.power_switch_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqBattleStateMonitor {
    fn id(&self) -> &str {
       "0x07f0"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckBattleStateMonitor {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub bfno: u32,
    pub bfno_raw: [u8; 4],
    pub play_count: i16,
    pub play_count_raw: [u8; 2],
    pub battle_state: i16,
    pub battle_state_raw: [u8; 2],
    pub team_count_a: i16,
    pub team_count_a_raw: [u8; 2],
    pub team_count_b: i16,
    pub team_count_b_raw: [u8; 2],
    pub my_count: i16,
    pub my_count_raw: [u8; 2],
    pub join_team: i16,
    pub join_team_raw: [u8; 2],
}

impl PacketZcAckBattleStateMonitor {
    pub fn from(buffer: &[u8]) -> PacketZcAckBattleStateMonitor {
        PacketZcAckBattleStateMonitor {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            bfno: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            play_count: i16::from_le_bytes([buffer[6], buffer[7]]),
            play_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            battle_state: i16::from_le_bytes([buffer[8], buffer[9]]),
            battle_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            team_count_a: i16::from_le_bytes([buffer[10], buffer[11]]),
            team_count_a_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            team_count_b: i16::from_le_bytes([buffer[12], buffer[13]]),
            team_count_b_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            my_count: i16::from_le_bytes([buffer[14], buffer[15]]),
            my_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            join_team: i16::from_le_bytes([buffer[16], buffer[17]]),
            join_team_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.play_count).unwrap();
        self.play_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.battle_state).unwrap();
        self.battle_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.team_count_a).unwrap();
        self.team_count_a_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.team_count_b).unwrap();
        self.team_count_b_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.my_count).unwrap();
        self.my_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.join_team).unwrap();
        self.join_team_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckBattleStateMonitor {
    fn id(&self) -> &str {
       "0x07f1"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcBattleNotiStartStep {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub bfno: u32,
    pub bfno_raw: [u8; 4],
    pub result: i16,
    pub result_raw: [u8; 2],
}

impl PacketZcBattleNotiStartStep {
    pub fn from(buffer: &[u8]) -> PacketZcBattleNotiStartStep {
        PacketZcBattleNotiStartStep {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            bfno: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            result: i16::from_le_bytes([buffer[6], buffer[7]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcBattleNotiStartStep {
    fn id(&self) -> &str {
       "0x07f2"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcBattleJoinNotiDefer {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub bfno: u32,
    pub bfno_raw: [u8; 4],
}

impl PacketZcBattleJoinNotiDefer {
    pub fn from(buffer: &[u8]) -> PacketZcBattleJoinNotiDefer {
        PacketZcBattleJoinNotiDefer {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            bfno: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcBattleJoinNotiDefer {
    fn id(&self) -> &str {
       "0x07f3"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcBattleJoinDisableState {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub enable: bool,
    pub enable_raw: [u8; 1],
}

impl PacketZcBattleJoinDisableState {
    pub fn from(buffer: &[u8]) -> PacketZcBattleJoinDisableState {
        PacketZcBattleJoinDisableState {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            enable: buffer[2] == 1,
            enable_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.enable as u8).unwrap();
        self.enable_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcBattleJoinDisableState {
    fn id(&self) -> &str {
       "0x07f4"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzGmFullstrip {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub target_aid: u32,
    pub target_aid_raw: [u8; 4],
}

impl PacketCzGmFullstrip {
    pub fn from(buffer: &[u8]) -> PacketCzGmFullstrip {
        PacketCzGmFullstrip {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            target_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            target_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_aid).unwrap();
        self.target_aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzGmFullstrip {
    fn id(&self) -> &str {
       "0x07f5"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyExp {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub amount: i32,
    pub amount_raw: [u8; 4],
    pub var_id: u16,
    pub var_id_raw: [u8; 2],
    pub exp_type: i16,
    pub exp_type_raw: [u8; 2],
}

impl PacketZcNotifyExp {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyExp {
        PacketZcNotifyExp {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            amount: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            amount_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            var_id: u16::from_le_bytes([buffer[10], buffer[11]]),
            var_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            exp_type: i16::from_le_bytes([buffer[12], buffer[13]]),
            exp_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.amount).unwrap();
        self.amount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var_id).unwrap();
        self.var_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.exp_type).unwrap();
        self.exp_type_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyExp {
    fn id(&self) -> &str {
       "0x07f6"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyMoveentry7 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub objecttype: u8,
    pub objecttype_raw: [u8; 1],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub speed: i16,
    pub speed_raw: [u8; 2],
    pub body_state: i16,
    pub body_state_raw: [u8; 2],
    pub health_state: i16,
    pub health_state_raw: [u8; 2],
    pub effect_state: i32,
    pub effect_state_raw: [u8; 4],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub weapon: i32,
    pub weapon_raw: [u8; 4],
    pub accessory: i16,
    pub accessory_raw: [u8; 2],
    pub move_start_time: u32,
    pub move_start_time_raw: [u8; 4],
    pub accessory2: i16,
    pub accessory2_raw: [u8; 2],
    pub accessory3: i16,
    pub accessory3_raw: [u8; 2],
    pub headpalette: i16,
    pub headpalette_raw: [u8; 2],
    pub bodypalette: i16,
    pub bodypalette_raw: [u8; 2],
    pub head_dir: i16,
    pub head_dir_raw: [u8; 2],
    pub guid: u32,
    pub guid_raw: [u8; 4],
    pub gemblem_ver: i16,
    pub gemblem_ver_raw: [u8; 2],
    pub honor: i16,
    pub honor_raw: [u8; 2],
    pub virtue: i32,
    pub virtue_raw: [u8; 4],
    pub is_pkmode_on: bool,
    pub is_pkmode_on_raw: [u8; 1],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub move_data: [u16; 6],
    pub move_data_raw: [u8; 6],
    pub x_size: u8,
    pub x_size_raw: [u8; 1],
    pub y_size: u8,
    pub y_size_raw: [u8; 1],
    pub clevel: i16,
    pub clevel_raw: [u8; 2],
    pub font: i16,
    pub font_raw: [u8; 2],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
}

impl PacketZcNotifyMoveentry7 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyMoveentry7 {
        PacketZcNotifyMoveentry7 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            objecttype: u8::from_le_bytes([buffer[4]]),
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            gid: u32::from_le_bytes([buffer[5], buffer[6], buffer[7], buffer[8]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[5..9]);
                dst
            },
            speed: i16::from_le_bytes([buffer[9], buffer[10]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[11], buffer[12]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[13], buffer[14]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[13..15]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[15], buffer[16], buffer[17], buffer[18]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[15..19]);
                dst
            },
            job: i16::from_le_bytes([buffer[19], buffer[20]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            head: i16::from_le_bytes([buffer[21], buffer[22]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[21..23]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[23], buffer[24], buffer[25], buffer[26]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[23..27]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[27], buffer[28]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[27..29]);
                dst
            },
            move_start_time: u32::from_le_bytes([buffer[29], buffer[30], buffer[31], buffer[32]]),
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[29..33]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[33], buffer[34]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[35], buffer[36]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[35..37]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[37], buffer[38]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[37..39]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[39], buffer[40]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[39..41]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[41], buffer[42]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[41..43]);
                dst
            },
            guid: u32::from_le_bytes([buffer[43], buffer[44], buffer[45], buffer[46]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[43..47]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[47], buffer[48]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[47..49]);
                dst
            },
            honor: i16::from_le_bytes([buffer[49], buffer[50]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[49..51]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[51], buffer[52], buffer[53], buffer[54]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[51..55]);
                dst
            },
            is_pkmode_on: buffer[55] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[55..56]);
                dst
            },
            sex: u8::from_le_bytes([buffer[56]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[56..57]);
                dst
            },
            move_data:  {
                let mut dst: [u16; 6] = [0 as u16; 6];
                for (index, byte) in buffer[57..63].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            },
            move_data_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[57..63]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[63]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[63..64]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[64]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[64..65]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[65], buffer[66]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[65..67]);
                dst
            },
            font: i16::from_le_bytes([buffer[67], buffer[68]]),
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[67..69]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[69..93].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[69..93]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyMoveentry7 {
    fn id(&self) -> &str {
       "0x07f7"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyNewentry5 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub objecttype: u8,
    pub objecttype_raw: [u8; 1],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub speed: i16,
    pub speed_raw: [u8; 2],
    pub body_state: i16,
    pub body_state_raw: [u8; 2],
    pub health_state: i16,
    pub health_state_raw: [u8; 2],
    pub effect_state: i32,
    pub effect_state_raw: [u8; 4],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub weapon: i32,
    pub weapon_raw: [u8; 4],
    pub accessory: i16,
    pub accessory_raw: [u8; 2],
    pub accessory2: i16,
    pub accessory2_raw: [u8; 2],
    pub accessory3: i16,
    pub accessory3_raw: [u8; 2],
    pub headpalette: i16,
    pub headpalette_raw: [u8; 2],
    pub bodypalette: i16,
    pub bodypalette_raw: [u8; 2],
    pub head_dir: i16,
    pub head_dir_raw: [u8; 2],
    pub guid: u32,
    pub guid_raw: [u8; 4],
    pub gemblem_ver: i16,
    pub gemblem_ver_raw: [u8; 2],
    pub honor: i16,
    pub honor_raw: [u8; 2],
    pub virtue: i32,
    pub virtue_raw: [u8; 4],
    pub is_pkmode_on: bool,
    pub is_pkmode_on_raw: [u8; 1],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub pos_dir: [char; 3],
    pub pos_dir_raw: [u8; 3],
    pub x_size: u8,
    pub x_size_raw: [u8; 1],
    pub y_size: u8,
    pub y_size_raw: [u8; 1],
    pub clevel: i16,
    pub clevel_raw: [u8; 2],
    pub font: i16,
    pub font_raw: [u8; 2],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
}

impl PacketZcNotifyNewentry5 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyNewentry5 {
        PacketZcNotifyNewentry5 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            objecttype: u8::from_le_bytes([buffer[4]]),
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            gid: u32::from_le_bytes([buffer[5], buffer[6], buffer[7], buffer[8]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[5..9]);
                dst
            },
            speed: i16::from_le_bytes([buffer[9], buffer[10]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[11], buffer[12]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[13], buffer[14]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[13..15]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[15], buffer[16], buffer[17], buffer[18]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[15..19]);
                dst
            },
            job: i16::from_le_bytes([buffer[19], buffer[20]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            head: i16::from_le_bytes([buffer[21], buffer[22]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[21..23]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[23], buffer[24], buffer[25], buffer[26]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[23..27]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[27], buffer[28]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[27..29]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[29], buffer[30]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[29..31]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[31], buffer[32]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[31..33]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[33], buffer[34]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[35], buffer[36]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[35..37]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[37], buffer[38]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[37..39]);
                dst
            },
            guid: u32::from_le_bytes([buffer[39], buffer[40], buffer[41], buffer[42]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[39..43]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[43], buffer[44]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[43..45]);
                dst
            },
            honor: i16::from_le_bytes([buffer[45], buffer[46]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[45..47]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[47], buffer[48], buffer[49], buffer[50]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[47..51]);
                dst
            },
            is_pkmode_on: buffer[51] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[51..52]);
                dst
            },
            sex: u8::from_le_bytes([buffer[52]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[52..53]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[53..56].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[53..56]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[56]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[56..57]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[57]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[57..58]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[58], buffer[59]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[58..60]);
                dst
            },
            font: i16::from_le_bytes([buffer[60], buffer[61]]),
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[60..62]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[62..86].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[62..86]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyNewentry5 {
    fn id(&self) -> &str {
       "0x07f8"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyStandentry5 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub objecttype: u8,
    pub objecttype_raw: [u8; 1],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub speed: i16,
    pub speed_raw: [u8; 2],
    pub body_state: i16,
    pub body_state_raw: [u8; 2],
    pub health_state: i16,
    pub health_state_raw: [u8; 2],
    pub effect_state: i32,
    pub effect_state_raw: [u8; 4],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub weapon: i32,
    pub weapon_raw: [u8; 4],
    pub accessory: i16,
    pub accessory_raw: [u8; 2],
    pub accessory2: i16,
    pub accessory2_raw: [u8; 2],
    pub accessory3: i16,
    pub accessory3_raw: [u8; 2],
    pub headpalette: i16,
    pub headpalette_raw: [u8; 2],
    pub bodypalette: i16,
    pub bodypalette_raw: [u8; 2],
    pub head_dir: i16,
    pub head_dir_raw: [u8; 2],
    pub guid: u32,
    pub guid_raw: [u8; 4],
    pub gemblem_ver: i16,
    pub gemblem_ver_raw: [u8; 2],
    pub honor: i16,
    pub honor_raw: [u8; 2],
    pub virtue: i32,
    pub virtue_raw: [u8; 4],
    pub is_pkmode_on: bool,
    pub is_pkmode_on_raw: [u8; 1],
    pub sex: u8,
    pub sex_raw: [u8; 1],
    pub pos_dir: [char; 3],
    pub pos_dir_raw: [u8; 3],
    pub x_size: u8,
    pub x_size_raw: [u8; 1],
    pub y_size: u8,
    pub y_size_raw: [u8; 1],
    pub state: u8,
    pub state_raw: [u8; 1],
    pub clevel: i16,
    pub clevel_raw: [u8; 2],
    pub font: i16,
    pub font_raw: [u8; 2],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
}

impl PacketZcNotifyStandentry5 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyStandentry5 {
        PacketZcNotifyStandentry5 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            objecttype: u8::from_le_bytes([buffer[4]]),
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            gid: u32::from_le_bytes([buffer[5], buffer[6], buffer[7], buffer[8]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[5..9]);
                dst
            },
            speed: i16::from_le_bytes([buffer[9], buffer[10]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            body_state: i16::from_le_bytes([buffer[11], buffer[12]]),
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[11..13]);
                dst
            },
            health_state: i16::from_le_bytes([buffer[13], buffer[14]]),
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[13..15]);
                dst
            },
            effect_state: i32::from_le_bytes([buffer[15], buffer[16], buffer[17], buffer[18]]),
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[15..19]);
                dst
            },
            job: i16::from_le_bytes([buffer[19], buffer[20]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[19..21]);
                dst
            },
            head: i16::from_le_bytes([buffer[21], buffer[22]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[21..23]);
                dst
            },
            weapon: i32::from_le_bytes([buffer[23], buffer[24], buffer[25], buffer[26]]),
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[23..27]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[27], buffer[28]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[27..29]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[29], buffer[30]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[29..31]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[31], buffer[32]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[31..33]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[33], buffer[34]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[33..35]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[35], buffer[36]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[35..37]);
                dst
            },
            head_dir: i16::from_le_bytes([buffer[37], buffer[38]]),
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[37..39]);
                dst
            },
            guid: u32::from_le_bytes([buffer[39], buffer[40], buffer[41], buffer[42]]),
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[39..43]);
                dst
            },
            gemblem_ver: i16::from_le_bytes([buffer[43], buffer[44]]),
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[43..45]);
                dst
            },
            honor: i16::from_le_bytes([buffer[45], buffer[46]]),
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[45..47]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[47], buffer[48], buffer[49], buffer[50]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[47..51]);
                dst
            },
            is_pkmode_on: buffer[51] == 1,
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[51..52]);
                dst
            },
            sex: u8::from_le_bytes([buffer[52]]),
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[52..53]);
                dst
            },
            pos_dir:  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[53..56].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[53..56]);
                dst
            },
            x_size: u8::from_le_bytes([buffer[56]]),
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[56..57]);
                dst
            },
            y_size: u8::from_le_bytes([buffer[57]]),
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[57..58]);
                dst
            },
            state: u8::from_le_bytes([buffer[58]]),
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[58..59]);
                dst
            },
            clevel: i16::from_le_bytes([buffer[59], buffer[60]]),
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[59..61]);
                dst
            },
            font: i16::from_le_bytes([buffer[61], buffer[62]]),
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[61..63]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[63..87].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[63..87]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyStandentry5 {
    fn id(&self) -> &str {
       "0x07f9"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcDeleteItemFromBody {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub delete_type: i16,
    pub delete_type_raw: [u8; 2],
    pub index: u16,
    pub index_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
}

impl PacketZcDeleteItemFromBody {
    pub fn from(buffer: &[u8]) -> PacketZcDeleteItemFromBody {
        PacketZcDeleteItemFromBody {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            delete_type: i16::from_le_bytes([buffer[2], buffer[3]]),
            delete_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            index: u16::from_le_bytes([buffer[4], buffer[5]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            count: i16::from_le_bytes([buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.delete_type).unwrap();
        self.delete_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcDeleteItemFromBody {
    fn id(&self) -> &str {
       "0x07fa"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcUseskillAck2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub target_id: u32,
    pub target_id_raw: [u8; 4],
    pub x_pos: i16,
    pub x_pos_raw: [u8; 2],
    pub y_pos: i16,
    pub y_pos_raw: [u8; 2],
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub property: u32,
    pub property_raw: [u8; 4],
    pub delay_time: u32,
    pub delay_time_raw: [u8; 4],
    pub is_disposable: bool,
    pub is_disposable_raw: [u8; 1],
}

impl PacketZcUseskillAck2 {
    pub fn from(buffer: &[u8]) -> PacketZcUseskillAck2 {
        PacketZcUseskillAck2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            target_id: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            x_pos: i16::from_le_bytes([buffer[10], buffer[11]]),
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            y_pos: i16::from_le_bytes([buffer[12], buffer[13]]),
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            skid: u16::from_le_bytes([buffer[14], buffer[15]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            property: u32::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19]]),
            property_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[16..20]);
                dst
            },
            delay_time: u32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            delay_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
            is_disposable: buffer[24] == 1,
            is_disposable_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[24..25]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.property).unwrap();
        self.property_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.delay_time).unwrap();
        self.delay_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_disposable as u8).unwrap();
        self.is_disposable_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcUseskillAck2 {
    fn id(&self) -> &str {
       "0x07fb"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcChangeGroupMaster {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub old_master_aid: u32,
    pub old_master_aid_raw: [u8; 4],
    pub new_master_aid: u32,
    pub new_master_aid_raw: [u8; 4],
}

impl PacketZcChangeGroupMaster {
    pub fn from(buffer: &[u8]) -> PacketZcChangeGroupMaster {
        PacketZcChangeGroupMaster {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            old_master_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            old_master_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            new_master_aid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            new_master_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.old_master_aid).unwrap();
        self.old_master_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.new_master_aid).unwrap();
        self.new_master_aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcChangeGroupMaster {
    fn id(&self) -> &str {
       "0x07fc"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPlayNpcBgm {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub bgm: [char; 24],
    pub bgm_raw: [u8; 24],
}

impl PacketZcPlayNpcBgm {
    pub fn from(buffer: &[u8]) -> PacketZcPlayNpcBgm {
        PacketZcPlayNpcBgm {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            bgm:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            bgm_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.bgm {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.bgm_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcPlayNpcBgm {
    fn id(&self) -> &str {
       "0x07fe"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcDefineCheck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub result: i32,
    pub result_raw: [u8; 4],
}

impl PacketZcDefineCheck {
    pub fn from(buffer: &[u8]) -> PacketZcDefineCheck {
        PacketZcDefineCheck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            result: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcDefineCheck {
    fn id(&self) -> &str {
       "0x07ff"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPcPurchaseItemlistFrommc2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub unique_id: u32,
    pub unique_id_raw: [u8; 4],
    pub item_list: Vec<PurchaseItemFrommc>,
    pub item_list_raw: Vec<Vec<u8>>,
}

impl PacketZcPcPurchaseItemlistFrommc2 {
    pub fn from(buffer: &[u8]) -> PacketZcPcPurchaseItemlistFrommc2 {
        let iter_count = &buffer.len() / 22;
        let mut vec_field: Vec<PurchaseItemFrommc> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 12 * i;
            let end_pos = 34 * i;
            vec_field.push(PurchaseItemFrommc::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPcPurchaseItemlistFrommc2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            unique_id: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            unique_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.unique_id).unwrap();
        self.unique_id_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.serialize());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcPcPurchaseItemlistFrommc2 {
    fn id(&self) -> &str {
       "0x0800"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzPcPurchaseItemlistFrommc2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub unique_id: u32,
    pub unique_id_raw: [u8; 4],
    pub item_list: Vec<CzPurchaseItemFrommc>,
    pub item_list_raw: Vec<Vec<u8>>,
}

impl PacketCzPcPurchaseItemlistFrommc2 {
    pub fn from(buffer: &[u8]) -> PacketCzPcPurchaseItemlistFrommc2 {
        let iter_count = &buffer.len() / 4;
        let mut vec_field: Vec<CzPurchaseItemFrommc> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 12 * i;
            let end_pos = 16 * i;
            vec_field.push(CzPurchaseItemFrommc::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzPcPurchaseItemlistFrommc2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            unique_id: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            unique_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.unique_id).unwrap();
        self.unique_id_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.serialize());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketCzPcPurchaseItemlistFrommc2 {
    fn id(&self) -> &str {
       "0x0801"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzPartyBookingReqRegister {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub register_info: PartyBookingDetail,
    pub register_info_raw: Vec<u8>,
}

impl PacketCzPartyBookingReqRegister {
    pub fn from(buffer: &[u8]) -> PacketCzPartyBookingReqRegister {
        PacketCzPartyBookingReqRegister {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            register_info: PartyBookingDetail::from(&buffer[2..buffer.len()]),
            register_info_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketCzPartyBookingReqRegister {
    fn id(&self) -> &str {
       "0x0802"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPartyBookingAckRegister {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: i16,
    pub result_raw: [u8; 2],
}

impl PacketZcPartyBookingAckRegister {
    pub fn from(buffer: &[u8]) -> PacketZcPartyBookingAckRegister {
        PacketZcPartyBookingAckRegister {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcPartyBookingAckRegister {
    fn id(&self) -> &str {
       "0x0803"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzPartyBookingReqSearch {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub level: i16,
    pub level_raw: [u8; 2],
    pub map_id: i16,
    pub map_id_raw: [u8; 2],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub last_index: u32,
    pub last_index_raw: [u8; 4],
    pub result_count: i16,
    pub result_count_raw: [u8; 2],
}

impl PacketCzPartyBookingReqSearch {
    pub fn from(buffer: &[u8]) -> PacketCzPartyBookingReqSearch {
        PacketCzPartyBookingReqSearch {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            level: i16::from_le_bytes([buffer[2], buffer[3]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            map_id: i16::from_le_bytes([buffer[4], buffer[5]]),
            map_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            job: i16::from_le_bytes([buffer[6], buffer[7]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            last_index: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            last_index_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            result_count: i16::from_le_bytes([buffer[12], buffer[13]]),
            result_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.map_id).unwrap();
        self.map_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.last_index).unwrap();
        self.last_index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result_count).unwrap();
        self.result_count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzPartyBookingReqSearch {
    fn id(&self) -> &str {
       "0x0804"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPartyBookingAckSearch {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub is_exist_more_result: bool,
    pub is_exist_more_result_raw: [u8; 1],
    pub info: Vec<PartyBookingAdInfo>,
    pub info_raw: Vec<Vec<u8>>,
}

impl PacketZcPartyBookingAckSearch {
    pub fn from(buffer: &[u8]) -> PacketZcPartyBookingAckSearch {
        let iter_count = &buffer.len() / 48;
        let mut vec_field: Vec<PartyBookingAdInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 5 * i;
            let end_pos = 53 * i;
            vec_field.push(PartyBookingAdInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcPartyBookingAckSearch {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            is_exist_more_result: buffer[4] == 1,
            is_exist_more_result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            info: vec_field.clone(),
            info_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_exist_more_result as u8).unwrap();
        self.is_exist_more_result_raw = wtr.try_into().unwrap();
        self.info_raw = {
            self.info.iter_mut().for_each(|item| item.serialize());
            self.info.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcPartyBookingAckSearch {
    fn id(&self) -> &str {
       "0x0805"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzPartyBookingReqDelete {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzPartyBookingReqDelete {
    pub fn from(buffer: &[u8]) -> PacketCzPartyBookingReqDelete {
        PacketCzPartyBookingReqDelete {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzPartyBookingReqDelete {
    fn id(&self) -> &str {
       "0x0806"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPartyBookingAckDelete {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: i16,
    pub result_raw: [u8; 2],
}

impl PacketZcPartyBookingAckDelete {
    pub fn from(buffer: &[u8]) -> PacketZcPartyBookingAckDelete {
        PacketZcPartyBookingAckDelete {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcPartyBookingAckDelete {
    fn id(&self) -> &str {
       "0x0807"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzPartyBookingReqUpdate {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub job: [i16; 6],
    pub job_raw: [u8; 6],
}

impl PacketCzPartyBookingReqUpdate {
    pub fn from(buffer: &[u8]) -> PacketCzPartyBookingReqUpdate {
        PacketCzPartyBookingReqUpdate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            job:  {
                let mut dst: [i16; 6] = [0 as i16; 6];
                for (index, byte) in buffer[2..8].iter().enumerate() {
                    dst[index] = *byte as i16;
                }
                dst
            },
            job_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[2..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.job {
            wtr.write_i16::<LittleEndian>(item).unwrap();
        }
        self.job_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzPartyBookingReqUpdate {
    fn id(&self) -> &str {
       "0x0808"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPartyBookingNotifyInsert {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub info: PartyBookingAdInfo,
    pub info_raw: Vec<u8>,
}

impl PacketZcPartyBookingNotifyInsert {
    pub fn from(buffer: &[u8]) -> PacketZcPartyBookingNotifyInsert {
        PacketZcPartyBookingNotifyInsert {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            info: PartyBookingAdInfo::from(&buffer[2..buffer.len()]),
            info_raw: buffer[2..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcPartyBookingNotifyInsert {
    fn id(&self) -> &str {
       "0x0809"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPartyBookingNotifyUpdate {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: u32,
    pub index_raw: [u8; 4],
    pub job1: i16,
    pub job1_raw: [u8; 2],
    pub job2: i16,
    pub job2_raw: [u8; 2],
    pub job3: i16,
    pub job3_raw: [u8; 2],
    pub job4: i16,
    pub job4_raw: [u8; 2],
    pub job5: i16,
    pub job5_raw: [u8; 2],
    pub job6: i16,
    pub job6_raw: [u8; 2],
}

impl PacketZcPartyBookingNotifyUpdate {
    pub fn from(buffer: &[u8]) -> PacketZcPartyBookingNotifyUpdate {
        PacketZcPartyBookingNotifyUpdate {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            index_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            job1: i16::from_le_bytes([buffer[6], buffer[7]]),
            job1_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            job2: i16::from_le_bytes([buffer[8], buffer[9]]),
            job2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            job3: i16::from_le_bytes([buffer[10], buffer[11]]),
            job3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            job4: i16::from_le_bytes([buffer[12], buffer[13]]),
            job4_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job5: i16::from_le_bytes([buffer[14], buffer[15]]),
            job5_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            job6: i16::from_le_bytes([buffer[16], buffer[17]]),
            job6_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job1).unwrap();
        self.job1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job2).unwrap();
        self.job2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job3).unwrap();
        self.job3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job4).unwrap();
        self.job4_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job5).unwrap();
        self.job5_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job6).unwrap();
        self.job6_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcPartyBookingNotifyUpdate {
    fn id(&self) -> &str {
       "0x080a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcPartyBookingNotifyDelete {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: u32,
    pub index_raw: [u8; 4],
}

impl PacketZcPartyBookingNotifyDelete {
    pub fn from(buffer: &[u8]) -> PacketZcPartyBookingNotifyDelete {
        PacketZcPartyBookingNotifyDelete {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            index_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcPartyBookingNotifyDelete {
    fn id(&self) -> &str {
       "0x080b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzSimpleCashBtnshow {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzSimpleCashBtnshow {
    pub fn from(buffer: &[u8]) -> PacketCzSimpleCashBtnshow {
        PacketCzSimpleCashBtnshow {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzSimpleCashBtnshow {
    fn id(&self) -> &str {
       "0x080c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSimpleCashBtnshow {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub show: bool,
    pub show_raw: [u8; 1],
}

impl PacketZcSimpleCashBtnshow {
    pub fn from(buffer: &[u8]) -> PacketZcSimpleCashBtnshow {
        PacketZcSimpleCashBtnshow {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            show: buffer[2] == 1,
            show_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.show as u8).unwrap();
        self.show_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSimpleCashBtnshow {
    fn id(&self) -> &str {
       "0x080d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcNotifyHpToGroupmR2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub hp: i32,
    pub hp_raw: [u8; 4],
    pub maxhp: i32,
    pub maxhp_raw: [u8; 4],
}

impl PacketZcNotifyHpToGroupmR2 {
    pub fn from(buffer: &[u8]) -> PacketZcNotifyHpToGroupmR2 {
        PacketZcNotifyHpToGroupmR2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            hp: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            maxhp: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            maxhp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.maxhp).unwrap();
        self.maxhp_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcNotifyHpToGroupmR2 {
    fn id(&self) -> &str {
       "0x080e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAddExchangeItem2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub count: i32,
    pub count_raw: [u8; 4],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub is_damaged: bool,
    pub is_damaged_raw: [u8; 1],
    pub refining_level: u8,
    pub refining_level_raw: [u8; 1],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
}

impl PacketZcAddExchangeItem2 {
    pub fn from(buffer: &[u8]) -> PacketZcAddExchangeItem2 {
        PacketZcAddExchangeItem2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: u8::from_le_bytes([buffer[4]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            count: i32::from_le_bytes([buffer[5], buffer[6], buffer[7], buffer[8]]),
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[5..9]);
                dst
            },
            is_identified: buffer[9] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[9..10]);
                dst
            },
            is_damaged: buffer[10] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[11]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[12..20]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[12..20]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();

    }
}

impl Packet for PacketZcAddExchangeItem2 {
    fn id(&self) -> &str {
       "0x080f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcOpenBuyingStore {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub count: u8,
    pub count_raw: [u8; 1],
}

impl PacketZcOpenBuyingStore {
    pub fn from(buffer: &[u8]) -> PacketZcOpenBuyingStore {
        PacketZcOpenBuyingStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            count: u8::from_le_bytes([buffer[2]]),
            count_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcOpenBuyingStore {
    fn id(&self) -> &str {
       "0x0810"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqOpenBuyingStore {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub limit_zeny: u32,
    pub limit_zeny_raw: [u8; 4],
    pub result: u8,
    pub result_raw: [u8; 1],
    pub store_name: [char; 80],
    pub store_name_raw: [u8; 80],
    pub item_list: Vec<ProductinfoInBuyingStore>,
    pub item_list_raw: Vec<Vec<u8>>,
}

impl PacketCzReqOpenBuyingStore {
    pub fn from(buffer: &[u8]) -> PacketCzReqOpenBuyingStore {
        let iter_count = &buffer.len() / 8;
        let mut vec_field: Vec<ProductinfoInBuyingStore> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 89 * i;
            let end_pos = 97 * i;
            vec_field.push(ProductinfoInBuyingStore::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzReqOpenBuyingStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            limit_zeny: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            limit_zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            result: u8::from_le_bytes([buffer[8]]),
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            store_name:  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[9..89].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            store_name_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[9..89]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.limit_zeny).unwrap();
        self.limit_zeny_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.store_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.store_name_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.serialize());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketCzReqOpenBuyingStore {
    fn id(&self) -> &str {
       "0x0811"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcFailedOpenBuyingStoreToBuyer {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: i16,
    pub result_raw: [u8; 2],
    pub total_weight: i32,
    pub total_weight_raw: [u8; 4],
}

impl PacketZcFailedOpenBuyingStoreToBuyer {
    pub fn from(buffer: &[u8]) -> PacketZcFailedOpenBuyingStoreToBuyer {
        PacketZcFailedOpenBuyingStoreToBuyer {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            total_weight: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            total_weight_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.total_weight).unwrap();
        self.total_weight_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcFailedOpenBuyingStoreToBuyer {
    fn id(&self) -> &str {
       "0x0812"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcMyitemlistBuyingStore {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub limit_zeny: i32,
    pub limit_zeny_raw: [u8; 4],
    pub item_list: Vec<BuyingStoreItemlist>,
    pub item_list_raw: Vec<Vec<u8>>,
}

impl PacketZcMyitemlistBuyingStore {
    pub fn from(buffer: &[u8]) -> PacketZcMyitemlistBuyingStore {
        let iter_count = &buffer.len() / 9;
        let mut vec_field: Vec<BuyingStoreItemlist> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 12 * i;
            let end_pos = 21 * i;
            vec_field.push(BuyingStoreItemlist::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcMyitemlistBuyingStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            limit_zeny: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            limit_zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.limit_zeny).unwrap();
        self.limit_zeny_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.serialize());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcMyitemlistBuyingStore {
    fn id(&self) -> &str {
       "0x0813"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcBuyingStoreEntry {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub maker_aid: u32,
    pub maker_aid_raw: [u8; 4],
    pub store_name: [char; 80],
    pub store_name_raw: [u8; 80],
}

impl PacketZcBuyingStoreEntry {
    pub fn from(buffer: &[u8]) -> PacketZcBuyingStoreEntry {
        PacketZcBuyingStoreEntry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            maker_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            store_name:  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[6..86].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            store_name_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[6..86]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.store_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.store_name_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcBuyingStoreEntry {
    fn id(&self) -> &str {
       "0x0814"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqCloseBuyingStore {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzReqCloseBuyingStore {
    pub fn from(buffer: &[u8]) -> PacketCzReqCloseBuyingStore {
        PacketCzReqCloseBuyingStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqCloseBuyingStore {
    fn id(&self) -> &str {
       "0x0815"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcDisappearBuyingStoreEntry {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub maker_aid: u32,
    pub maker_aid_raw: [u8; 4],
}

impl PacketZcDisappearBuyingStoreEntry {
    pub fn from(buffer: &[u8]) -> PacketZcDisappearBuyingStoreEntry {
        PacketZcDisappearBuyingStoreEntry {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            maker_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcDisappearBuyingStoreEntry {
    fn id(&self) -> &str {
       "0x0816"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqClickToBuyingStore {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub maker_aid: u32,
    pub maker_aid_raw: [u8; 4],
}

impl PacketCzReqClickToBuyingStore {
    pub fn from(buffer: &[u8]) -> PacketCzReqClickToBuyingStore {
        PacketCzReqClickToBuyingStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            maker_aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzReqClickToBuyingStore {
    fn id(&self) -> &str {
       "0x0817"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckItemlistBuyingStore {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub maker_aid: u32,
    pub maker_aid_raw: [u8; 4],
    pub store_id: u32,
    pub store_id_raw: [u8; 4],
    pub limit_zeny: i32,
    pub limit_zeny_raw: [u8; 4],
    pub item_list: Vec<BuyingStoreItemlist>,
    pub item_list_raw: Vec<Vec<u8>>,
}

impl PacketZcAckItemlistBuyingStore {
    pub fn from(buffer: &[u8]) -> PacketZcAckItemlistBuyingStore {
        let iter_count = &buffer.len() / 9;
        let mut vec_field: Vec<BuyingStoreItemlist> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 16 * i;
            let end_pos = 25 * i;
            vec_field.push(BuyingStoreItemlist::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcAckItemlistBuyingStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            maker_aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            store_id: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            store_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            limit_zeny: i32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            limit_zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.store_id).unwrap();
        self.store_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.limit_zeny).unwrap();
        self.limit_zeny_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.serialize());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcAckItemlistBuyingStore {
    fn id(&self) -> &str {
       "0x0818"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzReqTradeBuyingStore {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub maker_aid: u32,
    pub maker_aid_raw: [u8; 4],
    pub store_id: u32,
    pub store_id_raw: [u8; 4],
    pub item_list: Vec<TradeItemBuyingStore>,
    pub item_list_raw: Vec<Vec<u8>>,
}

impl PacketCzReqTradeBuyingStore {
    pub fn from(buffer: &[u8]) -> PacketCzReqTradeBuyingStore {
        let iter_count = &buffer.len() / 6;
        let mut vec_field: Vec<TradeItemBuyingStore> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 12 * i;
            let end_pos = 18 * i;
            vec_field.push(TradeItemBuyingStore::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketCzReqTradeBuyingStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            maker_aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            store_id: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            store_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            item_list: vec_field.clone(),
            item_list_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.store_id).unwrap();
        self.store_id_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.serialize());
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketCzReqTradeBuyingStore {
    fn id(&self) -> &str {
       "0x0819"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcFailedTradeBuyingStoreToBuyer {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: i16,
    pub result_raw: [u8; 2],
}

impl PacketZcFailedTradeBuyingStoreToBuyer {
    pub fn from(buffer: &[u8]) -> PacketZcFailedTradeBuyingStoreToBuyer {
        PacketZcFailedTradeBuyingStoreToBuyer {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcFailedTradeBuyingStoreToBuyer {
    fn id(&self) -> &str {
       "0x081a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcUpdateItemFromBuyingStore {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub limit_zeny: i32,
    pub limit_zeny_raw: [u8; 4],
}

impl PacketZcUpdateItemFromBuyingStore {
    pub fn from(buffer: &[u8]) -> PacketZcUpdateItemFromBuyingStore {
        PacketZcUpdateItemFromBuyingStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            limit_zeny: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            limit_zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.limit_zeny).unwrap();
        self.limit_zeny_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcUpdateItemFromBuyingStore {
    fn id(&self) -> &str {
       "0x081b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcItemDeleteBuyingStore {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub zeny: i32,
    pub zeny_raw: [u8; 4],
}

impl PacketZcItemDeleteBuyingStore {
    pub fn from(buffer: &[u8]) -> PacketZcItemDeleteBuyingStore {
        PacketZcItemDeleteBuyingStore {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            zeny: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.zeny).unwrap();
        self.zeny_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcItemDeleteBuyingStore {
    fn id(&self) -> &str {
       "0x081c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcElInit {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: i32,
    pub aid_raw: [u8; 4],
    pub hp: i32,
    pub hp_raw: [u8; 4],
    pub max_hp: i32,
    pub max_hp_raw: [u8; 4],
    pub sp: i32,
    pub sp_raw: [u8; 4],
    pub max_sp: i32,
    pub max_sp_raw: [u8; 4],
}

impl PacketZcElInit {
    pub fn from(buffer: &[u8]) -> PacketZcElInit {
        PacketZcElInit {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            hp: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            max_hp: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            max_hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
            sp: i32::from_le_bytes([buffer[14], buffer[15], buffer[16], buffer[17]]),
            sp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[14..18]);
                dst
            },
            max_sp: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            max_sp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.sp).unwrap();
        self.sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_sp).unwrap();
        self.max_sp_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcElInit {
    fn id(&self) -> &str {
       "0x081d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcElParChange {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub var: u16,
    pub var_raw: [u8; 2],
    pub value: i32,
    pub value_raw: [u8; 4],
}

impl PacketZcElParChange {
    pub fn from(buffer: &[u8]) -> PacketZcElParChange {
        PacketZcElParChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            var: u16::from_le_bytes([buffer[2], buffer[3]]),
            var_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            value: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var).unwrap();
        self.var_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcElParChange {
    fn id(&self) -> &str {
       "0x081e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcBroadcast4 {
    pub raw: Vec<u8>,
    pub pakcet_type: i16,
    pub pakcet_type_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub msgtype: u8,
    pub msgtype_raw: [u8; 1],
    pub color_rgb: u32,
    pub color_rgb_raw: [u8; 4],
    pub msg: String,
    pub msg_raw: Vec<u8>,
}

impl PacketZcBroadcast4 {
    pub fn from(buffer: &[u8]) -> PacketZcBroadcast4 {
        PacketZcBroadcast4 {
            raw: buffer.to_vec(),
            pakcet_type: i16::from_le_bytes([buffer[0], buffer[1]]),
            pakcet_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            msgtype: u8::from_le_bytes([buffer[4]]),
            msgtype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            color_rgb: u32::from_le_bytes([buffer[5], buffer[6], buffer[7], buffer[8]]),
            color_rgb_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[5..9]);
                dst
            },
            msg: String::from_utf8_lossy(&buffer[9..buffer.len()]).to_string(),
            msg_raw: buffer[9..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.pakcet_type).unwrap();
        self.pakcet_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.msgtype).unwrap();
        self.msgtype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.color_rgb).unwrap();
        self.color_rgb_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec()
    }
}

impl Packet for PacketZcBroadcast4 {
    fn id(&self) -> &str {
       "0x081f"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcCostumeSpriteChange {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub value: i32,
    pub value_raw: [u8; 4],
}

impl PacketZcCostumeSpriteChange {
    pub fn from(buffer: &[u8]) -> PacketZcCostumeSpriteChange {
        PacketZcCostumeSpriteChange {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            value: i32::from_le_bytes([buffer[7], buffer[8], buffer[9], buffer[10]]),
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[7..11]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcCostumeSpriteChange {
    fn id(&self) -> &str {
       "0x0820"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcOtpUser {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketAcOtpUser {
    pub fn from(buffer: &[u8]) -> PacketAcOtpUser {
        PacketAcOtpUser {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcOtpUser {
    fn id(&self) -> &str {
       "0x0821"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCaOtpAuthReq {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub otpcode: [char; 7],
    pub otpcode_raw: [u8; 7],
}

impl PacketCaOtpAuthReq {
    pub fn from(buffer: &[u8]) -> PacketCaOtpAuthReq {
        PacketCaOtpAuthReq {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            otpcode:  {
                let mut dst: [char; 7] = [0 as char; 7];
                for (index, byte) in buffer[2..9].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            otpcode_raw: {
                let mut dst: [u8; 7] = [0u8; 7];
                dst.clone_from_slice(&buffer[2..9]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.otpcode {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.otpcode_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCaOtpAuthReq {
    fn id(&self) -> &str {
       "0x0822"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcOtpAuthAck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub login_result: u16,
    pub login_result_raw: [u8; 2],
}

impl PacketAcOtpAuthAck {
    pub fn from(buffer: &[u8]) -> PacketAcOtpAuthAck {
        PacketAcOtpAuthAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            login_result: u16::from_le_bytes([buffer[4], buffer[5]]),
            login_result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.login_result).unwrap();
        self.login_result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcOtpAuthAck {
    fn id(&self) -> &str {
       "0x0823"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcFailedTradeBuyingStoreToSeller {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: i16,
    pub result_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
}

impl PacketZcFailedTradeBuyingStoreToSeller {
    pub fn from(buffer: &[u8]) -> PacketZcFailedTradeBuyingStoreToSeller {
        PacketZcFailedTradeBuyingStoreToSeller {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: i16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            itid: u16::from_le_bytes([buffer[4], buffer[5]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcFailedTradeBuyingStoreToSeller {
    fn id(&self) -> &str {
       "0x0824"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCaSsoLoginReqa {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub version: u32,
    pub version_raw: [u8; 4],
    pub clienttype: u8,
    pub clienttype_raw: [u8; 1],
    pub id: [char; 24],
    pub id_raw: [u8; 24],
    pub mac_addr: [char; 17],
    pub mac_addr_raw: [u8; 17],
    pub ip_addr: [char; 15],
    pub ip_addr_raw: [u8; 15],
    pub t1: String,
    pub t1_raw: Vec<u8>,
}

impl PacketCaSsoLoginReqa {
    pub fn from(buffer: &[u8]) -> PacketCaSsoLoginReqa {
        PacketCaSsoLoginReqa {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            version: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            clienttype: u8::from_le_bytes([buffer[8]]),
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            id:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[9..33].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[9..33]);
                dst
            },
            mac_addr:  {
                let mut dst: [char; 17] = [0 as char; 17];
                for (index, byte) in buffer[33..50].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            mac_addr_raw: {
                let mut dst: [u8; 17] = [0u8; 17];
                dst.clone_from_slice(&buffer[33..50]);
                dst
            },
            ip_addr:  {
                let mut dst: [char; 15] = [0 as char; 15];
                for (index, byte) in buffer[50..65].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            ip_addr_raw: {
                let mut dst: [u8; 15] = [0u8; 15];
                dst.clone_from_slice(&buffer[50..65]);
                dst
            },
            t1: String::from_utf8_lossy(&buffer[65..buffer.len()]).to_string(),
            t1_raw: buffer[65..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mac_addr {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mac_addr_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.ip_addr {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.ip_addr_raw = wtr.try_into().unwrap();
        self.t1_raw = self.t1.as_bytes().to_vec()
    }
}

impl Packet for PacketCaSsoLoginReqa {
    fn id(&self) -> &str {
       "0x825a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCaSsoLoginReq {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub version: u32,
    pub version_raw: [u8; 4],
    pub clienttype: u8,
    pub clienttype_raw: [u8; 1],
    pub id: [char; 24],
    pub id_raw: [u8; 24],
    pub passwd: [char; 27],
    pub passwd_raw: [u8; 27],
    pub mac_adress: [char; 17],
    pub mac_adress_raw: [u8; 17],
    pub ip: [char; 15],
    pub ip_raw: [u8; 15],
    pub t1: String,
    pub t1_raw: Vec<u8>,
}

impl PacketCaSsoLoginReq {
    pub fn from(buffer: &[u8]) -> PacketCaSsoLoginReq {
        PacketCaSsoLoginReq {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            version: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            clienttype: u8::from_le_bytes([buffer[8]]),
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            id:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[9..33].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[9..33]);
                dst
            },
            passwd:  {
                let mut dst: [char; 27] = [0 as char; 27];
                for (index, byte) in buffer[33..60].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            passwd_raw: {
                let mut dst: [u8; 27] = [0u8; 27];
                dst.clone_from_slice(&buffer[33..60]);
                dst
            },
            mac_adress:  {
                let mut dst: [char; 17] = [0 as char; 17];
                for (index, byte) in buffer[60..77].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            mac_adress_raw: {
                let mut dst: [u8; 17] = [0u8; 17];
                dst.clone_from_slice(&buffer[60..77]);
                dst
            },
            ip:  {
                let mut dst: [char; 15] = [0 as char; 15];
                for (index, byte) in buffer[77..92].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            ip_raw: {
                let mut dst: [u8; 15] = [0u8; 15];
                dst.clone_from_slice(&buffer[77..92]);
                dst
            },
            t1: String::from_utf8_lossy(&buffer[92..buffer.len()]).to_string(),
            t1_raw: buffer[92..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mac_adress {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mac_adress_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.ip {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.ip_raw = wtr.try_into().unwrap();
        self.t1_raw = self.t1.as_bytes().to_vec()
    }
}

impl Packet for PacketCaSsoLoginReq {
    fn id(&self) -> &str {
       "0x0825"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcSsoLoginAck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub result: u16,
    pub result_raw: [u8; 2],
}

impl PacketAcSsoLoginAck {
    pub fn from(buffer: &[u8]) -> PacketAcSsoLoginAck {
        PacketAcSsoLoginAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            result: u16::from_le_bytes([buffer[2], buffer[3]]),
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcSsoLoginAck {
    fn id(&self) -> &str {
       "0x0826"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketChDeleteChar3Reserved {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
}

impl PacketChDeleteChar3Reserved {
    pub fn from(buffer: &[u8]) -> PacketChDeleteChar3Reserved {
        PacketChDeleteChar3Reserved {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketChDeleteChar3Reserved {
    fn id(&self) -> &str {
       "0x0827"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketHcDeleteChar3Reserved {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub result: i32,
    pub result_raw: [u8; 4],
    pub delete_reserved_date: i32,
    pub delete_reserved_date_raw: [u8; 4],
}

impl PacketHcDeleteChar3Reserved {
    pub fn from(buffer: &[u8]) -> PacketHcDeleteChar3Reserved {
        PacketHcDeleteChar3Reserved {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            result: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            delete_reserved_date: i32::from_le_bytes([buffer[10], buffer[11], buffer[12], buffer[13]]),
            delete_reserved_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[10..14]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.delete_reserved_date).unwrap();
        self.delete_reserved_date_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketHcDeleteChar3Reserved {
    fn id(&self) -> &str {
       "0x0828"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketChDeleteChar3 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub birth: [char; 6],
    pub birth_raw: [u8; 6],
}

impl PacketChDeleteChar3 {
    pub fn from(buffer: &[u8]) -> PacketChDeleteChar3 {
        PacketChDeleteChar3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            birth:  {
                let mut dst: [char; 6] = [0 as char; 6];
                for (index, byte) in buffer[6..12].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            birth_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[6..12]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.birth {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.birth_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketChDeleteChar3 {
    fn id(&self) -> &str {
       "0x0829"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketHcDeleteChar3 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub result: i32,
    pub result_raw: [u8; 4],
}

impl PacketHcDeleteChar3 {
    pub fn from(buffer: &[u8]) -> PacketHcDeleteChar3 {
        PacketHcDeleteChar3 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            result: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketHcDeleteChar3 {
    fn id(&self) -> &str {
       "0x082a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketChDeleteChar3Cancel {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
}

impl PacketChDeleteChar3Cancel {
    pub fn from(buffer: &[u8]) -> PacketChDeleteChar3Cancel {
        PacketChDeleteChar3Cancel {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketChDeleteChar3Cancel {
    fn id(&self) -> &str {
       "0x082b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketHcDeleteChar3Cancel {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub result: i32,
    pub result_raw: [u8; 4],
}

impl PacketHcDeleteChar3Cancel {
    pub fn from(buffer: &[u8]) -> PacketHcDeleteChar3Cancel {
        PacketHcDeleteChar3Cancel {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            gid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            result: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketHcDeleteChar3Cancel {
    fn id(&self) -> &str {
       "0x082c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzSearchStoreInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub store_type: u8,
    pub store_type_raw: [u8; 1],
    pub max_price: u32,
    pub max_price_raw: [u8; 4],
    pub min_price: u32,
    pub min_price_raw: [u8; 4],
    pub item_idlist_size: u8,
    pub item_idlist_size_raw: [u8; 1],
    pub card_idlist_size: u8,
    pub card_idlist_size_raw: [u8; 1],
}

impl PacketCzSearchStoreInfo {
    pub fn from(buffer: &[u8]) -> PacketCzSearchStoreInfo {
        PacketCzSearchStoreInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            store_type: u8::from_le_bytes([buffer[4]]),
            store_type_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            max_price: u32::from_le_bytes([buffer[5], buffer[6], buffer[7], buffer[8]]),
            max_price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[5..9]);
                dst
            },
            min_price: u32::from_le_bytes([buffer[9], buffer[10], buffer[11], buffer[12]]),
            min_price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[9..13]);
                dst
            },
            item_idlist_size: u8::from_le_bytes([buffer[13]]),
            item_idlist_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[13..14]);
                dst
            },
            card_idlist_size: u8::from_le_bytes([buffer[14]]),
            card_idlist_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[14..15]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.store_type).unwrap();
        self.store_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.max_price).unwrap();
        self.max_price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.min_price).unwrap();
        self.min_price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_idlist_size).unwrap();
        self.item_idlist_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.card_idlist_size).unwrap();
        self.card_idlist_size_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzSearchStoreInfo {
    fn id(&self) -> &str {
       "0x0835"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSearchStoreInfoAck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub packet_length: i16,
    pub packet_length_raw: [u8; 2],
    pub is_first_page: bool,
    pub is_first_page_raw: [u8; 1],
    pub is_nex_page: bool,
    pub is_nex_page_raw: [u8; 1],
    pub remained_search_cnt: u8,
    pub remained_search_cnt_raw: [u8; 1],
    pub ssilist: Vec<ResultItemInfo>,
    pub ssilist_raw: Vec<Vec<u8>>,
}

impl PacketZcSearchStoreInfoAck {
    pub fn from(buffer: &[u8]) -> PacketZcSearchStoreInfoAck {
        let iter_count = &buffer.len() / 106;
        let mut vec_field: Vec<ResultItemInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 7 * i;
            let end_pos = 113 * i;
            vec_field.push(ResultItemInfo::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcSearchStoreInfoAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            packet_length: i16::from_le_bytes([buffer[2], buffer[3]]),
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            is_first_page: buffer[4] == 1,
            is_first_page_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            is_nex_page: buffer[5] == 1,
            is_nex_page_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            remained_search_cnt: u8::from_le_bytes([buffer[6]]),
            remained_search_cnt_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            ssilist: vec_field.clone(),
            ssilist_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_first_page as u8).unwrap();
        self.is_first_page_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_nex_page as u8).unwrap();
        self.is_nex_page_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.remained_search_cnt).unwrap();
        self.remained_search_cnt_raw = wtr.try_into().unwrap();
        self.ssilist_raw = {
            self.ssilist.iter_mut().for_each(|item| item.serialize());
            self.ssilist.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

impl Packet for PacketZcSearchStoreInfoAck {
    fn id(&self) -> &str {
       "0x0836"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSearchStoreInfoFailed {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub reason: u8,
    pub reason_raw: [u8; 1],
}

impl PacketZcSearchStoreInfoFailed {
    pub fn from(buffer: &[u8]) -> PacketZcSearchStoreInfoFailed {
        PacketZcSearchStoreInfoFailed {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            reason: u8::from_le_bytes([buffer[2]]),
            reason_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.reason).unwrap();
        self.reason_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSearchStoreInfoFailed {
    fn id(&self) -> &str {
       "0x0837"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzSearchStoreInfoNextPage {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzSearchStoreInfoNextPage {
    pub fn from(buffer: &[u8]) -> PacketCzSearchStoreInfoNextPage {
        PacketCzSearchStoreInfoNextPage {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzSearchStoreInfoNextPage {
    fn id(&self) -> &str {
       "0x0838"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcAckBanGuildSso {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub char_name: [char; 24],
    pub char_name_raw: [u8; 24],
    pub reason_desc: [char; 40],
    pub reason_desc_raw: [u8; 40],
}

impl PacketZcAckBanGuildSso {
    pub fn from(buffer: &[u8]) -> PacketZcAckBanGuildSso {
        PacketZcAckBanGuildSso {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            char_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[2..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[2..26]);
                dst
            },
            reason_desc:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[26..66].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            reason_desc_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[26..66]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason_desc {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_desc_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcAckBanGuildSso {
    fn id(&self) -> &str {
       "0x0839"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcOpenSearchStoreInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub open_type: i16,
    pub open_type_raw: [u8; 2],
    pub search_cnt_max: u8,
    pub search_cnt_max_raw: [u8; 1],
}

impl PacketZcOpenSearchStoreInfo {
    pub fn from(buffer: &[u8]) -> PacketZcOpenSearchStoreInfo {
        PacketZcOpenSearchStoreInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            open_type: i16::from_le_bytes([buffer[2], buffer[3]]),
            open_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            search_cnt_max: u8::from_le_bytes([buffer[4]]),
            search_cnt_max_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.open_type).unwrap();
        self.open_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.search_cnt_max).unwrap();
        self.search_cnt_max_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcOpenSearchStoreInfo {
    fn id(&self) -> &str {
       "0x083a"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzCloseSearchStoreInfo {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
}

impl PacketCzCloseSearchStoreInfo {
    pub fn from(buffer: &[u8]) -> PacketCzCloseSearchStoreInfo {
        PacketCzCloseSearchStoreInfo {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzCloseSearchStoreInfo {
    fn id(&self) -> &str {
       "0x083b"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzSsilistItemClick {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub ssiid: u32,
    pub ssiid_raw: [u8; 4],
    pub itid: u16,
    pub itid_raw: [u8; 2],
}

impl PacketCzSsilistItemClick {
    pub fn from(buffer: &[u8]) -> PacketCzSsilistItemClick {
        PacketCzSsilistItemClick {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            aid: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            ssiid: u32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            ssiid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
            itid: u16::from_le_bytes([buffer[10], buffer[11]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.ssiid).unwrap();
        self.ssiid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzSsilistItemClick {
    fn id(&self) -> &str {
       "0x083c"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketZcSsilistItemClickAck {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub x: i16,
    pub x_raw: [u8; 2],
    pub y: i16,
    pub y_raw: [u8; 2],
}

impl PacketZcSsilistItemClickAck {
    pub fn from(buffer: &[u8]) -> PacketZcSsilistItemClickAck {
        PacketZcSsilistItemClickAck {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            x: i16::from_le_bytes([buffer[2], buffer[3]]),
            x_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            y: i16::from_le_bytes([buffer[4], buffer[5]]),
            y_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x).unwrap();
        self.x_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y).unwrap();
        self.y_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketZcSsilistItemClickAck {
    fn id(&self) -> &str {
       "0x083d"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketAcRefuseLoginR2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub error_code: u32,
    pub error_code_raw: [u8; 4],
    pub block_date: [char; 20],
    pub block_date_raw: [u8; 20],
}

impl PacketAcRefuseLoginR2 {
    pub fn from(buffer: &[u8]) -> PacketAcRefuseLoginR2 {
        PacketAcRefuseLoginR2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            error_code: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            error_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            block_date:  {
                let mut dst: [char; 20] = [0 as char; 20];
                for (index, byte) in buffer[6..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            block_date_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[6..26]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.block_date {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.block_date_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketAcRefuseLoginR2 {
    fn id(&self) -> &str {
       "0x083e"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketChSelectAccessibleMapname {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub char_num: u8,
    pub char_num_raw: [u8; 1],
    pub map_list_num: u8,
    pub map_list_num_raw: [u8; 1],
}

impl PacketChSelectAccessibleMapname {
    pub fn from(buffer: &[u8]) -> PacketChSelectAccessibleMapname {
        PacketChSelectAccessibleMapname {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            char_num: u8::from_le_bytes([buffer[2]]),
            char_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            map_list_num: u8::from_le_bytes([buffer[3]]),
            map_list_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[3..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.char_num).unwrap();
        self.char_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.map_list_num).unwrap();
        self.map_list_num_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketChSelectAccessibleMapname {
    fn id(&self) -> &str {
       "0x0841"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct PacketCzRequestMove2 {
    pub raw: Vec<u8>,
    pub packet_id: i16,
    pub packet_id_raw: [u8; 2],
    pub dest: [u16; 3],
    pub dest_raw: [u8; 3],
}

impl PacketCzRequestMove2 {
    pub fn from(buffer: &[u8]) -> PacketCzRequestMove2 {
        PacketCzRequestMove2 {
            raw: buffer.to_vec(),
            packet_id: i16::from_le_bytes([buffer[0], buffer[1]]),
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            dest:  {
                let mut dst: [u16; 3] = [0 as u16; 3];
                for (index, byte) in buffer[2..5].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            },
            dest_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[2..5]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.dest {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.dest_raw = wtr.try_into().unwrap();
    }
}

impl Packet for PacketCzRequestMove2 {
    fn id(&self) -> &str {
       "0x5f03"
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}

#[derive(Clone)]
pub struct ServerAddr {
    pub raw: Vec<u8>,
    pub ip: u32,
    pub ip_raw: [u8; 4],
    pub port: i16,
    pub port_raw: [u8; 2],
    pub name: [char; 20],
    pub name_raw: [u8; 20],
    pub user_count: u16,
    pub user_count_raw: [u8; 2],
    pub state: u16,
    pub state_raw: [u8; 2],
    pub property: u16,
    pub property_raw: [u8; 2],
}

impl ServerAddr {
    pub fn from(buffer: &[u8]) -> ServerAddr {
        ServerAddr {
            raw: buffer.to_vec(),
            ip: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            port: i16::from_le_bytes([buffer[4], buffer[5]]),
            port_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            name:  {
                let mut dst: [char; 20] = [0 as char; 20];
                for (index, byte) in buffer[6..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[6..26]);
                dst
            },
            user_count: u16::from_le_bytes([buffer[26], buffer[27]]),
            user_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            state: u16::from_le_bytes([buffer[28], buffer[29]]),
            state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            property: u16::from_le_bytes([buffer[30], buffer[31]]),
            property_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.ip).unwrap();
        self.ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.port).unwrap();
        self.port_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.user_count).unwrap();
        self.user_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.property).unwrap();
        self.property_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct ServerAddr2 {
    pub raw: Vec<u8>,
    pub ip: u32,
    pub ip_raw: [u8; 4],
    pub port: i16,
    pub port_raw: [u8; 2],
    pub name: [char; 20],
    pub name_raw: [u8; 20],
    pub user_count: u16,
    pub user_count_raw: [u8; 2],
    pub state: u16,
    pub state_raw: [u8; 2],
    pub property: u16,
    pub property_raw: [u8; 2],
    pub unknown2: [char; 128],
    pub unknown2_raw: [u8; 128],
}

impl ServerAddr2 {
    pub fn from(buffer: &[u8]) -> ServerAddr2 {
        ServerAddr2 {
            raw: buffer.to_vec(),
            ip: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            port: i16::from_le_bytes([buffer[4], buffer[5]]),
            port_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            name:  {
                let mut dst: [char; 20] = [0 as char; 20];
                for (index, byte) in buffer[6..26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[6..26]);
                dst
            },
            user_count: u16::from_le_bytes([buffer[26], buffer[27]]),
            user_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
            state: u16::from_le_bytes([buffer[28], buffer[29]]),
            state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            property: u16::from_le_bytes([buffer[30], buffer[31]]),
            property_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[30..32]);
                dst
            },
            unknown2:  {
                let mut dst: [char; 128] = [0 as char; 128];
                for (index, byte) in buffer[31..159].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            unknown2_raw: {
                let mut dst: [u8; 128] = [0u8; 128];
                dst.clone_from_slice(&buffer[31..159]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.ip).unwrap();
        self.ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.port).unwrap();
        self.port_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.user_count).unwrap();
        self.user_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.property).unwrap();
        self.property_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.unknown2 {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.unknown2_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct CharacterInfoNeoUnion {
    pub raw: Vec<u8>,
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub exp: i32,
    pub exp_raw: [u8; 4],
    pub money: i32,
    pub money_raw: [u8; 4],
    pub jobexp: i32,
    pub jobexp_raw: [u8; 4],
    pub joblevel: i32,
    pub joblevel_raw: [u8; 4],
    pub bodystate: i32,
    pub bodystate_raw: [u8; 4],
    pub healthstate: i32,
    pub healthstate_raw: [u8; 4],
    pub effectstate: i32,
    pub effectstate_raw: [u8; 4],
    pub virtue: i32,
    pub virtue_raw: [u8; 4],
    pub honor: i32,
    pub honor_raw: [u8; 4],
    pub jobpoint: i16,
    pub jobpoint_raw: [u8; 2],
    pub hp: i32,
    pub hp_raw: [u8; 4],
    pub maxhp: i32,
    pub maxhp_raw: [u8; 4],
    pub sp: i16,
    pub sp_raw: [u8; 2],
    pub maxsp: i16,
    pub maxsp_raw: [u8; 2],
    pub speed: i16,
    pub speed_raw: [u8; 2],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub weapon: i16,
    pub weapon_raw: [u8; 2],
    pub level: i16,
    pub level_raw: [u8; 2],
    pub sppoint: i16,
    pub sppoint_raw: [u8; 2],
    pub accessory: i16,
    pub accessory_raw: [u8; 2],
    pub shield: i16,
    pub shield_raw: [u8; 2],
    pub accessory2: i16,
    pub accessory2_raw: [u8; 2],
    pub accessory3: i16,
    pub accessory3_raw: [u8; 2],
    pub headpalette: i16,
    pub headpalette_raw: [u8; 2],
    pub bodypalette: i16,
    pub bodypalette_raw: [u8; 2],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
    pub str: u8,
    pub str_raw: [u8; 1],
    pub agi: u8,
    pub agi_raw: [u8; 1],
    pub vit: u8,
    pub vit_raw: [u8; 1],
    pub int: u8,
    pub int_raw: [u8; 1],
    pub dex: u8,
    pub dex_raw: [u8; 1],
    pub luk: u8,
    pub luk_raw: [u8; 1],
    pub char_num: u8,
    pub char_num_raw: [u8; 1],
    pub haircolor: u8,
    pub haircolor_raw: [u8; 1],
    pub b_is_changed_char_name: i16,
    pub b_is_changed_char_name_raw: [u8; 2],
    pub last_map: [char; 16],
    pub last_map_raw: [u8; 16],
    pub delete_date: i32,
    pub delete_date_raw: [u8; 4],
    pub robe: i32,
    pub robe_raw: [u8; 4],
    pub slot_addon: i32,
    pub slot_addon_raw: [u8; 4],
    pub rename_addon: i32,
    pub rename_addon_raw: [u8; 4],
}

impl CharacterInfoNeoUnion {
    pub fn from(buffer: &[u8]) -> CharacterInfoNeoUnion {
        CharacterInfoNeoUnion {
            raw: buffer.to_vec(),
            gid: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            exp: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            money: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            money_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            jobexp: i32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            jobexp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            joblevel: i32::from_le_bytes([buffer[16], buffer[17], buffer[18], buffer[19]]),
            joblevel_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[16..20]);
                dst
            },
            bodystate: i32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            bodystate_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
            healthstate: i32::from_le_bytes([buffer[24], buffer[25], buffer[26], buffer[27]]),
            healthstate_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[24..28]);
                dst
            },
            effectstate: i32::from_le_bytes([buffer[28], buffer[29], buffer[30], buffer[31]]),
            effectstate_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[28..32]);
                dst
            },
            virtue: i32::from_le_bytes([buffer[32], buffer[33], buffer[34], buffer[35]]),
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[32..36]);
                dst
            },
            honor: i32::from_le_bytes([buffer[36], buffer[37], buffer[38], buffer[39]]),
            honor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[36..40]);
                dst
            },
            jobpoint: i16::from_le_bytes([buffer[40], buffer[41]]),
            jobpoint_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[40..42]);
                dst
            },
            hp: i32::from_le_bytes([buffer[42], buffer[43], buffer[44], buffer[45]]),
            hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[42..46]);
                dst
            },
            maxhp: i32::from_le_bytes([buffer[46], buffer[47], buffer[48], buffer[49]]),
            maxhp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[46..50]);
                dst
            },
            sp: i16::from_le_bytes([buffer[50], buffer[51]]),
            sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[50..52]);
                dst
            },
            maxsp: i16::from_le_bytes([buffer[52], buffer[53]]),
            maxsp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[52..54]);
                dst
            },
            speed: i16::from_le_bytes([buffer[54], buffer[55]]),
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[54..56]);
                dst
            },
            job: i16::from_le_bytes([buffer[56], buffer[57]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[56..58]);
                dst
            },
            head: i16::from_le_bytes([buffer[58], buffer[59]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[58..60]);
                dst
            },
            weapon: i16::from_le_bytes([buffer[60], buffer[61]]),
            weapon_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[60..62]);
                dst
            },
            level: i16::from_le_bytes([buffer[62], buffer[63]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[62..64]);
                dst
            },
            sppoint: i16::from_le_bytes([buffer[64], buffer[65]]),
            sppoint_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[64..66]);
                dst
            },
            accessory: i16::from_le_bytes([buffer[66], buffer[67]]),
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[66..68]);
                dst
            },
            shield: i16::from_le_bytes([buffer[68], buffer[69]]),
            shield_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[68..70]);
                dst
            },
            accessory2: i16::from_le_bytes([buffer[70], buffer[71]]),
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[70..72]);
                dst
            },
            accessory3: i16::from_le_bytes([buffer[72], buffer[73]]),
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[72..74]);
                dst
            },
            headpalette: i16::from_le_bytes([buffer[74], buffer[75]]),
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[74..76]);
                dst
            },
            bodypalette: i16::from_le_bytes([buffer[76], buffer[77]]),
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[76..78]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[78..102].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[78..102]);
                dst
            },
            str: u8::from_le_bytes([buffer[102]]),
            str_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[102..103]);
                dst
            },
            agi: u8::from_le_bytes([buffer[103]]),
            agi_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[103..104]);
                dst
            },
            vit: u8::from_le_bytes([buffer[104]]),
            vit_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[104..105]);
                dst
            },
            int: u8::from_le_bytes([buffer[105]]),
            int_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[105..106]);
                dst
            },
            dex: u8::from_le_bytes([buffer[106]]),
            dex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[106..107]);
                dst
            },
            luk: u8::from_le_bytes([buffer[107]]),
            luk_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[107..108]);
                dst
            },
            char_num: u8::from_le_bytes([buffer[108]]),
            char_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[108..109]);
                dst
            },
            haircolor: u8::from_le_bytes([buffer[109]]),
            haircolor_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[109..110]);
                dst
            },
            b_is_changed_char_name: i16::from_le_bytes([buffer[110], buffer[111]]),
            b_is_changed_char_name_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[110..112]);
                dst
            },
            last_map:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[112..128].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            last_map_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[112..128]);
                dst
            },
            delete_date: i32::from_le_bytes([buffer[128], buffer[129], buffer[130], buffer[131]]),
            delete_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[128..132]);
                dst
            },
            robe: i32::from_le_bytes([buffer[132], buffer[133], buffer[134], buffer[135]]),
            robe_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[132..136]);
                dst
            },
            slot_addon: i32::from_le_bytes([buffer[136], buffer[137], buffer[138], buffer[139]]),
            slot_addon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[136..140]);
                dst
            },
            rename_addon: i32::from_le_bytes([buffer[140], buffer[141], buffer[142], buffer[143]]),
            rename_addon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[140..144]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.exp).unwrap();
        self.exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.money).unwrap();
        self.money_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.jobexp).unwrap();
        self.jobexp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.joblevel).unwrap();
        self.joblevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.bodystate).unwrap();
        self.bodystate_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.healthstate).unwrap();
        self.healthstate_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effectstate).unwrap();
        self.effectstate_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.jobpoint).unwrap();
        self.jobpoint_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.maxhp).unwrap();
        self.maxhp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sp).unwrap();
        self.sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.maxsp).unwrap();
        self.maxsp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sppoint).unwrap();
        self.sppoint_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.str).unwrap();
        self.str_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.agi).unwrap();
        self.agi_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.vit).unwrap();
        self.vit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.int).unwrap();
        self.int_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dex).unwrap();
        self.dex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.luk).unwrap();
        self.luk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.char_num).unwrap();
        self.char_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.haircolor).unwrap();
        self.haircolor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.b_is_changed_char_name).unwrap();
        self.b_is_changed_char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.last_map {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.last_map_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.delete_date).unwrap();
        self.delete_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.robe).unwrap();
        self.robe_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.slot_addon).unwrap();
        self.slot_addon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.rename_addon).unwrap();
        self.rename_addon_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct ZserverAddr {
    pub raw: Vec<u8>,
    pub ip: u32,
    pub ip_raw: [u8; 4],
    pub port: i16,
    pub port_raw: [u8; 2],
}

impl ZserverAddr {
    pub fn from(buffer: &[u8]) -> ZserverAddr {
        ZserverAddr {
            raw: buffer.to_vec(),
            ip: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            port: i16::from_le_bytes([buffer[4], buffer[5]]),
            port_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.ip).unwrap();
        self.ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.port).unwrap();
        self.port_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct EQUIPSLOTINFO {
    pub raw: Vec<u8>,
    pub card1: u16,
    pub card1_raw: [u8; 2],
    pub card2: u16,
    pub card2_raw: [u8; 2],
    pub card3: u16,
    pub card3_raw: [u8; 2],
    pub card4: u16,
    pub card4_raw: [u8; 2],
}

impl EQUIPSLOTINFO {
    pub fn from(buffer: &[u8]) -> EQUIPSLOTINFO {
        EQUIPSLOTINFO {
            raw: buffer.to_vec(),
            card1: u16::from_le_bytes([buffer[0], buffer[1]]),
            card1_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            card2: u16::from_le_bytes([buffer[2], buffer[3]]),
            card2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            card3: u16::from_le_bytes([buffer[4], buffer[5]]),
            card3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            card4: u16::from_le_bytes([buffer[6], buffer[7]]),
            card4_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card1).unwrap();
        self.card1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card2).unwrap();
        self.card2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card3).unwrap();
        self.card3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card4).unwrap();
        self.card4_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct NormalitemExtrainfo {
    pub raw: Vec<u8>,
    pub index: i16,
    pub index_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub wear_state: u16,
    pub wear_state_raw: [u8; 2],
}

impl NormalitemExtrainfo {
    pub fn from(buffer: &[u8]) -> NormalitemExtrainfo {
        NormalitemExtrainfo {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: u8::from_le_bytes([buffer[4]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            is_identified: buffer[5] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            count: i16::from_le_bytes([buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            wear_state: u16::from_le_bytes([buffer[8], buffer[9]]),
            wear_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_state).unwrap();
        self.wear_state_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct EquipmentitemExtrainfo {
    pub raw: Vec<u8>,
    pub index: i16,
    pub index_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub location: u16,
    pub location_raw: [u8; 2],
    pub wear_state: u16,
    pub wear_state_raw: [u8; 2],
    pub is_damaged: bool,
    pub is_damaged_raw: [u8; 1],
    pub refining_level: u8,
    pub refining_level_raw: [u8; 1],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
}

impl EquipmentitemExtrainfo {
    pub fn from(buffer: &[u8]) -> EquipmentitemExtrainfo {
        EquipmentitemExtrainfo {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: u8::from_le_bytes([buffer[4]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            is_identified: buffer[5] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            location: u16::from_le_bytes([buffer[6], buffer[7]]),
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            wear_state: u16::from_le_bytes([buffer[8], buffer[9]]),
            wear_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            is_damaged: buffer[10] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[11]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[12..20]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[12..20]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_state).unwrap();
        self.wear_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();

    }
}

#[derive(Clone)]
pub struct PurchaseItem {
    pub raw: Vec<u8>,
    pub price: i32,
    pub price_raw: [u8; 4],
    pub discountprice: i32,
    pub discountprice_raw: [u8; 4],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub itid: u16,
    pub itid_raw: [u8; 2],
}

impl PurchaseItem {
    pub fn from(buffer: &[u8]) -> PurchaseItem {
        PurchaseItem {
            raw: buffer.to_vec(),
            price: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            discountprice: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            discountprice_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            atype: u8::from_le_bytes([buffer[8]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            itid: u16::from_le_bytes([buffer[9], buffer[10]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.discountprice).unwrap();
        self.discountprice_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct SellItem {
    pub raw: Vec<u8>,
    pub index: i16,
    pub index_raw: [u8; 2],
    pub price: i32,
    pub price_raw: [u8; 4],
    pub overchargeprice: i32,
    pub overchargeprice_raw: [u8; 4],
}

impl SellItem {
    pub fn from(buffer: &[u8]) -> SellItem {
        SellItem {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            price: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            overchargeprice: i32::from_le_bytes([buffer[6], buffer[7], buffer[8], buffer[9]]),
            overchargeprice_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[6..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.overchargeprice).unwrap();
        self.overchargeprice_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct CzPurchaseItem {
    pub raw: Vec<u8>,
    pub count: i16,
    pub count_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
}

impl CzPurchaseItem {
    pub fn from(buffer: &[u8]) -> CzPurchaseItem {
        CzPurchaseItem {
            raw: buffer.to_vec(),
            count: i16::from_le_bytes([buffer[0], buffer[1]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct CzSellItem {
    pub raw: Vec<u8>,
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
}

impl CzSellItem {
    pub fn from(buffer: &[u8]) -> CzSellItem {
        CzSellItem {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            count: i16::from_le_bytes([buffer[2], buffer[3]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct WhisperItem {
    pub raw: Vec<u8>,
    pub name: [char; 24],
    pub name_raw: [u8; 24],
}

impl WhisperItem {
    pub fn from(buffer: &[u8]) -> WhisperItem {
        WhisperItem {
            raw: buffer.to_vec(),
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[0..24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[0..24]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct RoomMember {
    pub raw: Vec<u8>,
    pub role: u32,
    pub role_raw: [u8; 4],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
}

impl RoomMember {
    pub fn from(buffer: &[u8]) -> RoomMember {
        RoomMember {
            raw: buffer.to_vec(),
            role: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            role_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.role).unwrap();
        self.role_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct GroupmemberInfo {
    pub raw: Vec<u8>,
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub character_name: [char; 24],
    pub character_name_raw: [u8; 24],
    pub map_name: [char; 16],
    pub map_name_raw: [u8; 16],
    pub role: u8,
    pub role_raw: [u8; 1],
    pub state: u8,
    pub state_raw: [u8; 1],
}

impl GroupmemberInfo {
    pub fn from(buffer: &[u8]) -> GroupmemberInfo {
        GroupmemberInfo {
            raw: buffer.to_vec(),
            aid: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            character_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
            map_name:  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[28..44].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[28..44]);
                dst
            },
            role: u8::from_le_bytes([buffer[44]]),
            role_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[44..45]);
                dst
            },
            state: u8::from_le_bytes([buffer[45]]),
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[45..46]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.role).unwrap();
        self.role_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct SKILLINFO {
    pub raw: Vec<u8>,
    pub skid: i16,
    pub skid_raw: [u8; 2],
    pub atype: i32,
    pub atype_raw: [u8; 4],
    pub level: i16,
    pub level_raw: [u8; 2],
    pub spcost: i16,
    pub spcost_raw: [u8; 2],
    pub attack_range: i16,
    pub attack_range_raw: [u8; 2],
    pub skill_name: [char; 24],
    pub skill_name_raw: [u8; 24],
    pub upgradable: i8,
    pub upgradable_raw: [u8; 1],
}

impl SKILLINFO {
    pub fn from(buffer: &[u8]) -> SKILLINFO {
        SKILLINFO {
            raw: buffer.to_vec(),
            skid: i16::from_le_bytes([buffer[0], buffer[1]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            atype: i32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
            level: i16::from_le_bytes([buffer[6], buffer[7]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            spcost: i16::from_le_bytes([buffer[8], buffer[9]]),
            spcost_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            attack_range: i16::from_le_bytes([buffer[10], buffer[11]]),
            attack_range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            skill_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[12..36].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            skill_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[12..36]);
                dst
            },
            upgradable: i8::from_le_bytes([buffer[36]]),
            upgradable_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[36..37]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.spcost).unwrap();
        self.spcost_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.attack_range).unwrap();
        self.attack_range_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.skill_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.skill_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.upgradable).unwrap();
        self.upgradable_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct StoreItem {
    pub raw: Vec<u8>,
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub price: i32,
    pub price_raw: [u8; 4],
}

impl StoreItem {
    pub fn from(buffer: &[u8]) -> StoreItem {
        StoreItem {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            count: i16::from_le_bytes([buffer[2], buffer[3]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            price: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct PurchaseItemFrommc {
    pub raw: Vec<u8>,
    pub price: i32,
    pub price_raw: [u8; 4],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub is_identified: u8,
    pub is_identified_raw: [u8; 1],
    pub is_damaged: u8,
    pub is_damaged_raw: [u8; 1],
    pub refining_level: u8,
    pub refining_level_raw: [u8; 1],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
}

impl PurchaseItemFrommc {
    pub fn from(buffer: &[u8]) -> PurchaseItemFrommc {
        PurchaseItemFrommc {
            raw: buffer.to_vec(),
            price: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            index: i16::from_le_bytes([buffer[6], buffer[7]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            atype: u8::from_le_bytes([buffer[8]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            itid: u16::from_le_bytes([buffer[9], buffer[10]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            is_identified: u8::from_le_bytes([buffer[11]]),
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            is_damaged: u8::from_le_bytes([buffer[12]]),
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[13]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[13..14]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[14..22]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[14..22]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();

    }
}

#[derive(Clone)]
pub struct CzPurchaseItemFrommc {
    pub raw: Vec<u8>,
    pub count: i16,
    pub count_raw: [u8; 2],
    pub index: i16,
    pub index_raw: [u8; 2],
}

impl CzPurchaseItemFrommc {
    pub fn from(buffer: &[u8]) -> CzPurchaseItemFrommc {
        CzPurchaseItemFrommc {
            raw: buffer.to_vec(),
            count: i16::from_le_bytes([buffer[0], buffer[1]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            index: i16::from_le_bytes([buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct PurchaseMyitem {
    pub raw: Vec<u8>,
    pub price: i32,
    pub price_raw: [u8; 4],
    pub index: i16,
    pub index_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub is_identified: u8,
    pub is_identified_raw: [u8; 1],
    pub is_damaged: u8,
    pub is_damaged_raw: [u8; 1],
    pub refining_level: u8,
    pub refining_level_raw: [u8; 1],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
}

impl PurchaseMyitem {
    pub fn from(buffer: &[u8]) -> PurchaseMyitem {
        PurchaseMyitem {
            raw: buffer.to_vec(),
            price: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            index: i16::from_le_bytes([buffer[4], buffer[5]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            count: i16::from_le_bytes([buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            atype: u8::from_le_bytes([buffer[8]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
            itid: u16::from_le_bytes([buffer[9], buffer[10]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[9..11]);
                dst
            },
            is_identified: u8::from_le_bytes([buffer[11]]),
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            is_damaged: u8::from_le_bytes([buffer[12]]),
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[12..13]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[13]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[13..14]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[14..22]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[14..22]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();

    }
}

#[derive(Clone)]
pub struct RelatedGuild {
    pub raw: Vec<u8>,
    pub gdid: i32,
    pub gdid_raw: [u8; 4],
    pub relation: i32,
    pub relation_raw: [u8; 4],
    pub guild_name: [char; 24],
    pub guild_name_raw: [u8; 24],
}

impl RelatedGuild {
    pub fn from(buffer: &[u8]) -> RelatedGuild {
        RelatedGuild {
            raw: buffer.to_vec(),
            gdid: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            relation: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            relation_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            guild_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[8..32].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            guild_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[8..32]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.relation).unwrap();
        self.relation_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.guild_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guild_name_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct GuildMembermgrInfo {
    pub raw: Vec<u8>,
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub head_type: i16,
    pub head_type_raw: [u8; 2],
    pub head_palette: i16,
    pub head_palette_raw: [u8; 2],
    pub sex: i16,
    pub sex_raw: [u8; 2],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub level: i16,
    pub level_raw: [u8; 2],
    pub member_exp: i32,
    pub member_exp_raw: [u8; 4],
    pub current_state: i32,
    pub current_state_raw: [u8; 4],
    pub gposition_id: i32,
    pub gposition_id_raw: [u8; 4],
    pub memo: [char; 50],
    pub memo_raw: [u8; 50],
    pub char_name: [char; 24],
    pub char_name_raw: [u8; 24],
}

impl GuildMembermgrInfo {
    pub fn from(buffer: &[u8]) -> GuildMembermgrInfo {
        GuildMembermgrInfo {
            raw: buffer.to_vec(),
            aid: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            gid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            head_type: i16::from_le_bytes([buffer[8], buffer[9]]),
            head_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            head_palette: i16::from_le_bytes([buffer[10], buffer[11]]),
            head_palette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            sex: i16::from_le_bytes([buffer[12], buffer[13]]),
            sex_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: i16::from_le_bytes([buffer[14], buffer[15]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            level: i16::from_le_bytes([buffer[16], buffer[17]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            member_exp: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            member_exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
            current_state: i32::from_le_bytes([buffer[22], buffer[23], buffer[24], buffer[25]]),
            current_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[22..26]);
                dst
            },
            gposition_id: i32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            gposition_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
            memo:  {
                let mut dst: [char; 50] = [0 as char; 50];
                for (index, byte) in buffer[30..80].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            memo_raw: {
                let mut dst: [u8; 50] = [0u8; 50];
                dst.clone_from_slice(&buffer[30..80]);
                dst
            },
            char_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[80..104].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[80..104]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_type).unwrap();
        self.head_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_palette).unwrap();
        self.head_palette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.member_exp).unwrap();
        self.member_exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.current_state).unwrap();
        self.current_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gposition_id).unwrap();
        self.gposition_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.memo {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.memo_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct MemberPositionInfo {
    pub raw: Vec<u8>,
    pub aid: i32,
    pub aid_raw: [u8; 4],
    pub gid: i32,
    pub gid_raw: [u8; 4],
    pub position_id: i32,
    pub position_id_raw: [u8; 4],
}

impl MemberPositionInfo {
    pub fn from(buffer: &[u8]) -> MemberPositionInfo {
        MemberPositionInfo {
            raw: buffer.to_vec(),
            aid: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            gid: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            position_id: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            position_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.position_id).unwrap();
        self.position_id_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct GuildMemberPositionInfo {
    pub raw: Vec<u8>,
    pub position_id: i32,
    pub position_id_raw: [u8; 4],
    pub right: i32,
    pub right_raw: [u8; 4],
    pub ranking: i32,
    pub ranking_raw: [u8; 4],
    pub pay_rate: i32,
    pub pay_rate_raw: [u8; 4],
}

impl GuildMemberPositionInfo {
    pub fn from(buffer: &[u8]) -> GuildMemberPositionInfo {
        GuildMemberPositionInfo {
            raw: buffer.to_vec(),
            position_id: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            position_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            right: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            right_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            ranking: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            ranking_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            pay_rate: i32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            pay_rate_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.position_id).unwrap();
        self.position_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.right).unwrap();
        self.right_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.ranking).unwrap();
        self.ranking_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.pay_rate).unwrap();
        self.pay_rate_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct GuildRegPositionInfo {
    pub raw: Vec<u8>,
    pub position_id: i32,
    pub position_id_raw: [u8; 4],
    pub right: i32,
    pub right_raw: [u8; 4],
    pub ranking: i32,
    pub ranking_raw: [u8; 4],
    pub pay_rate: i32,
    pub pay_rate_raw: [u8; 4],
    pub pos_name: [char; 24],
    pub pos_name_raw: [u8; 24],
}

impl GuildRegPositionInfo {
    pub fn from(buffer: &[u8]) -> GuildRegPositionInfo {
        GuildRegPositionInfo {
            raw: buffer.to_vec(),
            position_id: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            position_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            right: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            right_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            ranking: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            ranking_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            pay_rate: i32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            pay_rate_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
            pos_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[16..40].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[16..40]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.position_id).unwrap();
        self.position_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.right).unwrap();
        self.right_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.ranking).unwrap();
        self.ranking_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.pay_rate).unwrap();
        self.pay_rate_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_name_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct GuildBanInfo {
    pub raw: Vec<u8>,
    pub charname: [char; 24],
    pub charname_raw: [u8; 24],
    pub account: [char; 24],
    pub account_raw: [u8; 24],
    pub reason: [char; 40],
    pub reason_raw: [u8; 40],
}

impl GuildBanInfo {
    pub fn from(buffer: &[u8]) -> GuildBanInfo {
        GuildBanInfo {
            raw: buffer.to_vec(),
            charname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[0..24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            charname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[0..24]);
                dst
            },
            account:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[24..48].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            account_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[24..48]);
                dst
            },
            reason:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[48..88].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            reason_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[48..88]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        for item in self.charname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.charname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.account {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.account_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct OtherGuildInfo {
    pub raw: Vec<u8>,
    pub guildname: [char; 24],
    pub guildname_raw: [u8; 24],
    pub guild_level: i32,
    pub guild_level_raw: [u8; 4],
    pub guild_member_size: i32,
    pub guild_member_size_raw: [u8; 4],
    pub guild_ranking: i32,
    pub guild_ranking_raw: [u8; 4],
}

impl OtherGuildInfo {
    pub fn from(buffer: &[u8]) -> OtherGuildInfo {
        OtherGuildInfo {
            raw: buffer.to_vec(),
            guildname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[0..24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            guildname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[0..24]);
                dst
            },
            guild_level: i32::from_le_bytes([buffer[24], buffer[25], buffer[26], buffer[27]]),
            guild_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[24..28]);
                dst
            },
            guild_member_size: i32::from_le_bytes([buffer[28], buffer[29], buffer[30], buffer[31]]),
            guild_member_size_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[28..32]);
                dst
            },
            guild_ranking: i32::from_le_bytes([buffer[32], buffer[33], buffer[34], buffer[35]]),
            guild_ranking_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[32..36]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        for item in self.guildname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guildname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.guild_level).unwrap();
        self.guild_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.guild_member_size).unwrap();
        self.guild_member_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.guild_ranking).unwrap();
        self.guild_ranking_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct MemberPositionIdNameInfo {
    pub raw: Vec<u8>,
    pub position_id: i32,
    pub position_id_raw: [u8; 4],
    pub pos_name: [char; 24],
    pub pos_name_raw: [u8; 24],
}

impl MemberPositionIdNameInfo {
    pub fn from(buffer: &[u8]) -> MemberPositionIdNameInfo {
        MemberPositionIdNameInfo {
            raw: buffer.to_vec(),
            position_id: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            position_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            pos_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            pos_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.position_id).unwrap();
        self.position_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_name_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct GuildMemberInfo {
    pub raw: Vec<u8>,
    pub aid: i32,
    pub aid_raw: [u8; 4],
    pub gid: i32,
    pub gid_raw: [u8; 4],
    pub head: i16,
    pub head_raw: [u8; 2],
    pub head_palette: i16,
    pub head_palette_raw: [u8; 2],
    pub sex: i16,
    pub sex_raw: [u8; 2],
    pub job: i16,
    pub job_raw: [u8; 2],
    pub level: i16,
    pub level_raw: [u8; 2],
    pub contribution_exp: i32,
    pub contribution_exp_raw: [u8; 4],
    pub current_state: i32,
    pub current_state_raw: [u8; 4],
    pub position_id: i32,
    pub position_id_raw: [u8; 4],
    pub intro: [char; 50],
    pub intro_raw: [u8; 50],
    pub charname: [char; 24],
    pub charname_raw: [u8; 24],
}

impl GuildMemberInfo {
    pub fn from(buffer: &[u8]) -> GuildMemberInfo {
        GuildMemberInfo {
            raw: buffer.to_vec(),
            aid: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            gid: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            head: i16::from_le_bytes([buffer[8], buffer[9]]),
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            head_palette: i16::from_le_bytes([buffer[10], buffer[11]]),
            head_palette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
            sex: i16::from_le_bytes([buffer[12], buffer[13]]),
            sex_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            job: i16::from_le_bytes([buffer[14], buffer[15]]),
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[14..16]);
                dst
            },
            level: i16::from_le_bytes([buffer[16], buffer[17]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[16..18]);
                dst
            },
            contribution_exp: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            contribution_exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
            current_state: i32::from_le_bytes([buffer[22], buffer[23], buffer[24], buffer[25]]),
            current_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[22..26]);
                dst
            },
            position_id: i32::from_le_bytes([buffer[26], buffer[27], buffer[28], buffer[29]]),
            position_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[26..30]);
                dst
            },
            intro:  {
                let mut dst: [char; 50] = [0 as char; 50];
                for (index, byte) in buffer[30..80].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            intro_raw: {
                let mut dst: [u8; 50] = [0u8; 50];
                dst.clone_from_slice(&buffer[30..80]);
                dst
            },
            charname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[80..104].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            charname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[80..104]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_palette).unwrap();
        self.head_palette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.contribution_exp).unwrap();
        self.contribution_exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.current_state).unwrap();
        self.current_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.position_id).unwrap();
        self.position_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.intro {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.intro_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.charname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.charname_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct RelatedGuildInfo {
    pub raw: Vec<u8>,
    pub relation: i32,
    pub relation_raw: [u8; 4],
    pub gdid: i32,
    pub gdid_raw: [u8; 4],
    pub guildname: [char; 24],
    pub guildname_raw: [u8; 24],
}

impl RelatedGuildInfo {
    pub fn from(buffer: &[u8]) -> RelatedGuildInfo {
        RelatedGuildInfo {
            raw: buffer.to_vec(),
            relation: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            relation_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            gdid: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            guildname:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[8..32].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            guildname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[8..32]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.relation).unwrap();
        self.relation_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.guildname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guildname_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct MonsterInfoElement {
    pub raw: Vec<u8>,
    pub water: u8,
    pub water_raw: [u8; 1],
    pub earth: u8,
    pub earth_raw: [u8; 1],
    pub fire: u8,
    pub fire_raw: [u8; 1],
    pub wind: u8,
    pub wind_raw: [u8; 1],
    pub poison: u8,
    pub poison_raw: [u8; 1],
    pub saint: u8,
    pub saint_raw: [u8; 1],
    pub dark: u8,
    pub dark_raw: [u8; 1],
    pub mental: u8,
    pub mental_raw: [u8; 1],
    pub undead: u8,
    pub undead_raw: [u8; 1],
}

impl MonsterInfoElement {
    pub fn from(buffer: &[u8]) -> MonsterInfoElement {
        MonsterInfoElement {
            raw: buffer.to_vec(),
            water: u8::from_le_bytes([buffer[0]]),
            water_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[0..1]);
                dst
            },
            earth: u8::from_le_bytes([buffer[1]]),
            earth_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[1..2]);
                dst
            },
            fire: u8::from_le_bytes([buffer[2]]),
            fire_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[2..3]);
                dst
            },
            wind: u8::from_le_bytes([buffer[3]]),
            wind_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[3..4]);
                dst
            },
            poison: u8::from_le_bytes([buffer[4]]),
            poison_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            saint: u8::from_le_bytes([buffer[5]]),
            saint_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            dark: u8::from_le_bytes([buffer[6]]),
            dark_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            mental: u8::from_le_bytes([buffer[7]]),
            mental_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[7..8]);
                dst
            },
            undead: u8::from_le_bytes([buffer[8]]),
            undead_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[8..9]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u8(self.water).unwrap();
        self.water_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.earth).unwrap();
        self.earth_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.fire).unwrap();
        self.fire_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.wind).unwrap();
        self.wind_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.poison).unwrap();
        self.poison_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.saint).unwrap();
        self.saint_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dark).unwrap();
        self.dark_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.mental).unwrap();
        self.mental_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.undead).unwrap();
        self.undead_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct MakableitemInfo {
    pub raw: Vec<u8>,
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub material_id: [u16; 3],
    pub material_id_raw: [u8; 3],
}

impl MakableitemInfo {
    pub fn from(buffer: &[u8]) -> MakableitemInfo {
        MakableitemInfo {
            raw: buffer.to_vec(),
            itid: u16::from_le_bytes([buffer[0], buffer[1]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            material_id:  {
                let mut dst: [u16; 3] = [0 as u16; 3];
                for (index, byte) in buffer[2..5].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            },
            material_id_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[2..5]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.material_id {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.material_id_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct PeteggitemInfo {
    pub raw: Vec<u8>,
    pub index: i16,
    pub index_raw: [u8; 2],
}

impl PeteggitemInfo {
    pub fn from(buffer: &[u8]) -> PeteggitemInfo {
        PeteggitemInfo {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct ArrowitemInfo {
    pub raw: Vec<u8>,
    pub index: i16,
    pub index_raw: [u8; 2],
}

impl ArrowitemInfo {
    pub fn from(buffer: &[u8]) -> ArrowitemInfo {
        ArrowitemInfo {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct NormalitemExtrainfo2 {
    pub raw: Vec<u8>,
    pub index: i16,
    pub index_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub wear_state: u16,
    pub wear_state_raw: [u8; 2],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
}

impl NormalitemExtrainfo2 {
    pub fn from(buffer: &[u8]) -> NormalitemExtrainfo2 {
        NormalitemExtrainfo2 {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: u8::from_le_bytes([buffer[4]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            is_identified: buffer[5] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            count: i16::from_le_bytes([buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            wear_state: u16::from_le_bytes([buffer[8], buffer[9]]),
            wear_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[10..18]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[10..18]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_state).unwrap();
        self.wear_state_raw = wtr.try_into().unwrap();

    }
}

#[derive(Clone)]
pub struct RepairitemInfo {
    pub raw: Vec<u8>,
    pub index: i16,
    pub index_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub refining_level: u8,
    pub refining_level_raw: [u8; 1],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
}

impl RepairitemInfo {
    pub fn from(buffer: &[u8]) -> RepairitemInfo {
        RepairitemInfo {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[4]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[5..13]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[5..13]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();

    }
}

#[derive(Clone)]
pub struct StructFriend {
    pub raw: Vec<u8>,
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub name: [char; 24],
    pub name_raw: [u8; 24],
}

impl StructFriend {
    pub fn from(buffer: &[u8]) -> StructFriend {
        StructFriend {
            raw: buffer.to_vec(),
            aid: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            gid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[8..32].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[8..32]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct TagCharacterBlockInfo {
    pub raw: Vec<u8>,
    pub gid: u32,
    pub gid_raw: [u8; 4],
    pub sz_expire_date: [char; 20],
    pub sz_expire_date_raw: [u8; 20],
}

impl TagCharacterBlockInfo {
    pub fn from(buffer: &[u8]) -> TagCharacterBlockInfo {
        TagCharacterBlockInfo {
            raw: buffer.to_vec(),
            gid: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            sz_expire_date:  {
                let mut dst: [char; 20] = [0 as char; 20];
                for (index, byte) in buffer[4..24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            sz_expire_date_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[4..24]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_expire_date {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_expire_date_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct PVPINFO {
    pub raw: Vec<u8>,
    pub win_point: i32,
    pub win_point_raw: [u8; 4],
    pub lose_point: i32,
    pub lose_point_raw: [u8; 4],
    pub point: i32,
    pub point_raw: [u8; 4],
}

impl PVPINFO {
    pub fn from(buffer: &[u8]) -> PVPINFO {
        PVPINFO {
            raw: buffer.to_vec(),
            win_point: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            win_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            lose_point: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            lose_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            point: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.win_point).unwrap();
        self.win_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.lose_point).unwrap();
        self.lose_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct Filetime {
    pub raw: Vec<u8>,
    pub dw_low_date_time: u32,
    pub dw_low_date_time_raw: [u8; 4],
    pub dw_high_date_time: u32,
    pub dw_high_date_time_raw: [u8; 4],
}

impl Filetime {
    pub fn from(buffer: &[u8]) -> Filetime {
        Filetime {
            raw: buffer.to_vec(),
            dw_low_date_time: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            dw_low_date_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            dw_high_date_time: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            dw_high_date_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_low_date_time).unwrap();
        self.dw_low_date_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_high_date_time).unwrap();
        self.dw_high_date_time_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct MailList {
    pub raw: Vec<u8>,
    pub mail_id: u32,
    pub mail_id_raw: [u8; 4],
    pub header: [char; 40],
    pub header_raw: [u8; 40],
    pub is_open: i8,
    pub is_open_raw: [u8; 1],
    pub from_name: [char; 24],
    pub from_name_raw: [u8; 24],
    pub delete_time: i32,
    pub delete_time_raw: [u8; 4],
}

impl MailList {
    pub fn from(buffer: &[u8]) -> MailList {
        MailList {
            raw: buffer.to_vec(),
            mail_id: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            header:  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[4..44].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            header_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[4..44]);
                dst
            },
            is_open: i8::from_le_bytes([buffer[44]]),
            is_open_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[44..45]);
                dst
            },
            from_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[45..69].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            from_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[45..69]);
                dst
            },
            delete_time: i32::from_le_bytes([buffer[69], buffer[70], buffer[71], buffer[72]]),
            delete_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[69..73]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.header {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.header_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.is_open).unwrap();
        self.is_open_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.from_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.from_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.delete_time).unwrap();
        self.delete_time_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct AuctionItemSearchInfo {
    pub raw: Vec<u8>,
    pub auction_id: u32,
    pub auction_id_raw: [u8; 4],
    pub seller_name: [char; 24],
    pub seller_name_raw: [u8; 24],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub atype: i32,
    pub atype_raw: [u8; 4],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub is_damaged: bool,
    pub is_damaged_raw: [u8; 1],
    pub refining_level: u8,
    pub refining_level_raw: [u8; 1],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
    pub now_price: i32,
    pub now_price_raw: [u8; 4],
    pub max_price: i32,
    pub max_price_raw: [u8; 4],
    pub buyer_name: [char; 24],
    pub buyer_name_raw: [u8; 24],
    pub delete_time: i32,
    pub delete_time_raw: [u8; 4],
}

impl AuctionItemSearchInfo {
    pub fn from(buffer: &[u8]) -> AuctionItemSearchInfo {
        AuctionItemSearchInfo {
            raw: buffer.to_vec(),
            auction_id: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            auction_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            seller_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            seller_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
            itid: u16::from_le_bytes([buffer[28], buffer[29]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[28..30]);
                dst
            },
            atype: i32::from_le_bytes([buffer[30], buffer[31], buffer[32], buffer[33]]),
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[30..34]);
                dst
            },
            count: i16::from_le_bytes([buffer[34], buffer[35]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[34..36]);
                dst
            },
            is_identified: buffer[36] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[36..37]);
                dst
            },
            is_damaged: buffer[37] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[37..38]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[38]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[38..39]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[39..47]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[39..47]);
                dst
            },
            now_price: i32::from_le_bytes([buffer[47], buffer[48], buffer[49], buffer[50]]),
            now_price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[47..51]);
                dst
            },
            max_price: i32::from_le_bytes([buffer[51], buffer[52], buffer[53], buffer[54]]),
            max_price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[51..55]);
                dst
            },
            buyer_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[55..79].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            buyer_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[55..79]);
                dst
            },
            delete_time: i32::from_le_bytes([buffer[79], buffer[80], buffer[81], buffer[82]]),
            delete_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[79..83]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.auction_id).unwrap();
        self.auction_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.seller_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.seller_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.now_price).unwrap();
        self.now_price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_price).unwrap();
        self.max_price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.buyer_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.buyer_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.delete_time).unwrap();
        self.delete_time_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct PacketMobHunting {
    pub raw: Vec<u8>,
    pub quest_id: u32,
    pub quest_id_raw: [u8; 4],
    pub mob_gid: u32,
    pub mob_gid_raw: [u8; 4],
    pub max_count: i16,
    pub max_count_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
}

impl PacketMobHunting {
    pub fn from(buffer: &[u8]) -> PacketMobHunting {
        PacketMobHunting {
            raw: buffer.to_vec(),
            quest_id: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            mob_gid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            mob_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            max_count: i16::from_le_bytes([buffer[8], buffer[9]]),
            max_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            count: i16::from_le_bytes([buffer[10], buffer[11]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[10..12]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.mob_gid).unwrap();
        self.mob_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_count).unwrap();
        self.max_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct EquipmentitemExtrainfo2 {
    pub raw: Vec<u8>,
    pub index: i16,
    pub index_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub location: u16,
    pub location_raw: [u8; 2],
    pub wear_state: u16,
    pub wear_state_raw: [u8; 2],
    pub is_damaged: bool,
    pub is_damaged_raw: [u8; 1],
    pub refining_level: u8,
    pub refining_level_raw: [u8; 1],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
    pub hire_expire_date: i32,
    pub hire_expire_date_raw: [u8; 4],
}

impl EquipmentitemExtrainfo2 {
    pub fn from(buffer: &[u8]) -> EquipmentitemExtrainfo2 {
        EquipmentitemExtrainfo2 {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: u8::from_le_bytes([buffer[4]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            is_identified: buffer[5] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            location: u16::from_le_bytes([buffer[6], buffer[7]]),
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            wear_state: u16::from_le_bytes([buffer[8], buffer[9]]),
            wear_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            is_damaged: buffer[10] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[11]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[12..20]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[12..20]);
                dst
            },
            hire_expire_date: i32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            hire_expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_state).unwrap();
        self.wear_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hire_expire_date).unwrap();
        self.hire_expire_date_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct PggLingoKeyTemp {
    pub raw: Vec<u8>,
    pub dw_alg_num: u32,
    pub dw_alg_num_raw: [u8; 4],
    pub dw_alg_key1: u32,
    pub dw_alg_key1_raw: [u8; 4],
    pub dw_alg_key2: u32,
    pub dw_alg_key2_raw: [u8; 4],
    pub dw_seed: u32,
    pub dw_seed_raw: [u8; 4],
}

impl PggLingoKeyTemp {
    pub fn from(buffer: &[u8]) -> PggLingoKeyTemp {
        PggLingoKeyTemp {
            raw: buffer.to_vec(),
            dw_alg_num: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            dw_alg_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            dw_alg_key1: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            dw_alg_key1_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            dw_alg_key2: u32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            dw_alg_key2_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            dw_seed: u32::from_le_bytes([buffer[12], buffer[13], buffer[14], buffer[15]]),
            dw_seed_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[12..16]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_alg_num).unwrap();
        self.dw_alg_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_alg_key1).unwrap();
        self.dw_alg_key1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_alg_key2).unwrap();
        self.dw_alg_key2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_seed).unwrap();
        self.dw_seed_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct PacketZcQuestInfo {
    pub raw: Vec<u8>,
    pub quest_id: u32,
    pub quest_id_raw: [u8; 4],
    pub active: bool,
    pub active_raw: [u8; 1],
}

impl PacketZcQuestInfo {
    pub fn from(buffer: &[u8]) -> PacketZcQuestInfo {
        PacketZcQuestInfo {
            raw: buffer.to_vec(),
            quest_id: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            active: buffer[4] == 1,
            active_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.active as u8).unwrap();
        self.active_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct PacketZcMissionHunt {
    pub raw: Vec<u8>,
    pub mob_gid: u32,
    pub mob_gid_raw: [u8; 4],
    pub hunt_count: i16,
    pub hunt_count_raw: [u8; 2],
    pub mob_name: [char; 24],
    pub mob_name_raw: [u8; 24],
}

impl PacketZcMissionHunt {
    pub fn from(buffer: &[u8]) -> PacketZcMissionHunt {
        PacketZcMissionHunt {
            raw: buffer.to_vec(),
            mob_gid: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            mob_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            hunt_count: i16::from_le_bytes([buffer[4], buffer[5]]),
            hunt_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            mob_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[6..30].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            mob_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[6..30]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.mob_gid).unwrap();
        self.mob_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hunt_count).unwrap();
        self.hunt_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mob_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mob_name_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct PacketZcQuestMissionInfo {
    pub raw: Vec<u8>,
    pub quest_id: u32,
    pub quest_id_raw: [u8; 4],
    pub quest_svr_time: i32,
    pub quest_svr_time_raw: [u8; 4],
    pub quest_end_time: i32,
    pub quest_end_time_raw: [u8; 4],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub hunt: Vec<PacketZcMissionHunt>,
    pub hunt_raw: Vec<Vec<u8>>,
}

impl PacketZcQuestMissionInfo {
    pub fn from(buffer: &[u8]) -> PacketZcQuestMissionInfo {
        let iter_count = &buffer.len() / 30;
        let mut vec_field: Vec<PacketZcMissionHunt> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 14 * i;
            let end_pos = 44 * i;
            vec_field.push(PacketZcMissionHunt::from(&buffer[start_pos..end_pos]));
            i += 1;
        }
        PacketZcQuestMissionInfo {
            raw: buffer.to_vec(),
            quest_id: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            quest_svr_time: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            quest_svr_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            quest_end_time: i32::from_le_bytes([buffer[8], buffer[9], buffer[10], buffer[11]]),
            quest_end_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[8..12]);
                dst
            },
            count: i16::from_le_bytes([buffer[12], buffer[13]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[12..14]);
                dst
            },
            hunt: vec_field.clone(),
            hunt_raw: vec_field.iter().map(|item| item.raw.clone()).collect::<Vec<Vec<u8>>>(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.quest_svr_time).unwrap();
        self.quest_svr_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.quest_end_time).unwrap();
        self.quest_end_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        self.hunt_raw = {
            self.hunt.iter_mut().for_each(|item| item.serialize());
            self.hunt.iter().map(|item| item.raw.clone()).collect()
      };

    }
}

#[derive(Clone)]
pub struct ShortCutKey {
    pub raw: Vec<u8>,
    pub is_skill: i8,
    pub is_skill_raw: [u8; 1],
    pub id: u32,
    pub id_raw: [u8; 4],
    pub count: i16,
    pub count_raw: [u8; 2],
}

impl ShortCutKey {
    pub fn from(buffer: &[u8]) -> ShortCutKey {
        ShortCutKey {
            raw: buffer.to_vec(),
            is_skill: i8::from_le_bytes([buffer[0]]),
            is_skill_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[0..1]);
                dst
            },
            id: u32::from_le_bytes([buffer[1], buffer[2], buffer[3], buffer[4]]),
            id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[1..5]);
                dst
            },
            count: i16::from_le_bytes([buffer[5], buffer[6]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[5..7]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i8(self.is_skill).unwrap();
        self.is_skill_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.id).unwrap();
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct EquipmentitemExtrainfo301 {
    pub raw: Vec<u8>,
    pub index: i16,
    pub index_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub location: u16,
    pub location_raw: [u8; 2],
    pub wear_state: u16,
    pub wear_state_raw: [u8; 2],
    pub is_damaged: bool,
    pub is_damaged_raw: [u8; 1],
    pub refining_level: u8,
    pub refining_level_raw: [u8; 1],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
    pub hire_expire_date: i32,
    pub hire_expire_date_raw: [u8; 4],
    pub bind_on_equip_type: u16,
    pub bind_on_equip_type_raw: [u8; 2],
    pub w_item_sprite_number: u16,
    pub w_item_sprite_number_raw: [u8; 2],
}

impl EquipmentitemExtrainfo301 {
    pub fn from(buffer: &[u8]) -> EquipmentitemExtrainfo301 {
        EquipmentitemExtrainfo301 {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: u8::from_le_bytes([buffer[4]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            is_identified: buffer[5] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            location: u16::from_le_bytes([buffer[6], buffer[7]]),
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            wear_state: u16::from_le_bytes([buffer[8], buffer[9]]),
            wear_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            is_damaged: buffer[10] == 1,
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[10..11]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[11]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[11..12]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[12..20]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[12..20]);
                dst
            },
            hire_expire_date: i32::from_le_bytes([buffer[20], buffer[21], buffer[22], buffer[23]]),
            hire_expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[20..24]);
                dst
            },
            bind_on_equip_type: u16::from_le_bytes([buffer[24], buffer[25]]),
            bind_on_equip_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[24..26]);
                dst
            },
            w_item_sprite_number: u16::from_le_bytes([buffer[26], buffer[27]]),
            w_item_sprite_number_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[26..28]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_state).unwrap();
        self.wear_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hire_expire_date).unwrap();
        self.hire_expire_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.bind_on_equip_type).unwrap();
        self.bind_on_equip_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.w_item_sprite_number).unwrap();
        self.w_item_sprite_number_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct NormalitemExtrainfo3 {
    pub raw: Vec<u8>,
    pub index: i16,
    pub index_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub is_identified: bool,
    pub is_identified_raw: [u8; 1],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub wear_state: u16,
    pub wear_state_raw: [u8; 2],
    pub slot: EQUIPSLOTINFO,
    pub slot_raw: [u8; 8],
    pub hire_expire_date: i32,
    pub hire_expire_date_raw: [u8; 4],
}

impl NormalitemExtrainfo3 {
    pub fn from(buffer: &[u8]) -> NormalitemExtrainfo3 {
        NormalitemExtrainfo3 {
            raw: buffer.to_vec(),
            index: i16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            atype: u8::from_le_bytes([buffer[4]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
            is_identified: buffer[5] == 1,
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[5..6]);
                dst
            },
            count: i16::from_le_bytes([buffer[6], buffer[7]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[6..8]);
                dst
            },
            wear_state: u16::from_le_bytes([buffer[8], buffer[9]]),
            wear_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[8..10]);
                dst
            },
            slot: EQUIPSLOTINFO::from(&buffer[10..18]),
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[10..18]);
                dst
            },
            hire_expire_date: i32::from_le_bytes([buffer[18], buffer[19], buffer[20], buffer[21]]),
            hire_expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[18..22]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_state).unwrap();
        self.wear_state_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hire_expire_date).unwrap();
        self.hire_expire_date_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct SkillPostdelay {
    pub raw: Vec<u8>,
    pub skid: u16,
    pub skid_raw: [u8; 2],
    pub delay_tm: u32,
    pub delay_tm_raw: [u8; 4],
}

impl SkillPostdelay {
    pub fn from(buffer: &[u8]) -> SkillPostdelay {
        SkillPostdelay {
            raw: buffer.to_vec(),
            skid: u16::from_le_bytes([buffer[0], buffer[1]]),
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            delay_tm: u32::from_le_bytes([buffer[2], buffer[3], buffer[4], buffer[5]]),
            delay_tm_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[2..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.delay_tm).unwrap();
        self.delay_tm_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct CharacterList {
    pub raw: Vec<u8>,
    pub dw_gid: u32,
    pub dw_gid_raw: [u8; 4],
    pub slot_idx: u8,
    pub slot_idx_raw: [u8; 1],
}

impl CharacterList {
    pub fn from(buffer: &[u8]) -> CharacterList {
        CharacterList {
            raw: buffer.to_vec(),
            dw_gid: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            dw_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            slot_idx: u8::from_le_bytes([buffer[4]]),
            slot_idx_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[4..5]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_gid).unwrap();
        self.dw_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.slot_idx).unwrap();
        self.slot_idx_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct BattleFieldInfo {
    pub raw: Vec<u8>,
    pub bfno: u32,
    pub bfno_raw: [u8; 4],
    pub battle_field_name: [char; 56],
    pub battle_field_name_raw: [u8; 56],
    pub join_team: i16,
    pub join_team_raw: [u8; 2],
}

impl BattleFieldInfo {
    pub fn from(buffer: &[u8]) -> BattleFieldInfo {
        BattleFieldInfo {
            raw: buffer.to_vec(),
            bfno: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            battle_field_name:  {
                let mut dst: [char; 56] = [0 as char; 56];
                for (index, byte) in buffer[4..60].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            battle_field_name_raw: {
                let mut dst: [u8; 56] = [0u8; 56];
                dst.clone_from_slice(&buffer[4..60]);
                dst
            },
            join_team: i16::from_le_bytes([buffer[60], buffer[61]]),
            join_team_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[60..62]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.battle_field_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.battle_field_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.join_team).unwrap();
        self.join_team_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct PartyBookingDetail {
    pub raw: Vec<u8>,
    pub level: i16,
    pub level_raw: [u8; 2],
    pub map_id: i16,
    pub map_id_raw: [u8; 2],
    pub job: [i16; 6],
    pub job_raw: [u8; 6],
}

impl PartyBookingDetail {
    pub fn from(buffer: &[u8]) -> PartyBookingDetail {
        PartyBookingDetail {
            raw: buffer.to_vec(),
            level: i16::from_le_bytes([buffer[0], buffer[1]]),
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            map_id: i16::from_le_bytes([buffer[2], buffer[3]]),
            map_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            job:  {
                let mut dst: [i16; 6] = [0 as i16; 6];
                for (index, byte) in buffer[4..10].iter().enumerate() {
                    dst[index] = *byte as i16;
                }
                dst
            },
            job_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[4..10]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.map_id).unwrap();
        self.map_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.job {
            wtr.write_i16::<LittleEndian>(item).unwrap();
        }
        self.job_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct PartyBookingAdInfo {
    pub raw: Vec<u8>,
    pub index: u32,
    pub index_raw: [u8; 4],
    pub char_name: [char; 24],
    pub char_name_raw: [u8; 24],
    pub expire_time: i32,
    pub expire_time_raw: [u8; 4],
    pub detail: PartyBookingDetail,
    pub detail_raw: Vec<u8>,
}

impl PartyBookingAdInfo {
    pub fn from(buffer: &[u8]) -> PartyBookingAdInfo {
        PartyBookingAdInfo {
            raw: buffer.to_vec(),
            index: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            index_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            char_name:  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[4..28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[4..28]);
                dst
            },
            expire_time: i32::from_le_bytes([buffer[28], buffer[29], buffer[30], buffer[31]]),
            expire_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[28..32]);
                dst
            },
            detail: PartyBookingDetail::from(&buffer[32..buffer.len()]),
            detail_raw: buffer[32..buffer.len()].to_vec(),
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.expire_time).unwrap();
        self.expire_time_raw = wtr.try_into().unwrap();

    }
}

#[derive(Clone)]
pub struct ProductinfoInBuyingStore {
    pub raw: Vec<u8>,
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub price: i32,
    pub price_raw: [u8; 4],
}

impl ProductinfoInBuyingStore {
    pub fn from(buffer: &[u8]) -> ProductinfoInBuyingStore {
        ProductinfoInBuyingStore {
            raw: buffer.to_vec(),
            itid: u16::from_le_bytes([buffer[0], buffer[1]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            count: i16::from_le_bytes([buffer[2], buffer[3]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            price: i32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct BuyingStoreItemlist {
    pub raw: Vec<u8>,
    pub price: i32,
    pub price_raw: [u8; 4],
    pub count: i16,
    pub count_raw: [u8; 2],
    pub atype: u8,
    pub atype_raw: [u8; 1],
    pub itid: u16,
    pub itid_raw: [u8; 2],
}

impl BuyingStoreItemlist {
    pub fn from(buffer: &[u8]) -> BuyingStoreItemlist {
        BuyingStoreItemlist {
            raw: buffer.to_vec(),
            price: i32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
            atype: u8::from_le_bytes([buffer[6]]),
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[6..7]);
                dst
            },
            itid: u16::from_le_bytes([buffer[7], buffer[8]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[7..9]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct TradeItemBuyingStore {
    pub raw: Vec<u8>,
    pub index: u16,
    pub index_raw: [u8; 2],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub count: i16,
    pub count_raw: [u8; 2],
}

impl TradeItemBuyingStore {
    pub fn from(buffer: &[u8]) -> TradeItemBuyingStore {
        TradeItemBuyingStore {
            raw: buffer.to_vec(),
            index: u16::from_le_bytes([buffer[0], buffer[1]]),
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[0..2]);
                dst
            },
            itid: u16::from_le_bytes([buffer[2], buffer[3]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[2..4]);
                dst
            },
            count: i16::from_le_bytes([buffer[4], buffer[5]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[4..6]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
    }
}

#[derive(Clone)]
pub struct ResultItemInfo {
    pub raw: Vec<u8>,
    pub ssiid: u32,
    pub ssiid_raw: [u8; 4],
    pub aid: u32,
    pub aid_raw: [u8; 4],
    pub store_name: [char; 80],
    pub store_name_raw: [u8; 80],
    pub itid: u16,
    pub itid_raw: [u8; 2],
    pub item_type: u8,
    pub item_type_raw: [u8; 1],
    pub price: i32,
    pub price_raw: [u8; 4],
    pub count: u16,
    pub count_raw: [u8; 2],
    pub refining_level: u8,
    pub refining_level_raw: [u8; 1],
    pub card1: u16,
    pub card1_raw: [u8; 2],
    pub card2: u16,
    pub card2_raw: [u8; 2],
    pub card3: u16,
    pub card3_raw: [u8; 2],
    pub card4: u16,
    pub card4_raw: [u8; 2],
}

impl ResultItemInfo {
    pub fn from(buffer: &[u8]) -> ResultItemInfo {
        ResultItemInfo {
            raw: buffer.to_vec(),
            ssiid: u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]),
            ssiid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[0..4]);
                dst
            },
            aid: u32::from_le_bytes([buffer[4], buffer[5], buffer[6], buffer[7]]),
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[4..8]);
                dst
            },
            store_name:  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[8..88].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            },
            store_name_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[8..88]);
                dst
            },
            itid: u16::from_le_bytes([buffer[88], buffer[89]]),
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[88..90]);
                dst
            },
            item_type: u8::from_le_bytes([buffer[90]]),
            item_type_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[90..91]);
                dst
            },
            price: i32::from_le_bytes([buffer[91], buffer[92], buffer[93], buffer[94]]),
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[91..95]);
                dst
            },
            count: u16::from_le_bytes([buffer[95], buffer[96]]),
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[95..97]);
                dst
            },
            refining_level: u8::from_le_bytes([buffer[97]]),
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[97..98]);
                dst
            },
            card1: u16::from_le_bytes([buffer[98], buffer[99]]),
            card1_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[98..100]);
                dst
            },
            card2: u16::from_le_bytes([buffer[100], buffer[101]]),
            card2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[100..102]);
                dst
            },
            card3: u16::from_le_bytes([buffer[102], buffer[103]]),
            card3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[102..104]);
                dst
            },
            card4: u16::from_le_bytes([buffer[104], buffer[105]]),
            card4_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[104..106]);
                dst
            },
        }
    }
    pub fn serialize(&mut self) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.ssiid).unwrap();
        self.ssiid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.store_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.store_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_type).unwrap();
        self.item_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card1).unwrap();
        self.card1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card2).unwrap();
        self.card2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card3).unwrap();
        self.card3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card4).unwrap();
        self.card4_raw = wtr.try_into().unwrap();
    }
}

#[derive(Debug)]
pub struct PacketUnknown {
    pub raw: Vec<u8>,
    pub packet_id: String,
}
impl Packet for PacketUnknown {
    fn id(&self) -> &str {
        self.packet_id.as_str()
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            self.debug()
    }
    fn pretty_debug(&self) {
            self.debug()
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
}
impl PacketUnknown {
    pub fn from(buffer: &[u8]) -> PacketUnknown {
        PacketUnknown { raw: buffer.to_vec(), packet_id: format!("0x{:02X?}{:02X?}", buffer[0], buffer[1])}
    }
}
