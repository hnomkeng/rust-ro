// Generated by tools/skills/main.rs
// Auto generated file do not edit manually

#![allow(dead_code, unused_must_use, unused_imports, unused_variables)]

use enums::{EnumWithMaskValueU64, EnumWithNumberValue};
use enums::skill::*;
use enums::weapon::AmmoType;

use models::weapon::Weapon;
use models::item::NormalInventoryItem;

use crate::{Skill, SkillRequirementResult, DelegateSkill};

use crate::skills::*;
// SL_ALCHEMIST
pub struct SpiritoftheAlchemist {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for SpiritoftheAlchemist {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 5 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 460 { return Ok(460) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 360 { return Ok(360) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 260 { return Ok(260) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 160 { return Ok(160) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 60 { return Ok(60) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_MONK
pub struct SpiritoftheMonk {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for SpiritoftheMonk {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 5 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 460 { return Ok(460) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 360 { return Ok(360) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 260 { return Ok(260) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 160 { return Ok(160) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 60 { return Ok(60) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_STAR
pub struct SpiritoftheStarGladiator {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for SpiritoftheStarGladiator {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 5 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 460 { return Ok(460) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 360 { return Ok(360) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 260 { return Ok(260) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 160 { return Ok(160) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 60 { return Ok(60) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_SAGE
pub struct SpiritoftheSage {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for SpiritoftheSage {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 5 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 460 { return Ok(460) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 360 { return Ok(360) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 260 { return Ok(260) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 160 { return Ok(160) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 60 { return Ok(60) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_CRUSADER
pub struct SpiritoftheCrusader {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for SpiritoftheCrusader {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 5 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 460 { return Ok(460) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 360 { return Ok(360) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 260 { return Ok(260) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 160 { return Ok(160) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 60 { return Ok(60) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_SUPERNOVICE
pub struct SpiritoftheSupernovice {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for SpiritoftheSupernovice {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 5 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 460 { return Ok(460) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 360 { return Ok(360) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 260 { return Ok(260) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 160 { return Ok(160) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 60 { return Ok(60) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_KNIGHT
pub struct SpiritoftheKnight {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for SpiritoftheKnight {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 5 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 460 { return Ok(460) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 360 { return Ok(360) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 260 { return Ok(260) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 160 { return Ok(160) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 60 { return Ok(60) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_WIZARD
pub struct SpiritoftheWizard {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for SpiritoftheWizard {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 5 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 460 { return Ok(460) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 360 { return Ok(360) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 260 { return Ok(260) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 160 { return Ok(160) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 60 { return Ok(60) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_PRIEST
pub struct SpiritofthePriest {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for SpiritofthePriest {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 5 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 460 { return Ok(460) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 360 { return Ok(360) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 260 { return Ok(260) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 160 { return Ok(160) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 60 { return Ok(60) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_BARDDANCER
pub struct SpiritoftheArtist {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for SpiritoftheArtist {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 5 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 460 { return Ok(460) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 360 { return Ok(360) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 260 { return Ok(260) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 160 { return Ok(160) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 60 { return Ok(60) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_ROGUE
pub struct SpiritoftheRogue {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for SpiritoftheRogue {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 5 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 460 { return Ok(460) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 360 { return Ok(360) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 260 { return Ok(260) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 160 { return Ok(160) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 60 { return Ok(60) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_ASSASIN
pub struct SpiritoftheAssasin {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for SpiritoftheAssasin {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 5 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 460 { return Ok(460) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 360 { return Ok(360) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 260 { return Ok(260) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 160 { return Ok(160) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 60 { return Ok(60) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_BLACKSMITH
pub struct SpiritoftheBlacksmith {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for SpiritoftheBlacksmith {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 5 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 460 { return Ok(460) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 360 { return Ok(360) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 260 { return Ok(260) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 160 { return Ok(160) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 60 { return Ok(60) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_HUNTER
pub struct SpiritoftheHunter {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for SpiritoftheHunter {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 5 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 460 { return Ok(460) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 360 { return Ok(360) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 260 { return Ok(260) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 160 { return Ok(160) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 60 { return Ok(60) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_SOULLINKER
pub struct SpiritoftheSoulLinker {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for SpiritoftheSoulLinker {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 5 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 460 { return Ok(460) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 360 { return Ok(360) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 260 { return Ok(260) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 160 { return Ok(160) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 60 { return Ok(60) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_KAIZEL
pub struct Kaizel {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for Kaizel {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 7 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 120 { return Ok(120) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 110 { return Ok(110) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 100 { return Ok(100) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 90 { return Ok(90) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 80 { return Ok(80) } else {return Err(())}
        }
        if self.level == 6 {
            if character_sp >= 70 { return Ok(70) } else {return Err(())}
        }
        if self.level == 7 {
            if character_sp >= 60 { return Ok(60) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
        0
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_KAAHI
pub struct Kaahi {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for Kaahi {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 7 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if character_sp >= 30 { Ok(30) } else {Err(())}
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_KAUPE
pub struct Kaupe {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for Kaupe {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 3 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 20 { return Ok(20) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 30 { return Ok(30) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 40 { return Ok(40) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_KAITE
pub struct Kaite {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for Kaite {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 7 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if character_sp >= 70 { Ok(70) } else {Err(())}
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
        0
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_KAINA
pub struct Kaina {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for Kaina {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 7 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
        0
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
        0
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_STIN
pub struct Estin {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for Estin {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 7 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 18 { return Ok(18) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 20 { return Ok(20) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 22 { return Ok(22) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 24 { return Ok(24) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 26 { return Ok(26) } else {return Err(())}
        }
        if self.level == 6 {
            if character_sp >= 28 { return Ok(28) } else {return Err(())}
        }
        if self.level == 7 {
            if character_sp >= 30 { return Ok(30) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_STUN
pub struct Estun {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for Estun {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 7 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 18 { return Ok(18) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 20 { return Ok(20) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 22 { return Ok(22) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 24 { return Ok(24) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 26 { return Ok(26) } else {return Err(())}
        }
        if self.level == 6 {
            if character_sp >= 28 { return Ok(28) } else {return Err(())}
        }
        if self.level == 7 {
            if character_sp >= 30 { return Ok(30) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_SMA
pub struct Esma {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for Esma {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 10 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 8 { return Ok(8) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 16 { return Ok(16) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 24 { return Ok(24) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 32 { return Ok(32) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 40 { return Ok(40) } else {return Err(())}
        }
        if self.level == 6 {
            if character_sp >= 48 { return Ok(48) } else {return Err(())}
        }
        if self.level == 7 {
            if character_sp >= 56 { return Ok(56) } else {return Err(())}
        }
        if self.level == 8 {
            if character_sp >= 64 { return Ok(64) } else {return Err(())}
        }
        if self.level == 9 {
            if character_sp >= 72 { return Ok(72) } else {return Err(())}
        }
        if self.level == 10 {
            if character_sp >= 80 { return Ok(80) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
        if self.level == 1 {
            return 1
        }
        if self.level == 2 {
            return 2
        }
        if self.level == 3 {
            return 3
        }
        if self.level == 4 {
            return 4
        }
        if self.level == 5 {
            return 5
        }
        if self.level == 6 {
            return 6
        }
        if self.level == 7 {
            return 7
        }
        if self.level == 8 {
            return 8
        }
        if self.level == 9 {
            return 9
        }
        if self.level == 10 {
            return 10
        }
        0
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_SWOO
pub struct Eswoo {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for Eswoo {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 7 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 75 { return Ok(75) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 65 { return Ok(65) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 55 { return Ok(55) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 45 { return Ok(45) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 35 { return Ok(35) } else {return Err(())}
        }
        if self.level == 6 {
            if character_sp >= 25 { return Ok(25) } else {return Err(())}
        }
        if self.level == 7 {
            if character_sp >= 15 { return Ok(15) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_SKE
pub struct Eske {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for Eske {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 3 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 55 { return Ok(55) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 35 { return Ok(35) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 15 { return Ok(15) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_SKA
pub struct Eska {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for Eska {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 3 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 100 { return Ok(100) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 80 { return Ok(80) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 60 { return Ok(60) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
// SL_HIGH
pub struct SpiritofRebirth {
    level: u8,
    delegate: Option<Box<dyn DelegateSkill>>,
}
impl Skill for SpiritofRebirth {
    fn new(level: u8) -> Option<Self> where Self : Sized {
        if level < 1 || level > 5 { return None }
        Some(Self { level, delegate: None })
    }
    fn level(&self) -> u8 {
        self.level
    }
    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {
        &self.delegate
    }
    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {
        if self.level == 1 {
            if character_sp >= 460 { return Ok(460) } else {return Err(())}
        }
        if self.level == 2 {
            if character_sp >= 360 { return Ok(360) } else {return Err(())}
        }
        if self.level == 3 {
            if character_sp >= 260 { return Ok(260) } else {return Err(())}
        }
        if self.level == 4 {
            if character_sp >= 160 { return Ok(160) } else {return Err(())}
        }
        if self.level == 5 {
            if character_sp >= 60 { return Ok(60) } else {return Err(())}
        }
        Err(())
    }
    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {
        Ok(0)
    }
    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {
        Ok(None)
    }
    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
        Ok(())
    }
    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {
         Ok(())
    }
    fn hit_count(&self) -> i8 {
       1
    }
    fn cast_delay(&self) -> u32 {
        0
    }
    fn after_cast_act_delay(&self) -> u32 {
       500
    }
    fn after_cast_walk_delay(&self) -> u32 {
        0
    }
}
