// Generated by tools/packets_db/main.rs
// Auto generated file do not edit manually

#![allow(dead_code)]

#![allow(unused_assignments)]

#![allow(unused_variables)]

use crate::packets::*;
use byteorder::{LittleEndian,WriteBytesExt};
use std::any::Any;
use std::convert::TryInto;

impl PacketCaLogin {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6400"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaLogin {
        let mut offset: usize = 0;
        PacketCaLogin {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            version: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            id: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            passwd: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            passwd_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            client_type: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            client_type_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.client_type).unwrap();
        self.client_type_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.version_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.passwd_raw.to_vec());
        wtr.append(&mut self.client_type_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 55;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_version(&mut self, value: u32) {
        self.version = value;
    }
    pub fn set_version_raw(&mut self, value: [u8; 4]) {
        self.version_raw = value;
    }
    pub fn set_id(&mut self, value: [char; 24]) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 24]) {
        self.id_raw = value;
    }
    pub fn set_passwd(&mut self, value: [char; 24]) {
        self.passwd = value;
    }
    pub fn set_passwd_raw(&mut self, value: [u8; 24]) {
        self.passwd_raw = value;
    }
    pub fn set_client_type(&mut self, value: u8) {
        self.client_type = value;
    }
    pub fn set_client_type_raw(&mut self, value: [u8; 1]) {
        self.client_type_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaLogin {
        let packet_id = i16::from_le_bytes([0x64, 0x00]);
        let packet_id_raw = [0x64, 0x00];
        PacketCaLogin {
        raw: vec![],
        packet_id,
        packet_id_raw,
        version: 0,
        version_raw: [0; 4],
        id: [0 as char; 24],
        id_raw: [0; 24],
        passwd: [0 as char; 24],
        passwd_raw: [0; 24],
        client_type: 0,
        client_type_raw: [0; 1],
        }
    }
}

impl Packet for PacketCaLogin {
    fn id(&self, packetver: u32) -> &str {
       PacketCaLogin::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketChEnter {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6500"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketChEnter {
        let mut offset: usize = 0;
        PacketChEnter {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            auth_code: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            user_level: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            user_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            client_type: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            client_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.user_level).unwrap();
        self.user_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.client_type).unwrap();
        self.client_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.auth_code_raw.to_vec());
        wtr.append(&mut self.user_level_raw.to_vec());
        wtr.append(&mut self.client_type_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 17;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_auth_code(&mut self, value: i32) {
        self.auth_code = value;
    }
    pub fn set_auth_code_raw(&mut self, value: [u8; 4]) {
        self.auth_code_raw = value;
    }
    pub fn set_user_level(&mut self, value: u32) {
        self.user_level = value;
    }
    pub fn set_user_level_raw(&mut self, value: [u8; 4]) {
        self.user_level_raw = value;
    }
    pub fn set_client_type(&mut self, value: u16) {
        self.client_type = value;
    }
    pub fn set_client_type_raw(&mut self, value: [u8; 2]) {
        self.client_type_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn new(packetver: u32) -> PacketChEnter {
        let packet_id = i16::from_le_bytes([0x65, 0x00]);
        let packet_id_raw = [0x65, 0x00];
        PacketChEnter {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        auth_code: 0,
        auth_code_raw: [0; 4],
        user_level: 0,
        user_level_raw: [0; 4],
        client_type: 0,
        client_type_raw: [0; 2],
        sex: 0,
        sex_raw: [0; 1],
        }
    }
}

impl Packet for PacketChEnter {
    fn id(&self, packetver: u32) -> &str {
       PacketChEnter::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketChSelectChar {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6600"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketChSelectChar {
        let mut offset: usize = 0;
        PacketChSelectChar {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            char_num: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            char_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.char_num).unwrap();
        self.char_num_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.char_num_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_char_num(&mut self, value: u8) {
        self.char_num = value;
    }
    pub fn set_char_num_raw(&mut self, value: [u8; 1]) {
        self.char_num_raw = value;
    }
    pub fn new(packetver: u32) -> PacketChSelectChar {
        let packet_id = i16::from_le_bytes([0x66, 0x00]);
        let packet_id_raw = [0x66, 0x00];
        PacketChSelectChar {
        raw: vec![],
        packet_id,
        packet_id_raw,
        char_num: 0,
        char_num_raw: [0; 1],
        }
    }
}

impl Packet for PacketChSelectChar {
    fn id(&self, packetver: u32) -> &str {
       PacketChSelectChar::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketChMakeChar {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6700"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketChMakeChar {
        let mut offset: usize = 0;
        PacketChMakeChar {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            str: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            str_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            agi: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            agi_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            vit: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            vit_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            int: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            int_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            dex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            dex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            luk: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            luk_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            char_num: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            char_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            head_pal: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_pal_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.str).unwrap();
        self.str_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.agi).unwrap();
        self.agi_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.vit).unwrap();
        self.vit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.int).unwrap();
        self.int_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dex).unwrap();
        self.dex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.luk).unwrap();
        self.luk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.char_num).unwrap();
        self.char_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_pal).unwrap();
        self.head_pal_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.str_raw.to_vec());
        wtr.append(&mut self.agi_raw.to_vec());
        wtr.append(&mut self.vit_raw.to_vec());
        wtr.append(&mut self.int_raw.to_vec());
        wtr.append(&mut self.dex_raw.to_vec());
        wtr.append(&mut self.luk_raw.to_vec());
        wtr.append(&mut self.char_num_raw.to_vec());
        wtr.append(&mut self.head_pal_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 37;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_str(&mut self, value: u8) {
        self.str = value;
    }
    pub fn set_str_raw(&mut self, value: [u8; 1]) {
        self.str_raw = value;
    }
    pub fn set_agi(&mut self, value: u8) {
        self.agi = value;
    }
    pub fn set_agi_raw(&mut self, value: [u8; 1]) {
        self.agi_raw = value;
    }
    pub fn set_vit(&mut self, value: u8) {
        self.vit = value;
    }
    pub fn set_vit_raw(&mut self, value: [u8; 1]) {
        self.vit_raw = value;
    }
    pub fn set_int(&mut self, value: u8) {
        self.int = value;
    }
    pub fn set_int_raw(&mut self, value: [u8; 1]) {
        self.int_raw = value;
    }
    pub fn set_dex(&mut self, value: u8) {
        self.dex = value;
    }
    pub fn set_dex_raw(&mut self, value: [u8; 1]) {
        self.dex_raw = value;
    }
    pub fn set_luk(&mut self, value: u8) {
        self.luk = value;
    }
    pub fn set_luk_raw(&mut self, value: [u8; 1]) {
        self.luk_raw = value;
    }
    pub fn set_char_num(&mut self, value: u8) {
        self.char_num = value;
    }
    pub fn set_char_num_raw(&mut self, value: [u8; 1]) {
        self.char_num_raw = value;
    }
    pub fn set_head_pal(&mut self, value: i16) {
        self.head_pal = value;
    }
    pub fn set_head_pal_raw(&mut self, value: [u8; 2]) {
        self.head_pal_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn new(packetver: u32) -> PacketChMakeChar {
        let packet_id = i16::from_le_bytes([0x67, 0x00]);
        let packet_id_raw = [0x67, 0x00];
        PacketChMakeChar {
        raw: vec![],
        packet_id,
        packet_id_raw,
        name: [0 as char; 24],
        name_raw: [0; 24],
        str: 0,
        str_raw: [0; 1],
        agi: 0,
        agi_raw: [0; 1],
        vit: 0,
        vit_raw: [0; 1],
        int: 0,
        int_raw: [0; 1],
        dex: 0,
        dex_raw: [0; 1],
        luk: 0,
        luk_raw: [0; 1],
        char_num: 0,
        char_num_raw: [0; 1],
        head_pal: 0,
        head_pal_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        }
    }
}

impl Packet for PacketChMakeChar {
    fn id(&self, packetver: u32) -> &str {
       PacketChMakeChar::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketChMakeChar2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7009"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketChMakeChar2 {
        let mut offset: usize = 0;
        PacketChMakeChar2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            char_num: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            char_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            head_pal: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_pal_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.char_num).unwrap();
        self.char_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_pal).unwrap();
        self.head_pal_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.char_num_raw.to_vec());
        wtr.append(&mut self.head_pal_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 31;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_char_num(&mut self, value: u8) {
        self.char_num = value;
    }
    pub fn set_char_num_raw(&mut self, value: [u8; 1]) {
        self.char_num_raw = value;
    }
    pub fn set_head_pal(&mut self, value: i16) {
        self.head_pal = value;
    }
    pub fn set_head_pal_raw(&mut self, value: [u8; 2]) {
        self.head_pal_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn new(packetver: u32) -> PacketChMakeChar2 {
        let packet_id = i16::from_le_bytes([0x70, 0x09]);
        let packet_id_raw = [0x70, 0x09];
        PacketChMakeChar2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        name: [0 as char; 24],
        name_raw: [0; 24],
        char_num: 0,
        char_num_raw: [0; 1],
        head_pal: 0,
        head_pal_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        }
    }
}

impl Packet for PacketChMakeChar2 {
    fn id(&self, packetver: u32) -> &str {
       PacketChMakeChar2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketChDeleteChar {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6800"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketChDeleteChar {
        let mut offset: usize = 0;
        PacketChDeleteChar {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            key: {
                let field =  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[offset..offset + 40].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            key_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[offset..offset + 40]);
                offset += 40;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.key {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.key_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.key_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 46;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_key(&mut self, value: [char; 40]) {
        self.key = value;
    }
    pub fn set_key_raw(&mut self, value: [u8; 40]) {
        self.key_raw = value;
    }
    pub fn new(packetver: u32) -> PacketChDeleteChar {
        let packet_id = i16::from_le_bytes([0x68, 0x00]);
        let packet_id_raw = [0x68, 0x00];
        PacketChDeleteChar {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        key: [0 as char; 40],
        key_raw: [0; 40],
        }
    }
}

impl Packet for PacketChDeleteChar {
    fn id(&self, packetver: u32) -> &str {
       PacketChDeleteChar::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcAcceptLogin {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6900"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcAcceptLogin {
        let mut offset: usize = 0;
        let vec_type_len = ServerAddr::base_len(packetver);
        let iter_count = (&buffer.len() - 47) / vec_type_len;
        let mut vec_field: Vec<ServerAddr> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 47 + (vec_type_len * (i - 1));
            let end_pos = 47 + vec_type_len * i;
            vec_field.push(ServerAddr::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketAcAcceptLogin {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            auth_code: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            user_level: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            user_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            last_login_ip: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            last_login_ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            last_login_time: {
                let field =  {
                let mut dst: [char; 26] = [0 as char; 26];
                for (index, byte) in buffer[offset..offset + 26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            last_login_time_raw: {
                let mut dst: [u8; 26] = [0u8; 26];
                dst.clone_from_slice(&buffer[offset..offset + 26]);
                offset += 26;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            server_list: {
                let field = vec_field.clone();
                field
            },
            server_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.user_level).unwrap();
        self.user_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.last_login_ip).unwrap();
        self.last_login_ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.last_login_time {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.last_login_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        self.server_list_raw = {
            self.server_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.server_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.auth_code_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.user_level_raw.to_vec());
        wtr.append(&mut self.last_login_ip_raw.to_vec());
        wtr.append(&mut self.last_login_time_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        self.server_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 47;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_auth_code(&mut self, value: i32) {
        self.auth_code = value;
    }
    pub fn set_auth_code_raw(&mut self, value: [u8; 4]) {
        self.auth_code_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_user_level(&mut self, value: u32) {
        self.user_level = value;
    }
    pub fn set_user_level_raw(&mut self, value: [u8; 4]) {
        self.user_level_raw = value;
    }
    pub fn set_last_login_ip(&mut self, value: u32) {
        self.last_login_ip = value;
    }
    pub fn set_last_login_ip_raw(&mut self, value: [u8; 4]) {
        self.last_login_ip_raw = value;
    }
    pub fn set_last_login_time(&mut self, value: [char; 26]) {
        self.last_login_time = value;
    }
    pub fn set_last_login_time_raw(&mut self, value: [u8; 26]) {
        self.last_login_time_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_server_list(&mut self, value: Vec<ServerAddr>) {
        self.server_list = value;
    }
    pub fn set_server_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.server_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcAcceptLogin {
        let packet_id = i16::from_le_bytes([0x69, 0x00]);
        let packet_id_raw = [0x69, 0x00];
        PacketAcAcceptLogin {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        auth_code: 0,
        auth_code_raw: [0; 4],
        aid: 0,
        aid_raw: [0; 4],
        user_level: 0,
        user_level_raw: [0; 4],
        last_login_ip: 0,
        last_login_ip_raw: [0; 4],
        last_login_time: [0 as char; 26],
        last_login_time_raw: [0; 26],
        sex: 0,
        sex_raw: [0; 1],
        server_list: vec![],
        server_list_raw: vec![],
        }
    }
}

impl Packet for PacketAcAcceptLogin {
    fn id(&self, packetver: u32) -> &str {
       PacketAcAcceptLogin::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcAcceptLogin2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc40a"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcAcceptLogin2 {
        let mut offset: usize = 0;
        let vec_type_len = ServerAddr2::base_len(packetver);
        let iter_count = (&buffer.len() - 64) / vec_type_len;
        let mut vec_field: Vec<ServerAddr2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 64 + (vec_type_len * (i - 1));
            let end_pos = 64 + vec_type_len * i;
            vec_field.push(ServerAddr2::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketAcAcceptLogin2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            auth_code: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            user_level: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            user_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            last_login_ip: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            last_login_ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            last_login_time: {
                let field =  {
                let mut dst: [char; 26] = [0 as char; 26];
                for (index, byte) in buffer[offset..offset + 26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            last_login_time_raw: {
                let mut dst: [u8; 26] = [0u8; 26];
                dst.clone_from_slice(&buffer[offset..offset + 26]);
                offset += 26;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            twitter_auth_token: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            twitter_auth_token_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            twitter_flag: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            twitter_flag_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            server_list: {
                let field = vec_field.clone();
                field
            },
            server_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.user_level).unwrap();
        self.user_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.last_login_ip).unwrap();
        self.last_login_ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.last_login_time {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.last_login_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.twitter_auth_token {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.twitter_auth_token_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.twitter_flag).unwrap();
        self.twitter_flag_raw = wtr.try_into().unwrap();
        self.server_list_raw = {
            self.server_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.server_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.auth_code_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.user_level_raw.to_vec());
        wtr.append(&mut self.last_login_ip_raw.to_vec());
        wtr.append(&mut self.last_login_time_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.twitter_auth_token_raw.to_vec());
        wtr.append(&mut self.twitter_flag_raw.to_vec());
        self.server_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 64;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_auth_code(&mut self, value: i32) {
        self.auth_code = value;
    }
    pub fn set_auth_code_raw(&mut self, value: [u8; 4]) {
        self.auth_code_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_user_level(&mut self, value: u32) {
        self.user_level = value;
    }
    pub fn set_user_level_raw(&mut self, value: [u8; 4]) {
        self.user_level_raw = value;
    }
    pub fn set_last_login_ip(&mut self, value: u32) {
        self.last_login_ip = value;
    }
    pub fn set_last_login_ip_raw(&mut self, value: [u8; 4]) {
        self.last_login_ip_raw = value;
    }
    pub fn set_last_login_time(&mut self, value: [char; 26]) {
        self.last_login_time = value;
    }
    pub fn set_last_login_time_raw(&mut self, value: [u8; 26]) {
        self.last_login_time_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_twitter_auth_token(&mut self, value: [char; 16]) {
        self.twitter_auth_token = value;
    }
    pub fn set_twitter_auth_token_raw(&mut self, value: [u8; 16]) {
        self.twitter_auth_token_raw = value;
    }
    pub fn set_twitter_flag(&mut self, value: u8) {
        self.twitter_flag = value;
    }
    pub fn set_twitter_flag_raw(&mut self, value: [u8; 1]) {
        self.twitter_flag_raw = value;
    }
    pub fn set_server_list(&mut self, value: Vec<ServerAddr2>) {
        self.server_list = value;
    }
    pub fn set_server_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.server_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcAcceptLogin2 {
        let packet_id = i16::from_le_bytes([0xc4, 0x0a]);
        let packet_id_raw = [0xc4, 0x0a];
        PacketAcAcceptLogin2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        auth_code: 0,
        auth_code_raw: [0; 4],
        aid: 0,
        aid_raw: [0; 4],
        user_level: 0,
        user_level_raw: [0; 4],
        last_login_ip: 0,
        last_login_ip_raw: [0; 4],
        last_login_time: [0 as char; 26],
        last_login_time_raw: [0; 26],
        sex: 0,
        sex_raw: [0; 1],
        twitter_auth_token: [0 as char; 16],
        twitter_auth_token_raw: [0; 16],
        twitter_flag: 0,
        twitter_flag_raw: [0; 1],
        server_list: vec![],
        server_list_raw: vec![],
        }
    }
}

impl Packet for PacketAcAcceptLogin2 {
    fn id(&self, packetver: u32) -> &str {
       PacketAcAcceptLogin2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcRefuseLogin {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6a00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcRefuseLogin {
        let mut offset: usize = 0;
        PacketAcRefuseLogin {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_code: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            block_date: {
                let field =  {
                let mut dst: [char; 20] = [0 as char; 20];
                for (index, byte) in buffer[offset..offset + 20].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            block_date_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[offset..offset + 20]);
                offset += 20;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.block_date {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.block_date_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        wtr.append(&mut self.block_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 23;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u8) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 1]) {
        self.error_code_raw = value;
    }
    pub fn set_block_date(&mut self, value: [char; 20]) {
        self.block_date = value;
    }
    pub fn set_block_date_raw(&mut self, value: [u8; 20]) {
        self.block_date_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcRefuseLogin {
        let packet_id = i16::from_le_bytes([0x6a, 0x00]);
        let packet_id_raw = [0x6a, 0x00];
        PacketAcRefuseLogin {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_code: 0,
        error_code_raw: [0; 1],
        block_date: [0 as char; 20],
        block_date_raw: [0; 20],
        }
    }
}

impl Packet for PacketAcRefuseLogin {
    fn id(&self, packetver: u32) -> &str {
       PacketAcRefuseLogin::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcAcceptEnterNeoUnion {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6b00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcAcceptEnterNeoUnion {
        let mut offset: usize = 0;
        let vec_type_len = CharacterInfoNeoUnion::base_len(packetver);
        let iter_count = (&buffer.len() - 27) / vec_type_len;
        let mut vec_field: Vec<CharacterInfoNeoUnion> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 27 + (vec_type_len * (i - 1));
            let end_pos = 27 + vec_type_len * i;
            vec_field.push(CharacterInfoNeoUnion::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketHcAcceptEnterNeoUnion {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            total_slot_num: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            total_slot_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            premium_start_slot: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            premium_start_slot_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            premium_end_slot: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            premium_end_slot_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            dummy1_beginbilling: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            dummy1_beginbilling_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            code: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            time1: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            time1_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            time2: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            time2_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            dummy2_endbilling: {
                let field =  {
                let mut dst: [char; 7] = [0 as char; 7];
                for (index, byte) in buffer[offset..offset + 7].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            dummy2_endbilling_raw: {
                let mut dst: [u8; 7] = [0u8; 7];
                dst.clone_from_slice(&buffer[offset..offset + 7]);
                offset += 7;
                dst
            },
            char_info: {
                let field = vec_field.clone();
                field
            },
            char_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.total_slot_num).unwrap();
        self.total_slot_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.premium_start_slot).unwrap();
        self.premium_start_slot_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.premium_end_slot).unwrap();
        self.premium_end_slot_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.dummy1_beginbilling).unwrap();
        self.dummy1_beginbilling_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.code).unwrap();
        self.code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.time1).unwrap();
        self.time1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.time2).unwrap();
        self.time2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.dummy2_endbilling {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.dummy2_endbilling_raw = wtr.try_into().unwrap();
        self.char_info_raw = {
            self.char_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.char_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.total_slot_num_raw.to_vec());
        wtr.append(&mut self.premium_start_slot_raw.to_vec());
        wtr.append(&mut self.premium_end_slot_raw.to_vec());
        wtr.append(&mut self.dummy1_beginbilling_raw.to_vec());
        wtr.append(&mut self.code_raw.to_vec());
        wtr.append(&mut self.time1_raw.to_vec());
        wtr.append(&mut self.time2_raw.to_vec());
        wtr.append(&mut self.dummy2_endbilling_raw.to_vec());
        self.char_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 27;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_total_slot_num(&mut self, value: u8) {
        self.total_slot_num = value;
    }
    pub fn set_total_slot_num_raw(&mut self, value: [u8; 1]) {
        self.total_slot_num_raw = value;
    }
    pub fn set_premium_start_slot(&mut self, value: u8) {
        self.premium_start_slot = value;
    }
    pub fn set_premium_start_slot_raw(&mut self, value: [u8; 1]) {
        self.premium_start_slot_raw = value;
    }
    pub fn set_premium_end_slot(&mut self, value: u8) {
        self.premium_end_slot = value;
    }
    pub fn set_premium_end_slot_raw(&mut self, value: [u8; 1]) {
        self.premium_end_slot_raw = value;
    }
    pub fn set_dummy1_beginbilling(&mut self, value: i8) {
        self.dummy1_beginbilling = value;
    }
    pub fn set_dummy1_beginbilling_raw(&mut self, value: [u8; 1]) {
        self.dummy1_beginbilling_raw = value;
    }
    pub fn set_code(&mut self, value: u32) {
        self.code = value;
    }
    pub fn set_code_raw(&mut self, value: [u8; 4]) {
        self.code_raw = value;
    }
    pub fn set_time1(&mut self, value: u32) {
        self.time1 = value;
    }
    pub fn set_time1_raw(&mut self, value: [u8; 4]) {
        self.time1_raw = value;
    }
    pub fn set_time2(&mut self, value: u32) {
        self.time2 = value;
    }
    pub fn set_time2_raw(&mut self, value: [u8; 4]) {
        self.time2_raw = value;
    }
    pub fn set_dummy2_endbilling(&mut self, value: [char; 7]) {
        self.dummy2_endbilling = value;
    }
    pub fn set_dummy2_endbilling_raw(&mut self, value: [u8; 7]) {
        self.dummy2_endbilling_raw = value;
    }
    pub fn set_char_info(&mut self, value: Vec<CharacterInfoNeoUnion>) {
        self.char_info = value;
    }
    pub fn set_char_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.char_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcAcceptEnterNeoUnion {
        let packet_id = i16::from_le_bytes([0x6b, 0x00]);
        let packet_id_raw = [0x6b, 0x00];
        PacketHcAcceptEnterNeoUnion {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        total_slot_num: 0,
        total_slot_num_raw: [0; 1],
        premium_start_slot: 0,
        premium_start_slot_raw: [0; 1],
        premium_end_slot: 0,
        premium_end_slot_raw: [0; 1],
        dummy1_beginbilling: 0,
        dummy1_beginbilling_raw: [0; 1],
        code: 0,
        code_raw: [0; 4],
        time1: 0,
        time1_raw: [0; 4],
        time2: 0,
        time2_raw: [0; 4],
        dummy2_endbilling: [0 as char; 7],
        dummy2_endbilling_raw: [0; 7],
        char_info: vec![],
        char_info_raw: vec![],
        }
    }
}

impl Packet for PacketHcAcceptEnterNeoUnion {
    fn id(&self, packetver: u32) -> &str {
       PacketHcAcceptEnterNeoUnion::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcRefuseEnter {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6c00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcRefuseEnter {
        let mut offset: usize = 0;
        PacketHcRefuseEnter {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_code: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u8) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 1]) {
        self.error_code_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcRefuseEnter {
        let packet_id = i16::from_le_bytes([0x6c, 0x00]);
        let packet_id_raw = [0x6c, 0x00];
        PacketHcRefuseEnter {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_code: 0,
        error_code_raw: [0; 1],
        }
    }
}

impl Packet for PacketHcRefuseEnter {
    fn id(&self, packetver: u32) -> &str {
       PacketHcRefuseEnter::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcAcceptMakecharNeoUnion {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6d00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcAcceptMakecharNeoUnion {
        let mut offset: usize = 0;
        PacketHcAcceptMakecharNeoUnion {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            charinfo: {
                let field = CharacterInfoNeoUnion::from(&buffer[offset..offset + CharacterInfoNeoUnion::base_len(packetver)], packetver);
                field
            },
            charinfo_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.charinfo.fill_raw_with_packetver(packetver);
        self.charinfo_raw = self.charinfo.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.charinfo_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 1;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_charinfo(&mut self, value: CharacterInfoNeoUnion) {
        self.charinfo = value;
    }
    pub fn set_charinfo_raw(&mut self, value: Vec<u8>) {
        self.charinfo_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcAcceptMakecharNeoUnion {
        let packet_id = i16::from_le_bytes([0x6d, 0x00]);
        let packet_id_raw = [0x6d, 0x00];
        PacketHcAcceptMakecharNeoUnion {
        raw: vec![],
        packet_id,
        packet_id_raw,
        charinfo: CharacterInfoNeoUnion::new(packetver),
        charinfo_raw: vec![],
        }
    }
}

impl Packet for PacketHcAcceptMakecharNeoUnion {
    fn id(&self, packetver: u32) -> &str {
       PacketHcAcceptMakecharNeoUnion::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcRefuseMakechar {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6e00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcRefuseMakechar {
        let mut offset: usize = 0;
        PacketHcRefuseMakechar {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_code: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u8) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 1]) {
        self.error_code_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcRefuseMakechar {
        let packet_id = i16::from_le_bytes([0x6e, 0x00]);
        let packet_id_raw = [0x6e, 0x00];
        PacketHcRefuseMakechar {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_code: 0,
        error_code_raw: [0; 1],
        }
    }
}

impl Packet for PacketHcRefuseMakechar {
    fn id(&self, packetver: u32) -> &str {
       PacketHcRefuseMakechar::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcAcceptDeletechar {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6f00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcAcceptDeletechar {
        let mut offset: usize = 0;
        PacketHcAcceptDeletechar {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcAcceptDeletechar {
        let packet_id = i16::from_le_bytes([0x6f, 0x00]);
        let packet_id_raw = [0x6f, 0x00];
        PacketHcAcceptDeletechar {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketHcAcceptDeletechar {
    fn id(&self, packetver: u32) -> &str {
       PacketHcAcceptDeletechar::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcRefuseDeletechar {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7000"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcRefuseDeletechar {
        let mut offset: usize = 0;
        PacketHcRefuseDeletechar {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_code: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u8) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 1]) {
        self.error_code_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcRefuseDeletechar {
        let packet_id = i16::from_le_bytes([0x70, 0x00]);
        let packet_id_raw = [0x70, 0x00];
        PacketHcRefuseDeletechar {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_code: 0,
        error_code_raw: [0; 1],
        }
    }
}

impl Packet for PacketHcRefuseDeletechar {
    fn id(&self, packetver: u32) -> &str {
       PacketHcRefuseDeletechar::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcNotifyZonesvr {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7100"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcNotifyZonesvr {
        let mut offset: usize = 0;
        PacketHcNotifyZonesvr {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            map_name: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            addr: {
                let field = ZserverAddr::from(&buffer[offset..offset + ZserverAddr::base_len(packetver)], packetver);
                field
            },
            addr_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        self.addr.fill_raw_with_packetver(packetver);
        self.addr_raw = self.addr.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.addr_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 21;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_addr(&mut self, value: ZserverAddr) {
        self.addr = value;
    }
    pub fn set_addr_raw(&mut self, value: Vec<u8>) {
        self.addr_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcNotifyZonesvr {
        let packet_id = i16::from_le_bytes([0x71, 0x00]);
        let packet_id_raw = [0x71, 0x00];
        PacketHcNotifyZonesvr {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        addr: ZserverAddr::new(packetver),
        addr_raw: vec![],
        }
    }
}

impl Packet for PacketHcNotifyZonesvr {
    fn id(&self, packetver: u32) -> &str {
       PacketHcNotifyZonesvr::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzEnter {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7200"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzEnter {
        let mut offset: usize = 0;
        PacketCzEnter {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            auth_code: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            client_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            client_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.client_time).unwrap();
        self.client_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.auth_code_raw.to_vec());
        wtr.append(&mut self.client_time_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 19;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_auth_code(&mut self, value: i32) {
        self.auth_code = value;
    }
    pub fn set_auth_code_raw(&mut self, value: [u8; 4]) {
        self.auth_code_raw = value;
    }
    pub fn set_client_time(&mut self, value: u32) {
        self.client_time = value;
    }
    pub fn set_client_time_raw(&mut self, value: [u8; 4]) {
        self.client_time_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzEnter {
        let packet_id = i16::from_le_bytes([0x72, 0x00]);
        let packet_id_raw = [0x72, 0x00];
        PacketCzEnter {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        auth_code: 0,
        auth_code_raw: [0; 4],
        client_time: 0,
        client_time_raw: [0; 4],
        sex: 0,
        sex_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzEnter {
    fn id(&self, packetver: u32) -> &str {
       PacketCzEnter::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAcceptEnter {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7300"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAcceptEnter {
        let mut offset: usize = 0;
        PacketZcAcceptEnter {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            start_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            pos_dir: {
                let field =  {
                let mut dst: [u8; 3] = [0_u8; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[offset..offset + 3]);
                offset += 3;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.start_time_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 11;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_start_time(&mut self, value: u32) {
        self.start_time = value;
    }
    pub fn set_start_time_raw(&mut self, value: [u8; 4]) {
        self.start_time_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [u8; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAcceptEnter {
        let packet_id = i16::from_le_bytes([0x73, 0x00]);
        let packet_id_raw = [0x73, 0x00];
        PacketZcAcceptEnter {
        raw: vec![],
        packet_id,
        packet_id_raw,
        start_time: 0,
        start_time_raw: [0; 4],
        pos_dir: [0; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAcceptEnter {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAcceptEnter::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcRefuseEnter {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7400"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcRefuseEnter {
        let mut offset: usize = 0;
        PacketZcRefuseEnter {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_code: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u8) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 1]) {
        self.error_code_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcRefuseEnter {
        let packet_id = i16::from_le_bytes([0x74, 0x00]);
        let packet_id_raw = [0x74, 0x00];
        PacketZcRefuseEnter {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_code: 0,
        error_code_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcRefuseEnter {
    fn id(&self, packetver: u32) -> &str {
       PacketZcRefuseEnter::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyInitchar {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7500"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyInitchar {
        let mut offset: usize = 0;
        PacketZcNotifyInitchar {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            style: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            style_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            item_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.style).unwrap();
        self.style_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item).unwrap();
        self.item_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.style_raw.to_vec());
        wtr.append(&mut self.item_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 11;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_style(&mut self, value: i16) {
        self.style = value;
    }
    pub fn set_style_raw(&mut self, value: [u8; 2]) {
        self.style_raw = value;
    }
    pub fn set_item(&mut self, value: u8) {
        self.item = value;
    }
    pub fn set_item_raw(&mut self, value: [u8; 1]) {
        self.item_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyInitchar {
        let packet_id = i16::from_le_bytes([0x75, 0x00]);
        let packet_id_raw = [0x75, 0x00];
        PacketZcNotifyInitchar {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        gid: 0,
        gid_raw: [0; 4],
        style: 0,
        style_raw: [0; 2],
        item: 0,
        item_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcNotifyInitchar {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyInitchar::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyUpdatechar {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7600"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyUpdatechar {
        let mut offset: usize = 0;
        PacketZcNotifyUpdatechar {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            style: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            style_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            item_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.style).unwrap();
        self.style_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item).unwrap();
        self.item_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.style_raw.to_vec());
        wtr.append(&mut self.item_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 9;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_style(&mut self, value: i16) {
        self.style = value;
    }
    pub fn set_style_raw(&mut self, value: [u8; 2]) {
        self.style_raw = value;
    }
    pub fn set_item(&mut self, value: u8) {
        self.item = value;
    }
    pub fn set_item_raw(&mut self, value: [u8; 1]) {
        self.item_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyUpdatechar {
        let packet_id = i16::from_le_bytes([0x76, 0x00]);
        let packet_id_raw = [0x76, 0x00];
        PacketZcNotifyUpdatechar {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        style: 0,
        style_raw: [0; 2],
        item: 0,
        item_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcNotifyUpdatechar {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyUpdatechar::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyUpdateplayer {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7700"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyUpdateplayer {
        let mut offset: usize = 0;
        PacketZcNotifyUpdateplayer {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            style: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            style_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            item_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.style).unwrap();
        self.style_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item).unwrap();
        self.item_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.style_raw.to_vec());
        wtr.append(&mut self.item_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_style(&mut self, value: i16) {
        self.style = value;
    }
    pub fn set_style_raw(&mut self, value: [u8; 2]) {
        self.style_raw = value;
    }
    pub fn set_item(&mut self, value: u8) {
        self.item = value;
    }
    pub fn set_item_raw(&mut self, value: [u8; 1]) {
        self.item_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyUpdateplayer {
        let packet_id = i16::from_le_bytes([0x77, 0x00]);
        let packet_id_raw = [0x77, 0x00];
        PacketZcNotifyUpdateplayer {
        raw: vec![],
        packet_id,
        packet_id_raw,
        style: 0,
        style_raw: [0; 2],
        item: 0,
        item_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcNotifyUpdateplayer {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyUpdateplayer::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyStandentry {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7800"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyStandentry {
        let mut offset: usize = 0;
        PacketZcNotifyStandentry {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            objecttype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            shield: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            shield_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory2: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gemblem_ver: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            honor: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            virtue: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            pos_dir: {
                let field =  {
                let mut dst: [u8; 3] = [0_u8; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[offset..offset + 3]);
                offset += 3;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            state: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            clevel: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.objecttype_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.shield_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 55;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_objecttype(&mut self, value: u8) {
        self.objecttype = value;
    }
    pub fn set_objecttype_raw(&mut self, value: [u8; 1]) {
        self.objecttype_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i16) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 2]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i16) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 2]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_shield(&mut self, value: i16) {
        self.shield = value;
    }
    pub fn set_shield_raw(&mut self, value: [u8; 2]) {
        self.shield_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i16) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 2]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [u8; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_state(&mut self, value: u8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyStandentry {
        let packet_id = i16::from_le_bytes([0x78, 0x00]);
        let packet_id_raw = [0x78, 0x00];
        PacketZcNotifyStandentry {
        raw: vec![],
        packet_id,
        packet_id_raw,
        objecttype: 0,
        objecttype_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 2],
        accessory: 0,
        accessory_raw: [0; 2],
        shield: 0,
        shield_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 2],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        state: 0,
        state_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyStandentry {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyStandentry::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyNewentry {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7900"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyNewentry {
        let mut offset: usize = 0;
        PacketZcNotifyNewentry {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            shield: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            shield_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory2: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gemblem_ver: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            honor: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            virtue: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            pos_dir: {
                let field =  {
                let mut dst: [u8; 3] = [0_u8; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[offset..offset + 3]);
                offset += 3;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            clevel: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.shield_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 53;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i16) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 2]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i16) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 2]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_shield(&mut self, value: i16) {
        self.shield = value;
    }
    pub fn set_shield_raw(&mut self, value: [u8; 2]) {
        self.shield_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i16) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 2]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [u8; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyNewentry {
        let packet_id = i16::from_le_bytes([0x79, 0x00]);
        let packet_id_raw = [0x79, 0x00];
        PacketZcNotifyNewentry {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 2],
        accessory: 0,
        accessory_raw: [0; 2],
        shield: 0,
        shield_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 2],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyNewentry {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyNewentry::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyActentry {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7a00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyActentry {
        let mut offset: usize = 0;
        PacketZcNotifyActentry {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            shield: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            shield_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory2: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gemblem_ver: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            honor: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            virtue: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            pos_dir: {
                let field =  {
                let mut dst: [u8; 3] = [0_u8; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[offset..offset + 3]);
                offset += 3;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            action: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            act_start_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            act_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            clevel: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.act_start_time).unwrap();
        self.act_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.shield_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        wtr.append(&mut self.act_start_time_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 58;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i16) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 2]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i16) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 2]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_shield(&mut self, value: i16) {
        self.shield = value;
    }
    pub fn set_shield_raw(&mut self, value: [u8; 2]) {
        self.shield_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i16) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 2]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [u8; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn set_act_start_time(&mut self, value: u32) {
        self.act_start_time = value;
    }
    pub fn set_act_start_time_raw(&mut self, value: [u8; 4]) {
        self.act_start_time_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyActentry {
        let packet_id = i16::from_le_bytes([0x7a, 0x00]);
        let packet_id_raw = [0x7a, 0x00];
        PacketZcNotifyActentry {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 2],
        accessory: 0,
        accessory_raw: [0; 2],
        shield: 0,
        shield_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 2],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        action: 0,
        action_raw: [0; 1],
        act_start_time: 0,
        act_start_time_raw: [0; 4],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyActentry {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyActentry::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyMoveentry {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7b00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyMoveentry {
        let mut offset: usize = 0;
        PacketZcNotifyMoveentry {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            move_start_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            shield: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            shield_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory2: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gemblem_ver: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            honor: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            virtue: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            move_data: {
                let field =  {
                let mut dst: [u16; 6] = [0_u16; 6];
                for (index, byte) in buffer[offset..offset + 6].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            };
                field
            },
            move_data_raw: {
                let mut dst: [u8; 12] = [0u8; 12];
                dst.clone_from_slice(&buffer[offset..offset + 12]);
                offset += 12;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            clevel: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.move_start_time_raw.to_vec());
        wtr.append(&mut self.shield_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.move_data_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 60;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i16) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 2]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i16) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 2]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_move_start_time(&mut self, value: u32) {
        self.move_start_time = value;
    }
    pub fn set_move_start_time_raw(&mut self, value: [u8; 4]) {
        self.move_start_time_raw = value;
    }
    pub fn set_shield(&mut self, value: i16) {
        self.shield = value;
    }
    pub fn set_shield_raw(&mut self, value: [u8; 2]) {
        self.shield_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i16) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 2]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_move_data(&mut self, value: [u16; 6]) {
        self.move_data = value;
    }
    pub fn set_move_data_raw(&mut self, value: [u8; 12]) {
        self.move_data_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyMoveentry {
        let packet_id = i16::from_le_bytes([0x7b, 0x00]);
        let packet_id_raw = [0x7b, 0x00];
        PacketZcNotifyMoveentry {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 2],
        accessory: 0,
        accessory_raw: [0; 2],
        move_start_time: 0,
        move_start_time_raw: [0; 4],
        shield: 0,
        shield_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 2],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        move_data: [0; 6],
        move_data_raw: [0; 12],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyMoveentry {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyMoveentry::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyStandentryNpc {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7c00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyStandentryNpc {
        let mut offset: usize = 0;
        PacketZcNotifyStandentryNpc {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            objecttype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            shield: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            shield_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory2: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            pos_dir: {
                let field =  {
                let mut dst: [u8; 3] = [0_u8; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[offset..offset + 3]);
                offset += 3;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.objecttype_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.shield_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 42;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_objecttype(&mut self, value: u8) {
        self.objecttype = value;
    }
    pub fn set_objecttype_raw(&mut self, value: [u8; 1]) {
        self.objecttype_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i16) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 2]) {
        self.effect_state_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i16) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 2]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_shield(&mut self, value: i16) {
        self.shield = value;
    }
    pub fn set_shield_raw(&mut self, value: [u8; 2]) {
        self.shield_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [u8; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyStandentryNpc {
        let packet_id = i16::from_le_bytes([0x7c, 0x00]);
        let packet_id_raw = [0x7c, 0x00];
        PacketZcNotifyStandentryNpc {
        raw: vec![],
        packet_id,
        packet_id_raw,
        objecttype: 0,
        objecttype_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 2],
        accessory: 0,
        accessory_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        shield: 0,
        shield_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcNotifyStandentryNpc {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyStandentryNpc::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzNotifyActorinit {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7d00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzNotifyActorinit {
        let mut offset: usize = 0;
        PacketCzNotifyActorinit {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzNotifyActorinit {
        let packet_id = i16::from_le_bytes([0x7d, 0x00]);
        let packet_id_raw = [0x7d, 0x00];
        PacketCzNotifyActorinit {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzNotifyActorinit {
    fn id(&self, packetver: u32) -> &str {
       PacketCzNotifyActorinit::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRequestTime {
    pub fn packet_id(packetver: u32) -> &'static str {
        if packetver >= 20120307 {
            "0x0887"
        } else if packetver >= 20111005 {
            "0x0817"
        } else {
            "0x7e00"
        }
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRequestTime {
        let mut offset: usize = 0;
        PacketCzRequestTime {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            client_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            client_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.client_time).unwrap();
        self.client_time_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.client_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_client_time(&mut self, value: u32) {
        self.client_time = value;
    }
    pub fn set_client_time_raw(&mut self, value: [u8; 4]) {
        self.client_time_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRequestTime {
        let (packet_id, packet_id_raw) = if packetver >= 20120307 {
            (i16::from_le_bytes([0x87, 0x08]), [0x87, 0x08])
        } else if packetver >= 20111005 {
            (i16::from_le_bytes([0x17, 0x08]), [0x17, 0x08])
        } else {
            (i16::from_le_bytes([0x7e, 0x00]), [0x7e, 0x00])
        };
        PacketCzRequestTime {
        raw: vec![],
        packet_id,
        packet_id_raw,
        client_time: 0,
        client_time_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzRequestTime {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRequestTime::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyTime {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7f00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyTime {
        let mut offset: usize = 0;
        PacketZcNotifyTime {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.time).unwrap();
        self.time_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_time(&mut self, value: u32) {
        self.time = value;
    }
    pub fn set_time_raw(&mut self, value: [u8; 4]) {
        self.time_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyTime {
        let packet_id = i16::from_le_bytes([0x7f, 0x00]);
        let packet_id_raw = [0x7f, 0x00];
        PacketZcNotifyTime {
        raw: vec![],
        packet_id,
        packet_id_raw,
        time: 0,
        time_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyTime {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyTime::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyVanish {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8000"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyVanish {
        let mut offset: usize = 0;
        PacketZcNotifyVanish {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyVanish {
        let packet_id = i16::from_le_bytes([0x80, 0x00]);
        let packet_id_raw = [0x80, 0x00];
        PacketZcNotifyVanish {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcNotifyVanish {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyVanish::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketScNotifyBan {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8100"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketScNotifyBan {
        let mut offset: usize = 0;
        PacketScNotifyBan {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_code: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u8) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 1]) {
        self.error_code_raw = value;
    }
    pub fn new(packetver: u32) -> PacketScNotifyBan {
        let packet_id = i16::from_le_bytes([0x81, 0x00]);
        let packet_id_raw = [0x81, 0x00];
        PacketScNotifyBan {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_code: 0,
        error_code_raw: [0; 1],
        }
    }
}

impl Packet for PacketScNotifyBan {
    fn id(&self, packetver: u32) -> &str {
       PacketScNotifyBan::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRequestQuit {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8200"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRequestQuit {
        let mut offset: usize = 0;
        PacketCzRequestQuit {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRequestQuit {
        let packet_id = i16::from_le_bytes([0x82, 0x00]);
        let packet_id_raw = [0x82, 0x00];
        PacketCzRequestQuit {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzRequestQuit {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRequestQuit::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAcceptQuit {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8300"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAcceptQuit {
        let mut offset: usize = 0;
        PacketZcAcceptQuit {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAcceptQuit {
        let packet_id = i16::from_le_bytes([0x83, 0x00]);
        let packet_id_raw = [0x83, 0x00];
        PacketZcAcceptQuit {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketZcAcceptQuit {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAcceptQuit::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcRefuseQuit {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8400"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcRefuseQuit {
        let mut offset: usize = 0;
        PacketZcRefuseQuit {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcRefuseQuit {
        let packet_id = i16::from_le_bytes([0x84, 0x00]);
        let packet_id_raw = [0x84, 0x00];
        PacketZcRefuseQuit {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketZcRefuseQuit {
    fn id(&self, packetver: u32) -> &str {
       PacketZcRefuseQuit::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRequestMove {
    pub fn packet_id(packetver: u32) -> &'static str {
        if packetver >= 20130515 {
            "0x0437"
        } else if packetver >= 20120702 {
            "0x0953"
        } else if packetver >= 20120307 {
            "0x0437"
        } else if packetver >= 20111005 {
            "0x0364"
        } else if packetver >= 20101124 {
            "0x035f"
        } else {
            "0x8500"
        }
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRequestMove {
        let mut offset: usize = 0;
        PacketCzRequestMove {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            dest: {
                let field =  {
                let mut dst: [u8; 3] = [0_u8; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            dest_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[offset..offset + 3]);
                offset += 3;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.dest {
            wtr.write_u8(item).unwrap();
        }
        self.dest_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.dest_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_dest(&mut self, value: [u8; 3]) {
        self.dest = value;
    }
    pub fn set_dest_raw(&mut self, value: [u8; 3]) {
        self.dest_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRequestMove {
        let (packet_id, packet_id_raw) = if packetver >= 20130515 {
            (i16::from_le_bytes([0x37, 0x04]), [0x37, 0x04])
        } else if packetver >= 20120702 {
            (i16::from_le_bytes([0x53, 0x09]), [0x53, 0x09])
        } else if packetver >= 20120307 {
            (i16::from_le_bytes([0x37, 0x04]), [0x37, 0x04])
        } else if packetver >= 20111005 {
            (i16::from_le_bytes([0x64, 0x03]), [0x64, 0x03])
        } else if packetver >= 20101124 {
            (i16::from_le_bytes([0x5f, 0x03]), [0x5f, 0x03])
        } else {
            (i16::from_le_bytes([0x85, 0x00]), [0x85, 0x00])
        };
        PacketCzRequestMove {
        raw: vec![],
        packet_id,
        packet_id_raw,
        dest: [0; 3],
        dest_raw: [0; 3],
        }
    }
}

impl Packet for PacketCzRequestMove {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRequestMove::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyMove {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8600"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyMove {
        let mut offset: usize = 0;
        PacketZcNotifyMove {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            move_data: {
                let field =  {
                let mut dst: [u8; 6] = [0_u8; 6];
                for (index, byte) in buffer[offset..offset + 6].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            move_data_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[offset..offset + 6]);
                offset += 6;
                dst
            },
            move_start_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u8(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.move_data_raw.to_vec());
        wtr.append(&mut self.move_start_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 16;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_move_data(&mut self, value: [u8; 6]) {
        self.move_data = value;
    }
    pub fn set_move_data_raw(&mut self, value: [u8; 6]) {
        self.move_data_raw = value;
    }
    pub fn set_move_start_time(&mut self, value: u32) {
        self.move_start_time = value;
    }
    pub fn set_move_start_time_raw(&mut self, value: [u8; 4]) {
        self.move_start_time_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyMove {
        let packet_id = i16::from_le_bytes([0x86, 0x00]);
        let packet_id_raw = [0x86, 0x00];
        PacketZcNotifyMove {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        move_data: [0; 6],
        move_data_raw: [0; 6],
        move_start_time: 0,
        move_start_time_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyMove {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyMove::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyPlayermove {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8700"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyPlayermove {
        let mut offset: usize = 0;
        PacketZcNotifyPlayermove {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            move_start_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            move_data: {
                let field =  {
                let mut dst: [u8; 6] = [0_u8; 6];
                for (index, byte) in buffer[offset..offset + 6].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            move_data_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[offset..offset + 6]);
                offset += 6;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u8(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.move_start_time_raw.to_vec());
        wtr.append(&mut self.move_data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 12;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_move_start_time(&mut self, value: u32) {
        self.move_start_time = value;
    }
    pub fn set_move_start_time_raw(&mut self, value: [u8; 4]) {
        self.move_start_time_raw = value;
    }
    pub fn set_move_data(&mut self, value: [u8; 6]) {
        self.move_data = value;
    }
    pub fn set_move_data_raw(&mut self, value: [u8; 6]) {
        self.move_data_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyPlayermove {
        let packet_id = i16::from_le_bytes([0x87, 0x00]);
        let packet_id_raw = [0x87, 0x00];
        PacketZcNotifyPlayermove {
        raw: vec![],
        packet_id,
        packet_id_raw,
        move_start_time: 0,
        move_start_time_raw: [0; 4],
        move_data: [0; 6],
        move_data_raw: [0; 6],
        }
    }
}

impl Packet for PacketZcNotifyPlayermove {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyPlayermove::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcStopmove {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8800"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcStopmove {
        let mut offset: usize = 0;
        PacketZcStopmove {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcStopmove {
        let packet_id = i16::from_le_bytes([0x88, 0x00]);
        let packet_id_raw = [0x88, 0x00];
        PacketZcStopmove {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcStopmove {
    fn id(&self, packetver: u32) -> &str {
       PacketZcStopmove::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRequestAct {
    pub fn packet_id(packetver: u32) -> &'static str {
        if packetver >= 20120307 {
            "0x0885"
        } else {
            "0x8900"
        }
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRequestAct {
        let mut offset: usize = 0;
        PacketCzRequestAct {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            target_gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            target_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            action: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_gid).unwrap();
        self.target_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.target_gid_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_target_gid(&mut self, value: u32) {
        self.target_gid = value;
    }
    pub fn set_target_gid_raw(&mut self, value: [u8; 4]) {
        self.target_gid_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRequestAct {
        let (packet_id, packet_id_raw) = if packetver >= 20120307 {
            (i16::from_le_bytes([0x85, 0x08]), [0x85, 0x08])
        } else {
            (i16::from_le_bytes([0x89, 0x00]), [0x89, 0x00])
        };
        PacketCzRequestAct {
        raw: vec![],
        packet_id,
        packet_id_raw,
        target_gid: 0,
        target_gid_raw: [0; 4],
        action: 0,
        action_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzRequestAct {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRequestAct::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyAct {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8a00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyAct {
        let mut offset: usize = 0;
        PacketZcNotifyAct {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            target_gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            target_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            start_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            attack_mt: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            attack_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            attacked_mt: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            attacked_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            damage: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            damage_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            action: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            left_damage: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            left_damage_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_gid).unwrap();
        self.target_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attack_mt).unwrap();
        self.attack_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attacked_mt).unwrap();
        self.attacked_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.damage).unwrap();
        self.damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.left_damage).unwrap();
        self.left_damage_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.target_gid_raw.to_vec());
        wtr.append(&mut self.start_time_raw.to_vec());
        wtr.append(&mut self.attack_mt_raw.to_vec());
        wtr.append(&mut self.attacked_mt_raw.to_vec());
        wtr.append(&mut self.damage_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        wtr.append(&mut self.left_damage_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 29;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_target_gid(&mut self, value: u32) {
        self.target_gid = value;
    }
    pub fn set_target_gid_raw(&mut self, value: [u8; 4]) {
        self.target_gid_raw = value;
    }
    pub fn set_start_time(&mut self, value: u32) {
        self.start_time = value;
    }
    pub fn set_start_time_raw(&mut self, value: [u8; 4]) {
        self.start_time_raw = value;
    }
    pub fn set_attack_mt(&mut self, value: i32) {
        self.attack_mt = value;
    }
    pub fn set_attack_mt_raw(&mut self, value: [u8; 4]) {
        self.attack_mt_raw = value;
    }
    pub fn set_attacked_mt(&mut self, value: i32) {
        self.attacked_mt = value;
    }
    pub fn set_attacked_mt_raw(&mut self, value: [u8; 4]) {
        self.attacked_mt_raw = value;
    }
    pub fn set_damage(&mut self, value: i16) {
        self.damage = value;
    }
    pub fn set_damage_raw(&mut self, value: [u8; 2]) {
        self.damage_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn set_left_damage(&mut self, value: i16) {
        self.left_damage = value;
    }
    pub fn set_left_damage_raw(&mut self, value: [u8; 2]) {
        self.left_damage_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyAct {
        let packet_id = i16::from_le_bytes([0x8a, 0x00]);
        let packet_id_raw = [0x8a, 0x00];
        PacketZcNotifyAct {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        target_gid: 0,
        target_gid_raw: [0; 4],
        start_time: 0,
        start_time_raw: [0; 4],
        attack_mt: 0,
        attack_mt_raw: [0; 4],
        attacked_mt: 0,
        attacked_mt_raw: [0; 4],
        damage: 0,
        damage_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        action: 0,
        action_raw: [0; 1],
        left_damage: 0,
        left_damage_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyAct {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyAct::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyActPosition {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8b00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyActPosition {
        let mut offset: usize = 0;
        PacketZcNotifyActPosition {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            target_gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            target_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            start_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            damage: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            damage_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            action: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_gid).unwrap();
        self.target_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.damage).unwrap();
        self.damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.target_gid_raw.to_vec());
        wtr.append(&mut self.start_time_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.damage_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 23;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_target_gid(&mut self, value: u32) {
        self.target_gid = value;
    }
    pub fn set_target_gid_raw(&mut self, value: [u8; 4]) {
        self.target_gid_raw = value;
    }
    pub fn set_start_time(&mut self, value: u32) {
        self.start_time = value;
    }
    pub fn set_start_time_raw(&mut self, value: [u8; 4]) {
        self.start_time_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_damage(&mut self, value: i16) {
        self.damage = value;
    }
    pub fn set_damage_raw(&mut self, value: [u8; 2]) {
        self.damage_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyActPosition {
        let packet_id = i16::from_le_bytes([0x8b, 0x00]);
        let packet_id_raw = [0x8b, 0x00];
        PacketZcNotifyActPosition {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        target_gid: 0,
        target_gid_raw: [0; 4],
        start_time: 0,
        start_time_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        damage: 0,
        damage_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        action: 0,
        action_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcNotifyActPosition {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyActPosition::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRequestChat {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8c00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRequestChat {
        let mut offset: usize = 0;
        PacketCzRequestChat {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRequestChat {
        let packet_id = i16::from_le_bytes([0x8c, 0x00]);
        let packet_id_raw = [0x8c, 0x00];
        PacketCzRequestChat {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketCzRequestChat {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRequestChat::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyChat {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8d00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyChat {
        let mut offset: usize = 0;
        PacketZcNotifyChat {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyChat {
        let packet_id = i16::from_le_bytes([0x8d, 0x00]);
        let packet_id_raw = [0x8d, 0x00];
        PacketZcNotifyChat {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        gid: 0,
        gid_raw: [0; 4],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcNotifyChat {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyChat::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyPlayerchat {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8e00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyPlayerchat {
        let mut offset: usize = 0;
        PacketZcNotifyPlayerchat {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyPlayerchat {
        let packet_id = i16::from_le_bytes([0x8e, 0x00]);
        let packet_id_raw = [0x8e, 0x00];
        PacketZcNotifyPlayerchat {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcNotifyPlayerchat {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyPlayerchat::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketServerEntryAck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8f00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketServerEntryAck {
        let mut offset: usize = 0;
        PacketServerEntryAck {
            header: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            header_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.header).unwrap();
        self.header_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.header_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_header(&mut self, value: i16) {
        self.header = value;
    }
    pub fn set_header_raw(&mut self, value: [u8; 2]) {
        self.header_raw = value;
    }
    pub fn set_aid(&mut self, value: i32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketServerEntryAck {
        let packet_id = i16::from_le_bytes([0x8f, 0x00]);
        let packet_id_raw = [0x8f, 0x00];
        PacketServerEntryAck {
        raw: vec![],
        header: 0,
        header_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketServerEntryAck {
    fn id(&self, packetver: u32) -> &str {
       PacketServerEntryAck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzContactnpc {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9000"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzContactnpc {
        let mut offset: usize = 0;
        PacketCzContactnpc {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            naid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzContactnpc {
        let packet_id = i16::from_le_bytes([0x90, 0x00]);
        let packet_id_raw = [0x90, 0x00];
        PacketCzContactnpc {
        raw: vec![],
        packet_id,
        packet_id_raw,
        naid: 0,
        naid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzContactnpc {
    fn id(&self, packetver: u32) -> &str {
       PacketCzContactnpc::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNpcackMapmove {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9100"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNpcackMapmove {
        let mut offset: usize = 0;
        PacketZcNpcackMapmove {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            map_name: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 22;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNpcackMapmove {
        let packet_id = i16::from_le_bytes([0x91, 0x00]);
        let packet_id_raw = [0x91, 0x00];
        PacketZcNpcackMapmove {
        raw: vec![],
        packet_id,
        packet_id_raw,
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNpcackMapmove {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNpcackMapmove::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNpcackServermove {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9200"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNpcackServermove {
        let mut offset: usize = 0;
        PacketZcNpcackServermove {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            map_name: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            addr: {
                let field = ZserverAddr::from(&buffer[offset..offset + ZserverAddr::base_len(packetver)], packetver);
                field
            },
            addr_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        self.addr.fill_raw_with_packetver(packetver);
        self.addr_raw = self.addr.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.addr_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 21;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_addr(&mut self, value: ZserverAddr) {
        self.addr = value;
    }
    pub fn set_addr_raw(&mut self, value: Vec<u8>) {
        self.addr_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNpcackServermove {
        let packet_id = i16::from_le_bytes([0x92, 0x00]);
        let packet_id_raw = [0x92, 0x00];
        PacketZcNpcackServermove {
        raw: vec![],
        packet_id,
        packet_id_raw,
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        addr: ZserverAddr::new(packetver),
        addr_raw: vec![],
        }
    }
}

impl Packet for PacketZcNpcackServermove {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNpcackServermove::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNpcackEnable {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9300"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNpcackEnable {
        let mut offset: usize = 0;
        PacketZcNpcackEnable {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNpcackEnable {
        let packet_id = i16::from_le_bytes([0x93, 0x00]);
        let packet_id_raw = [0x93, 0x00];
        PacketZcNpcackEnable {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketZcNpcackEnable {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNpcackEnable::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqname {
    pub fn packet_id(packetver: u32) -> &'static str {
        if packetver >= 20140402 {
            "0x088A"
        } else if packetver >= 20131223 {
            "0x096A"
        } else if packetver >= 20120218 {
            "0x096A"
        } else if packetver >= 20111005 {
            "0x088A"
        } else {
            "0x9400"
        }
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqname {
        let mut offset: usize = 0;
        PacketCzReqname {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqname {
        let (packet_id, packet_id_raw) = if packetver >= 20140402 {
            (i16::from_le_bytes([0x8A, 0x08]), [0x8A, 0x08])
        } else if packetver >= 20131223 {
            (i16::from_le_bytes([0x6A, 0x09]), [0x6A, 0x09])
        } else if packetver >= 20120218 {
            (i16::from_le_bytes([0x6A, 0x09]), [0x6A, 0x09])
        } else if packetver >= 20111005 {
            (i16::from_le_bytes([0x8A, 0x08]), [0x8A, 0x08])
        } else {
            (i16::from_le_bytes([0x94, 0x00]), [0x94, 0x00])
        };
        PacketCzReqname {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqname {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqname::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckReqname {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9500"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckReqname {
        let mut offset: usize = 0;
        PacketZcAckReqname {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            cname: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            cname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.cname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.cname_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.cname_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 30;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_cname(&mut self, value: [char; 24]) {
        self.cname = value;
    }
    pub fn set_cname_raw(&mut self, value: [u8; 24]) {
        self.cname_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckReqname {
        let packet_id = i16::from_le_bytes([0x95, 0x00]);
        let packet_id_raw = [0x95, 0x00];
        PacketZcAckReqname {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        cname: [0 as char; 24],
        cname_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcAckReqname {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckReqname::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzWhisper {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9600"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzWhisper {
        let mut offset: usize = 0;
        PacketCzWhisper {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            receiver: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            receiver_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.receiver {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.receiver_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.receiver_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 27;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_receiver(&mut self, value: [char; 24]) {
        self.receiver = value;
    }
    pub fn set_receiver_raw(&mut self, value: [u8; 24]) {
        self.receiver_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzWhisper {
        let packet_id = i16::from_le_bytes([0x96, 0x00]);
        let packet_id_raw = [0x96, 0x00];
        PacketCzWhisper {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        receiver: [0 as char; 24],
        receiver_raw: [0; 24],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketCzWhisper {
    fn id(&self, packetver: u32) -> &str {
       PacketCzWhisper::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcWhisper {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9700"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcWhisper {
        let mut offset: usize = 0;
        PacketZcWhisper {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            sender: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            sender_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sender {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sender_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.sender_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 27;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_sender(&mut self, value: [char; 24]) {
        self.sender = value;
    }
    pub fn set_sender_raw(&mut self, value: [u8; 24]) {
        self.sender_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcWhisper {
        let packet_id = i16::from_le_bytes([0x97, 0x00]);
        let packet_id_raw = [0x97, 0x00];
        PacketZcWhisper {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        sender: [0 as char; 24],
        sender_raw: [0; 24],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcWhisper {
    fn id(&self, packetver: u32) -> &str {
       PacketZcWhisper::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckWhisper {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9800"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckWhisper {
        let mut offset: usize = 0;
        PacketZcAckWhisper {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckWhisper {
        let packet_id = i16::from_le_bytes([0x98, 0x00]);
        let packet_id_raw = [0x98, 0x00];
        PacketZcAckWhisper {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckWhisper {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckWhisper::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzBroadcast {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9900"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzBroadcast {
        let mut offset: usize = 0;
        PacketCzBroadcast {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzBroadcast {
        let packet_id = i16::from_le_bytes([0x99, 0x00]);
        let packet_id_raw = [0x99, 0x00];
        PacketCzBroadcast {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketCzBroadcast {
    fn id(&self, packetver: u32) -> &str {
       PacketCzBroadcast::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcBroadcast {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9a00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcBroadcast {
        let mut offset: usize = 0;
        PacketZcBroadcast {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcBroadcast {
        let packet_id = i16::from_le_bytes([0x9a, 0x00]);
        let packet_id_raw = [0x9a, 0x00];
        PacketZcBroadcast {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcBroadcast {
    fn id(&self, packetver: u32) -> &str {
       PacketZcBroadcast::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzChangeDirection {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9b00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzChangeDirection {
        let mut offset: usize = 0;
        PacketCzChangeDirection {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            dir: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            dir_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dir).unwrap();
        self.dir_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.dir_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_dir(&mut self, value: u8) {
        self.dir = value;
    }
    pub fn set_dir_raw(&mut self, value: [u8; 1]) {
        self.dir_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzChangeDirection {
        let packet_id = i16::from_le_bytes([0x9b, 0x00]);
        let packet_id_raw = [0x9b, 0x00];
        PacketCzChangeDirection {
        raw: vec![],
        packet_id,
        packet_id_raw,
        head_dir: 0,
        head_dir_raw: [0; 2],
        dir: 0,
        dir_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzChangeDirection {
    fn id(&self, packetver: u32) -> &str {
       PacketCzChangeDirection::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcChangeDirection {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9c00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcChangeDirection {
        let mut offset: usize = 0;
        PacketZcChangeDirection {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            head_dir: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            dir: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            dir_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dir).unwrap();
        self.dir_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.dir_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 9;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_dir(&mut self, value: u8) {
        self.dir = value;
    }
    pub fn set_dir_raw(&mut self, value: [u8; 1]) {
        self.dir_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcChangeDirection {
        let packet_id = i16::from_le_bytes([0x9c, 0x00]);
        let packet_id_raw = [0x9c, 0x00];
        PacketZcChangeDirection {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        head_dir: 0,
        head_dir_raw: [0; 2],
        dir: 0,
        dir_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcChangeDirection {
    fn id(&self, packetver: u32) -> &str {
       PacketZcChangeDirection::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcItemEntry {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9d00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcItemEntry {
        let mut offset: usize = 0;
        PacketZcItemEntry {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itaid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            itaid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            sub_x: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sub_x_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sub_y: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sub_y_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.itaid).unwrap();
        self.itaid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sub_x).unwrap();
        self.sub_x_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sub_y).unwrap();
        self.sub_y_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itaid_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.sub_x_raw.to_vec());
        wtr.append(&mut self.sub_y_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 17;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itaid(&mut self, value: u32) {
        self.itaid = value;
    }
    pub fn set_itaid_raw(&mut self, value: [u8; 4]) {
        self.itaid_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_sub_x(&mut self, value: u8) {
        self.sub_x = value;
    }
    pub fn set_sub_x_raw(&mut self, value: [u8; 1]) {
        self.sub_x_raw = value;
    }
    pub fn set_sub_y(&mut self, value: u8) {
        self.sub_y = value;
    }
    pub fn set_sub_y_raw(&mut self, value: [u8; 1]) {
        self.sub_y_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcItemEntry {
        let packet_id = i16::from_le_bytes([0x9d, 0x00]);
        let packet_id_raw = [0x9d, 0x00];
        PacketZcItemEntry {
        raw: vec![],
        packet_id,
        packet_id_raw,
        itaid: 0,
        itaid_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        sub_x: 0,
        sub_x_raw: [0; 1],
        sub_y: 0,
        sub_y_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcItemEntry {
    fn id(&self, packetver: u32) -> &str {
       PacketZcItemEntry::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcItemFallEntry {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9e00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcItemFallEntry {
        let mut offset: usize = 0;
        PacketZcItemFallEntry {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itaid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            itaid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            sub_x: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sub_x_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sub_y: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sub_y_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.itaid).unwrap();
        self.itaid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sub_x).unwrap();
        self.sub_x_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sub_y).unwrap();
        self.sub_y_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itaid_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.sub_x_raw.to_vec());
        wtr.append(&mut self.sub_y_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 17;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itaid(&mut self, value: u32) {
        self.itaid = value;
    }
    pub fn set_itaid_raw(&mut self, value: [u8; 4]) {
        self.itaid_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_sub_x(&mut self, value: u8) {
        self.sub_x = value;
    }
    pub fn set_sub_x_raw(&mut self, value: [u8; 1]) {
        self.sub_x_raw = value;
    }
    pub fn set_sub_y(&mut self, value: u8) {
        self.sub_y = value;
    }
    pub fn set_sub_y_raw(&mut self, value: [u8; 1]) {
        self.sub_y_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcItemFallEntry {
        let packet_id = i16::from_le_bytes([0x9e, 0x00]);
        let packet_id_raw = [0x9e, 0x00];
        PacketZcItemFallEntry {
        raw: vec![],
        packet_id,
        packet_id_raw,
        itaid: 0,
        itaid_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        sub_x: 0,
        sub_x_raw: [0; 1],
        sub_y: 0,
        sub_y_raw: [0; 1],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcItemFallEntry {
    fn id(&self, packetver: u32) -> &str {
       PacketZcItemFallEntry::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzItemPickup {
    pub fn packet_id(packetver: u32) -> &'static str {
        if packetver >= 20120307 {
            "0x0865"
        } else {
            "0x9f00"
        }
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzItemPickup {
        let mut offset: usize = 0;
        PacketCzItemPickup {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itaid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            itaid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.itaid).unwrap();
        self.itaid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itaid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itaid(&mut self, value: u32) {
        self.itaid = value;
    }
    pub fn set_itaid_raw(&mut self, value: [u8; 4]) {
        self.itaid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzItemPickup {
        let (packet_id, packet_id_raw) = if packetver >= 20120307 {
            (i16::from_le_bytes([0x65, 0x08]), [0x65, 0x08])
        } else {
            (i16::from_le_bytes([0x9f, 0x00]), [0x9f, 0x00])
        };
        PacketCzItemPickup {
        raw: vec![],
        packet_id,
        packet_id_raw,
        itaid: 0,
        itaid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzItemPickup {
    fn id(&self, packetver: u32) -> &str {
       PacketCzItemPickup::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcItemPickupAck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa000"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcItemPickupAck {
        let mut offset: usize = 0;
        PacketZcItemPickupAck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_damaged: {
                let field = buffer[offset] == 1;
                field
            },
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            refining_level: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            location: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        wtr.append(&mut self.location_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 23;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: u16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn set_location(&mut self, value: u16) {
        self.location = value;
    }
    pub fn set_location_raw(&mut self, value: [u8; 2]) {
        self.location_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcItemPickupAck {
        let packet_id = i16::from_le_bytes([0xa0, 0x00]);
        let packet_id_raw = [0xa0, 0x00];
        PacketZcItemPickupAck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        location: 0,
        location_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcItemPickupAck {
    fn id(&self, packetver: u32) -> &str {
       PacketZcItemPickupAck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcItemDisappear {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa100"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcItemDisappear {
        let mut offset: usize = 0;
        PacketZcItemDisappear {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itaid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            itaid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.itaid).unwrap();
        self.itaid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itaid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itaid(&mut self, value: u32) {
        self.itaid = value;
    }
    pub fn set_itaid_raw(&mut self, value: [u8; 4]) {
        self.itaid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcItemDisappear {
        let packet_id = i16::from_le_bytes([0xa1, 0x00]);
        let packet_id_raw = [0xa1, 0x00];
        PacketZcItemDisappear {
        raw: vec![],
        packet_id,
        packet_id_raw,
        itaid: 0,
        itaid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcItemDisappear {
    fn id(&self, packetver: u32) -> &str {
       PacketZcItemDisappear::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzItemThrow {
    pub fn packet_id(packetver: u32) -> &'static str {
        if packetver >= 20120307 {
            "0x02c4"
        } else {
            "0xa200"
        }
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzItemThrow {
        let mut offset: usize = 0;
        PacketCzItemThrow {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzItemThrow {
        let (packet_id, packet_id_raw) = if packetver >= 20120307 {
            (i16::from_le_bytes([0xc4, 0x02]), [0xc4, 0x02])
        } else {
            (i16::from_le_bytes([0xa2, 0x00]), [0xa2, 0x00])
        };
        PacketCzItemThrow {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzItemThrow {
    fn id(&self, packetver: u32) -> &str {
       PacketCzItemThrow::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNormalItemlist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa300"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNormalItemlist {
        let mut offset: usize = 0;
        let vec_type_len = NormalitemExtrainfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<NormalitemExtrainfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(NormalitemExtrainfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcNormalItemlist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_info: {
                let field = vec_field.clone();
                field
            },
            item_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<NormalitemExtrainfo>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNormalItemlist {
        let packet_id = i16::from_le_bytes([0xa3, 0x00]);
        let packet_id_raw = [0xa3, 0x00];
        PacketZcNormalItemlist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcNormalItemlist {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNormalItemlist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcEquipmentItemlist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa400"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcEquipmentItemlist {
        let mut offset: usize = 0;
        let vec_type_len = EquipmentitemExtrainfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<EquipmentitemExtrainfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(EquipmentitemExtrainfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcEquipmentItemlist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_info: {
                let field = vec_field.clone();
                field
            },
            item_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcEquipmentItemlist {
        let packet_id = i16::from_le_bytes([0xa4, 0x00]);
        let packet_id_raw = [0xa4, 0x00];
        PacketZcEquipmentItemlist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcEquipmentItemlist {
    fn id(&self, packetver: u32) -> &str {
       PacketZcEquipmentItemlist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcStoreNormalItemlist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa500"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcStoreNormalItemlist {
        let mut offset: usize = 0;
        let vec_type_len = NormalitemExtrainfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<NormalitemExtrainfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(NormalitemExtrainfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcStoreNormalItemlist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_info: {
                let field = vec_field.clone();
                field
            },
            item_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<NormalitemExtrainfo>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcStoreNormalItemlist {
        let packet_id = i16::from_le_bytes([0xa5, 0x00]);
        let packet_id_raw = [0xa5, 0x00];
        PacketZcStoreNormalItemlist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcStoreNormalItemlist {
    fn id(&self, packetver: u32) -> &str {
       PacketZcStoreNormalItemlist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcStoreEquipmentItemlist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa600"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcStoreEquipmentItemlist {
        let mut offset: usize = 0;
        let vec_type_len = EquipmentitemExtrainfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<EquipmentitemExtrainfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(EquipmentitemExtrainfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcStoreEquipmentItemlist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_info: {
                let field = vec_field.clone();
                field
            },
            item_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcStoreEquipmentItemlist {
        let packet_id = i16::from_le_bytes([0xa6, 0x00]);
        let packet_id_raw = [0xa6, 0x00];
        PacketZcStoreEquipmentItemlist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcStoreEquipmentItemlist {
    fn id(&self, packetver: u32) -> &str {
       PacketZcStoreEquipmentItemlist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzUseItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        if packetver >= 20120307 {
            "0x0439"
        } else {
            "0xa700"
        }
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzUseItem {
        let mut offset: usize = 0;
        PacketCzUseItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzUseItem {
        let (packet_id, packet_id_raw) = if packetver >= 20120307 {
            (i16::from_le_bytes([0x39, 0x04]), [0x39, 0x04])
        } else {
            (i16::from_le_bytes([0xa7, 0x00]), [0xa7, 0x00])
        };
        PacketCzUseItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzUseItem {
    fn id(&self, packetver: u32) -> &str {
       PacketCzUseItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcUseItemAck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa800"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcUseItemAck {
        let mut offset: usize = 0;
        PacketZcUseItemAck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = buffer[offset] == 1;
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_result(&mut self, value: bool) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcUseItemAck {
        let packet_id = i16::from_le_bytes([0xa8, 0x00]);
        let packet_id_raw = [0xa8, 0x00];
        PacketZcUseItemAck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        result: false,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcUseItemAck {
    fn id(&self, packetver: u32) -> &str {
       PacketZcUseItemAck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqWearEquip {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa900"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqWearEquip {
        let mut offset: usize = 0;
        PacketCzReqWearEquip {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            wear_location: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            wear_location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_location).unwrap();
        self.wear_location_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.wear_location_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_wear_location(&mut self, value: u16) {
        self.wear_location = value;
    }
    pub fn set_wear_location_raw(&mut self, value: [u8; 2]) {
        self.wear_location_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqWearEquip {
        let packet_id = i16::from_le_bytes([0xa9, 0x00]);
        let packet_id_raw = [0xa9, 0x00];
        PacketCzReqWearEquip {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        wear_location: 0,
        wear_location_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqWearEquip {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqWearEquip::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcReqWearEquipAck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xaa00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcReqWearEquipAck {
        let mut offset: usize = 0;
        PacketZcReqWearEquipAck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            wear_location: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            wear_location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_location).unwrap();
        self.wear_location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.wear_location_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_wear_location(&mut self, value: u16) {
        self.wear_location = value;
    }
    pub fn set_wear_location_raw(&mut self, value: [u8; 2]) {
        self.wear_location_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcReqWearEquipAck {
        let packet_id = i16::from_le_bytes([0xaa, 0x00]);
        let packet_id_raw = [0xaa, 0x00];
        PacketZcReqWearEquipAck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        wear_location: 0,
        wear_location_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcReqWearEquipAck {
    fn id(&self, packetver: u32) -> &str {
       PacketZcReqWearEquipAck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcReqWearEquipAck2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd008"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcReqWearEquipAck2 {
        let mut offset: usize = 0;
        PacketZcReqWearEquipAck2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            wear_location: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            wear_location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            view_id: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            view_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_location).unwrap();
        self.wear_location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.view_id).unwrap();
        self.view_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.wear_location_raw.to_vec());
        wtr.append(&mut self.view_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 9;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_wear_location(&mut self, value: u16) {
        self.wear_location = value;
    }
    pub fn set_wear_location_raw(&mut self, value: [u8; 2]) {
        self.wear_location_raw = value;
    }
    pub fn set_view_id(&mut self, value: u16) {
        self.view_id = value;
    }
    pub fn set_view_id_raw(&mut self, value: [u8; 2]) {
        self.view_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcReqWearEquipAck2 {
        let packet_id = i16::from_le_bytes([0xd0, 0x08]);
        let packet_id_raw = [0xd0, 0x08];
        PacketZcReqWearEquipAck2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        wear_location: 0,
        wear_location_raw: [0; 2],
        view_id: 0,
        view_id_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcReqWearEquipAck2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcReqWearEquipAck2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqTakeoffEquip {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xab00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqTakeoffEquip {
        let mut offset: usize = 0;
        PacketCzReqTakeoffEquip {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqTakeoffEquip {
        let packet_id = i16::from_le_bytes([0xab, 0x00]);
        let packet_id_raw = [0xab, 0x00];
        PacketCzReqTakeoffEquip {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqTakeoffEquip {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqTakeoffEquip::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcReqTakeoffEquipAck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xac00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcReqTakeoffEquipAck {
        let mut offset: usize = 0;
        PacketZcReqTakeoffEquipAck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            wear_location: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            wear_location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_location).unwrap();
        self.wear_location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.wear_location_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_wear_location(&mut self, value: u16) {
        self.wear_location = value;
    }
    pub fn set_wear_location_raw(&mut self, value: [u8; 2]) {
        self.wear_location_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcReqTakeoffEquipAck {
        let packet_id = i16::from_le_bytes([0xac, 0x00]);
        let packet_id_raw = [0xac, 0x00];
        PacketZcReqTakeoffEquipAck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        wear_location: 0,
        wear_location_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcReqTakeoffEquipAck {
    fn id(&self, packetver: u32) -> &str {
       PacketZcReqTakeoffEquipAck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcReqTakeoffEquipAck2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd108"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcReqTakeoffEquipAck2 {
        let mut offset: usize = 0;
        PacketZcReqTakeoffEquipAck2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            wear_location: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            wear_location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_location).unwrap();
        self.wear_location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.wear_location_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_wear_location(&mut self, value: u16) {
        self.wear_location = value;
    }
    pub fn set_wear_location_raw(&mut self, value: [u8; 2]) {
        self.wear_location_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcReqTakeoffEquipAck2 {
        let packet_id = i16::from_le_bytes([0xd1, 0x08]);
        let packet_id_raw = [0xd1, 0x08];
        PacketZcReqTakeoffEquipAck2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        wear_location: 0,
        wear_location_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcReqTakeoffEquipAck2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcReqTakeoffEquipAck2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcItemThrowAck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xaf00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcItemThrowAck {
        let mut offset: usize = 0;
        PacketZcItemThrowAck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcItemThrowAck {
        let packet_id = i16::from_le_bytes([0xaf, 0x00]);
        let packet_id_raw = [0xaf, 0x00];
        PacketZcItemThrowAck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcItemThrowAck {
    fn id(&self, packetver: u32) -> &str {
       PacketZcItemThrowAck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcParChange {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb000"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcParChange {
        let mut offset: usize = 0;
        PacketZcParChange {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            var_id: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            var_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var_id).unwrap();
        self.var_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.var_id_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_var_id(&mut self, value: u16) {
        self.var_id = value;
    }
    pub fn set_var_id_raw(&mut self, value: [u8; 2]) {
        self.var_id_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcParChange {
        let packet_id = i16::from_le_bytes([0xb0, 0x00]);
        let packet_id_raw = [0xb0, 0x00];
        PacketZcParChange {
        raw: vec![],
        packet_id,
        packet_id_raw,
        var_id: 0,
        var_id_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcParChange {
    fn id(&self, packetver: u32) -> &str {
       PacketZcParChange::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcLongparChange {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb100"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcLongparChange {
        let mut offset: usize = 0;
        PacketZcLongparChange {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            var_id: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            var_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            amount: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            amount_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var_id).unwrap();
        self.var_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.amount).unwrap();
        self.amount_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.var_id_raw.to_vec());
        wtr.append(&mut self.amount_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_var_id(&mut self, value: u16) {
        self.var_id = value;
    }
    pub fn set_var_id_raw(&mut self, value: [u8; 2]) {
        self.var_id_raw = value;
    }
    pub fn set_amount(&mut self, value: i32) {
        self.amount = value;
    }
    pub fn set_amount_raw(&mut self, value: [u8; 4]) {
        self.amount_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcLongparChange {
        let packet_id = i16::from_le_bytes([0xb1, 0x00]);
        let packet_id_raw = [0xb1, 0x00];
        PacketZcLongparChange {
        raw: vec![],
        packet_id,
        packet_id_raw,
        var_id: 0,
        var_id_raw: [0; 2],
        amount: 0,
        amount_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcLongparChange {
    fn id(&self, packetver: u32) -> &str {
       PacketZcLongparChange::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRestart {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb200"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRestart {
        let mut offset: usize = 0;
        PacketCzRestart {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRestart {
        let packet_id = i16::from_le_bytes([0xb2, 0x00]);
        let packet_id_raw = [0xb2, 0x00];
        PacketCzRestart {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzRestart {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRestart::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcRestartAck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb300"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcRestartAck {
        let mut offset: usize = 0;
        PacketZcRestartAck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcRestartAck {
        let packet_id = i16::from_le_bytes([0xb3, 0x00]);
        let packet_id_raw = [0xb3, 0x00];
        PacketZcRestartAck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcRestartAck {
    fn id(&self, packetver: u32) -> &str {
       PacketZcRestartAck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSayDialog {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb400"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSayDialog {
        let mut offset: usize = 0;
        PacketZcSayDialog {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            naid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSayDialog {
        let packet_id = i16::from_le_bytes([0xb4, 0x00]);
        let packet_id_raw = [0xb4, 0x00];
        PacketZcSayDialog {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        naid: 0,
        naid_raw: [0; 4],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcSayDialog {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSayDialog::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcWaitDialog {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb500"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcWaitDialog {
        let mut offset: usize = 0;
        PacketZcWaitDialog {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            naid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcWaitDialog {
        let packet_id = i16::from_le_bytes([0xb5, 0x00]);
        let packet_id_raw = [0xb5, 0x00];
        PacketZcWaitDialog {
        raw: vec![],
        packet_id,
        packet_id_raw,
        naid: 0,
        naid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcWaitDialog {
    fn id(&self, packetver: u32) -> &str {
       PacketZcWaitDialog::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcCloseDialog {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb600"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcCloseDialog {
        let mut offset: usize = 0;
        PacketZcCloseDialog {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            naid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcCloseDialog {
        let packet_id = i16::from_le_bytes([0xb6, 0x00]);
        let packet_id_raw = [0xb6, 0x00];
        PacketZcCloseDialog {
        raw: vec![],
        packet_id,
        packet_id_raw,
        naid: 0,
        naid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcCloseDialog {
    fn id(&self, packetver: u32) -> &str {
       PacketZcCloseDialog::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMenuList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb700"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMenuList {
        let mut offset: usize = 0;
        PacketZcMenuList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            naid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMenuList {
        let packet_id = i16::from_le_bytes([0xb7, 0x00]);
        let packet_id_raw = [0xb7, 0x00];
        PacketZcMenuList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        naid: 0,
        naid_raw: [0; 4],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcMenuList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMenuList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzChooseMenu {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb800"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzChooseMenu {
        let mut offset: usize = 0;
        PacketCzChooseMenu {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            naid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            num: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.num).unwrap();
        self.num_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        wtr.append(&mut self.num_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn set_num(&mut self, value: u8) {
        self.num = value;
    }
    pub fn set_num_raw(&mut self, value: [u8; 1]) {
        self.num_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzChooseMenu {
        let packet_id = i16::from_le_bytes([0xb8, 0x00]);
        let packet_id_raw = [0xb8, 0x00];
        PacketCzChooseMenu {
        raw: vec![],
        packet_id,
        packet_id_raw,
        naid: 0,
        naid_raw: [0; 4],
        num: 0,
        num_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzChooseMenu {
    fn id(&self, packetver: u32) -> &str {
       PacketCzChooseMenu::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqNextScript {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb900"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqNextScript {
        let mut offset: usize = 0;
        PacketCzReqNextScript {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            naid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqNextScript {
        let packet_id = i16::from_le_bytes([0xb9, 0x00]);
        let packet_id_raw = [0xb9, 0x00];
        PacketCzReqNextScript {
        raw: vec![],
        packet_id,
        packet_id_raw,
        naid: 0,
        naid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqNextScript {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqNextScript::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqStatus {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xba00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqStatus {
        let mut offset: usize = 0;
        PacketCzReqStatus {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqStatus {
        let packet_id = i16::from_le_bytes([0xba, 0x00]);
        let packet_id_raw = [0xba, 0x00];
        PacketCzReqStatus {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzReqStatus {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqStatus::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzStatusChange {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xbb00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzStatusChange {
        let mut offset: usize = 0;
        PacketCzStatusChange {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            status_id: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            status_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            change_amount: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            change_amount_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.status_id).unwrap();
        self.status_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.change_amount).unwrap();
        self.change_amount_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.status_id_raw.to_vec());
        wtr.append(&mut self.change_amount_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_status_id(&mut self, value: u16) {
        self.status_id = value;
    }
    pub fn set_status_id_raw(&mut self, value: [u8; 2]) {
        self.status_id_raw = value;
    }
    pub fn set_change_amount(&mut self, value: u8) {
        self.change_amount = value;
    }
    pub fn set_change_amount_raw(&mut self, value: [u8; 1]) {
        self.change_amount_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzStatusChange {
        let packet_id = i16::from_le_bytes([0xbb, 0x00]);
        let packet_id_raw = [0xbb, 0x00];
        PacketCzStatusChange {
        raw: vec![],
        packet_id,
        packet_id_raw,
        status_id: 0,
        status_id_raw: [0; 2],
        change_amount: 0,
        change_amount_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzStatusChange {
    fn id(&self, packetver: u32) -> &str {
       PacketCzStatusChange::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcStatusChangeAck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xbc00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcStatusChangeAck {
        let mut offset: usize = 0;
        PacketZcStatusChangeAck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            status_id: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            status_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = buffer[offset] == 1;
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            value: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            value_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.status_id).unwrap();
        self.status_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.status_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_status_id(&mut self, value: u16) {
        self.status_id = value;
    }
    pub fn set_status_id_raw(&mut self, value: [u8; 2]) {
        self.status_id_raw = value;
    }
    pub fn set_result(&mut self, value: bool) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn set_value(&mut self, value: u8) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 1]) {
        self.value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcStatusChangeAck {
        let packet_id = i16::from_le_bytes([0xbc, 0x00]);
        let packet_id_raw = [0xbc, 0x00];
        PacketZcStatusChangeAck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        status_id: 0,
        status_id_raw: [0; 2],
        result: false,
        result_raw: [0; 1],
        value: 0,
        value_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcStatusChangeAck {
    fn id(&self, packetver: u32) -> &str {
       PacketZcStatusChangeAck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcStatus {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xbd00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcStatus {
        let mut offset: usize = 0;
        PacketZcStatus {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            point: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            point_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            str: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            str_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            standard_str: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            standard_str_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            agi: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            agi_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            standard_agi: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            standard_agi_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            vit: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            vit_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            standard_vit: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            standard_vit_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            int: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            int_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            standard_int: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            standard_int_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            dex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            dex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            standard_dex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            standard_dex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            luk: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            luk_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            standard_luk: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            standard_luk_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            att_power: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            att_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            refining_power: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            refining_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            max_matt_power: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            max_matt_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            min_matt_power: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            min_matt_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itemdef_power: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itemdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            plusdef_power: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            plusdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mdef_power: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            mdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            plusmdef_power: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            plusmdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            hit_success_value: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            hit_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            avoid_success_value: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            avoid_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            plus_avoid_success_value: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            plus_avoid_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            critical_success_value: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            critical_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aspd: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            plus_aspd: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            plus_aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.str).unwrap();
        self.str_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_str).unwrap();
        self.standard_str_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.agi).unwrap();
        self.agi_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_agi).unwrap();
        self.standard_agi_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.vit).unwrap();
        self.vit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_vit).unwrap();
        self.standard_vit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.int).unwrap();
        self.int_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_int).unwrap();
        self.standard_int_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dex).unwrap();
        self.dex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_dex).unwrap();
        self.standard_dex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.luk).unwrap();
        self.luk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_luk).unwrap();
        self.standard_luk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.att_power).unwrap();
        self.att_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.refining_power).unwrap();
        self.refining_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_matt_power).unwrap();
        self.max_matt_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.min_matt_power).unwrap();
        self.min_matt_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.itemdef_power).unwrap();
        self.itemdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plusdef_power).unwrap();
        self.plusdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef_power).unwrap();
        self.mdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plusmdef_power).unwrap();
        self.plusmdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hit_success_value).unwrap();
        self.hit_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.avoid_success_value).unwrap();
        self.avoid_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plus_avoid_success_value).unwrap();
        self.plus_avoid_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.critical_success_value).unwrap();
        self.critical_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.aspd).unwrap();
        self.aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plus_aspd).unwrap();
        self.plus_aspd_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        wtr.append(&mut self.str_raw.to_vec());
        wtr.append(&mut self.standard_str_raw.to_vec());
        wtr.append(&mut self.agi_raw.to_vec());
        wtr.append(&mut self.standard_agi_raw.to_vec());
        wtr.append(&mut self.vit_raw.to_vec());
        wtr.append(&mut self.standard_vit_raw.to_vec());
        wtr.append(&mut self.int_raw.to_vec());
        wtr.append(&mut self.standard_int_raw.to_vec());
        wtr.append(&mut self.dex_raw.to_vec());
        wtr.append(&mut self.standard_dex_raw.to_vec());
        wtr.append(&mut self.luk_raw.to_vec());
        wtr.append(&mut self.standard_luk_raw.to_vec());
        wtr.append(&mut self.att_power_raw.to_vec());
        wtr.append(&mut self.refining_power_raw.to_vec());
        wtr.append(&mut self.max_matt_power_raw.to_vec());
        wtr.append(&mut self.min_matt_power_raw.to_vec());
        wtr.append(&mut self.itemdef_power_raw.to_vec());
        wtr.append(&mut self.plusdef_power_raw.to_vec());
        wtr.append(&mut self.mdef_power_raw.to_vec());
        wtr.append(&mut self.plusmdef_power_raw.to_vec());
        wtr.append(&mut self.hit_success_value_raw.to_vec());
        wtr.append(&mut self.avoid_success_value_raw.to_vec());
        wtr.append(&mut self.plus_avoid_success_value_raw.to_vec());
        wtr.append(&mut self.critical_success_value_raw.to_vec());
        wtr.append(&mut self.aspd_raw.to_vec());
        wtr.append(&mut self.plus_aspd_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 44;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_point(&mut self, value: i16) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 2]) {
        self.point_raw = value;
    }
    pub fn set_str(&mut self, value: u8) {
        self.str = value;
    }
    pub fn set_str_raw(&mut self, value: [u8; 1]) {
        self.str_raw = value;
    }
    pub fn set_standard_str(&mut self, value: u8) {
        self.standard_str = value;
    }
    pub fn set_standard_str_raw(&mut self, value: [u8; 1]) {
        self.standard_str_raw = value;
    }
    pub fn set_agi(&mut self, value: u8) {
        self.agi = value;
    }
    pub fn set_agi_raw(&mut self, value: [u8; 1]) {
        self.agi_raw = value;
    }
    pub fn set_standard_agi(&mut self, value: u8) {
        self.standard_agi = value;
    }
    pub fn set_standard_agi_raw(&mut self, value: [u8; 1]) {
        self.standard_agi_raw = value;
    }
    pub fn set_vit(&mut self, value: u8) {
        self.vit = value;
    }
    pub fn set_vit_raw(&mut self, value: [u8; 1]) {
        self.vit_raw = value;
    }
    pub fn set_standard_vit(&mut self, value: u8) {
        self.standard_vit = value;
    }
    pub fn set_standard_vit_raw(&mut self, value: [u8; 1]) {
        self.standard_vit_raw = value;
    }
    pub fn set_int(&mut self, value: u8) {
        self.int = value;
    }
    pub fn set_int_raw(&mut self, value: [u8; 1]) {
        self.int_raw = value;
    }
    pub fn set_standard_int(&mut self, value: u8) {
        self.standard_int = value;
    }
    pub fn set_standard_int_raw(&mut self, value: [u8; 1]) {
        self.standard_int_raw = value;
    }
    pub fn set_dex(&mut self, value: u8) {
        self.dex = value;
    }
    pub fn set_dex_raw(&mut self, value: [u8; 1]) {
        self.dex_raw = value;
    }
    pub fn set_standard_dex(&mut self, value: u8) {
        self.standard_dex = value;
    }
    pub fn set_standard_dex_raw(&mut self, value: [u8; 1]) {
        self.standard_dex_raw = value;
    }
    pub fn set_luk(&mut self, value: u8) {
        self.luk = value;
    }
    pub fn set_luk_raw(&mut self, value: [u8; 1]) {
        self.luk_raw = value;
    }
    pub fn set_standard_luk(&mut self, value: u8) {
        self.standard_luk = value;
    }
    pub fn set_standard_luk_raw(&mut self, value: [u8; 1]) {
        self.standard_luk_raw = value;
    }
    pub fn set_att_power(&mut self, value: i16) {
        self.att_power = value;
    }
    pub fn set_att_power_raw(&mut self, value: [u8; 2]) {
        self.att_power_raw = value;
    }
    pub fn set_refining_power(&mut self, value: i16) {
        self.refining_power = value;
    }
    pub fn set_refining_power_raw(&mut self, value: [u8; 2]) {
        self.refining_power_raw = value;
    }
    pub fn set_max_matt_power(&mut self, value: i16) {
        self.max_matt_power = value;
    }
    pub fn set_max_matt_power_raw(&mut self, value: [u8; 2]) {
        self.max_matt_power_raw = value;
    }
    pub fn set_min_matt_power(&mut self, value: i16) {
        self.min_matt_power = value;
    }
    pub fn set_min_matt_power_raw(&mut self, value: [u8; 2]) {
        self.min_matt_power_raw = value;
    }
    pub fn set_itemdef_power(&mut self, value: i16) {
        self.itemdef_power = value;
    }
    pub fn set_itemdef_power_raw(&mut self, value: [u8; 2]) {
        self.itemdef_power_raw = value;
    }
    pub fn set_plusdef_power(&mut self, value: i16) {
        self.plusdef_power = value;
    }
    pub fn set_plusdef_power_raw(&mut self, value: [u8; 2]) {
        self.plusdef_power_raw = value;
    }
    pub fn set_mdef_power(&mut self, value: i16) {
        self.mdef_power = value;
    }
    pub fn set_mdef_power_raw(&mut self, value: [u8; 2]) {
        self.mdef_power_raw = value;
    }
    pub fn set_plusmdef_power(&mut self, value: i16) {
        self.plusmdef_power = value;
    }
    pub fn set_plusmdef_power_raw(&mut self, value: [u8; 2]) {
        self.plusmdef_power_raw = value;
    }
    pub fn set_hit_success_value(&mut self, value: i16) {
        self.hit_success_value = value;
    }
    pub fn set_hit_success_value_raw(&mut self, value: [u8; 2]) {
        self.hit_success_value_raw = value;
    }
    pub fn set_avoid_success_value(&mut self, value: i16) {
        self.avoid_success_value = value;
    }
    pub fn set_avoid_success_value_raw(&mut self, value: [u8; 2]) {
        self.avoid_success_value_raw = value;
    }
    pub fn set_plus_avoid_success_value(&mut self, value: i16) {
        self.plus_avoid_success_value = value;
    }
    pub fn set_plus_avoid_success_value_raw(&mut self, value: [u8; 2]) {
        self.plus_avoid_success_value_raw = value;
    }
    pub fn set_critical_success_value(&mut self, value: i16) {
        self.critical_success_value = value;
    }
    pub fn set_critical_success_value_raw(&mut self, value: [u8; 2]) {
        self.critical_success_value_raw = value;
    }
    pub fn set_aspd(&mut self, value: i16) {
        self.aspd = value;
    }
    pub fn set_aspd_raw(&mut self, value: [u8; 2]) {
        self.aspd_raw = value;
    }
    pub fn set_plus_aspd(&mut self, value: i16) {
        self.plus_aspd = value;
    }
    pub fn set_plus_aspd_raw(&mut self, value: [u8; 2]) {
        self.plus_aspd_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcStatus {
        let packet_id = i16::from_le_bytes([0xbd, 0x00]);
        let packet_id_raw = [0xbd, 0x00];
        PacketZcStatus {
        raw: vec![],
        packet_id,
        packet_id_raw,
        point: 0,
        point_raw: [0; 2],
        str: 0,
        str_raw: [0; 1],
        standard_str: 0,
        standard_str_raw: [0; 1],
        agi: 0,
        agi_raw: [0; 1],
        standard_agi: 0,
        standard_agi_raw: [0; 1],
        vit: 0,
        vit_raw: [0; 1],
        standard_vit: 0,
        standard_vit_raw: [0; 1],
        int: 0,
        int_raw: [0; 1],
        standard_int: 0,
        standard_int_raw: [0; 1],
        dex: 0,
        dex_raw: [0; 1],
        standard_dex: 0,
        standard_dex_raw: [0; 1],
        luk: 0,
        luk_raw: [0; 1],
        standard_luk: 0,
        standard_luk_raw: [0; 1],
        att_power: 0,
        att_power_raw: [0; 2],
        refining_power: 0,
        refining_power_raw: [0; 2],
        max_matt_power: 0,
        max_matt_power_raw: [0; 2],
        min_matt_power: 0,
        min_matt_power_raw: [0; 2],
        itemdef_power: 0,
        itemdef_power_raw: [0; 2],
        plusdef_power: 0,
        plusdef_power_raw: [0; 2],
        mdef_power: 0,
        mdef_power_raw: [0; 2],
        plusmdef_power: 0,
        plusmdef_power_raw: [0; 2],
        hit_success_value: 0,
        hit_success_value_raw: [0; 2],
        avoid_success_value: 0,
        avoid_success_value_raw: [0; 2],
        plus_avoid_success_value: 0,
        plus_avoid_success_value_raw: [0; 2],
        critical_success_value: 0,
        critical_success_value_raw: [0; 2],
        aspd: 0,
        aspd_raw: [0; 2],
        plus_aspd: 0,
        plus_aspd_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcStatus {
    fn id(&self, packetver: u32) -> &str {
       PacketZcStatus::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcStatusChange {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xbe00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcStatusChange {
        let mut offset: usize = 0;
        PacketZcStatusChange {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            status_id: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            status_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            value: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            value_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.status_id).unwrap();
        self.status_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.status_id_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_status_id(&mut self, value: u16) {
        self.status_id = value;
    }
    pub fn set_status_id_raw(&mut self, value: [u8; 2]) {
        self.status_id_raw = value;
    }
    pub fn set_value(&mut self, value: u8) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 1]) {
        self.value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcStatusChange {
        let packet_id = i16::from_le_bytes([0xbe, 0x00]);
        let packet_id_raw = [0xbe, 0x00];
        PacketZcStatusChange {
        raw: vec![],
        packet_id,
        packet_id_raw,
        status_id: 0,
        status_id_raw: [0; 2],
        value: 0,
        value_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcStatusChange {
    fn id(&self, packetver: u32) -> &str {
       PacketZcStatusChange::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqEmotion {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xbf00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqEmotion {
        let mut offset: usize = 0;
        PacketCzReqEmotion {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqEmotion {
        let packet_id = i16::from_le_bytes([0xbf, 0x00]);
        let packet_id_raw = [0xbf, 0x00];
        PacketCzReqEmotion {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzReqEmotion {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqEmotion::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcEmotion {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc000"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcEmotion {
        let mut offset: usize = 0;
        PacketZcEmotion {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcEmotion {
        let packet_id = i16::from_le_bytes([0xc0, 0x00]);
        let packet_id_raw = [0xc0, 0x00];
        PacketZcEmotion {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcEmotion {
    fn id(&self, packetver: u32) -> &str {
       PacketZcEmotion::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqUserCount {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc100"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqUserCount {
        let mut offset: usize = 0;
        PacketCzReqUserCount {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqUserCount {
        let packet_id = i16::from_le_bytes([0xc1, 0x00]);
        let packet_id_raw = [0xc1, 0x00];
        PacketCzReqUserCount {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzReqUserCount {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqUserCount::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcUserCount {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc200"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcUserCount {
        let mut offset: usize = 0;
        PacketZcUserCount {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcUserCount {
        let packet_id = i16::from_le_bytes([0xc2, 0x00]);
        let packet_id_raw = [0xc2, 0x00];
        PacketZcUserCount {
        raw: vec![],
        packet_id,
        packet_id_raw,
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcUserCount {
    fn id(&self, packetver: u32) -> &str {
       PacketZcUserCount::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSpriteChange {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc300"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSpriteChange {
        let mut offset: usize = 0;
        PacketZcSpriteChange {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            value: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            value_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_value(&mut self, value: u8) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 1]) {
        self.value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSpriteChange {
        let packet_id = i16::from_le_bytes([0xc3, 0x00]);
        let packet_id_raw = [0xc3, 0x00];
        PacketZcSpriteChange {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        value: 0,
        value_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcSpriteChange {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSpriteChange::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSelectDealtype {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc400"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSelectDealtype {
        let mut offset: usize = 0;
        PacketZcSelectDealtype {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            naid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSelectDealtype {
        let packet_id = i16::from_le_bytes([0xc4, 0x00]);
        let packet_id_raw = [0xc4, 0x00];
        PacketZcSelectDealtype {
        raw: vec![],
        packet_id,
        packet_id_raw,
        naid: 0,
        naid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcSelectDealtype {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSelectDealtype::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzAckSelectDealtype {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc500"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzAckSelectDealtype {
        let mut offset: usize = 0;
        PacketCzAckSelectDealtype {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            naid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzAckSelectDealtype {
        let packet_id = i16::from_le_bytes([0xc5, 0x00]);
        let packet_id_raw = [0xc5, 0x00];
        PacketCzAckSelectDealtype {
        raw: vec![],
        packet_id,
        packet_id_raw,
        naid: 0,
        naid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzAckSelectDealtype {
    fn id(&self, packetver: u32) -> &str {
       PacketCzAckSelectDealtype::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPcPurchaseItemlist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc600"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPcPurchaseItemlist {
        let mut offset: usize = 0;
        let vec_type_len = PurchaseItem::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<PurchaseItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(PurchaseItem::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcPcPurchaseItemlist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_list: {
                let field = vec_field.clone();
                field
            },
            item_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<PurchaseItem>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPcPurchaseItemlist {
        let packet_id = i16::from_le_bytes([0xc6, 0x00]);
        let packet_id_raw = [0xc6, 0x00];
        PacketZcPcPurchaseItemlist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcPcPurchaseItemlist {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPcPurchaseItemlist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPcSellItemlist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc700"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPcSellItemlist {
        let mut offset: usize = 0;
        let vec_type_len = SellItem::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<SellItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(SellItem::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcPcSellItemlist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_list: {
                let field = vec_field.clone();
                field
            },
            item_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<SellItem>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPcSellItemlist {
        let packet_id = i16::from_le_bytes([0xc7, 0x00]);
        let packet_id_raw = [0xc7, 0x00];
        PacketZcPcSellItemlist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcPcSellItemlist {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPcSellItemlist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzPcPurchaseItemlist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc800"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzPcPurchaseItemlist {
        let mut offset: usize = 0;
        let vec_type_len = CzPurchaseItem::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<CzPurchaseItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(CzPurchaseItem::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketCzPcPurchaseItemlist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_list: {
                let field = vec_field.clone();
                field
            },
            item_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<CzPurchaseItem>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzPcPurchaseItemlist {
        let packet_id = i16::from_le_bytes([0xc8, 0x00]);
        let packet_id_raw = [0xc8, 0x00];
        PacketCzPcPurchaseItemlist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketCzPcPurchaseItemlist {
    fn id(&self, packetver: u32) -> &str {
       PacketCzPcPurchaseItemlist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzPcSellItemlist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc900"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzPcSellItemlist {
        let mut offset: usize = 0;
        let vec_type_len = CzSellItem::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<CzSellItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(CzSellItem::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketCzPcSellItemlist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_list: {
                let field = vec_field.clone();
                field
            },
            item_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<CzSellItem>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzPcSellItemlist {
        let packet_id = i16::from_le_bytes([0xc9, 0x00]);
        let packet_id_raw = [0xc9, 0x00];
        PacketCzPcSellItemlist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketCzPcSellItemlist {
    fn id(&self, packetver: u32) -> &str {
       PacketCzPcSellItemlist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPcPurchaseResult {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xca00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPcPurchaseResult {
        let mut offset: usize = 0;
        PacketZcPcPurchaseResult {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPcPurchaseResult {
        let packet_id = i16::from_le_bytes([0xca, 0x00]);
        let packet_id_raw = [0xca, 0x00];
        PacketZcPcPurchaseResult {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcPcPurchaseResult {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPcPurchaseResult::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPcSellResult {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xcb00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPcSellResult {
        let mut offset: usize = 0;
        PacketZcPcSellResult {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPcSellResult {
        let packet_id = i16::from_le_bytes([0xcb, 0x00]);
        let packet_id_raw = [0xcb, 0x00];
        PacketZcPcSellResult {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcPcSellResult {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPcSellResult::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzDisconnectCharacter {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xcc00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzDisconnectCharacter {
        let mut offset: usize = 0;
        PacketCzDisconnectCharacter {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzDisconnectCharacter {
        let packet_id = i16::from_le_bytes([0xcc, 0x00]);
        let packet_id_raw = [0xcc, 0x00];
        PacketCzDisconnectCharacter {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzDisconnectCharacter {
    fn id(&self, packetver: u32) -> &str {
       PacketCzDisconnectCharacter::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckDisconnectCharacter {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xcd00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckDisconnectCharacter {
        let mut offset: usize = 0;
        PacketZcAckDisconnectCharacter {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckDisconnectCharacter {
        let packet_id = i16::from_le_bytes([0xcd, 0x00]);
        let packet_id_raw = [0xcd, 0x00];
        PacketZcAckDisconnectCharacter {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckDisconnectCharacter {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckDisconnectCharacter::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzDisconnectAllCharacter {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xce00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzDisconnectAllCharacter {
        let mut offset: usize = 0;
        PacketCzDisconnectAllCharacter {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzDisconnectAllCharacter {
        let packet_id = i16::from_le_bytes([0xce, 0x00]);
        let packet_id_raw = [0xce, 0x00];
        PacketCzDisconnectAllCharacter {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzDisconnectAllCharacter {
    fn id(&self, packetver: u32) -> &str {
       PacketCzDisconnectAllCharacter::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzSettingWhisperPc {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xcf00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzSettingWhisperPc {
        let mut offset: usize = 0;
        PacketCzSettingWhisperPc {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 27;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzSettingWhisperPc {
        let packet_id = i16::from_le_bytes([0xcf, 0x00]);
        let packet_id_raw = [0xcf, 0x00];
        PacketCzSettingWhisperPc {
        raw: vec![],
        packet_id,
        packet_id_raw,
        name: [0 as char; 24],
        name_raw: [0; 24],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzSettingWhisperPc {
    fn id(&self, packetver: u32) -> &str {
       PacketCzSettingWhisperPc::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzSettingWhisperState {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd000"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzSettingWhisperState {
        let mut offset: usize = 0;
        PacketCzSettingWhisperState {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzSettingWhisperState {
        let packet_id = i16::from_le_bytes([0xd0, 0x00]);
        let packet_id_raw = [0xd0, 0x00];
        PacketCzSettingWhisperState {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzSettingWhisperState {
    fn id(&self, packetver: u32) -> &str {
       PacketCzSettingWhisperState::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSettingWhisperPc {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd100"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSettingWhisperPc {
        let mut offset: usize = 0;
        PacketZcSettingWhisperPc {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSettingWhisperPc {
        let packet_id = i16::from_le_bytes([0xd1, 0x00]);
        let packet_id_raw = [0xd1, 0x00];
        PacketZcSettingWhisperPc {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 1],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcSettingWhisperPc {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSettingWhisperPc::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSettingWhisperState {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd200"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSettingWhisperState {
        let mut offset: usize = 0;
        PacketZcSettingWhisperState {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSettingWhisperState {
        let packet_id = i16::from_le_bytes([0xd2, 0x00]);
        let packet_id_raw = [0xd2, 0x00];
        PacketZcSettingWhisperState {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 1],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcSettingWhisperState {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSettingWhisperState::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqWhisperList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd300"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqWhisperList {
        let mut offset: usize = 0;
        PacketCzReqWhisperList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqWhisperList {
        let packet_id = i16::from_le_bytes([0xd3, 0x00]);
        let packet_id_raw = [0xd3, 0x00];
        PacketCzReqWhisperList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzReqWhisperList {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqWhisperList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcWhisperList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd400"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcWhisperList {
        let mut offset: usize = 0;
        let vec_type_len = WhisperItem::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<WhisperItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(WhisperItem::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcWhisperList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            wisper_list: {
                let field = vec_field.clone();
                field
            },
            wisper_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.wisper_list_raw = {
            self.wisper_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.wisper_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.wisper_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_wisper_list(&mut self, value: Vec<WhisperItem>) {
        self.wisper_list = value;
    }
    pub fn set_wisper_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.wisper_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcWhisperList {
        let packet_id = i16::from_le_bytes([0xd4, 0x00]);
        let packet_id_raw = [0xd4, 0x00];
        PacketZcWhisperList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        wisper_list: vec![],
        wisper_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcWhisperList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcWhisperList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzCreateChatroom {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd500"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzCreateChatroom {
        let mut offset: usize = 0;
        PacketCzCreateChatroom {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            size: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            size_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            passwd: {
                let field =  {
                let mut dst: [char; 8] = [0 as char; 8];
                for (index, byte) in buffer[offset..offset + 8].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            passwd_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            title: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            title_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.size).unwrap();
        self.size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
        self.title_raw = self.title.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.size_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.passwd_raw.to_vec());
        wtr.append(&mut self.title_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_size(&mut self, value: i16) {
        self.size = value;
    }
    pub fn set_size_raw(&mut self, value: [u8; 2]) {
        self.size_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_passwd(&mut self, value: [char; 8]) {
        self.passwd = value;
    }
    pub fn set_passwd_raw(&mut self, value: [u8; 8]) {
        self.passwd_raw = value;
    }
    pub fn set_title(&mut self, value: String) {
        self.title = value;
    }
    pub fn set_title_raw(&mut self, value: Vec<u8>) {
        self.title_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzCreateChatroom {
        let packet_id = i16::from_le_bytes([0xd5, 0x00]);
        let packet_id_raw = [0xd5, 0x00];
        PacketCzCreateChatroom {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        size: 0,
        size_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        passwd: [0 as char; 8],
        passwd_raw: [0; 8],
        title: String::new(),
        title_raw: vec![],
        }
    }
}

impl Packet for PacketCzCreateChatroom {
    fn id(&self, packetver: u32) -> &str {
       PacketCzCreateChatroom::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckCreateChatroom {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd600"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckCreateChatroom {
        let mut offset: usize = 0;
        PacketZcAckCreateChatroom {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckCreateChatroom {
        let packet_id = i16::from_le_bytes([0xd6, 0x00]);
        let packet_id_raw = [0xd6, 0x00];
        PacketZcAckCreateChatroom {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckCreateChatroom {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckCreateChatroom::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcRoomNewentry {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd700"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcRoomNewentry {
        let mut offset: usize = 0;
        PacketZcRoomNewentry {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            room_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            room_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            maxcount: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            maxcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            curcount: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            curcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            title: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            title_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.room_id).unwrap();
        self.room_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.maxcount).unwrap();
        self.maxcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.curcount).unwrap();
        self.curcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        self.title_raw = self.title.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.room_id_raw.to_vec());
        wtr.append(&mut self.maxcount_raw.to_vec());
        wtr.append(&mut self.curcount_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.title_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 16;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_room_id(&mut self, value: u32) {
        self.room_id = value;
    }
    pub fn set_room_id_raw(&mut self, value: [u8; 4]) {
        self.room_id_raw = value;
    }
    pub fn set_maxcount(&mut self, value: i16) {
        self.maxcount = value;
    }
    pub fn set_maxcount_raw(&mut self, value: [u8; 2]) {
        self.maxcount_raw = value;
    }
    pub fn set_curcount(&mut self, value: i16) {
        self.curcount = value;
    }
    pub fn set_curcount_raw(&mut self, value: [u8; 2]) {
        self.curcount_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_title(&mut self, value: String) {
        self.title = value;
    }
    pub fn set_title_raw(&mut self, value: Vec<u8>) {
        self.title_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcRoomNewentry {
        let packet_id = i16::from_le_bytes([0xd7, 0x00]);
        let packet_id_raw = [0xd7, 0x00];
        PacketZcRoomNewentry {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        room_id: 0,
        room_id_raw: [0; 4],
        maxcount: 0,
        maxcount_raw: [0; 2],
        curcount: 0,
        curcount_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        title: String::new(),
        title_raw: vec![],
        }
    }
}

impl Packet for PacketZcRoomNewentry {
    fn id(&self, packetver: u32) -> &str {
       PacketZcRoomNewentry::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcDestroyRoom {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd800"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcDestroyRoom {
        let mut offset: usize = 0;
        PacketZcDestroyRoom {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            room_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            room_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.room_id).unwrap();
        self.room_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.room_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_room_id(&mut self, value: u32) {
        self.room_id = value;
    }
    pub fn set_room_id_raw(&mut self, value: [u8; 4]) {
        self.room_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcDestroyRoom {
        let packet_id = i16::from_le_bytes([0xd8, 0x00]);
        let packet_id_raw = [0xd8, 0x00];
        PacketZcDestroyRoom {
        raw: vec![],
        packet_id,
        packet_id_raw,
        room_id: 0,
        room_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDestroyRoom {
    fn id(&self, packetver: u32) -> &str {
       PacketZcDestroyRoom::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqEnterRoom {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd900"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqEnterRoom {
        let mut offset: usize = 0;
        PacketCzReqEnterRoom {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            room_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            room_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            passwd: {
                let field =  {
                let mut dst: [char; 8] = [0 as char; 8];
                for (index, byte) in buffer[offset..offset + 8].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            passwd_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.room_id).unwrap();
        self.room_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.room_id_raw.to_vec());
        wtr.append(&mut self.passwd_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_room_id(&mut self, value: u32) {
        self.room_id = value;
    }
    pub fn set_room_id_raw(&mut self, value: [u8; 4]) {
        self.room_id_raw = value;
    }
    pub fn set_passwd(&mut self, value: [char; 8]) {
        self.passwd = value;
    }
    pub fn set_passwd_raw(&mut self, value: [u8; 8]) {
        self.passwd_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqEnterRoom {
        let packet_id = i16::from_le_bytes([0xd9, 0x00]);
        let packet_id_raw = [0xd9, 0x00];
        PacketCzReqEnterRoom {
        raw: vec![],
        packet_id,
        packet_id_raw,
        room_id: 0,
        room_id_raw: [0; 4],
        passwd: [0 as char; 8],
        passwd_raw: [0; 8],
        }
    }
}

impl Packet for PacketCzReqEnterRoom {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqEnterRoom::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcRefuseEnterRoom {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xda00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcRefuseEnterRoom {
        let mut offset: usize = 0;
        PacketZcRefuseEnterRoom {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcRefuseEnterRoom {
        let packet_id = i16::from_le_bytes([0xda, 0x00]);
        let packet_id_raw = [0xda, 0x00];
        PacketZcRefuseEnterRoom {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcRefuseEnterRoom {
    fn id(&self, packetver: u32) -> &str {
       PacketZcRefuseEnterRoom::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcEnterRoom {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xdb00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcEnterRoom {
        let mut offset: usize = 0;
        let vec_type_len = RoomMember::base_len(packetver);
        let iter_count = (&buffer.len() - 8) / vec_type_len;
        let mut vec_field: Vec<RoomMember> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (vec_type_len * (i - 1));
            let end_pos = 8 + vec_type_len * i;
            vec_field.push(RoomMember::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcEnterRoom {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            room_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            room_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            member_list: {
                let field = vec_field.clone();
                field
            },
            member_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.room_id).unwrap();
        self.room_id_raw = wtr.try_into().unwrap();
        self.member_list_raw = {
            self.member_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.member_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.room_id_raw.to_vec());
        self.member_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_room_id(&mut self, value: u32) {
        self.room_id = value;
    }
    pub fn set_room_id_raw(&mut self, value: [u8; 4]) {
        self.room_id_raw = value;
    }
    pub fn set_member_list(&mut self, value: Vec<RoomMember>) {
        self.member_list = value;
    }
    pub fn set_member_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.member_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcEnterRoom {
        let packet_id = i16::from_le_bytes([0xdb, 0x00]);
        let packet_id_raw = [0xdb, 0x00];
        PacketZcEnterRoom {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        room_id: 0,
        room_id_raw: [0; 4],
        member_list: vec![],
        member_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcEnterRoom {
    fn id(&self, packetver: u32) -> &str {
       PacketZcEnterRoom::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMemberNewentry {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xdc00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMemberNewentry {
        let mut offset: usize = 0;
        PacketZcMemberNewentry {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            curcount: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            curcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.curcount).unwrap();
        self.curcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.curcount_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 28;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_curcount(&mut self, value: i16) {
        self.curcount = value;
    }
    pub fn set_curcount_raw(&mut self, value: [u8; 2]) {
        self.curcount_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMemberNewentry {
        let packet_id = i16::from_le_bytes([0xdc, 0x00]);
        let packet_id_raw = [0xdc, 0x00];
        PacketZcMemberNewentry {
        raw: vec![],
        packet_id,
        packet_id_raw,
        curcount: 0,
        curcount_raw: [0; 2],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcMemberNewentry {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMemberNewentry::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMemberExit {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xdd00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMemberExit {
        let mut offset: usize = 0;
        PacketZcMemberExit {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            curcount: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            curcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.curcount).unwrap();
        self.curcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.curcount_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 29;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_curcount(&mut self, value: i16) {
        self.curcount = value;
    }
    pub fn set_curcount_raw(&mut self, value: [u8; 2]) {
        self.curcount_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMemberExit {
        let packet_id = i16::from_le_bytes([0xdd, 0x00]);
        let packet_id_raw = [0xdd, 0x00];
        PacketZcMemberExit {
        raw: vec![],
        packet_id,
        packet_id_raw,
        curcount: 0,
        curcount_raw: [0; 2],
        name: [0 as char; 24],
        name_raw: [0; 24],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcMemberExit {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMemberExit::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzChangeChatroom {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xde00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzChangeChatroom {
        let mut offset: usize = 0;
        PacketCzChangeChatroom {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            size: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            size_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            passwd: {
                let field =  {
                let mut dst: [char; 8] = [0 as char; 8];
                for (index, byte) in buffer[offset..offset + 8].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            passwd_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            title: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            title_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.size).unwrap();
        self.size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
        self.title_raw = self.title.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.size_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.passwd_raw.to_vec());
        wtr.append(&mut self.title_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_size(&mut self, value: i16) {
        self.size = value;
    }
    pub fn set_size_raw(&mut self, value: [u8; 2]) {
        self.size_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_passwd(&mut self, value: [char; 8]) {
        self.passwd = value;
    }
    pub fn set_passwd_raw(&mut self, value: [u8; 8]) {
        self.passwd_raw = value;
    }
    pub fn set_title(&mut self, value: String) {
        self.title = value;
    }
    pub fn set_title_raw(&mut self, value: Vec<u8>) {
        self.title_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzChangeChatroom {
        let packet_id = i16::from_le_bytes([0xde, 0x00]);
        let packet_id_raw = [0xde, 0x00];
        PacketCzChangeChatroom {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        size: 0,
        size_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        passwd: [0 as char; 8],
        passwd_raw: [0; 8],
        title: String::new(),
        title_raw: vec![],
        }
    }
}

impl Packet for PacketCzChangeChatroom {
    fn id(&self, packetver: u32) -> &str {
       PacketCzChangeChatroom::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcChangeChatroom {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xdf00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcChangeChatroom {
        let mut offset: usize = 0;
        PacketZcChangeChatroom {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            room_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            room_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            maxcount: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            maxcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            curcount: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            curcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            title: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            title_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.room_id).unwrap();
        self.room_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.maxcount).unwrap();
        self.maxcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.curcount).unwrap();
        self.curcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        self.title_raw = self.title.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.room_id_raw.to_vec());
        wtr.append(&mut self.maxcount_raw.to_vec());
        wtr.append(&mut self.curcount_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.title_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 16;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_room_id(&mut self, value: u32) {
        self.room_id = value;
    }
    pub fn set_room_id_raw(&mut self, value: [u8; 4]) {
        self.room_id_raw = value;
    }
    pub fn set_maxcount(&mut self, value: i16) {
        self.maxcount = value;
    }
    pub fn set_maxcount_raw(&mut self, value: [u8; 2]) {
        self.maxcount_raw = value;
    }
    pub fn set_curcount(&mut self, value: i16) {
        self.curcount = value;
    }
    pub fn set_curcount_raw(&mut self, value: [u8; 2]) {
        self.curcount_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_title(&mut self, value: String) {
        self.title = value;
    }
    pub fn set_title_raw(&mut self, value: Vec<u8>) {
        self.title_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcChangeChatroom {
        let packet_id = i16::from_le_bytes([0xdf, 0x00]);
        let packet_id_raw = [0xdf, 0x00];
        PacketZcChangeChatroom {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        room_id: 0,
        room_id_raw: [0; 4],
        maxcount: 0,
        maxcount_raw: [0; 2],
        curcount: 0,
        curcount_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        title: String::new(),
        title_raw: vec![],
        }
    }
}

impl Packet for PacketZcChangeChatroom {
    fn id(&self, packetver: u32) -> &str {
       PacketZcChangeChatroom::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqRoleChange {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe000"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqRoleChange {
        let mut offset: usize = 0;
        PacketCzReqRoleChange {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            role: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            role_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.role).unwrap();
        self.role_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.role_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 30;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_role(&mut self, value: u32) {
        self.role = value;
    }
    pub fn set_role_raw(&mut self, value: [u8; 4]) {
        self.role_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqRoleChange {
        let packet_id = i16::from_le_bytes([0xe0, 0x00]);
        let packet_id_raw = [0xe0, 0x00];
        PacketCzReqRoleChange {
        raw: vec![],
        packet_id,
        packet_id_raw,
        role: 0,
        role_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzReqRoleChange {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqRoleChange::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcRoleChange {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe100"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcRoleChange {
        let mut offset: usize = 0;
        PacketZcRoleChange {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            role: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            role_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.role).unwrap();
        self.role_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.role_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 30;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_role(&mut self, value: u32) {
        self.role = value;
    }
    pub fn set_role_raw(&mut self, value: [u8; 4]) {
        self.role_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcRoleChange {
        let packet_id = i16::from_le_bytes([0xe1, 0x00]);
        let packet_id_raw = [0xe1, 0x00];
        PacketZcRoleChange {
        raw: vec![],
        packet_id,
        packet_id_raw,
        role: 0,
        role_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcRoleChange {
    fn id(&self, packetver: u32) -> &str {
       PacketZcRoleChange::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqExpelMember {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe200"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqExpelMember {
        let mut offset: usize = 0;
        PacketCzReqExpelMember {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqExpelMember {
        let packet_id = i16::from_le_bytes([0xe2, 0x00]);
        let packet_id_raw = [0xe2, 0x00];
        PacketCzReqExpelMember {
        raw: vec![],
        packet_id,
        packet_id_raw,
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzReqExpelMember {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqExpelMember::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzExitRoom {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe300"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzExitRoom {
        let mut offset: usize = 0;
        PacketCzExitRoom {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzExitRoom {
        let packet_id = i16::from_le_bytes([0xe3, 0x00]);
        let packet_id_raw = [0xe3, 0x00];
        PacketCzExitRoom {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzExitRoom {
    fn id(&self, packetver: u32) -> &str {
       PacketCzExitRoom::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqExchangeItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe400"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqExchangeItem {
        let mut offset: usize = 0;
        PacketCzReqExchangeItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqExchangeItem {
        let packet_id = i16::from_le_bytes([0xe4, 0x00]);
        let packet_id_raw = [0xe4, 0x00];
        PacketCzReqExchangeItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqExchangeItem {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqExchangeItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcReqExchangeItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe500"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcReqExchangeItem {
        let mut offset: usize = 0;
        PacketZcReqExchangeItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcReqExchangeItem {
        let packet_id = i16::from_le_bytes([0xe5, 0x00]);
        let packet_id_raw = [0xe5, 0x00];
        PacketZcReqExchangeItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcReqExchangeItem {
    fn id(&self, packetver: u32) -> &str {
       PacketZcReqExchangeItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzAckExchangeItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe600"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzAckExchangeItem {
        let mut offset: usize = 0;
        PacketCzAckExchangeItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzAckExchangeItem {
        let packet_id = i16::from_le_bytes([0xe6, 0x00]);
        let packet_id_raw = [0xe6, 0x00];
        PacketCzAckExchangeItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzAckExchangeItem {
    fn id(&self, packetver: u32) -> &str {
       PacketCzAckExchangeItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckExchangeItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe700"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckExchangeItem {
        let mut offset: usize = 0;
        PacketZcAckExchangeItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckExchangeItem {
        let packet_id = i16::from_le_bytes([0xe7, 0x00]);
        let packet_id_raw = [0xe7, 0x00];
        PacketZcAckExchangeItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckExchangeItem {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckExchangeItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzAddExchangeItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe800"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzAddExchangeItem {
        let mut offset: usize = 0;
        PacketCzAddExchangeItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzAddExchangeItem {
        let packet_id = i16::from_le_bytes([0xe8, 0x00]);
        let packet_id_raw = [0xe8, 0x00];
        PacketCzAddExchangeItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzAddExchangeItem {
    fn id(&self, packetver: u32) -> &str {
       PacketCzAddExchangeItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAddExchangeItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe900"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAddExchangeItem {
        let mut offset: usize = 0;
        PacketZcAddExchangeItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_damaged: {
                let field = buffer[offset] == 1;
                field
            },
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            refining_level: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 19;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAddExchangeItem {
        let packet_id = i16::from_le_bytes([0xe9, 0x00]);
        let packet_id_raw = [0xe9, 0x00];
        PacketZcAddExchangeItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        count: 0,
        count_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        }
    }
}

impl Packet for PacketZcAddExchangeItem {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAddExchangeItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckAddExchangeItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xea00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckAddExchangeItem {
        let mut offset: usize = 0;
        PacketZcAckAddExchangeItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckAddExchangeItem {
        let packet_id = i16::from_le_bytes([0xea, 0x00]);
        let packet_id_raw = [0xea, 0x00];
        PacketZcAckAddExchangeItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckAddExchangeItem {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckAddExchangeItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzConcludeExchangeItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xeb00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzConcludeExchangeItem {
        let mut offset: usize = 0;
        PacketCzConcludeExchangeItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzConcludeExchangeItem {
        let packet_id = i16::from_le_bytes([0xeb, 0x00]);
        let packet_id_raw = [0xeb, 0x00];
        PacketCzConcludeExchangeItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzConcludeExchangeItem {
    fn id(&self, packetver: u32) -> &str {
       PacketCzConcludeExchangeItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcConcludeExchangeItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xec00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcConcludeExchangeItem {
        let mut offset: usize = 0;
        PacketZcConcludeExchangeItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            who: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            who_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.who).unwrap();
        self.who_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.who_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_who(&mut self, value: u8) {
        self.who = value;
    }
    pub fn set_who_raw(&mut self, value: [u8; 1]) {
        self.who_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcConcludeExchangeItem {
        let packet_id = i16::from_le_bytes([0xec, 0x00]);
        let packet_id_raw = [0xec, 0x00];
        PacketZcConcludeExchangeItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        who: 0,
        who_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcConcludeExchangeItem {
    fn id(&self, packetver: u32) -> &str {
       PacketZcConcludeExchangeItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzCancelExchangeItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xed00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzCancelExchangeItem {
        let mut offset: usize = 0;
        PacketCzCancelExchangeItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzCancelExchangeItem {
        let packet_id = i16::from_le_bytes([0xed, 0x00]);
        let packet_id_raw = [0xed, 0x00];
        PacketCzCancelExchangeItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzCancelExchangeItem {
    fn id(&self, packetver: u32) -> &str {
       PacketCzCancelExchangeItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcCancelExchangeItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xee00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcCancelExchangeItem {
        let mut offset: usize = 0;
        PacketZcCancelExchangeItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcCancelExchangeItem {
        let packet_id = i16::from_le_bytes([0xee, 0x00]);
        let packet_id_raw = [0xee, 0x00];
        PacketZcCancelExchangeItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketZcCancelExchangeItem {
    fn id(&self, packetver: u32) -> &str {
       PacketZcCancelExchangeItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzExecExchangeItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xef00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzExecExchangeItem {
        let mut offset: usize = 0;
        PacketCzExecExchangeItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzExecExchangeItem {
        let packet_id = i16::from_le_bytes([0xef, 0x00]);
        let packet_id_raw = [0xef, 0x00];
        PacketCzExecExchangeItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzExecExchangeItem {
    fn id(&self, packetver: u32) -> &str {
       PacketCzExecExchangeItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcExecExchangeItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf000"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcExecExchangeItem {
        let mut offset: usize = 0;
        PacketZcExecExchangeItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcExecExchangeItem {
        let packet_id = i16::from_le_bytes([0xf0, 0x00]);
        let packet_id_raw = [0xf0, 0x00];
        PacketZcExecExchangeItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcExecExchangeItem {
    fn id(&self, packetver: u32) -> &str {
       PacketZcExecExchangeItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcExchangeitemUndo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf100"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcExchangeitemUndo {
        let mut offset: usize = 0;
        PacketZcExchangeitemUndo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcExchangeitemUndo {
        let packet_id = i16::from_le_bytes([0xf1, 0x00]);
        let packet_id_raw = [0xf1, 0x00];
        PacketZcExchangeitemUndo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketZcExchangeitemUndo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcExchangeitemUndo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyStoreitemCountinfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf200"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyStoreitemCountinfo {
        let mut offset: usize = 0;
        PacketZcNotifyStoreitemCountinfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            cur_count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            cur_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            max_count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            max_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.cur_count).unwrap();
        self.cur_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_count).unwrap();
        self.max_count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.cur_count_raw.to_vec());
        wtr.append(&mut self.max_count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_cur_count(&mut self, value: i16) {
        self.cur_count = value;
    }
    pub fn set_cur_count_raw(&mut self, value: [u8; 2]) {
        self.cur_count_raw = value;
    }
    pub fn set_max_count(&mut self, value: i16) {
        self.max_count = value;
    }
    pub fn set_max_count_raw(&mut self, value: [u8; 2]) {
        self.max_count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyStoreitemCountinfo {
        let packet_id = i16::from_le_bytes([0xf2, 0x00]);
        let packet_id_raw = [0xf2, 0x00];
        PacketZcNotifyStoreitemCountinfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        cur_count: 0,
        cur_count_raw: [0; 2],
        max_count: 0,
        max_count_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyStoreitemCountinfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyStoreitemCountinfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzPlayerChat {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf300"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzPlayerChat {
        let mut offset: usize = 0;
        PacketCzPlayerChat {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzPlayerChat {
        let packet_id = i16::from_le_bytes([0xf3, 0x00]);
        let packet_id_raw = [0xf3, 0x00];
        PacketCzPlayerChat {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketCzPlayerChat {
    fn id(&self, packetver: u32) -> &str {
       PacketCzPlayerChat::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAddItemToStore {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf400"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAddItemToStore {
        let mut offset: usize = 0;
        PacketZcAddItemToStore {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_damaged: {
                let field = buffer[offset] == 1;
                field
            },
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            refining_level: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 21;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAddItemToStore {
        let packet_id = i16::from_le_bytes([0xf4, 0x00]);
        let packet_id_raw = [0xf4, 0x00];
        PacketZcAddItemToStore {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        }
    }
}

impl Packet for PacketZcAddItemToStore {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAddItemToStore::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzMoveItemFromStoreToBody {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf500"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzMoveItemFromStoreToBody {
        let mut offset: usize = 0;
        PacketCzMoveItemFromStoreToBody {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzMoveItemFromStoreToBody {
        let packet_id = i16::from_le_bytes([0xf5, 0x00]);
        let packet_id_raw = [0xf5, 0x00];
        PacketCzMoveItemFromStoreToBody {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMoveItemFromStoreToBody {
    fn id(&self, packetver: u32) -> &str {
       PacketCzMoveItemFromStoreToBody::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcDeleteItemFromStore {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf600"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcDeleteItemFromStore {
        let mut offset: usize = 0;
        PacketZcDeleteItemFromStore {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcDeleteItemFromStore {
        let packet_id = i16::from_le_bytes([0xf6, 0x00]);
        let packet_id_raw = [0xf6, 0x00];
        PacketZcDeleteItemFromStore {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDeleteItemFromStore {
    fn id(&self, packetver: u32) -> &str {
       PacketZcDeleteItemFromStore::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzCloseStore {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf700"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzCloseStore {
        let mut offset: usize = 0;
        PacketCzCloseStore {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzCloseStore {
        let packet_id = i16::from_le_bytes([0xf7, 0x00]);
        let packet_id_raw = [0xf7, 0x00];
        PacketCzCloseStore {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzCloseStore {
    fn id(&self, packetver: u32) -> &str {
       PacketCzCloseStore::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcCloseStore {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf800"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcCloseStore {
        let mut offset: usize = 0;
        PacketZcCloseStore {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcCloseStore {
        let packet_id = i16::from_le_bytes([0xf8, 0x00]);
        let packet_id_raw = [0xf8, 0x00];
        PacketZcCloseStore {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketZcCloseStore {
    fn id(&self, packetver: u32) -> &str {
       PacketZcCloseStore::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzMakeGroup {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf900"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzMakeGroup {
        let mut offset: usize = 0;
        PacketCzMakeGroup {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            group_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.group_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_group_name(&mut self, value: [char; 24]) {
        self.group_name = value;
    }
    pub fn set_group_name_raw(&mut self, value: [u8; 24]) {
        self.group_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzMakeGroup {
        let packet_id = i16::from_le_bytes([0xf9, 0x00]);
        let packet_id_raw = [0xf9, 0x00];
        PacketCzMakeGroup {
        raw: vec![],
        packet_id,
        packet_id_raw,
        group_name: [0 as char; 24],
        group_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzMakeGroup {
    fn id(&self, packetver: u32) -> &str {
       PacketCzMakeGroup::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckMakeGroup {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xfa00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckMakeGroup {
        let mut offset: usize = 0;
        PacketZcAckMakeGroup {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckMakeGroup {
        let packet_id = i16::from_le_bytes([0xfa, 0x00]);
        let packet_id_raw = [0xfa, 0x00];
        PacketZcAckMakeGroup {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckMakeGroup {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckMakeGroup::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcGroupList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xfb00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcGroupList {
        let mut offset: usize = 0;
        let vec_type_len = GroupmemberInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 28) / vec_type_len;
        let mut vec_field: Vec<GroupmemberInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 28 + (vec_type_len * (i - 1));
            let end_pos = 28 + vec_type_len * i;
            vec_field.push(GroupmemberInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcGroupList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            group_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            group_info: {
                let field = vec_field.clone();
                field
            },
            group_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();
        self.group_info_raw = {
            self.group_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.group_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.group_name_raw.to_vec());
        self.group_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 28;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_group_name(&mut self, value: [char; 24]) {
        self.group_name = value;
    }
    pub fn set_group_name_raw(&mut self, value: [u8; 24]) {
        self.group_name_raw = value;
    }
    pub fn set_group_info(&mut self, value: Vec<GroupmemberInfo>) {
        self.group_info = value;
    }
    pub fn set_group_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.group_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcGroupList {
        let packet_id = i16::from_le_bytes([0xfb, 0x00]);
        let packet_id_raw = [0xfb, 0x00];
        PacketZcGroupList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        group_name: [0 as char; 24],
        group_name_raw: [0; 24],
        group_info: vec![],
        group_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcGroupList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcGroupList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqJoinGroup {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xfc00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqJoinGroup {
        let mut offset: usize = 0;
        PacketCzReqJoinGroup {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqJoinGroup {
        let packet_id = i16::from_le_bytes([0xfc, 0x00]);
        let packet_id_raw = [0xfc, 0x00];
        PacketCzReqJoinGroup {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqJoinGroup {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqJoinGroup::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckReqJoinGroup {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xfd00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckReqJoinGroup {
        let mut offset: usize = 0;
        PacketZcAckReqJoinGroup {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            character_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            answer: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            answer_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        wtr.append(&mut self.answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 27;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn set_answer(&mut self, value: u8) {
        self.answer = value;
    }
    pub fn set_answer_raw(&mut self, value: [u8; 1]) {
        self.answer_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckReqJoinGroup {
        let packet_id = i16::from_le_bytes([0xfd, 0x00]);
        let packet_id_raw = [0xfd, 0x00];
        PacketZcAckReqJoinGroup {
        raw: vec![],
        packet_id,
        packet_id_raw,
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        answer: 0,
        answer_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckReqJoinGroup {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckReqJoinGroup::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcReqJoinGroup {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xfe00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcReqJoinGroup {
        let mut offset: usize = 0;
        PacketZcReqJoinGroup {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            grid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            grid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            group_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.grid).unwrap();
        self.grid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.grid_raw.to_vec());
        wtr.append(&mut self.group_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 30;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_grid(&mut self, value: u32) {
        self.grid = value;
    }
    pub fn set_grid_raw(&mut self, value: [u8; 4]) {
        self.grid_raw = value;
    }
    pub fn set_group_name(&mut self, value: [char; 24]) {
        self.group_name = value;
    }
    pub fn set_group_name_raw(&mut self, value: [u8; 24]) {
        self.group_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcReqJoinGroup {
        let packet_id = i16::from_le_bytes([0xfe, 0x00]);
        let packet_id_raw = [0xfe, 0x00];
        PacketZcReqJoinGroup {
        raw: vec![],
        packet_id,
        packet_id_raw,
        grid: 0,
        grid_raw: [0; 4],
        group_name: [0 as char; 24],
        group_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcReqJoinGroup {
    fn id(&self, packetver: u32) -> &str {
       PacketZcReqJoinGroup::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzJoinGroup {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xff00"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzJoinGroup {
        let mut offset: usize = 0;
        PacketCzJoinGroup {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            grid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            grid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            answer: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            answer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.grid).unwrap();
        self.grid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.grid_raw.to_vec());
        wtr.append(&mut self.answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_grid(&mut self, value: u32) {
        self.grid = value;
    }
    pub fn set_grid_raw(&mut self, value: [u8; 4]) {
        self.grid_raw = value;
    }
    pub fn set_answer(&mut self, value: i32) {
        self.answer = value;
    }
    pub fn set_answer_raw(&mut self, value: [u8; 4]) {
        self.answer_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzJoinGroup {
        let packet_id = i16::from_le_bytes([0xff, 0x00]);
        let packet_id_raw = [0xff, 0x00];
        PacketCzJoinGroup {
        raw: vec![],
        packet_id,
        packet_id_raw,
        grid: 0,
        grid_raw: [0; 4],
        answer: 0,
        answer_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzJoinGroup {
    fn id(&self, packetver: u32) -> &str {
       PacketCzJoinGroup::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqLeaveGroup {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0001"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqLeaveGroup {
        let mut offset: usize = 0;
        PacketCzReqLeaveGroup {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqLeaveGroup {
        let packet_id = i16::from_le_bytes([0x00, 0x01]);
        let packet_id_raw = [0x00, 0x01];
        PacketCzReqLeaveGroup {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzReqLeaveGroup {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqLeaveGroup::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcGroupinfoChange {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0101"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcGroupinfoChange {
        let mut offset: usize = 0;
        PacketZcGroupinfoChange {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            exp_option: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            exp_option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.exp_option).unwrap();
        self.exp_option_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.exp_option_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_exp_option(&mut self, value: u32) {
        self.exp_option = value;
    }
    pub fn set_exp_option_raw(&mut self, value: [u8; 4]) {
        self.exp_option_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcGroupinfoChange {
        let packet_id = i16::from_le_bytes([0x01, 0x01]);
        let packet_id_raw = [0x01, 0x01];
        PacketZcGroupinfoChange {
        raw: vec![],
        packet_id,
        packet_id_raw,
        exp_option: 0,
        exp_option_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcGroupinfoChange {
    fn id(&self, packetver: u32) -> &str {
       PacketZcGroupinfoChange::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzChangeGroupexpoption {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0201"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzChangeGroupexpoption {
        let mut offset: usize = 0;
        PacketCzChangeGroupexpoption {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            exp_option: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            exp_option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.exp_option).unwrap();
        self.exp_option_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.exp_option_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_exp_option(&mut self, value: u32) {
        self.exp_option = value;
    }
    pub fn set_exp_option_raw(&mut self, value: [u8; 4]) {
        self.exp_option_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzChangeGroupexpoption {
        let packet_id = i16::from_le_bytes([0x02, 0x01]);
        let packet_id_raw = [0x02, 0x01];
        PacketCzChangeGroupexpoption {
        raw: vec![],
        packet_id,
        packet_id_raw,
        exp_option: 0,
        exp_option_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzChangeGroupexpoption {
    fn id(&self, packetver: u32) -> &str {
       PacketCzChangeGroupexpoption::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqExpelGroupMember {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0301"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqExpelGroupMember {
        let mut offset: usize = 0;
        PacketCzReqExpelGroupMember {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            character_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 30;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqExpelGroupMember {
        let packet_id = i16::from_le_bytes([0x03, 0x01]);
        let packet_id_raw = [0x03, 0x01];
        PacketCzReqExpelGroupMember {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzReqExpelGroupMember {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqExpelGroupMember::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAddMemberToGroup {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0401"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAddMemberToGroup {
        let mut offset: usize = 0;
        PacketZcAddMemberToGroup {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            role: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            role_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            state: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            group_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            character_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            map_name: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.role).unwrap();
        self.role_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.role_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.group_name_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 79;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_role(&mut self, value: u32) {
        self.role = value;
    }
    pub fn set_role_raw(&mut self, value: [u8; 4]) {
        self.role_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_state(&mut self, value: u8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_group_name(&mut self, value: [char; 24]) {
        self.group_name = value;
    }
    pub fn set_group_name_raw(&mut self, value: [u8; 24]) {
        self.group_name_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAddMemberToGroup {
        let packet_id = i16::from_le_bytes([0x04, 0x01]);
        let packet_id_raw = [0x04, 0x01];
        PacketZcAddMemberToGroup {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        role: 0,
        role_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        state: 0,
        state_raw: [0; 1],
        group_name: [0 as char; 24],
        group_name_raw: [0; 24],
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        }
    }
}

impl Packet for PacketZcAddMemberToGroup {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAddMemberToGroup::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcDeleteMemberFromGroup {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0501"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcDeleteMemberFromGroup {
        let mut offset: usize = 0;
        PacketZcDeleteMemberFromGroup {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            character_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 31;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcDeleteMemberFromGroup {
        let packet_id = i16::from_le_bytes([0x05, 0x01]);
        let packet_id_raw = [0x05, 0x01];
        PacketZcDeleteMemberFromGroup {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcDeleteMemberFromGroup {
    fn id(&self, packetver: u32) -> &str {
       PacketZcDeleteMemberFromGroup::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyHpToGroupm {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0601"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyHpToGroupm {
        let mut offset: usize = 0;
        PacketZcNotifyHpToGroupm {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            hp: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            maxhp: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            maxhp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.maxhp).unwrap();
        self.maxhp_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.maxhp_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_hp(&mut self, value: i16) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 2]) {
        self.hp_raw = value;
    }
    pub fn set_maxhp(&mut self, value: i16) {
        self.maxhp = value;
    }
    pub fn set_maxhp_raw(&mut self, value: [u8; 2]) {
        self.maxhp_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyHpToGroupm {
        let packet_id = i16::from_le_bytes([0x06, 0x01]);
        let packet_id_raw = [0x06, 0x01];
        PacketZcNotifyHpToGroupm {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        hp: 0,
        hp_raw: [0; 2],
        maxhp: 0,
        maxhp_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyHpToGroupm {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyHpToGroupm::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyPositionToGroupm {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0701"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyPositionToGroupm {
        let mut offset: usize = 0;
        PacketZcNotifyPositionToGroupm {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyPositionToGroupm {
        let packet_id = i16::from_le_bytes([0x07, 0x01]);
        let packet_id_raw = [0x07, 0x01];
        PacketZcNotifyPositionToGroupm {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyPositionToGroupm {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyPositionToGroupm::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRequestChatParty {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0801"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRequestChatParty {
        let mut offset: usize = 0;
        PacketCzRequestChatParty {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRequestChatParty {
        let packet_id = i16::from_le_bytes([0x08, 0x01]);
        let packet_id_raw = [0x08, 0x01];
        PacketCzRequestChatParty {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketCzRequestChatParty {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRequestChatParty::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyChatParty {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0901"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyChatParty {
        let mut offset: usize = 0;
        PacketZcNotifyChatParty {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyChatParty {
        let packet_id = i16::from_le_bytes([0x09, 0x01]);
        let packet_id_raw = [0x09, 0x01];
        PacketZcNotifyChatParty {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcNotifyChatParty {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyChatParty::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMvpGettingItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0a01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMvpGettingItem {
        let mut offset: usize = 0;
        PacketZcMvpGettingItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMvpGettingItem {
        let packet_id = i16::from_le_bytes([0x0a, 0x01]);
        let packet_id_raw = [0x0a, 0x01];
        PacketZcMvpGettingItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcMvpGettingItem {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMvpGettingItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMvpGettingSpecialExp {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0b01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMvpGettingSpecialExp {
        let mut offset: usize = 0;
        PacketZcMvpGettingSpecialExp {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            exp: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.exp).unwrap();
        self.exp_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.exp_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_exp(&mut self, value: u32) {
        self.exp = value;
    }
    pub fn set_exp_raw(&mut self, value: [u8; 4]) {
        self.exp_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMvpGettingSpecialExp {
        let packet_id = i16::from_le_bytes([0x0b, 0x01]);
        let packet_id_raw = [0x0b, 0x01];
        PacketZcMvpGettingSpecialExp {
        raw: vec![],
        packet_id,
        packet_id_raw,
        exp: 0,
        exp_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcMvpGettingSpecialExp {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMvpGettingSpecialExp::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMvp {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0c01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMvp {
        let mut offset: usize = 0;
        PacketZcMvp {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMvp {
        let packet_id = i16::from_le_bytes([0x0c, 0x01]);
        let packet_id_raw = [0x0c, 0x01];
        PacketZcMvp {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcMvp {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMvp::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcThrowMvpitem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0d01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcThrowMvpitem {
        let mut offset: usize = 0;
        PacketZcThrowMvpitem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcThrowMvpitem {
        let packet_id = i16::from_le_bytes([0x0d, 0x01]);
        let packet_id_raw = [0x0d, 0x01];
        PacketZcThrowMvpitem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketZcThrowMvpitem {
    fn id(&self, packetver: u32) -> &str {
       PacketZcThrowMvpitem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSkillinfoUpdate {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0e01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSkillinfoUpdate {
        let mut offset: usize = 0;
        PacketZcSkillinfoUpdate {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            spcost: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            spcost_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            attack_range: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            attack_range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            upgradable: {
                let field = buffer[offset] == 1;
                field
            },
            upgradable_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.spcost).unwrap();
        self.spcost_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.attack_range).unwrap();
        self.attack_range_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.upgradable as u8).unwrap();
        self.upgradable_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.spcost_raw.to_vec());
        wtr.append(&mut self.attack_range_raw.to_vec());
        wtr.append(&mut self.upgradable_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 11;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_spcost(&mut self, value: i16) {
        self.spcost = value;
    }
    pub fn set_spcost_raw(&mut self, value: [u8; 2]) {
        self.spcost_raw = value;
    }
    pub fn set_attack_range(&mut self, value: i16) {
        self.attack_range = value;
    }
    pub fn set_attack_range_raw(&mut self, value: [u8; 2]) {
        self.attack_range_raw = value;
    }
    pub fn set_upgradable(&mut self, value: bool) {
        self.upgradable = value;
    }
    pub fn set_upgradable_raw(&mut self, value: [u8; 1]) {
        self.upgradable_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSkillinfoUpdate {
        let packet_id = i16::from_le_bytes([0x0e, 0x01]);
        let packet_id_raw = [0x0e, 0x01];
        PacketZcSkillinfoUpdate {
        raw: vec![],
        packet_id,
        packet_id_raw,
        skid: 0,
        skid_raw: [0; 2],
        level: 0,
        level_raw: [0; 2],
        spcost: 0,
        spcost_raw: [0; 2],
        attack_range: 0,
        attack_range_raw: [0; 2],
        upgradable: false,
        upgradable_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcSkillinfoUpdate {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSkillinfoUpdate::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSkillinfoList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0f01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSkillinfoList {
        let mut offset: usize = 0;
        let vec_type_len = SKILLINFO::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<SKILLINFO> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(SKILLINFO::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcSkillinfoList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skill_list: {
                let field = vec_field.clone();
                field
            },
            skill_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.skill_list_raw = {
            self.skill_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.skill_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.skill_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_skill_list(&mut self, value: Vec<SKILLINFO>) {
        self.skill_list = value;
    }
    pub fn set_skill_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.skill_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSkillinfoList {
        let packet_id = i16::from_le_bytes([0x0f, 0x01]);
        let packet_id_raw = [0x0f, 0x01];
        PacketZcSkillinfoList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        skill_list: vec![],
        skill_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcSkillinfoList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSkillinfoList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckTouseskill {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1001"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckTouseskill {
        let mut offset: usize = 0;
        PacketZcAckTouseskill {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            num: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            result: {
                let field = buffer[offset] == 1;
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            cause: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            cause_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.num).unwrap();
        self.num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.cause).unwrap();
        self.cause_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.num_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.cause_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_num(&mut self, value: u32) {
        self.num = value;
    }
    pub fn set_num_raw(&mut self, value: [u8; 4]) {
        self.num_raw = value;
    }
    pub fn set_result(&mut self, value: bool) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn set_cause(&mut self, value: u8) {
        self.cause = value;
    }
    pub fn set_cause_raw(&mut self, value: [u8; 1]) {
        self.cause_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckTouseskill {
        let packet_id = i16::from_le_bytes([0x10, 0x01]);
        let packet_id_raw = [0x10, 0x01];
        PacketZcAckTouseskill {
        raw: vec![],
        packet_id,
        packet_id_raw,
        skid: 0,
        skid_raw: [0; 2],
        num: 0,
        num_raw: [0; 4],
        result: false,
        result_raw: [0; 1],
        cause: 0,
        cause_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckTouseskill {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckTouseskill::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAddSkill {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1101"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAddSkill {
        let mut offset: usize = 0;
        PacketZcAddSkill {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            data: {
                let field = SKILLINFO::from(&buffer[offset..offset + SKILLINFO::base_len(packetver)], packetver);
                field
            },
            data_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.data.fill_raw_with_packetver(packetver);
        self.data_raw = self.data.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 1;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_data(&mut self, value: SKILLINFO) {
        self.data = value;
    }
    pub fn set_data_raw(&mut self, value: Vec<u8>) {
        self.data_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAddSkill {
        let packet_id = i16::from_le_bytes([0x11, 0x01]);
        let packet_id_raw = [0x11, 0x01];
        PacketZcAddSkill {
        raw: vec![],
        packet_id,
        packet_id_raw,
        data: SKILLINFO::new(packetver),
        data_raw: vec![],
        }
    }
}

impl Packet for PacketZcAddSkill {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAddSkill::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzUpgradeSkilllevel {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1201"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzUpgradeSkilllevel {
        let mut offset: usize = 0;
        PacketCzUpgradeSkilllevel {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzUpgradeSkilllevel {
        let packet_id = i16::from_le_bytes([0x12, 0x01]);
        let packet_id_raw = [0x12, 0x01];
        PacketCzUpgradeSkilllevel {
        raw: vec![],
        packet_id,
        packet_id_raw,
        skid: 0,
        skid_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzUpgradeSkilllevel {
    fn id(&self, packetver: u32) -> &str {
       PacketCzUpgradeSkilllevel::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzUseSkill {
    pub fn packet_id(packetver: u32) -> &'static str {
        if packetver >= 20120307 {
            "0x0889"
        } else {
            "0x1301"
        }
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzUseSkill {
        let mut offset: usize = 0;
        PacketCzUseSkill {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            selected_level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            selected_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            target_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.selected_level).unwrap();
        self.selected_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.selected_level_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.target_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_selected_level(&mut self, value: i16) {
        self.selected_level = value;
    }
    pub fn set_selected_level_raw(&mut self, value: [u8; 2]) {
        self.selected_level_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_target_id(&mut self, value: u32) {
        self.target_id = value;
    }
    pub fn set_target_id_raw(&mut self, value: [u8; 4]) {
        self.target_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzUseSkill {
        let (packet_id, packet_id_raw) = if packetver >= 20120307 {
            (i16::from_le_bytes([0x89, 0x08]), [0x89, 0x08])
        } else {
            (i16::from_le_bytes([0x13, 0x01]), [0x13, 0x01])
        };
        PacketCzUseSkill {
        raw: vec![],
        packet_id,
        packet_id_raw,
        selected_level: 0,
        selected_level_raw: [0; 2],
        skid: 0,
        skid_raw: [0; 2],
        target_id: 0,
        target_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzUseSkill {
    fn id(&self, packetver: u32) -> &str {
       PacketCzUseSkill::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifySkill {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1401"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifySkill {
        let mut offset: usize = 0;
        PacketZcNotifySkill {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            target_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            start_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            attack_mt: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            attack_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            attacked_mt: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            attacked_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            damage: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            damage_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            action: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attack_mt).unwrap();
        self.attack_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attacked_mt).unwrap();
        self.attacked_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.damage).unwrap();
        self.damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.target_id_raw.to_vec());
        wtr.append(&mut self.start_time_raw.to_vec());
        wtr.append(&mut self.attack_mt_raw.to_vec());
        wtr.append(&mut self.attacked_mt_raw.to_vec());
        wtr.append(&mut self.damage_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 31;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_target_id(&mut self, value: u32) {
        self.target_id = value;
    }
    pub fn set_target_id_raw(&mut self, value: [u8; 4]) {
        self.target_id_raw = value;
    }
    pub fn set_start_time(&mut self, value: u32) {
        self.start_time = value;
    }
    pub fn set_start_time_raw(&mut self, value: [u8; 4]) {
        self.start_time_raw = value;
    }
    pub fn set_attack_mt(&mut self, value: i32) {
        self.attack_mt = value;
    }
    pub fn set_attack_mt_raw(&mut self, value: [u8; 4]) {
        self.attack_mt_raw = value;
    }
    pub fn set_attacked_mt(&mut self, value: i32) {
        self.attacked_mt = value;
    }
    pub fn set_attacked_mt_raw(&mut self, value: [u8; 4]) {
        self.attacked_mt_raw = value;
    }
    pub fn set_damage(&mut self, value: i16) {
        self.damage = value;
    }
    pub fn set_damage_raw(&mut self, value: [u8; 2]) {
        self.damage_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifySkill {
        let packet_id = i16::from_le_bytes([0x14, 0x01]);
        let packet_id_raw = [0x14, 0x01];
        PacketZcNotifySkill {
        raw: vec![],
        packet_id,
        packet_id_raw,
        skid: 0,
        skid_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        target_id: 0,
        target_id_raw: [0; 4],
        start_time: 0,
        start_time_raw: [0; 4],
        attack_mt: 0,
        attack_mt_raw: [0; 4],
        attacked_mt: 0,
        attacked_mt_raw: [0; 4],
        damage: 0,
        damage_raw: [0; 2],
        level: 0,
        level_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        action: 0,
        action_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcNotifySkill {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifySkill::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifySkillPosition {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1501"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifySkillPosition {
        let mut offset: usize = 0;
        PacketZcNotifySkillPosition {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            target_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            start_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            attack_mt: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            attack_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            attacked_mt: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            attacked_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            damage: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            damage_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            action: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attack_mt).unwrap();
        self.attack_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attacked_mt).unwrap();
        self.attacked_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.damage).unwrap();
        self.damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.target_id_raw.to_vec());
        wtr.append(&mut self.start_time_raw.to_vec());
        wtr.append(&mut self.attack_mt_raw.to_vec());
        wtr.append(&mut self.attacked_mt_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.damage_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 35;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_target_id(&mut self, value: u32) {
        self.target_id = value;
    }
    pub fn set_target_id_raw(&mut self, value: [u8; 4]) {
        self.target_id_raw = value;
    }
    pub fn set_start_time(&mut self, value: u32) {
        self.start_time = value;
    }
    pub fn set_start_time_raw(&mut self, value: [u8; 4]) {
        self.start_time_raw = value;
    }
    pub fn set_attack_mt(&mut self, value: i32) {
        self.attack_mt = value;
    }
    pub fn set_attack_mt_raw(&mut self, value: [u8; 4]) {
        self.attack_mt_raw = value;
    }
    pub fn set_attacked_mt(&mut self, value: i32) {
        self.attacked_mt = value;
    }
    pub fn set_attacked_mt_raw(&mut self, value: [u8; 4]) {
        self.attacked_mt_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_damage(&mut self, value: i16) {
        self.damage = value;
    }
    pub fn set_damage_raw(&mut self, value: [u8; 2]) {
        self.damage_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifySkillPosition {
        let packet_id = i16::from_le_bytes([0x15, 0x01]);
        let packet_id_raw = [0x15, 0x01];
        PacketZcNotifySkillPosition {
        raw: vec![],
        packet_id,
        packet_id_raw,
        skid: 0,
        skid_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        target_id: 0,
        target_id_raw: [0; 4],
        start_time: 0,
        start_time_raw: [0; 4],
        attack_mt: 0,
        attack_mt_raw: [0; 4],
        attacked_mt: 0,
        attacked_mt_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        damage: 0,
        damage_raw: [0; 2],
        level: 0,
        level_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        action: 0,
        action_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcNotifySkillPosition {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifySkillPosition::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzUseSkillToground {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1601"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzUseSkillToground {
        let mut offset: usize = 0;
        PacketCzUseSkillToground {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            selected_level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            selected_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.selected_level).unwrap();
        self.selected_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.selected_level_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_selected_level(&mut self, value: i16) {
        self.selected_level = value;
    }
    pub fn set_selected_level_raw(&mut self, value: [u8; 2]) {
        self.selected_level_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzUseSkillToground {
        let packet_id = i16::from_le_bytes([0x16, 0x01]);
        let packet_id_raw = [0x16, 0x01];
        PacketCzUseSkillToground {
        raw: vec![],
        packet_id,
        packet_id_raw,
        selected_level: 0,
        selected_level_raw: [0; 2],
        skid: 0,
        skid_raw: [0; 2],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzUseSkillToground {
    fn id(&self, packetver: u32) -> &str {
       PacketCzUseSkillToground::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyGroundskill {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1701"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyGroundskill {
        let mut offset: usize = 0;
        PacketZcNotifyGroundskill {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            start_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.start_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 18;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_start_time(&mut self, value: u32) {
        self.start_time = value;
    }
    pub fn set_start_time_raw(&mut self, value: [u8; 4]) {
        self.start_time_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyGroundskill {
        let packet_id = i16::from_le_bytes([0x17, 0x01]);
        let packet_id_raw = [0x17, 0x01];
        PacketZcNotifyGroundskill {
        raw: vec![],
        packet_id,
        packet_id_raw,
        skid: 0,
        skid_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        level: 0,
        level_raw: [0; 2],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        start_time: 0,
        start_time_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyGroundskill {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyGroundskill::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzCancelLockon {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1801"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzCancelLockon {
        let mut offset: usize = 0;
        PacketCzCancelLockon {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzCancelLockon {
        let packet_id = i16::from_le_bytes([0x18, 0x01]);
        let packet_id_raw = [0x18, 0x01];
        PacketCzCancelLockon {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzCancelLockon {
    fn id(&self, packetver: u32) -> &str {
       PacketCzCancelLockon::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcStateChange {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1901"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcStateChange {
        let mut offset: usize = 0;
        PacketZcStateChange {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 13;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i16) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 2]) {
        self.effect_state_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcStateChange {
        let packet_id = i16::from_le_bytes([0x19, 0x01]);
        let packet_id_raw = [0x19, 0x01];
        PacketZcStateChange {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 2],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcStateChange {
    fn id(&self, packetver: u32) -> &str {
       PacketZcStateChange::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcUseSkill {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1a01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcUseSkill {
        let mut offset: usize = 0;
        PacketZcUseSkill {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            target_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            target_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            src_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            src_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            result: {
                let field = buffer[offset] == 1;
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_aid).unwrap();
        self.target_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.src_aid).unwrap();
        self.src_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.target_aid_raw.to_vec());
        wtr.append(&mut self.src_aid_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 15;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_target_aid(&mut self, value: u32) {
        self.target_aid = value;
    }
    pub fn set_target_aid_raw(&mut self, value: [u8; 4]) {
        self.target_aid_raw = value;
    }
    pub fn set_src_aid(&mut self, value: u32) {
        self.src_aid = value;
    }
    pub fn set_src_aid_raw(&mut self, value: [u8; 4]) {
        self.src_aid_raw = value;
    }
    pub fn set_result(&mut self, value: bool) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcUseSkill {
        let packet_id = i16::from_le_bytes([0x1a, 0x01]);
        let packet_id_raw = [0x1a, 0x01];
        PacketZcUseSkill {
        raw: vec![],
        packet_id,
        packet_id_raw,
        skid: 0,
        skid_raw: [0; 2],
        level: 0,
        level_raw: [0; 2],
        target_aid: 0,
        target_aid_raw: [0; 4],
        src_aid: 0,
        src_aid_raw: [0; 4],
        result: false,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcUseSkill {
    fn id(&self, packetver: u32) -> &str {
       PacketZcUseSkill::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzSelectWarppoint {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1b01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzSelectWarppoint {
        let mut offset: usize = 0;
        PacketCzSelectWarppoint {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            map_name: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 20;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzSelectWarppoint {
        let packet_id = i16::from_le_bytes([0x1b, 0x01]);
        let packet_id_raw = [0x1b, 0x01];
        PacketCzSelectWarppoint {
        raw: vec![],
        packet_id,
        packet_id_raw,
        skid: 0,
        skid_raw: [0; 2],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        }
    }
}

impl Packet for PacketCzSelectWarppoint {
    fn id(&self, packetver: u32) -> &str {
       PacketCzSelectWarppoint::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcWarplist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1c01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcWarplist {
        let mut offset: usize = 0;
        PacketZcWarplist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            map_name: {
                let field =  {
                let mut dst: [char; 4] = [0 as char; 4];
                for (index, byte) in buffer[offset..offset + 4].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            map_name_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 4]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 4]) {
        self.map_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcWarplist {
        let packet_id = i16::from_le_bytes([0x1c, 0x01]);
        let packet_id_raw = [0x1c, 0x01];
        PacketZcWarplist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        skid: 0,
        skid_raw: [0; 2],
        map_name: [0 as char; 4],
        map_name_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcWarplist {
    fn id(&self, packetver: u32) -> &str {
       PacketZcWarplist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRememberWarppoint {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1d01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRememberWarppoint {
        let mut offset: usize = 0;
        PacketCzRememberWarppoint {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRememberWarppoint {
        let packet_id = i16::from_le_bytes([0x1d, 0x01]);
        let packet_id_raw = [0x1d, 0x01];
        PacketCzRememberWarppoint {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzRememberWarppoint {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRememberWarppoint::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckRememberWarppoint {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1e01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckRememberWarppoint {
        let mut offset: usize = 0;
        PacketZcAckRememberWarppoint {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_code: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u8) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 1]) {
        self.error_code_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckRememberWarppoint {
        let packet_id = i16::from_le_bytes([0x1e, 0x01]);
        let packet_id_raw = [0x1e, 0x01];
        PacketZcAckRememberWarppoint {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_code: 0,
        error_code_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckRememberWarppoint {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckRememberWarppoint::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSkillEntry {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1f01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSkillEntry {
        let mut offset: usize = 0;
        PacketZcSkillEntry {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            creator_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            creator_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_visible: {
                let field = buffer[offset] == 1;
                field
            },
            is_visible_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.creator_aid).unwrap();
        self.creator_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_visible as u8).unwrap();
        self.is_visible_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.creator_aid_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.is_visible_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 16;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_creator_aid(&mut self, value: u32) {
        self.creator_aid = value;
    }
    pub fn set_creator_aid_raw(&mut self, value: [u8; 4]) {
        self.creator_aid_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_job(&mut self, value: u8) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 1]) {
        self.job_raw = value;
    }
    pub fn set_is_visible(&mut self, value: bool) {
        self.is_visible = value;
    }
    pub fn set_is_visible_raw(&mut self, value: [u8; 1]) {
        self.is_visible_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSkillEntry {
        let packet_id = i16::from_le_bytes([0x1f, 0x01]);
        let packet_id_raw = [0x1f, 0x01];
        PacketZcSkillEntry {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        creator_aid: 0,
        creator_aid_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        job: 0,
        job_raw: [0; 1],
        is_visible: false,
        is_visible_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcSkillEntry {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSkillEntry::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSkillDisappear {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2001"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSkillDisappear {
        let mut offset: usize = 0;
        PacketZcSkillDisappear {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSkillDisappear {
        let packet_id = i16::from_le_bytes([0x20, 0x01]);
        let packet_id_raw = [0x20, 0x01];
        PacketZcSkillDisappear {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcSkillDisappear {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSkillDisappear::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyCartitemCountinfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2101"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyCartitemCountinfo {
        let mut offset: usize = 0;
        PacketZcNotifyCartitemCountinfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            cur_count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            cur_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            max_count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            max_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            cur_weight: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            cur_weight_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            max_weight: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            max_weight_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.cur_count).unwrap();
        self.cur_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_count).unwrap();
        self.max_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.cur_weight).unwrap();
        self.cur_weight_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_weight).unwrap();
        self.max_weight_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.cur_count_raw.to_vec());
        wtr.append(&mut self.max_count_raw.to_vec());
        wtr.append(&mut self.cur_weight_raw.to_vec());
        wtr.append(&mut self.max_weight_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_cur_count(&mut self, value: i16) {
        self.cur_count = value;
    }
    pub fn set_cur_count_raw(&mut self, value: [u8; 2]) {
        self.cur_count_raw = value;
    }
    pub fn set_max_count(&mut self, value: i16) {
        self.max_count = value;
    }
    pub fn set_max_count_raw(&mut self, value: [u8; 2]) {
        self.max_count_raw = value;
    }
    pub fn set_cur_weight(&mut self, value: i32) {
        self.cur_weight = value;
    }
    pub fn set_cur_weight_raw(&mut self, value: [u8; 4]) {
        self.cur_weight_raw = value;
    }
    pub fn set_max_weight(&mut self, value: i32) {
        self.max_weight = value;
    }
    pub fn set_max_weight_raw(&mut self, value: [u8; 4]) {
        self.max_weight_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyCartitemCountinfo {
        let packet_id = i16::from_le_bytes([0x21, 0x01]);
        let packet_id_raw = [0x21, 0x01];
        PacketZcNotifyCartitemCountinfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        cur_count: 0,
        cur_count_raw: [0; 2],
        max_count: 0,
        max_count_raw: [0; 2],
        cur_weight: 0,
        cur_weight_raw: [0; 4],
        max_weight: 0,
        max_weight_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyCartitemCountinfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyCartitemCountinfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcCartEquipmentItemlist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2201"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcCartEquipmentItemlist {
        let mut offset: usize = 0;
        let vec_type_len = EquipmentitemExtrainfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<EquipmentitemExtrainfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(EquipmentitemExtrainfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcCartEquipmentItemlist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_info: {
                let field = vec_field.clone();
                field
            },
            item_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcCartEquipmentItemlist {
        let packet_id = i16::from_le_bytes([0x22, 0x01]);
        let packet_id_raw = [0x22, 0x01];
        PacketZcCartEquipmentItemlist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcCartEquipmentItemlist {
    fn id(&self, packetver: u32) -> &str {
       PacketZcCartEquipmentItemlist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcCartNormalItemlist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2301"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcCartNormalItemlist {
        let mut offset: usize = 0;
        let vec_type_len = NormalitemExtrainfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<NormalitemExtrainfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(NormalitemExtrainfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcCartNormalItemlist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_info: {
                let field = vec_field.clone();
                field
            },
            item_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<NormalitemExtrainfo>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcCartNormalItemlist {
        let packet_id = i16::from_le_bytes([0x23, 0x01]);
        let packet_id_raw = [0x23, 0x01];
        PacketZcCartNormalItemlist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcCartNormalItemlist {
    fn id(&self, packetver: u32) -> &str {
       PacketZcCartNormalItemlist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAddItemToCart {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2401"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAddItemToCart {
        let mut offset: usize = 0;
        PacketZcAddItemToCart {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_damaged: {
                let field = buffer[offset] == 1;
                field
            },
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            refining_level: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 21;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAddItemToCart {
        let packet_id = i16::from_le_bytes([0x24, 0x01]);
        let packet_id_raw = [0x24, 0x01];
        PacketZcAddItemToCart {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        }
    }
}

impl Packet for PacketZcAddItemToCart {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAddItemToCart::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcDeleteItemFromCart {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2501"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcDeleteItemFromCart {
        let mut offset: usize = 0;
        PacketZcDeleteItemFromCart {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcDeleteItemFromCart {
        let packet_id = i16::from_le_bytes([0x25, 0x01]);
        let packet_id_raw = [0x25, 0x01];
        PacketZcDeleteItemFromCart {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDeleteItemFromCart {
    fn id(&self, packetver: u32) -> &str {
       PacketZcDeleteItemFromCart::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzMoveItemFromBodyToCart {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2601"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzMoveItemFromBodyToCart {
        let mut offset: usize = 0;
        PacketCzMoveItemFromBodyToCart {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzMoveItemFromBodyToCart {
        let packet_id = i16::from_le_bytes([0x26, 0x01]);
        let packet_id_raw = [0x26, 0x01];
        PacketCzMoveItemFromBodyToCart {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMoveItemFromBodyToCart {
    fn id(&self, packetver: u32) -> &str {
       PacketCzMoveItemFromBodyToCart::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzMoveItemFromCartToBody {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2701"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzMoveItemFromCartToBody {
        let mut offset: usize = 0;
        PacketCzMoveItemFromCartToBody {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzMoveItemFromCartToBody {
        let packet_id = i16::from_le_bytes([0x27, 0x01]);
        let packet_id_raw = [0x27, 0x01];
        PacketCzMoveItemFromCartToBody {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMoveItemFromCartToBody {
    fn id(&self, packetver: u32) -> &str {
       PacketCzMoveItemFromCartToBody::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzMoveItemFromStoreToCart {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2801"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzMoveItemFromStoreToCart {
        let mut offset: usize = 0;
        PacketCzMoveItemFromStoreToCart {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzMoveItemFromStoreToCart {
        let packet_id = i16::from_le_bytes([0x28, 0x01]);
        let packet_id_raw = [0x28, 0x01];
        PacketCzMoveItemFromStoreToCart {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMoveItemFromStoreToCart {
    fn id(&self, packetver: u32) -> &str {
       PacketCzMoveItemFromStoreToCart::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzMoveItemFromCartToStore {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2901"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzMoveItemFromCartToStore {
        let mut offset: usize = 0;
        PacketCzMoveItemFromCartToStore {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzMoveItemFromCartToStore {
        let packet_id = i16::from_le_bytes([0x29, 0x01]);
        let packet_id_raw = [0x29, 0x01];
        PacketCzMoveItemFromCartToStore {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMoveItemFromCartToStore {
    fn id(&self, packetver: u32) -> &str {
       PacketCzMoveItemFromCartToStore::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqCartoff {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2a01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqCartoff {
        let mut offset: usize = 0;
        PacketCzReqCartoff {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqCartoff {
        let packet_id = i16::from_le_bytes([0x2a, 0x01]);
        let packet_id_raw = [0x2a, 0x01];
        PacketCzReqCartoff {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzReqCartoff {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqCartoff::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcCartoff {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2b01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcCartoff {
        let mut offset: usize = 0;
        PacketZcCartoff {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcCartoff {
        let packet_id = i16::from_le_bytes([0x2b, 0x01]);
        let packet_id_raw = [0x2b, 0x01];
        PacketZcCartoff {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketZcCartoff {
    fn id(&self, packetver: u32) -> &str {
       PacketZcCartoff::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckAdditemToCart {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2c01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckAdditemToCart {
        let mut offset: usize = 0;
        PacketZcAckAdditemToCart {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckAdditemToCart {
        let packet_id = i16::from_le_bytes([0x2c, 0x01]);
        let packet_id_raw = [0x2c, 0x01];
        PacketZcAckAdditemToCart {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckAdditemToCart {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckAdditemToCart::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcOpenstore {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2d01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcOpenstore {
        let mut offset: usize = 0;
        PacketZcOpenstore {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itemcount: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itemcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.itemcount).unwrap();
        self.itemcount_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itemcount_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itemcount(&mut self, value: i16) {
        self.itemcount = value;
    }
    pub fn set_itemcount_raw(&mut self, value: [u8; 2]) {
        self.itemcount_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcOpenstore {
        let packet_id = i16::from_le_bytes([0x2d, 0x01]);
        let packet_id_raw = [0x2d, 0x01];
        PacketZcOpenstore {
        raw: vec![],
        packet_id,
        packet_id_raw,
        itemcount: 0,
        itemcount_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcOpenstore {
    fn id(&self, packetver: u32) -> &str {
       PacketZcOpenstore::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqClosestore {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2e01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqClosestore {
        let mut offset: usize = 0;
        PacketCzReqClosestore {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqClosestore {
        let packet_id = i16::from_le_bytes([0x2e, 0x01]);
        let packet_id_raw = [0x2e, 0x01];
        PacketCzReqClosestore {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzReqClosestore {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqClosestore::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqOpenstore {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2f01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqOpenstore {
        let mut offset: usize = 0;
        let vec_type_len = StoreItem::base_len(packetver);
        let iter_count = (&buffer.len() - 84) / vec_type_len;
        let mut vec_field: Vec<StoreItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 84 + (vec_type_len * (i - 1));
            let end_pos = 84 + vec_type_len * i;
            vec_field.push(StoreItem::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketCzReqOpenstore {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            store_name: {
                let field =  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[offset..offset + 80].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            store_name_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[offset..offset + 80]);
                offset += 80;
                dst
            },
            store_list: {
                let field = vec_field.clone();
                field
            },
            store_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.store_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.store_name_raw = wtr.try_into().unwrap();
        self.store_list_raw = {
            self.store_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.store_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.store_name_raw.to_vec());
        self.store_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 84;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_store_name(&mut self, value: [char; 80]) {
        self.store_name = value;
    }
    pub fn set_store_name_raw(&mut self, value: [u8; 80]) {
        self.store_name_raw = value;
    }
    pub fn set_store_list(&mut self, value: Vec<StoreItem>) {
        self.store_list = value;
    }
    pub fn set_store_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.store_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqOpenstore {
        let packet_id = i16::from_le_bytes([0x2f, 0x01]);
        let packet_id_raw = [0x2f, 0x01];
        PacketCzReqOpenstore {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        store_name: [0 as char; 80],
        store_name_raw: [0; 80],
        store_list: vec![],
        store_list_raw: vec![],
        }
    }
}

impl Packet for PacketCzReqOpenstore {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqOpenstore::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqBuyFrommc {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3001"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqBuyFrommc {
        let mut offset: usize = 0;
        PacketCzReqBuyFrommc {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqBuyFrommc {
        let packet_id = i16::from_le_bytes([0x30, 0x01]);
        let packet_id_raw = [0x30, 0x01];
        PacketCzReqBuyFrommc {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqBuyFrommc {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqBuyFrommc::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcStoreEntry {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3101"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcStoreEntry {
        let mut offset: usize = 0;
        PacketZcStoreEntry {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            maker_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            store_name: {
                let field =  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[offset..offset + 80].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            store_name_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[offset..offset + 80]);
                offset += 80;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.store_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.store_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.maker_aid_raw.to_vec());
        wtr.append(&mut self.store_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 86;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_maker_aid(&mut self, value: u32) {
        self.maker_aid = value;
    }
    pub fn set_maker_aid_raw(&mut self, value: [u8; 4]) {
        self.maker_aid_raw = value;
    }
    pub fn set_store_name(&mut self, value: [char; 80]) {
        self.store_name = value;
    }
    pub fn set_store_name_raw(&mut self, value: [u8; 80]) {
        self.store_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcStoreEntry {
        let packet_id = i16::from_le_bytes([0x31, 0x01]);
        let packet_id_raw = [0x31, 0x01];
        PacketZcStoreEntry {
        raw: vec![],
        packet_id,
        packet_id_raw,
        maker_aid: 0,
        maker_aid_raw: [0; 4],
        store_name: [0 as char; 80],
        store_name_raw: [0; 80],
        }
    }
}

impl Packet for PacketZcStoreEntry {
    fn id(&self, packetver: u32) -> &str {
       PacketZcStoreEntry::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcDisappearEntry {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3201"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcDisappearEntry {
        let mut offset: usize = 0;
        PacketZcDisappearEntry {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            maker_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.maker_aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_maker_aid(&mut self, value: u32) {
        self.maker_aid = value;
    }
    pub fn set_maker_aid_raw(&mut self, value: [u8; 4]) {
        self.maker_aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcDisappearEntry {
        let packet_id = i16::from_le_bytes([0x32, 0x01]);
        let packet_id_raw = [0x32, 0x01];
        PacketZcDisappearEntry {
        raw: vec![],
        packet_id,
        packet_id_raw,
        maker_aid: 0,
        maker_aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDisappearEntry {
    fn id(&self, packetver: u32) -> &str {
       PacketZcDisappearEntry::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPcPurchaseItemlistFrommc {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3301"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPcPurchaseItemlistFrommc {
        let mut offset: usize = 0;
        let vec_type_len = PurchaseItemFrommc::base_len(packetver);
        let iter_count = (&buffer.len() - 8) / vec_type_len;
        let mut vec_field: Vec<PurchaseItemFrommc> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (vec_type_len * (i - 1));
            let end_pos = 8 + vec_type_len * i;
            vec_field.push(PurchaseItemFrommc::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcPcPurchaseItemlistFrommc {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            item_list: {
                let field = vec_field.clone();
                field
            },
            item_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<PurchaseItemFrommc>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPcPurchaseItemlistFrommc {
        let packet_id = i16::from_le_bytes([0x33, 0x01]);
        let packet_id_raw = [0x33, 0x01];
        PacketZcPcPurchaseItemlistFrommc {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcPcPurchaseItemlistFrommc {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPcPurchaseItemlistFrommc::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzPcPurchaseItemlistFrommc {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3401"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzPcPurchaseItemlistFrommc {
        let mut offset: usize = 0;
        let vec_type_len = CzPurchaseItemFrommc::base_len(packetver);
        let iter_count = (&buffer.len() - 8) / vec_type_len;
        let mut vec_field: Vec<CzPurchaseItemFrommc> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (vec_type_len * (i - 1));
            let end_pos = 8 + vec_type_len * i;
            vec_field.push(CzPurchaseItemFrommc::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketCzPcPurchaseItemlistFrommc {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            item_list: {
                let field = vec_field.clone();
                field
            },
            item_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<CzPurchaseItemFrommc>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzPcPurchaseItemlistFrommc {
        let packet_id = i16::from_le_bytes([0x34, 0x01]);
        let packet_id_raw = [0x34, 0x01];
        PacketCzPcPurchaseItemlistFrommc {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketCzPcPurchaseItemlistFrommc {
    fn id(&self, packetver: u32) -> &str {
       PacketCzPcPurchaseItemlistFrommc::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPcPurchaseResultFrommc {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3501"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPcPurchaseResultFrommc {
        let mut offset: usize = 0;
        PacketZcPcPurchaseResultFrommc {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            curcount: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            curcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.curcount).unwrap();
        self.curcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.curcount_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_curcount(&mut self, value: i16) {
        self.curcount = value;
    }
    pub fn set_curcount_raw(&mut self, value: [u8; 2]) {
        self.curcount_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPcPurchaseResultFrommc {
        let packet_id = i16::from_le_bytes([0x35, 0x01]);
        let packet_id_raw = [0x35, 0x01];
        PacketZcPcPurchaseResultFrommc {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        curcount: 0,
        curcount_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcPcPurchaseResultFrommc {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPcPurchaseResultFrommc::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPcPurchaseMyitemlist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3601"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPcPurchaseMyitemlist {
        let mut offset: usize = 0;
        let vec_type_len = PurchaseMyitem::base_len(packetver);
        let iter_count = (&buffer.len() - 8) / vec_type_len;
        let mut vec_field: Vec<PurchaseMyitem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (vec_type_len * (i - 1));
            let end_pos = 8 + vec_type_len * i;
            vec_field.push(PurchaseMyitem::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcPcPurchaseMyitemlist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            item_list: {
                let field = vec_field.clone();
                field
            },
            item_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<PurchaseMyitem>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPcPurchaseMyitemlist {
        let packet_id = i16::from_le_bytes([0x36, 0x01]);
        let packet_id_raw = [0x36, 0x01];
        PacketZcPcPurchaseMyitemlist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcPcPurchaseMyitemlist {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPcPurchaseMyitemlist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcDeleteitemFromMcstore {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3701"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcDeleteitemFromMcstore {
        let mut offset: usize = 0;
        PacketZcDeleteitemFromMcstore {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcDeleteitemFromMcstore {
        let packet_id = i16::from_le_bytes([0x37, 0x01]);
        let packet_id_raw = [0x37, 0x01];
        PacketZcDeleteitemFromMcstore {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcDeleteitemFromMcstore {
    fn id(&self, packetver: u32) -> &str {
       PacketZcDeleteitemFromMcstore::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzPkmodeChange {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3801"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzPkmodeChange {
        let mut offset: usize = 0;
        PacketCzPkmodeChange {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_turn_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_turn_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_turn_on as u8).unwrap();
        self.is_turn_on_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.is_turn_on_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_is_turn_on(&mut self, value: bool) {
        self.is_turn_on = value;
    }
    pub fn set_is_turn_on_raw(&mut self, value: [u8; 1]) {
        self.is_turn_on_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzPkmodeChange {
        let packet_id = i16::from_le_bytes([0x38, 0x01]);
        let packet_id_raw = [0x38, 0x01];
        PacketCzPkmodeChange {
        raw: vec![],
        packet_id,
        packet_id_raw,
        is_turn_on: false,
        is_turn_on_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzPkmodeChange {
    fn id(&self, packetver: u32) -> &str {
       PacketCzPkmodeChange::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAttackFailureForDistance {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3901"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAttackFailureForDistance {
        let mut offset: usize = 0;
        PacketZcAttackFailureForDistance {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            target_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            target_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            target_xpos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            target_xpos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            target_ypos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            target_ypos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            current_att_range: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            current_att_range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_aid).unwrap();
        self.target_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.target_xpos).unwrap();
        self.target_xpos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.target_ypos).unwrap();
        self.target_ypos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.current_att_range).unwrap();
        self.current_att_range_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.target_aid_raw.to_vec());
        wtr.append(&mut self.target_xpos_raw.to_vec());
        wtr.append(&mut self.target_ypos_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.current_att_range_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 16;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_target_aid(&mut self, value: u32) {
        self.target_aid = value;
    }
    pub fn set_target_aid_raw(&mut self, value: [u8; 4]) {
        self.target_aid_raw = value;
    }
    pub fn set_target_xpos(&mut self, value: i16) {
        self.target_xpos = value;
    }
    pub fn set_target_xpos_raw(&mut self, value: [u8; 2]) {
        self.target_xpos_raw = value;
    }
    pub fn set_target_ypos(&mut self, value: i16) {
        self.target_ypos = value;
    }
    pub fn set_target_ypos_raw(&mut self, value: [u8; 2]) {
        self.target_ypos_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_current_att_range(&mut self, value: i16) {
        self.current_att_range = value;
    }
    pub fn set_current_att_range_raw(&mut self, value: [u8; 2]) {
        self.current_att_range_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAttackFailureForDistance {
        let packet_id = i16::from_le_bytes([0x39, 0x01]);
        let packet_id_raw = [0x39, 0x01];
        PacketZcAttackFailureForDistance {
        raw: vec![],
        packet_id,
        packet_id_raw,
        target_aid: 0,
        target_aid_raw: [0; 4],
        target_xpos: 0,
        target_xpos_raw: [0; 2],
        target_ypos: 0,
        target_ypos_raw: [0; 2],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        current_att_range: 0,
        current_att_range_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAttackFailureForDistance {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAttackFailureForDistance::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAttackRange {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3a01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAttackRange {
        let mut offset: usize = 0;
        PacketZcAttackRange {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            current_att_range: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            current_att_range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.current_att_range).unwrap();
        self.current_att_range_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.current_att_range_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_current_att_range(&mut self, value: i16) {
        self.current_att_range = value;
    }
    pub fn set_current_att_range_raw(&mut self, value: [u8; 2]) {
        self.current_att_range_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAttackRange {
        let packet_id = i16::from_le_bytes([0x3a, 0x01]);
        let packet_id_raw = [0x3a, 0x01];
        PacketZcAttackRange {
        raw: vec![],
        packet_id,
        packet_id_raw,
        current_att_range: 0,
        current_att_range_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAttackRange {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAttackRange::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcActionFailure {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3b01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcActionFailure {
        let mut offset: usize = 0;
        PacketZcActionFailure {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_code: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: i16) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 2]) {
        self.error_code_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcActionFailure {
        let packet_id = i16::from_le_bytes([0x3b, 0x01]);
        let packet_id_raw = [0x3b, 0x01];
        PacketZcActionFailure {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_code: 0,
        error_code_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcActionFailure {
    fn id(&self, packetver: u32) -> &str {
       PacketZcActionFailure::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcEquipArrow {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3c01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcEquipArrow {
        let mut offset: usize = 0;
        PacketZcEquipArrow {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcEquipArrow {
        let packet_id = i16::from_le_bytes([0x3c, 0x01]);
        let packet_id_raw = [0x3c, 0x01];
        PacketZcEquipArrow {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcEquipArrow {
    fn id(&self, packetver: u32) -> &str {
       PacketZcEquipArrow::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcRecovery {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3d01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcRecovery {
        let mut offset: usize = 0;
        PacketZcRecovery {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            var_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            var_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            amount: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            amount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.var_id).unwrap();
        self.var_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.amount).unwrap();
        self.amount_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.var_id_raw.to_vec());
        wtr.append(&mut self.amount_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_var_id(&mut self, value: i16) {
        self.var_id = value;
    }
    pub fn set_var_id_raw(&mut self, value: [u8; 2]) {
        self.var_id_raw = value;
    }
    pub fn set_amount(&mut self, value: i16) {
        self.amount = value;
    }
    pub fn set_amount_raw(&mut self, value: [u8; 2]) {
        self.amount_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcRecovery {
        let packet_id = i16::from_le_bytes([0x3d, 0x01]);
        let packet_id_raw = [0x3d, 0x01];
        PacketZcRecovery {
        raw: vec![],
        packet_id,
        packet_id_raw,
        var_id: 0,
        var_id_raw: [0; 2],
        amount: 0,
        amount_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcRecovery {
    fn id(&self, packetver: u32) -> &str {
       PacketZcRecovery::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcUseskillAck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3e01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcUseskillAck {
        let mut offset: usize = 0;
        PacketZcUseskillAck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            target_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            property: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            property_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            delay_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            delay_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.property).unwrap();
        self.property_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.delay_time).unwrap();
        self.delay_time_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.target_id_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.property_raw.to_vec());
        wtr.append(&mut self.delay_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 24;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_target_id(&mut self, value: u32) {
        self.target_id = value;
    }
    pub fn set_target_id_raw(&mut self, value: [u8; 4]) {
        self.target_id_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_property(&mut self, value: u32) {
        self.property = value;
    }
    pub fn set_property_raw(&mut self, value: [u8; 4]) {
        self.property_raw = value;
    }
    pub fn set_delay_time(&mut self, value: u32) {
        self.delay_time = value;
    }
    pub fn set_delay_time_raw(&mut self, value: [u8; 4]) {
        self.delay_time_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcUseskillAck {
        let packet_id = i16::from_le_bytes([0x3e, 0x01]);
        let packet_id_raw = [0x3e, 0x01];
        PacketZcUseskillAck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        target_id: 0,
        target_id_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        skid: 0,
        skid_raw: [0; 2],
        property: 0,
        property_raw: [0; 4],
        delay_time: 0,
        delay_time_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcUseskillAck {
    fn id(&self, packetver: u32) -> &str {
       PacketZcUseskillAck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzItemCreate {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3f01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzItemCreate {
        let mut offset: usize = 0;
        PacketCzItemCreate {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            item_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.item_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.item_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.item_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_item_name(&mut self, value: [char; 24]) {
        self.item_name = value;
    }
    pub fn set_item_name_raw(&mut self, value: [u8; 24]) {
        self.item_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzItemCreate {
        let packet_id = i16::from_le_bytes([0x3f, 0x01]);
        let packet_id_raw = [0x3f, 0x01];
        PacketCzItemCreate {
        raw: vec![],
        packet_id,
        packet_id_raw,
        item_name: [0 as char; 24],
        item_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzItemCreate {
    fn id(&self, packetver: u32) -> &str {
       PacketCzItemCreate::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzMovetoMap {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4001"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzMovetoMap {
        let mut offset: usize = 0;
        PacketCzMovetoMap {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            map_name: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 22;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzMovetoMap {
        let packet_id = i16::from_le_bytes([0x40, 0x01]);
        let packet_id_raw = [0x40, 0x01];
        PacketCzMovetoMap {
        raw: vec![],
        packet_id,
        packet_id_raw,
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzMovetoMap {
    fn id(&self, packetver: u32) -> &str {
       PacketCzMovetoMap::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcStatusValues {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4101"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcStatusValues {
        let mut offset: usize = 0;
        PacketZcStatusValues {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            status_type: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            status_type_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            default_status: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            default_status_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            plus_status: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            plus_status_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.status_type).unwrap();
        self.status_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.default_status).unwrap();
        self.default_status_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.plus_status).unwrap();
        self.plus_status_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.status_type_raw.to_vec());
        wtr.append(&mut self.default_status_raw.to_vec());
        wtr.append(&mut self.plus_status_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_status_type(&mut self, value: u32) {
        self.status_type = value;
    }
    pub fn set_status_type_raw(&mut self, value: [u8; 4]) {
        self.status_type_raw = value;
    }
    pub fn set_default_status(&mut self, value: i32) {
        self.default_status = value;
    }
    pub fn set_default_status_raw(&mut self, value: [u8; 4]) {
        self.default_status_raw = value;
    }
    pub fn set_plus_status(&mut self, value: i32) {
        self.plus_status = value;
    }
    pub fn set_plus_status_raw(&mut self, value: [u8; 4]) {
        self.plus_status_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcStatusValues {
        let packet_id = i16::from_le_bytes([0x41, 0x01]);
        let packet_id_raw = [0x41, 0x01];
        PacketZcStatusValues {
        raw: vec![],
        packet_id,
        packet_id_raw,
        status_type: 0,
        status_type_raw: [0; 4],
        default_status: 0,
        default_status_raw: [0; 4],
        plus_status: 0,
        plus_status_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcStatusValues {
    fn id(&self, packetver: u32) -> &str {
       PacketZcStatusValues::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcOpenEditdlg {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4201"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcOpenEditdlg {
        let mut offset: usize = 0;
        PacketZcOpenEditdlg {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            naid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcOpenEditdlg {
        let packet_id = i16::from_le_bytes([0x42, 0x01]);
        let packet_id_raw = [0x42, 0x01];
        PacketZcOpenEditdlg {
        raw: vec![],
        packet_id,
        packet_id_raw,
        naid: 0,
        naid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcOpenEditdlg {
    fn id(&self, packetver: u32) -> &str {
       PacketZcOpenEditdlg::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzInputEditdlg {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4301"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzInputEditdlg {
        let mut offset: usize = 0;
        PacketCzInputEditdlg {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            naid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            value: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzInputEditdlg {
        let packet_id = i16::from_le_bytes([0x43, 0x01]);
        let packet_id_raw = [0x43, 0x01];
        PacketCzInputEditdlg {
        raw: vec![],
        packet_id,
        packet_id_raw,
        naid: 0,
        naid_raw: [0; 4],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzInputEditdlg {
    fn id(&self, packetver: u32) -> &str {
       PacketCzInputEditdlg::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcCompass {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4401"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcCompass {
        let mut offset: usize = 0;
        PacketZcCompass {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            naid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            atype: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            x_pos: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            y_pos: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            id: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            id_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            color: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            color_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.id).unwrap();
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.color).unwrap();
        self.color_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.color_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 23;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i32) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 4]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i32) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 4]) {
        self.y_pos_raw = value;
    }
    pub fn set_id(&mut self, value: u8) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 1]) {
        self.id_raw = value;
    }
    pub fn set_color(&mut self, value: u32) {
        self.color = value;
    }
    pub fn set_color_raw(&mut self, value: [u8; 4]) {
        self.color_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcCompass {
        let packet_id = i16::from_le_bytes([0x44, 0x01]);
        let packet_id_raw = [0x44, 0x01];
        PacketZcCompass {
        raw: vec![],
        packet_id,
        packet_id_raw,
        naid: 0,
        naid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 4],
        y_pos: 0,
        y_pos_raw: [0; 4],
        id: 0,
        id_raw: [0; 1],
        color: 0,
        color_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcCompass {
    fn id(&self, packetver: u32) -> &str {
       PacketZcCompass::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcShowImage {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4501"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcShowImage {
        let mut offset: usize = 0;
        PacketZcShowImage {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            image_name: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            image_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.image_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.image_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.image_name_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 19;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_image_name(&mut self, value: [char; 16]) {
        self.image_name = value;
    }
    pub fn set_image_name_raw(&mut self, value: [u8; 16]) {
        self.image_name_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcShowImage {
        let packet_id = i16::from_le_bytes([0x45, 0x01]);
        let packet_id_raw = [0x45, 0x01];
        PacketZcShowImage {
        raw: vec![],
        packet_id,
        packet_id_raw,
        image_name: [0 as char; 16],
        image_name_raw: [0; 16],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcShowImage {
    fn id(&self, packetver: u32) -> &str {
       PacketZcShowImage::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzCloseDialog {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4601"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzCloseDialog {
        let mut offset: usize = 0;
        PacketCzCloseDialog {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            naid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzCloseDialog {
        let packet_id = i16::from_le_bytes([0x46, 0x01]);
        let packet_id_raw = [0x46, 0x01];
        PacketCzCloseDialog {
        raw: vec![],
        packet_id,
        packet_id_raw,
        naid: 0,
        naid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzCloseDialog {
    fn id(&self, packetver: u32) -> &str {
       PacketCzCloseDialog::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAutorunSkill {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4701"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAutorunSkill {
        let mut offset: usize = 0;
        PacketZcAutorunSkill {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            data: {
                let field = SKILLINFO::from(&buffer[offset..offset + SKILLINFO::base_len(packetver)], packetver);
                field
            },
            data_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.data.fill_raw_with_packetver(packetver);
        self.data_raw = self.data.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 1;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_data(&mut self, value: SKILLINFO) {
        self.data = value;
    }
    pub fn set_data_raw(&mut self, value: Vec<u8>) {
        self.data_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAutorunSkill {
        let packet_id = i16::from_le_bytes([0x47, 0x01]);
        let packet_id_raw = [0x47, 0x01];
        PacketZcAutorunSkill {
        raw: vec![],
        packet_id,
        packet_id_raw,
        data: SKILLINFO::new(packetver),
        data_raw: vec![],
        }
    }
}

impl Packet for PacketZcAutorunSkill {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAutorunSkill::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcResurrection {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4801"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcResurrection {
        let mut offset: usize = 0;
        PacketZcResurrection {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            atype: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcResurrection {
        let packet_id = i16::from_le_bytes([0x48, 0x01]);
        let packet_id_raw = [0x48, 0x01];
        PacketZcResurrection {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcResurrection {
    fn id(&self, packetver: u32) -> &str {
       PacketZcResurrection::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqGiveMannerPoint {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4901"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqGiveMannerPoint {
        let mut offset: usize = 0;
        PacketCzReqGiveMannerPoint {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            other_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            other_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            point: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            point_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.other_aid).unwrap();
        self.other_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.other_aid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 9;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_other_aid(&mut self, value: u32) {
        self.other_aid = value;
    }
    pub fn set_other_aid_raw(&mut self, value: [u8; 4]) {
        self.other_aid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_point(&mut self, value: i16) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 2]) {
        self.point_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqGiveMannerPoint {
        let packet_id = i16::from_le_bytes([0x49, 0x01]);
        let packet_id_raw = [0x49, 0x01];
        PacketCzReqGiveMannerPoint {
        raw: vec![],
        packet_id,
        packet_id_raw,
        other_aid: 0,
        other_aid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        point: 0,
        point_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqGiveMannerPoint {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqGiveMannerPoint::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckGiveMannerPoint {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4a01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckGiveMannerPoint {
        let mut offset: usize = 0;
        PacketZcAckGiveMannerPoint {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u32) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 4]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckGiveMannerPoint {
        let packet_id = i16::from_le_bytes([0x4a, 0x01]);
        let packet_id_raw = [0x4a, 0x01];
        PacketZcAckGiveMannerPoint {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcAckGiveMannerPoint {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckGiveMannerPoint::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyMannerPointGiven {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4b01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyMannerPointGiven {
        let mut offset: usize = 0;
        PacketZcNotifyMannerPointGiven {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            other_char_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            other_char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.other_char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.other_char_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.other_char_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 27;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_other_char_name(&mut self, value: [char; 24]) {
        self.other_char_name = value;
    }
    pub fn set_other_char_name_raw(&mut self, value: [u8; 24]) {
        self.other_char_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyMannerPointGiven {
        let packet_id = i16::from_le_bytes([0x4b, 0x01]);
        let packet_id_raw = [0x4b, 0x01];
        PacketZcNotifyMannerPointGiven {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 1],
        other_char_name: [0 as char; 24],
        other_char_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcNotifyMannerPointGiven {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyMannerPointGiven::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMyguildBasicInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4c01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMyguildBasicInfo {
        let mut offset: usize = 0;
        let vec_type_len = RelatedGuild::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<RelatedGuild> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(RelatedGuild::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcMyguildBasicInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            related_guild_list: {
                let field = vec_field.clone();
                field
            },
            related_guild_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.related_guild_list_raw = {
            self.related_guild_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.related_guild_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.related_guild_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_related_guild_list(&mut self, value: Vec<RelatedGuild>) {
        self.related_guild_list = value;
    }
    pub fn set_related_guild_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.related_guild_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMyguildBasicInfo {
        let packet_id = i16::from_le_bytes([0x4c, 0x01]);
        let packet_id_raw = [0x4c, 0x01];
        PacketZcMyguildBasicInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        related_guild_list: vec![],
        related_guild_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcMyguildBasicInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMyguildBasicInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqGuildMenuinterface {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4d01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqGuildMenuinterface {
        let mut offset: usize = 0;
        PacketCzReqGuildMenuinterface {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqGuildMenuinterface {
        let packet_id = i16::from_le_bytes([0x4d, 0x01]);
        let packet_id_raw = [0x4d, 0x01];
        PacketCzReqGuildMenuinterface {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzReqGuildMenuinterface {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqGuildMenuinterface::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckGuildMenuinterface {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4e01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckGuildMenuinterface {
        let mut offset: usize = 0;
        PacketZcAckGuildMenuinterface {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guild_memu_flag: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guild_memu_flag_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.guild_memu_flag).unwrap();
        self.guild_memu_flag_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.guild_memu_flag_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_guild_memu_flag(&mut self, value: i32) {
        self.guild_memu_flag = value;
    }
    pub fn set_guild_memu_flag_raw(&mut self, value: [u8; 4]) {
        self.guild_memu_flag_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckGuildMenuinterface {
        let packet_id = i16::from_le_bytes([0x4e, 0x01]);
        let packet_id_raw = [0x4e, 0x01];
        PacketZcAckGuildMenuinterface {
        raw: vec![],
        packet_id,
        packet_id_raw,
        guild_memu_flag: 0,
        guild_memu_flag_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcAckGuildMenuinterface {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckGuildMenuinterface::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqGuildMenu {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4f01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqGuildMenu {
        let mut offset: usize = 0;
        PacketCzReqGuildMenu {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqGuildMenu {
        let packet_id = i16::from_le_bytes([0x4f, 0x01]);
        let packet_id_raw = [0x4f, 0x01];
        PacketCzReqGuildMenu {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqGuildMenu {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqGuildMenu::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcGuildInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5001"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcGuildInfo {
        let mut offset: usize = 0;
        PacketZcGuildInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gdid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            level: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            user_num: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            user_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            max_user_num: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            max_user_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            user_average_level: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            user_average_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            exp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            max_exp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            max_exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            point: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            honor: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            virtue: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            emblem_version: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            emblem_version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            guildname: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            guildname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            master_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            master_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            manage_land: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            manage_land_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.user_num).unwrap();
        self.user_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_user_num).unwrap();
        self.max_user_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.user_average_level).unwrap();
        self.user_average_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.exp).unwrap();
        self.exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_exp).unwrap();
        self.max_exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.emblem_version).unwrap();
        self.emblem_version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.guildname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guildname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.master_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.master_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.manage_land {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.manage_land_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.user_num_raw.to_vec());
        wtr.append(&mut self.max_user_num_raw.to_vec());
        wtr.append(&mut self.user_average_level_raw.to_vec());
        wtr.append(&mut self.exp_raw.to_vec());
        wtr.append(&mut self.max_exp_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.emblem_version_raw.to_vec());
        wtr.append(&mut self.guildname_raw.to_vec());
        wtr.append(&mut self.master_name_raw.to_vec());
        wtr.append(&mut self.manage_land_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 110;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: i32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_level(&mut self, value: i32) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 4]) {
        self.level_raw = value;
    }
    pub fn set_user_num(&mut self, value: i32) {
        self.user_num = value;
    }
    pub fn set_user_num_raw(&mut self, value: [u8; 4]) {
        self.user_num_raw = value;
    }
    pub fn set_max_user_num(&mut self, value: i32) {
        self.max_user_num = value;
    }
    pub fn set_max_user_num_raw(&mut self, value: [u8; 4]) {
        self.max_user_num_raw = value;
    }
    pub fn set_user_average_level(&mut self, value: i32) {
        self.user_average_level = value;
    }
    pub fn set_user_average_level_raw(&mut self, value: [u8; 4]) {
        self.user_average_level_raw = value;
    }
    pub fn set_exp(&mut self, value: i32) {
        self.exp = value;
    }
    pub fn set_exp_raw(&mut self, value: [u8; 4]) {
        self.exp_raw = value;
    }
    pub fn set_max_exp(&mut self, value: i32) {
        self.max_exp = value;
    }
    pub fn set_max_exp_raw(&mut self, value: [u8; 4]) {
        self.max_exp_raw = value;
    }
    pub fn set_point(&mut self, value: i32) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 4]) {
        self.point_raw = value;
    }
    pub fn set_honor(&mut self, value: i32) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 4]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_emblem_version(&mut self, value: i32) {
        self.emblem_version = value;
    }
    pub fn set_emblem_version_raw(&mut self, value: [u8; 4]) {
        self.emblem_version_raw = value;
    }
    pub fn set_guildname(&mut self, value: [char; 24]) {
        self.guildname = value;
    }
    pub fn set_guildname_raw(&mut self, value: [u8; 24]) {
        self.guildname_raw = value;
    }
    pub fn set_master_name(&mut self, value: [char; 24]) {
        self.master_name = value;
    }
    pub fn set_master_name_raw(&mut self, value: [u8; 24]) {
        self.master_name_raw = value;
    }
    pub fn set_manage_land(&mut self, value: [char; 16]) {
        self.manage_land = value;
    }
    pub fn set_manage_land_raw(&mut self, value: [u8; 16]) {
        self.manage_land_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcGuildInfo {
        let packet_id = i16::from_le_bytes([0x50, 0x01]);
        let packet_id_raw = [0x50, 0x01];
        PacketZcGuildInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gdid: 0,
        gdid_raw: [0; 4],
        level: 0,
        level_raw: [0; 4],
        user_num: 0,
        user_num_raw: [0; 4],
        max_user_num: 0,
        max_user_num_raw: [0; 4],
        user_average_level: 0,
        user_average_level_raw: [0; 4],
        exp: 0,
        exp_raw: [0; 4],
        max_exp: 0,
        max_exp_raw: [0; 4],
        point: 0,
        point_raw: [0; 4],
        honor: 0,
        honor_raw: [0; 4],
        virtue: 0,
        virtue_raw: [0; 4],
        emblem_version: 0,
        emblem_version_raw: [0; 4],
        guildname: [0 as char; 24],
        guildname_raw: [0; 24],
        master_name: [0 as char; 24],
        master_name_raw: [0; 24],
        manage_land: [0 as char; 16],
        manage_land_raw: [0; 16],
        }
    }
}

impl Packet for PacketZcGuildInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcGuildInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqGuildEmblemImg {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5101"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqGuildEmblemImg {
        let mut offset: usize = 0;
        PacketCzReqGuildEmblemImg {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gdid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: i32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqGuildEmblemImg {
        let packet_id = i16::from_le_bytes([0x51, 0x01]);
        let packet_id_raw = [0x51, 0x01];
        PacketCzReqGuildEmblemImg {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gdid: 0,
        gdid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqGuildEmblemImg {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqGuildEmblemImg::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcGuildEmblemImg {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5201"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcGuildEmblemImg {
        let mut offset: usize = 0;
        PacketZcGuildEmblemImg {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gdid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            emblem_version: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            emblem_version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            img: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            img_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.emblem_version).unwrap();
        self.emblem_version_raw = wtr.try_into().unwrap();
        self.img_raw = self.img.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.emblem_version_raw.to_vec());
        wtr.append(&mut self.img_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 11;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_gdid(&mut self, value: i32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_emblem_version(&mut self, value: i32) {
        self.emblem_version = value;
    }
    pub fn set_emblem_version_raw(&mut self, value: [u8; 4]) {
        self.emblem_version_raw = value;
    }
    pub fn set_img(&mut self, value: String) {
        self.img = value;
    }
    pub fn set_img_raw(&mut self, value: Vec<u8>) {
        self.img_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcGuildEmblemImg {
        let packet_id = i16::from_le_bytes([0x52, 0x01]);
        let packet_id_raw = [0x52, 0x01];
        PacketZcGuildEmblemImg {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        gdid: 0,
        gdid_raw: [0; 4],
        emblem_version: 0,
        emblem_version_raw: [0; 4],
        img: String::new(),
        img_raw: vec![],
        }
    }
}

impl Packet for PacketZcGuildEmblemImg {
    fn id(&self, packetver: u32) -> &str {
       PacketZcGuildEmblemImg::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRegisterGuildEmblemImg {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5301"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRegisterGuildEmblemImg {
        let mut offset: usize = 0;
        PacketCzRegisterGuildEmblemImg {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            img: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            img_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.img_raw = self.img.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.img_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_img(&mut self, value: String) {
        self.img = value;
    }
    pub fn set_img_raw(&mut self, value: Vec<u8>) {
        self.img_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRegisterGuildEmblemImg {
        let packet_id = i16::from_le_bytes([0x53, 0x01]);
        let packet_id_raw = [0x53, 0x01];
        PacketCzRegisterGuildEmblemImg {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        img: String::new(),
        img_raw: vec![],
        }
    }
}

impl Packet for PacketCzRegisterGuildEmblemImg {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRegisterGuildEmblemImg::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMembermgrInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5401"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMembermgrInfo {
        let mut offset: usize = 0;
        let vec_type_len = GuildMembermgrInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<GuildMembermgrInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(GuildMembermgrInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcMembermgrInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            member_info: {
                let field = vec_field.clone();
                field
            },
            member_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_info_raw = {
            self.member_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.member_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.member_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_member_info(&mut self, value: Vec<GuildMembermgrInfo>) {
        self.member_info = value;
    }
    pub fn set_member_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.member_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMembermgrInfo {
        let packet_id = i16::from_le_bytes([0x54, 0x01]);
        let packet_id_raw = [0x54, 0x01];
        PacketZcMembermgrInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        member_info: vec![],
        member_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcMembermgrInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMembermgrInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqChangeMemberpos {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5501"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqChangeMemberpos {
        let mut offset: usize = 0;
        let vec_type_len = MemberPositionInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<MemberPositionInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(MemberPositionInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketCzReqChangeMemberpos {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            member_info: {
                let field = vec_field.clone();
                field
            },
            member_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_info_raw = {
            self.member_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.member_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.member_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_member_info(&mut self, value: Vec<MemberPositionInfo>) {
        self.member_info = value;
    }
    pub fn set_member_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.member_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqChangeMemberpos {
        let packet_id = i16::from_le_bytes([0x55, 0x01]);
        let packet_id_raw = [0x55, 0x01];
        PacketCzReqChangeMemberpos {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        member_info: vec![],
        member_info_raw: vec![],
        }
    }
}

impl Packet for PacketCzReqChangeMemberpos {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqChangeMemberpos::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckReqChangeMembers {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5601"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckReqChangeMembers {
        let mut offset: usize = 0;
        let vec_type_len = MemberPositionInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<MemberPositionInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(MemberPositionInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcAckReqChangeMembers {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            member_info: {
                let field = vec_field.clone();
                field
            },
            member_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_info_raw = {
            self.member_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.member_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.member_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_member_info(&mut self, value: Vec<MemberPositionInfo>) {
        self.member_info = value;
    }
    pub fn set_member_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.member_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckReqChangeMembers {
        let packet_id = i16::from_le_bytes([0x56, 0x01]);
        let packet_id_raw = [0x56, 0x01];
        PacketZcAckReqChangeMembers {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        member_info: vec![],
        member_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcAckReqChangeMembers {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckReqChangeMembers::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqOpenMemberInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5701"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqOpenMemberInfo {
        let mut offset: usize = 0;
        PacketCzReqOpenMemberInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: i32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqOpenMemberInfo {
        let packet_id = i16::from_le_bytes([0x57, 0x01]);
        let packet_id_raw = [0x57, 0x01];
        PacketCzReqOpenMemberInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqOpenMemberInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqOpenMemberInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckOpenMemberInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5801"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckOpenMemberInfo {
        let mut offset: usize = 0;
        PacketZcAckOpenMemberInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckOpenMemberInfo {
        let packet_id = i16::from_le_bytes([0x58, 0x01]);
        let packet_id_raw = [0x58, 0x01];
        PacketZcAckOpenMemberInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketZcAckOpenMemberInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckOpenMemberInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqLeaveGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5901"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqLeaveGuild {
        let mut offset: usize = 0;
        PacketCzReqLeaveGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gdid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            aid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            reason_desc: {
                let field =  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[offset..offset + 40].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            reason_desc_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[offset..offset + 40]);
                offset += 40;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason_desc {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_desc_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.reason_desc_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 54;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: u32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_aid(&mut self, value: i32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: i32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_reason_desc(&mut self, value: [char; 40]) {
        self.reason_desc = value;
    }
    pub fn set_reason_desc_raw(&mut self, value: [u8; 40]) {
        self.reason_desc_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqLeaveGuild {
        let packet_id = i16::from_le_bytes([0x59, 0x01]);
        let packet_id_raw = [0x59, 0x01];
        PacketCzReqLeaveGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gdid: 0,
        gdid_raw: [0; 4],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        reason_desc: [0 as char; 40],
        reason_desc_raw: [0; 40],
        }
    }
}

impl Packet for PacketCzReqLeaveGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqLeaveGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckLeaveGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5a01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckLeaveGuild {
        let mut offset: usize = 0;
        PacketZcAckLeaveGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            char_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            reason_desc: {
                let field =  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[offset..offset + 40].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            reason_desc_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[offset..offset + 40]);
                offset += 40;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason_desc {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_desc_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.char_name_raw.to_vec());
        wtr.append(&mut self.reason_desc_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 66;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_char_name(&mut self, value: [char; 24]) {
        self.char_name = value;
    }
    pub fn set_char_name_raw(&mut self, value: [u8; 24]) {
        self.char_name_raw = value;
    }
    pub fn set_reason_desc(&mut self, value: [char; 40]) {
        self.reason_desc = value;
    }
    pub fn set_reason_desc_raw(&mut self, value: [u8; 40]) {
        self.reason_desc_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckLeaveGuild {
        let packet_id = i16::from_le_bytes([0x5a, 0x01]);
        let packet_id_raw = [0x5a, 0x01];
        PacketZcAckLeaveGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        char_name: [0 as char; 24],
        char_name_raw: [0; 24],
        reason_desc: [0 as char; 40],
        reason_desc_raw: [0; 40],
        }
    }
}

impl Packet for PacketZcAckLeaveGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckLeaveGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqBanGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5b01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqBanGuild {
        let mut offset: usize = 0;
        PacketCzReqBanGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gdid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            aid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            reason_desc: {
                let field =  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[offset..offset + 40].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            reason_desc_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[offset..offset + 40]);
                offset += 40;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason_desc {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_desc_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.reason_desc_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 54;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: u32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_aid(&mut self, value: i32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: i32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_reason_desc(&mut self, value: [char; 40]) {
        self.reason_desc = value;
    }
    pub fn set_reason_desc_raw(&mut self, value: [u8; 40]) {
        self.reason_desc_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqBanGuild {
        let packet_id = i16::from_le_bytes([0x5b, 0x01]);
        let packet_id_raw = [0x5b, 0x01];
        PacketCzReqBanGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gdid: 0,
        gdid_raw: [0; 4],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        reason_desc: [0 as char; 40],
        reason_desc_raw: [0; 40],
        }
    }
}

impl Packet for PacketCzReqBanGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqBanGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckBanGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5c01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckBanGuild {
        let mut offset: usize = 0;
        PacketZcAckBanGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            char_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            reason_desc: {
                let field =  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[offset..offset + 40].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            reason_desc_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[offset..offset + 40]);
                offset += 40;
                dst
            },
            account: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            account_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason_desc {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_desc_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.account {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.account_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.char_name_raw.to_vec());
        wtr.append(&mut self.reason_desc_raw.to_vec());
        wtr.append(&mut self.account_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 90;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_char_name(&mut self, value: [char; 24]) {
        self.char_name = value;
    }
    pub fn set_char_name_raw(&mut self, value: [u8; 24]) {
        self.char_name_raw = value;
    }
    pub fn set_reason_desc(&mut self, value: [char; 40]) {
        self.reason_desc = value;
    }
    pub fn set_reason_desc_raw(&mut self, value: [u8; 40]) {
        self.reason_desc_raw = value;
    }
    pub fn set_account(&mut self, value: [char; 24]) {
        self.account = value;
    }
    pub fn set_account_raw(&mut self, value: [u8; 24]) {
        self.account_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckBanGuild {
        let packet_id = i16::from_le_bytes([0x5c, 0x01]);
        let packet_id_raw = [0x5c, 0x01];
        PacketZcAckBanGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        char_name: [0 as char; 24],
        char_name_raw: [0; 24],
        reason_desc: [0 as char; 40],
        reason_desc_raw: [0; 40],
        account: [0 as char; 24],
        account_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcAckBanGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckBanGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqDisorganizeGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5d01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqDisorganizeGuild {
        let mut offset: usize = 0;
        PacketCzReqDisorganizeGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            key: {
                let field =  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[offset..offset + 40].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            key_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[offset..offset + 40]);
                offset += 40;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.key {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.key_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.key_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 42;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_key(&mut self, value: [char; 40]) {
        self.key = value;
    }
    pub fn set_key_raw(&mut self, value: [u8; 40]) {
        self.key_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqDisorganizeGuild {
        let packet_id = i16::from_le_bytes([0x5d, 0x01]);
        let packet_id_raw = [0x5d, 0x01];
        PacketCzReqDisorganizeGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        key: [0 as char; 40],
        key_raw: [0; 40],
        }
    }
}

impl Packet for PacketCzReqDisorganizeGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqDisorganizeGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckDisorganizeGuildResult {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5e01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckDisorganizeGuildResult {
        let mut offset: usize = 0;
        PacketZcAckDisorganizeGuildResult {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            reason: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            reason_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.reason).unwrap();
        self.reason_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.reason_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_reason(&mut self, value: i32) {
        self.reason = value;
    }
    pub fn set_reason_raw(&mut self, value: [u8; 4]) {
        self.reason_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckDisorganizeGuildResult {
        let packet_id = i16::from_le_bytes([0x5e, 0x01]);
        let packet_id_raw = [0x5e, 0x01];
        PacketZcAckDisorganizeGuildResult {
        raw: vec![],
        packet_id,
        packet_id_raw,
        reason: 0,
        reason_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcAckDisorganizeGuildResult {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckDisorganizeGuildResult::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckDisorganizeGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5f01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckDisorganizeGuild {
        let mut offset: usize = 0;
        PacketZcAckDisorganizeGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            reason_desc: {
                let field =  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[offset..offset + 40].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            reason_desc_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[offset..offset + 40]);
                offset += 40;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason_desc {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_desc_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.reason_desc_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 42;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_reason_desc(&mut self, value: [char; 40]) {
        self.reason_desc = value;
    }
    pub fn set_reason_desc_raw(&mut self, value: [u8; 40]) {
        self.reason_desc_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckDisorganizeGuild {
        let packet_id = i16::from_le_bytes([0x5f, 0x01]);
        let packet_id_raw = [0x5f, 0x01];
        PacketZcAckDisorganizeGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        reason_desc: [0 as char; 40],
        reason_desc_raw: [0; 40],
        }
    }
}

impl Packet for PacketZcAckDisorganizeGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckDisorganizeGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPositionInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6001"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPositionInfo {
        let mut offset: usize = 0;
        let vec_type_len = GuildMemberPositionInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<GuildMemberPositionInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(GuildMemberPositionInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcPositionInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            member_info: {
                let field = vec_field.clone();
                field
            },
            member_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_info_raw = {
            self.member_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.member_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.member_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_member_info(&mut self, value: Vec<GuildMemberPositionInfo>) {
        self.member_info = value;
    }
    pub fn set_member_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.member_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPositionInfo {
        let packet_id = i16::from_le_bytes([0x60, 0x01]);
        let packet_id_raw = [0x60, 0x01];
        PacketZcPositionInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        member_info: vec![],
        member_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcPositionInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPositionInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRegChangeGuildPositioninfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6101"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRegChangeGuildPositioninfo {
        let mut offset: usize = 0;
        let vec_type_len = GuildRegPositionInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<GuildRegPositionInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(GuildRegPositionInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketCzRegChangeGuildPositioninfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            member_list: {
                let field = vec_field.clone();
                field
            },
            member_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_list_raw = {
            self.member_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.member_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.member_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_member_list(&mut self, value: Vec<GuildRegPositionInfo>) {
        self.member_list = value;
    }
    pub fn set_member_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.member_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRegChangeGuildPositioninfo {
        let packet_id = i16::from_le_bytes([0x61, 0x01]);
        let packet_id_raw = [0x61, 0x01];
        PacketCzRegChangeGuildPositioninfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        member_list: vec![],
        member_list_raw: vec![],
        }
    }
}

impl Packet for PacketCzRegChangeGuildPositioninfo {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRegChangeGuildPositioninfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcGuildSkillinfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6201"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcGuildSkillinfo {
        let mut offset: usize = 0;
        let vec_type_len = SKILLINFO::base_len(packetver);
        let iter_count = (&buffer.len() - 6) / vec_type_len;
        let mut vec_field: Vec<SKILLINFO> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 6 + (vec_type_len * (i - 1));
            let end_pos = 6 + vec_type_len * i;
            vec_field.push(SKILLINFO::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcGuildSkillinfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skill_point: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skill_point_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skill_list: {
                let field = vec_field.clone();
                field
            },
            skill_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.skill_point).unwrap();
        self.skill_point_raw = wtr.try_into().unwrap();
        self.skill_list_raw = {
            self.skill_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.skill_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.skill_point_raw.to_vec());
        self.skill_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_skill_point(&mut self, value: i16) {
        self.skill_point = value;
    }
    pub fn set_skill_point_raw(&mut self, value: [u8; 2]) {
        self.skill_point_raw = value;
    }
    pub fn set_skill_list(&mut self, value: Vec<SKILLINFO>) {
        self.skill_list = value;
    }
    pub fn set_skill_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.skill_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcGuildSkillinfo {
        let packet_id = i16::from_le_bytes([0x62, 0x01]);
        let packet_id_raw = [0x62, 0x01];
        PacketZcGuildSkillinfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        skill_point: 0,
        skill_point_raw: [0; 2],
        skill_list: vec![],
        skill_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcGuildSkillinfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcGuildSkillinfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcBanList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6301"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcBanList {
        let mut offset: usize = 0;
        let vec_type_len = GuildBanInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<GuildBanInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(GuildBanInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcBanList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            ban_list: {
                let field = vec_field.clone();
                field
            },
            ban_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.ban_list_raw = {
            self.ban_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.ban_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.ban_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_ban_list(&mut self, value: Vec<GuildBanInfo>) {
        self.ban_list = value;
    }
    pub fn set_ban_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.ban_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcBanList {
        let packet_id = i16::from_le_bytes([0x63, 0x01]);
        let packet_id_raw = [0x63, 0x01];
        PacketZcBanList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        ban_list: vec![],
        ban_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcBanList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcBanList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcOtherGuildList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6401"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcOtherGuildList {
        let mut offset: usize = 0;
        let vec_type_len = OtherGuildInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<OtherGuildInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(OtherGuildInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcOtherGuildList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guild_list: {
                let field = vec_field.clone();
                field
            },
            guild_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.guild_list_raw = {
            self.guild_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.guild_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.guild_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_guild_list(&mut self, value: Vec<OtherGuildInfo>) {
        self.guild_list = value;
    }
    pub fn set_guild_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.guild_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcOtherGuildList {
        let packet_id = i16::from_le_bytes([0x64, 0x01]);
        let packet_id_raw = [0x64, 0x01];
        PacketZcOtherGuildList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        guild_list: vec![],
        guild_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcOtherGuildList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcOtherGuildList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqMakeGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6501"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqMakeGuild {
        let mut offset: usize = 0;
        PacketCzReqMakeGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gname: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            gname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.gname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.gname_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.gname_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 30;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_gname(&mut self, value: [char; 24]) {
        self.gname = value;
    }
    pub fn set_gname_raw(&mut self, value: [u8; 24]) {
        self.gname_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqMakeGuild {
        let packet_id = i16::from_le_bytes([0x65, 0x01]);
        let packet_id_raw = [0x65, 0x01];
        PacketCzReqMakeGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        gname: [0 as char; 24],
        gname_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzReqMakeGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqMakeGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPositionIdNameInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6601"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPositionIdNameInfo {
        let mut offset: usize = 0;
        let vec_type_len = MemberPositionIdNameInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<MemberPositionIdNameInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(MemberPositionIdNameInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcPositionIdNameInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            member_list: {
                let field = vec_field.clone();
                field
            },
            member_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_list_raw = {
            self.member_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.member_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.member_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_member_list(&mut self, value: Vec<MemberPositionIdNameInfo>) {
        self.member_list = value;
    }
    pub fn set_member_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.member_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPositionIdNameInfo {
        let packet_id = i16::from_le_bytes([0x66, 0x01]);
        let packet_id_raw = [0x66, 0x01];
        PacketZcPositionIdNameInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        member_list: vec![],
        member_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcPositionIdNameInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPositionIdNameInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcResultMakeGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6701"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcResultMakeGuild {
        let mut offset: usize = 0;
        PacketZcResultMakeGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcResultMakeGuild {
        let packet_id = i16::from_le_bytes([0x67, 0x01]);
        let packet_id_raw = [0x67, 0x01];
        PacketZcResultMakeGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcResultMakeGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketZcResultMakeGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqJoinGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6801"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqJoinGuild {
        let mut offset: usize = 0;
        PacketCzReqJoinGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            my_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            my_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            my_gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            my_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.my_aid).unwrap();
        self.my_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.my_gid).unwrap();
        self.my_gid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.my_aid_raw.to_vec());
        wtr.append(&mut self.my_gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_my_aid(&mut self, value: u32) {
        self.my_aid = value;
    }
    pub fn set_my_aid_raw(&mut self, value: [u8; 4]) {
        self.my_aid_raw = value;
    }
    pub fn set_my_gid(&mut self, value: u32) {
        self.my_gid = value;
    }
    pub fn set_my_gid_raw(&mut self, value: [u8; 4]) {
        self.my_gid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqJoinGuild {
        let packet_id = i16::from_le_bytes([0x68, 0x01]);
        let packet_id_raw = [0x68, 0x01];
        PacketCzReqJoinGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        my_aid: 0,
        my_aid_raw: [0; 4],
        my_gid: 0,
        my_gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqJoinGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqJoinGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckReqJoinGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6901"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckReqJoinGuild {
        let mut offset: usize = 0;
        PacketZcAckReqJoinGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            answer: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            answer_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_answer(&mut self, value: u8) {
        self.answer = value;
    }
    pub fn set_answer_raw(&mut self, value: [u8; 1]) {
        self.answer_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckReqJoinGuild {
        let packet_id = i16::from_le_bytes([0x69, 0x01]);
        let packet_id_raw = [0x69, 0x01];
        PacketZcAckReqJoinGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        answer: 0,
        answer_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckReqJoinGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckReqJoinGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcReqJoinGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6a01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcReqJoinGuild {
        let mut offset: usize = 0;
        PacketZcReqJoinGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gdid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            guild_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            guild_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.guild_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guild_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.guild_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 30;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: u32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_guild_name(&mut self, value: [char; 24]) {
        self.guild_name = value;
    }
    pub fn set_guild_name_raw(&mut self, value: [u8; 24]) {
        self.guild_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcReqJoinGuild {
        let packet_id = i16::from_le_bytes([0x6a, 0x01]);
        let packet_id_raw = [0x6a, 0x01];
        PacketZcReqJoinGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gdid: 0,
        gdid_raw: [0; 4],
        guild_name: [0 as char; 24],
        guild_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcReqJoinGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketZcReqJoinGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzJoinGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6b01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzJoinGuild {
        let mut offset: usize = 0;
        PacketCzJoinGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gdid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            answer: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            answer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: u32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_answer(&mut self, value: i32) {
        self.answer = value;
    }
    pub fn set_answer_raw(&mut self, value: [u8; 4]) {
        self.answer_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzJoinGuild {
        let packet_id = i16::from_le_bytes([0x6b, 0x01]);
        let packet_id_raw = [0x6b, 0x01];
        PacketCzJoinGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gdid: 0,
        gdid_raw: [0; 4],
        answer: 0,
        answer_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzJoinGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketCzJoinGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcUpdateGdid {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6c01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcUpdateGdid {
        let mut offset: usize = 0;
        PacketZcUpdateGdid {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gdid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            emblem_version: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            emblem_version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            right: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            right_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_master: {
                let field = buffer[offset] == 1;
                field
            },
            is_master_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            inter_sid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            inter_sid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gname: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            gname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.emblem_version).unwrap();
        self.emblem_version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.right).unwrap();
        self.right_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_master as u8).unwrap();
        self.is_master_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.inter_sid).unwrap();
        self.inter_sid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.gname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.gname_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.emblem_version_raw.to_vec());
        wtr.append(&mut self.right_raw.to_vec());
        wtr.append(&mut self.is_master_raw.to_vec());
        wtr.append(&mut self.inter_sid_raw.to_vec());
        wtr.append(&mut self.gname_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 43;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: u32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_emblem_version(&mut self, value: i32) {
        self.emblem_version = value;
    }
    pub fn set_emblem_version_raw(&mut self, value: [u8; 4]) {
        self.emblem_version_raw = value;
    }
    pub fn set_right(&mut self, value: i32) {
        self.right = value;
    }
    pub fn set_right_raw(&mut self, value: [u8; 4]) {
        self.right_raw = value;
    }
    pub fn set_is_master(&mut self, value: bool) {
        self.is_master = value;
    }
    pub fn set_is_master_raw(&mut self, value: [u8; 1]) {
        self.is_master_raw = value;
    }
    pub fn set_inter_sid(&mut self, value: i32) {
        self.inter_sid = value;
    }
    pub fn set_inter_sid_raw(&mut self, value: [u8; 4]) {
        self.inter_sid_raw = value;
    }
    pub fn set_gname(&mut self, value: [char; 24]) {
        self.gname = value;
    }
    pub fn set_gname_raw(&mut self, value: [u8; 24]) {
        self.gname_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcUpdateGdid {
        let packet_id = i16::from_le_bytes([0x6c, 0x01]);
        let packet_id_raw = [0x6c, 0x01];
        PacketZcUpdateGdid {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gdid: 0,
        gdid_raw: [0; 4],
        emblem_version: 0,
        emblem_version_raw: [0; 4],
        right: 0,
        right_raw: [0; 4],
        is_master: false,
        is_master_raw: [0; 1],
        inter_sid: 0,
        inter_sid_raw: [0; 4],
        gname: [0 as char; 24],
        gname_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcUpdateGdid {
    fn id(&self, packetver: u32) -> &str {
       PacketZcUpdateGdid::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcUpdateCharstat {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6d01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcUpdateCharstat {
        let mut offset: usize = 0;
        PacketZcUpdateCharstat {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            status: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            status_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.status).unwrap();
        self.status_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.status_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_status(&mut self, value: i32) {
        self.status = value;
    }
    pub fn set_status_raw(&mut self, value: [u8; 4]) {
        self.status_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcUpdateCharstat {
        let packet_id = i16::from_le_bytes([0x6d, 0x01]);
        let packet_id_raw = [0x6d, 0x01];
        PacketZcUpdateCharstat {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        status: 0,
        status_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcUpdateCharstat {
    fn id(&self, packetver: u32) -> &str {
       PacketZcUpdateCharstat::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzGuildNotice {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6e01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzGuildNotice {
        let mut offset: usize = 0;
        PacketCzGuildNotice {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gdid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            subject: {
                let field =  {
                let mut dst: [char; 60] = [0 as char; 60];
                for (index, byte) in buffer[offset..offset + 60].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            subject_raw: {
                let mut dst: [u8; 60] = [0u8; 60];
                dst.clone_from_slice(&buffer[offset..offset + 60]);
                offset += 60;
                dst
            },
            notice: {
                let field =  {
                let mut dst: [char; 120] = [0 as char; 120];
                for (index, byte) in buffer[offset..offset + 120].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            notice_raw: {
                let mut dst: [u8; 120] = [0u8; 120];
                dst.clone_from_slice(&buffer[offset..offset + 120]);
                offset += 120;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.subject {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.subject_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.notice {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.notice_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.subject_raw.to_vec());
        wtr.append(&mut self.notice_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 186;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: u32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_subject(&mut self, value: [char; 60]) {
        self.subject = value;
    }
    pub fn set_subject_raw(&mut self, value: [u8; 60]) {
        self.subject_raw = value;
    }
    pub fn set_notice(&mut self, value: [char; 120]) {
        self.notice = value;
    }
    pub fn set_notice_raw(&mut self, value: [u8; 120]) {
        self.notice_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzGuildNotice {
        let packet_id = i16::from_le_bytes([0x6e, 0x01]);
        let packet_id_raw = [0x6e, 0x01];
        PacketCzGuildNotice {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gdid: 0,
        gdid_raw: [0; 4],
        subject: [0 as char; 60],
        subject_raw: [0; 60],
        notice: [0 as char; 120],
        notice_raw: [0; 120],
        }
    }
}

impl Packet for PacketCzGuildNotice {
    fn id(&self, packetver: u32) -> &str {
       PacketCzGuildNotice::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcGuildNotice {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6f01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcGuildNotice {
        let mut offset: usize = 0;
        PacketZcGuildNotice {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            subject: {
                let field =  {
                let mut dst: [char; 60] = [0 as char; 60];
                for (index, byte) in buffer[offset..offset + 60].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            subject_raw: {
                let mut dst: [u8; 60] = [0u8; 60];
                dst.clone_from_slice(&buffer[offset..offset + 60]);
                offset += 60;
                dst
            },
            notice: {
                let field =  {
                let mut dst: [char; 120] = [0 as char; 120];
                for (index, byte) in buffer[offset..offset + 120].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            notice_raw: {
                let mut dst: [u8; 120] = [0u8; 120];
                dst.clone_from_slice(&buffer[offset..offset + 120]);
                offset += 120;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.subject {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.subject_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.notice {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.notice_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.subject_raw.to_vec());
        wtr.append(&mut self.notice_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 182;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_subject(&mut self, value: [char; 60]) {
        self.subject = value;
    }
    pub fn set_subject_raw(&mut self, value: [u8; 60]) {
        self.subject_raw = value;
    }
    pub fn set_notice(&mut self, value: [char; 120]) {
        self.notice = value;
    }
    pub fn set_notice_raw(&mut self, value: [u8; 120]) {
        self.notice_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcGuildNotice {
        let packet_id = i16::from_le_bytes([0x6f, 0x01]);
        let packet_id_raw = [0x6f, 0x01];
        PacketZcGuildNotice {
        raw: vec![],
        packet_id,
        packet_id_raw,
        subject: [0 as char; 60],
        subject_raw: [0; 60],
        notice: [0 as char; 120],
        notice_raw: [0; 120],
        }
    }
}

impl Packet for PacketZcGuildNotice {
    fn id(&self, packetver: u32) -> &str {
       PacketZcGuildNotice::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqAllyGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7001"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqAllyGuild {
        let mut offset: usize = 0;
        PacketCzReqAllyGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            my_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            my_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            my_gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            my_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.my_aid).unwrap();
        self.my_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.my_gid).unwrap();
        self.my_gid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.my_aid_raw.to_vec());
        wtr.append(&mut self.my_gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_my_aid(&mut self, value: u32) {
        self.my_aid = value;
    }
    pub fn set_my_aid_raw(&mut self, value: [u8; 4]) {
        self.my_aid_raw = value;
    }
    pub fn set_my_gid(&mut self, value: u32) {
        self.my_gid = value;
    }
    pub fn set_my_gid_raw(&mut self, value: [u8; 4]) {
        self.my_gid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqAllyGuild {
        let packet_id = i16::from_le_bytes([0x70, 0x01]);
        let packet_id_raw = [0x70, 0x01];
        PacketCzReqAllyGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        my_aid: 0,
        my_aid_raw: [0; 4],
        my_gid: 0,
        my_gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqAllyGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqAllyGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcReqAllyGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7101"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcReqAllyGuild {
        let mut offset: usize = 0;
        PacketZcReqAllyGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            other_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            other_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            guild_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            guild_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.other_aid).unwrap();
        self.other_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.guild_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guild_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.other_aid_raw.to_vec());
        wtr.append(&mut self.guild_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 30;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_other_aid(&mut self, value: u32) {
        self.other_aid = value;
    }
    pub fn set_other_aid_raw(&mut self, value: [u8; 4]) {
        self.other_aid_raw = value;
    }
    pub fn set_guild_name(&mut self, value: [char; 24]) {
        self.guild_name = value;
    }
    pub fn set_guild_name_raw(&mut self, value: [u8; 24]) {
        self.guild_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcReqAllyGuild {
        let packet_id = i16::from_le_bytes([0x71, 0x01]);
        let packet_id_raw = [0x71, 0x01];
        PacketZcReqAllyGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        other_aid: 0,
        other_aid_raw: [0; 4],
        guild_name: [0 as char; 24],
        guild_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcReqAllyGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketZcReqAllyGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzAllyGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7201"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzAllyGuild {
        let mut offset: usize = 0;
        PacketCzAllyGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            other_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            other_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            answer: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            answer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.other_aid).unwrap();
        self.other_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.other_aid_raw.to_vec());
        wtr.append(&mut self.answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_other_aid(&mut self, value: u32) {
        self.other_aid = value;
    }
    pub fn set_other_aid_raw(&mut self, value: [u8; 4]) {
        self.other_aid_raw = value;
    }
    pub fn set_answer(&mut self, value: i32) {
        self.answer = value;
    }
    pub fn set_answer_raw(&mut self, value: [u8; 4]) {
        self.answer_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzAllyGuild {
        let packet_id = i16::from_le_bytes([0x72, 0x01]);
        let packet_id_raw = [0x72, 0x01];
        PacketCzAllyGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        other_aid: 0,
        other_aid_raw: [0; 4],
        answer: 0,
        answer_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzAllyGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketCzAllyGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckReqAllyGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7301"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckReqAllyGuild {
        let mut offset: usize = 0;
        PacketZcAckReqAllyGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            answer: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            answer_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_answer(&mut self, value: u8) {
        self.answer = value;
    }
    pub fn set_answer_raw(&mut self, value: [u8; 1]) {
        self.answer_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckReqAllyGuild {
        let packet_id = i16::from_le_bytes([0x73, 0x01]);
        let packet_id_raw = [0x73, 0x01];
        PacketZcAckReqAllyGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        answer: 0,
        answer_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckReqAllyGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckReqAllyGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckChangeGuildPositioninfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7401"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckChangeGuildPositioninfo {
        let mut offset: usize = 0;
        let vec_type_len = GuildRegPositionInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<GuildRegPositionInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(GuildRegPositionInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcAckChangeGuildPositioninfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            member_list: {
                let field = vec_field.clone();
                field
            },
            member_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.member_list_raw = {
            self.member_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.member_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.member_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_member_list(&mut self, value: Vec<GuildRegPositionInfo>) {
        self.member_list = value;
    }
    pub fn set_member_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.member_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckChangeGuildPositioninfo {
        let packet_id = i16::from_le_bytes([0x74, 0x01]);
        let packet_id_raw = [0x74, 0x01];
        PacketZcAckChangeGuildPositioninfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        member_list: vec![],
        member_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcAckChangeGuildPositioninfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckChangeGuildPositioninfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqGuildMemberInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7501"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqGuildMemberInfo {
        let mut offset: usize = 0;
        PacketCzReqGuildMemberInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: i32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqGuildMemberInfo {
        let packet_id = i16::from_le_bytes([0x75, 0x01]);
        let packet_id_raw = [0x75, 0x01];
        PacketCzReqGuildMemberInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqGuildMemberInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqGuildMemberInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckGuildMemberInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7601"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckGuildMemberInfo {
        let mut offset: usize = 0;
        PacketZcAckGuildMemberInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            info: {
                let field = GuildMemberInfo::from(&buffer[offset..offset + GuildMemberInfo::base_len(packetver)], packetver);
                field
            },
            info_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.info.fill_raw_with_packetver(packetver);
        self.info_raw = self.info.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 1;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_info(&mut self, value: GuildMemberInfo) {
        self.info = value;
    }
    pub fn set_info_raw(&mut self, value: Vec<u8>) {
        self.info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckGuildMemberInfo {
        let packet_id = i16::from_le_bytes([0x76, 0x01]);
        let packet_id_raw = [0x76, 0x01];
        PacketZcAckGuildMemberInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        info: GuildMemberInfo::new(packetver),
        info_raw: vec![],
        }
    }
}

impl Packet for PacketZcAckGuildMemberInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckGuildMemberInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcItemidentifyList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7701"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcItemidentifyList {
        let mut offset: usize = 0;
        PacketZcItemidentifyList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itidlist: {
                let field =  {
                let dst: Vec<u8> = buffer[offset..buffer.len()].to_vec();
                dst
            };
                field
            },
            itidlist_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.itidlist_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_itidlist(&mut self, value: Vec<u8>) {
        self.itidlist = value;
    }
    pub fn set_itidlist_raw(&mut self, value: Vec<u8>) {
        self.itidlist_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcItemidentifyList {
        let packet_id = i16::from_le_bytes([0x77, 0x01]);
        let packet_id_raw = [0x77, 0x01];
        PacketZcItemidentifyList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        itidlist: vec![],
        itidlist_raw: vec![],
        }
    }
}

impl Packet for PacketZcItemidentifyList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcItemidentifyList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqItemidentify {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7801"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqItemidentify {
        let mut offset: usize = 0;
        PacketCzReqItemidentify {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqItemidentify {
        let packet_id = i16::from_le_bytes([0x78, 0x01]);
        let packet_id_raw = [0x78, 0x01];
        PacketCzReqItemidentify {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqItemidentify {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqItemidentify::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckItemidentify {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7901"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckItemidentify {
        let mut offset: usize = 0;
        PacketZcAckItemidentify {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckItemidentify {
        let packet_id = i16::from_le_bytes([0x79, 0x01]);
        let packet_id_raw = [0x79, 0x01];
        PacketZcAckItemidentify {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckItemidentify {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckItemidentify::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqItemcompositionList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7a01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqItemcompositionList {
        let mut offset: usize = 0;
        PacketCzReqItemcompositionList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            card_index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            card_index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.card_index).unwrap();
        self.card_index_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.card_index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_card_index(&mut self, value: i16) {
        self.card_index = value;
    }
    pub fn set_card_index_raw(&mut self, value: [u8; 2]) {
        self.card_index_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqItemcompositionList {
        let packet_id = i16::from_le_bytes([0x7a, 0x01]);
        let packet_id_raw = [0x7a, 0x01];
        PacketCzReqItemcompositionList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        card_index: 0,
        card_index_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqItemcompositionList {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqItemcompositionList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcItemcompositionList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7b01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcItemcompositionList {
        let mut offset: usize = 0;
        PacketZcItemcompositionList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itidlist: {
                let field =  {
                let dst: Vec<u8> = buffer[offset..buffer.len()].to_vec();
                dst
            };
                field
            },
            itidlist_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.itidlist_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_itidlist(&mut self, value: Vec<u8>) {
        self.itidlist = value;
    }
    pub fn set_itidlist_raw(&mut self, value: Vec<u8>) {
        self.itidlist_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcItemcompositionList {
        let packet_id = i16::from_le_bytes([0x7b, 0x01]);
        let packet_id_raw = [0x7b, 0x01];
        PacketZcItemcompositionList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        itidlist: vec![],
        itidlist_raw: vec![],
        }
    }
}

impl Packet for PacketZcItemcompositionList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcItemcompositionList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqItemcomposition {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7c01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqItemcomposition {
        let mut offset: usize = 0;
        PacketCzReqItemcomposition {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            card_index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            card_index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            equip_index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            equip_index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.card_index).unwrap();
        self.card_index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.equip_index).unwrap();
        self.equip_index_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.card_index_raw.to_vec());
        wtr.append(&mut self.equip_index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_card_index(&mut self, value: i16) {
        self.card_index = value;
    }
    pub fn set_card_index_raw(&mut self, value: [u8; 2]) {
        self.card_index_raw = value;
    }
    pub fn set_equip_index(&mut self, value: i16) {
        self.equip_index = value;
    }
    pub fn set_equip_index_raw(&mut self, value: [u8; 2]) {
        self.equip_index_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqItemcomposition {
        let packet_id = i16::from_le_bytes([0x7c, 0x01]);
        let packet_id_raw = [0x7c, 0x01];
        PacketCzReqItemcomposition {
        raw: vec![],
        packet_id,
        packet_id_raw,
        card_index: 0,
        card_index_raw: [0; 2],
        equip_index: 0,
        equip_index_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqItemcomposition {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqItemcomposition::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckItemcomposition {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7d01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckItemcomposition {
        let mut offset: usize = 0;
        PacketZcAckItemcomposition {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            equip_index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            equip_index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            card_index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            card_index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.equip_index).unwrap();
        self.equip_index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.card_index).unwrap();
        self.card_index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.equip_index_raw.to_vec());
        wtr.append(&mut self.card_index_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_equip_index(&mut self, value: i16) {
        self.equip_index = value;
    }
    pub fn set_equip_index_raw(&mut self, value: [u8; 2]) {
        self.equip_index_raw = value;
    }
    pub fn set_card_index(&mut self, value: i16) {
        self.card_index = value;
    }
    pub fn set_card_index_raw(&mut self, value: [u8; 2]) {
        self.card_index_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckItemcomposition {
        let packet_id = i16::from_le_bytes([0x7d, 0x01]);
        let packet_id_raw = [0x7d, 0x01];
        PacketZcAckItemcomposition {
        raw: vec![],
        packet_id,
        packet_id_raw,
        equip_index: 0,
        equip_index_raw: [0; 2],
        card_index: 0,
        card_index_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckItemcomposition {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckItemcomposition::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzGuildChat {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7e01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzGuildChat {
        let mut offset: usize = 0;
        PacketCzGuildChat {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzGuildChat {
        let packet_id = i16::from_le_bytes([0x7e, 0x01]);
        let packet_id_raw = [0x7e, 0x01];
        PacketCzGuildChat {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketCzGuildChat {
    fn id(&self, packetver: u32) -> &str {
       PacketCzGuildChat::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcGuildChat {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7f01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcGuildChat {
        let mut offset: usize = 0;
        PacketZcGuildChat {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcGuildChat {
        let packet_id = i16::from_le_bytes([0x7f, 0x01]);
        let packet_id_raw = [0x7f, 0x01];
        PacketZcGuildChat {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcGuildChat {
    fn id(&self, packetver: u32) -> &str {
       PacketZcGuildChat::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqHostileGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8001"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqHostileGuild {
        let mut offset: usize = 0;
        PacketCzReqHostileGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqHostileGuild {
        let packet_id = i16::from_le_bytes([0x80, 0x01]);
        let packet_id_raw = [0x80, 0x01];
        PacketCzReqHostileGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqHostileGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqHostileGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckReqHostileGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8101"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckReqHostileGuild {
        let mut offset: usize = 0;
        PacketZcAckReqHostileGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckReqHostileGuild {
        let packet_id = i16::from_le_bytes([0x81, 0x01]);
        let packet_id_raw = [0x81, 0x01];
        PacketZcAckReqHostileGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckReqHostileGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckReqHostileGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMemberAdd {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8201"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMemberAdd {
        let mut offset: usize = 0;
        PacketZcMemberAdd {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            info: {
                let field = GuildMemberInfo::from(&buffer[offset..offset + GuildMemberInfo::base_len(packetver)], packetver);
                field
            },
            info_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.info.fill_raw_with_packetver(packetver);
        self.info_raw = self.info.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 1;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_info(&mut self, value: GuildMemberInfo) {
        self.info = value;
    }
    pub fn set_info_raw(&mut self, value: Vec<u8>) {
        self.info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMemberAdd {
        let packet_id = i16::from_le_bytes([0x82, 0x01]);
        let packet_id_raw = [0x82, 0x01];
        PacketZcMemberAdd {
        raw: vec![],
        packet_id,
        packet_id_raw,
        info: GuildMemberInfo::new(packetver),
        info_raw: vec![],
        }
    }
}

impl Packet for PacketZcMemberAdd {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMemberAdd::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqDeleteRelatedGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8301"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqDeleteRelatedGuild {
        let mut offset: usize = 0;
        PacketCzReqDeleteRelatedGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            opponent_gdid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            opponent_gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            relation: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            relation_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.opponent_gdid).unwrap();
        self.opponent_gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.relation).unwrap();
        self.relation_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.opponent_gdid_raw.to_vec());
        wtr.append(&mut self.relation_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_opponent_gdid(&mut self, value: u32) {
        self.opponent_gdid = value;
    }
    pub fn set_opponent_gdid_raw(&mut self, value: [u8; 4]) {
        self.opponent_gdid_raw = value;
    }
    pub fn set_relation(&mut self, value: i32) {
        self.relation = value;
    }
    pub fn set_relation_raw(&mut self, value: [u8; 4]) {
        self.relation_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqDeleteRelatedGuild {
        let packet_id = i16::from_le_bytes([0x83, 0x01]);
        let packet_id_raw = [0x83, 0x01];
        PacketCzReqDeleteRelatedGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        opponent_gdid: 0,
        opponent_gdid_raw: [0; 4],
        relation: 0,
        relation_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqDeleteRelatedGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqDeleteRelatedGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcDeleteRelatedGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8401"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcDeleteRelatedGuild {
        let mut offset: usize = 0;
        PacketZcDeleteRelatedGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            opponent_gdid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            opponent_gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            relation: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            relation_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.opponent_gdid).unwrap();
        self.opponent_gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.relation).unwrap();
        self.relation_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.opponent_gdid_raw.to_vec());
        wtr.append(&mut self.relation_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_opponent_gdid(&mut self, value: u32) {
        self.opponent_gdid = value;
    }
    pub fn set_opponent_gdid_raw(&mut self, value: [u8; 4]) {
        self.opponent_gdid_raw = value;
    }
    pub fn set_relation(&mut self, value: i32) {
        self.relation = value;
    }
    pub fn set_relation_raw(&mut self, value: [u8; 4]) {
        self.relation_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcDeleteRelatedGuild {
        let packet_id = i16::from_le_bytes([0x84, 0x01]);
        let packet_id_raw = [0x84, 0x01];
        PacketZcDeleteRelatedGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        opponent_gdid: 0,
        opponent_gdid_raw: [0; 4],
        relation: 0,
        relation_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDeleteRelatedGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketZcDeleteRelatedGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAddRelatedGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8501"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAddRelatedGuild {
        let mut offset: usize = 0;
        PacketZcAddRelatedGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            info: {
                let field = RelatedGuildInfo::from(&buffer[offset..offset + RelatedGuildInfo::base_len(packetver)], packetver);
                field
            },
            info_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.info.fill_raw_with_packetver(packetver);
        self.info_raw = self.info.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 1;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_info(&mut self, value: RelatedGuildInfo) {
        self.info = value;
    }
    pub fn set_info_raw(&mut self, value: Vec<u8>) {
        self.info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAddRelatedGuild {
        let packet_id = i16::from_le_bytes([0x85, 0x01]);
        let packet_id_raw = [0x85, 0x01];
        PacketZcAddRelatedGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        info: RelatedGuildInfo::new(packetver),
        info_raw: vec![],
        }
    }
}

impl Packet for PacketZcAddRelatedGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAddRelatedGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCollectordead {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8601"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCollectordead {
        let mut offset: usize = 0;
        PacketCollectordead {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            server_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            server_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.server_id).unwrap();
        self.server_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.server_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_server_id(&mut self, value: u32) {
        self.server_id = value;
    }
    pub fn set_server_id_raw(&mut self, value: [u8; 4]) {
        self.server_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCollectordead {
        let packet_id = i16::from_le_bytes([0x86, 0x01]);
        let packet_id_raw = [0x86, 0x01];
        PacketCollectordead {
        raw: vec![],
        packet_id,
        packet_id_raw,
        server_id: 0,
        server_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketCollectordead {
    fn id(&self, packetver: u32) -> &str {
       PacketCollectordead::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketPing {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8701"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketPing {
        let mut offset: usize = 0;
        PacketPing {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketPing {
        let packet_id = i16::from_le_bytes([0x87, 0x01]);
        let packet_id_raw = [0x87, 0x01];
        PacketPing {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketPing {
    fn id(&self, packetver: u32) -> &str {
       PacketPing::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckItemrefining {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8801"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckItemrefining {
        let mut offset: usize = 0;
        PacketZcAckItemrefining {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            item_index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            refining_level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.item_index).unwrap();
        self.item_index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.item_index_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn set_item_index(&mut self, value: i16) {
        self.item_index = value;
    }
    pub fn set_item_index_raw(&mut self, value: [u8; 2]) {
        self.item_index_raw = value;
    }
    pub fn set_refining_level(&mut self, value: i16) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 2]) {
        self.refining_level_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckItemrefining {
        let packet_id = i16::from_le_bytes([0x88, 0x01]);
        let packet_id_raw = [0x88, 0x01];
        PacketZcAckItemrefining {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 2],
        item_index: 0,
        item_index_raw: [0; 2],
        refining_level: 0,
        refining_level_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAckItemrefining {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckItemrefining::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyMapinfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8901"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyMapinfo {
        let mut offset: usize = 0;
        PacketZcNotifyMapinfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyMapinfo {
        let packet_id = i16::from_le_bytes([0x89, 0x01]);
        let packet_id_raw = [0x89, 0x01];
        PacketZcNotifyMapinfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyMapinfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyMapinfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqDisconnect {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8a01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqDisconnect {
        let mut offset: usize = 0;
        PacketCzReqDisconnect {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqDisconnect {
        let packet_id = i16::from_le_bytes([0x8a, 0x01]);
        let packet_id_raw = [0x8a, 0x01];
        PacketCzReqDisconnect {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqDisconnect {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqDisconnect::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckReqDisconnect {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8b01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckReqDisconnect {
        let mut offset: usize = 0;
        PacketZcAckReqDisconnect {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckReqDisconnect {
        let packet_id = i16::from_le_bytes([0x8b, 0x01]);
        let packet_id_raw = [0x8b, 0x01];
        PacketZcAckReqDisconnect {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAckReqDisconnect {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckReqDisconnect::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMonsterInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8c01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMonsterInfo {
        let mut offset: usize = 0;
        PacketZcMonsterInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            size: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            size_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            hp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            def: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            def_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            race_type: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            race_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mdef_power: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            mdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            property: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            property_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            property_table: {
                let field = MonsterInfoElement::from(&buffer[offset..offset + MonsterInfoElement::base_len(packetver)], packetver);
                field
            },
            property_table_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.size).unwrap();
        self.size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.def).unwrap();
        self.def_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.race_type).unwrap();
        self.race_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef_power).unwrap();
        self.mdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.property).unwrap();
        self.property_raw = wtr.try_into().unwrap();
        self.property_table.fill_raw_with_packetver(packetver);
        self.property_table_raw = self.property_table.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.size_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.def_raw.to_vec());
        wtr.append(&mut self.race_type_raw.to_vec());
        wtr.append(&mut self.mdef_power_raw.to_vec());
        wtr.append(&mut self.property_raw.to_vec());
        wtr.append(&mut self.property_table_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 19;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_size(&mut self, value: i16) {
        self.size = value;
    }
    pub fn set_size_raw(&mut self, value: [u8; 2]) {
        self.size_raw = value;
    }
    pub fn set_hp(&mut self, value: i32) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 4]) {
        self.hp_raw = value;
    }
    pub fn set_def(&mut self, value: i16) {
        self.def = value;
    }
    pub fn set_def_raw(&mut self, value: [u8; 2]) {
        self.def_raw = value;
    }
    pub fn set_race_type(&mut self, value: i16) {
        self.race_type = value;
    }
    pub fn set_race_type_raw(&mut self, value: [u8; 2]) {
        self.race_type_raw = value;
    }
    pub fn set_mdef_power(&mut self, value: i16) {
        self.mdef_power = value;
    }
    pub fn set_mdef_power_raw(&mut self, value: [u8; 2]) {
        self.mdef_power_raw = value;
    }
    pub fn set_property(&mut self, value: i16) {
        self.property = value;
    }
    pub fn set_property_raw(&mut self, value: [u8; 2]) {
        self.property_raw = value;
    }
    pub fn set_property_table(&mut self, value: MonsterInfoElement) {
        self.property_table = value;
    }
    pub fn set_property_table_raw(&mut self, value: Vec<u8>) {
        self.property_table_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMonsterInfo {
        let packet_id = i16::from_le_bytes([0x8c, 0x01]);
        let packet_id_raw = [0x8c, 0x01];
        PacketZcMonsterInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        job: 0,
        job_raw: [0; 2],
        level: 0,
        level_raw: [0; 2],
        size: 0,
        size_raw: [0; 2],
        hp: 0,
        hp_raw: [0; 4],
        def: 0,
        def_raw: [0; 2],
        race_type: 0,
        race_type_raw: [0; 2],
        mdef_power: 0,
        mdef_power_raw: [0; 2],
        property: 0,
        property_raw: [0; 2],
        property_table: MonsterInfoElement::new(packetver),
        property_table_raw: vec![],
        }
    }
}

impl Packet for PacketZcMonsterInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMonsterInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMakableitemlist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8d01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMakableitemlist {
        let mut offset: usize = 0;
        PacketZcMakableitemlist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            info: {
                let field = MakableitemInfo::from(&buffer[offset..offset + MakableitemInfo::base_len(packetver)], packetver);
                field
            },
            info_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.info.fill_raw_with_packetver(packetver);
        self.info_raw = self.info.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_info(&mut self, value: MakableitemInfo) {
        self.info = value;
    }
    pub fn set_info_raw(&mut self, value: Vec<u8>) {
        self.info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMakableitemlist {
        let packet_id = i16::from_le_bytes([0x8d, 0x01]);
        let packet_id_raw = [0x8d, 0x01];
        PacketZcMakableitemlist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        info: MakableitemInfo::new(packetver),
        info_raw: vec![],
        }
    }
}

impl Packet for PacketZcMakableitemlist {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMakableitemlist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqmakingitem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8e01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqmakingitem {
        let mut offset: usize = 0;
        PacketCzReqmakingitem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            info: {
                let field = MakableitemInfo::from(&buffer[offset..offset + MakableitemInfo::base_len(packetver)], packetver);
                field
            },
            info_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.info.fill_raw_with_packetver(packetver);
        self.info_raw = self.info.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 1;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_info(&mut self, value: MakableitemInfo) {
        self.info = value;
    }
    pub fn set_info_raw(&mut self, value: Vec<u8>) {
        self.info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqmakingitem {
        let packet_id = i16::from_le_bytes([0x8e, 0x01]);
        let packet_id_raw = [0x8e, 0x01];
        PacketCzReqmakingitem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        info: MakableitemInfo::new(packetver),
        info_raw: vec![],
        }
    }
}

impl Packet for PacketCzReqmakingitem {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqmakingitem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckReqmakingitem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8f01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckReqmakingitem {
        let mut offset: usize = 0;
        PacketZcAckReqmakingitem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckReqmakingitem {
        let packet_id = i16::from_le_bytes([0x8f, 0x01]);
        let packet_id_raw = [0x8f, 0x01];
        PacketZcAckReqmakingitem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAckReqmakingitem {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckReqmakingitem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzUseSkillTogroundWithtalkbox {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9001"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzUseSkillTogroundWithtalkbox {
        let mut offset: usize = 0;
        PacketCzUseSkillTogroundWithtalkbox {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            selected_level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            selected_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            contents: {
                let field =  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[offset..offset + 80].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            contents_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[offset..offset + 80]);
                offset += 80;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.selected_level).unwrap();
        self.selected_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.contents {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.contents_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.selected_level_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.contents_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 90;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_selected_level(&mut self, value: i16) {
        self.selected_level = value;
    }
    pub fn set_selected_level_raw(&mut self, value: [u8; 2]) {
        self.selected_level_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_contents(&mut self, value: [char; 80]) {
        self.contents = value;
    }
    pub fn set_contents_raw(&mut self, value: [u8; 80]) {
        self.contents_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzUseSkillTogroundWithtalkbox {
        let packet_id = i16::from_le_bytes([0x90, 0x01]);
        let packet_id_raw = [0x90, 0x01];
        PacketCzUseSkillTogroundWithtalkbox {
        raw: vec![],
        packet_id,
        packet_id_raw,
        selected_level: 0,
        selected_level_raw: [0; 2],
        skid: 0,
        skid_raw: [0; 2],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        contents: [0 as char; 80],
        contents_raw: [0; 80],
        }
    }
}

impl Packet for PacketCzUseSkillTogroundWithtalkbox {
    fn id(&self, packetver: u32) -> &str {
       PacketCzUseSkillTogroundWithtalkbox::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcTalkboxChatcontents {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9101"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcTalkboxChatcontents {
        let mut offset: usize = 0;
        PacketZcTalkboxChatcontents {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            contents: {
                let field =  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[offset..offset + 80].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            contents_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[offset..offset + 80]);
                offset += 80;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.contents {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.contents_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.contents_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 86;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_contents(&mut self, value: [char; 80]) {
        self.contents = value;
    }
    pub fn set_contents_raw(&mut self, value: [u8; 80]) {
        self.contents_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcTalkboxChatcontents {
        let packet_id = i16::from_le_bytes([0x91, 0x01]);
        let packet_id_raw = [0x91, 0x01];
        PacketZcTalkboxChatcontents {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        contents: [0 as char; 80],
        contents_raw: [0; 80],
        }
    }
}

impl Packet for PacketZcTalkboxChatcontents {
    fn id(&self, packetver: u32) -> &str {
       PacketZcTalkboxChatcontents::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcUpdateMapinfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9201"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcUpdateMapinfo {
        let mut offset: usize = 0;
        PacketZcUpdateMapinfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            map_name: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 24;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcUpdateMapinfo {
        let packet_id = i16::from_le_bytes([0x92, 0x01]);
        let packet_id_raw = [0x92, 0x01];
        PacketZcUpdateMapinfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 2],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        }
    }
}

impl Packet for PacketZcUpdateMapinfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcUpdateMapinfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqnameBygid {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9301"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqnameBygid {
        let mut offset: usize = 0;
        PacketCzReqnameBygid {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqnameBygid {
        let packet_id = i16::from_le_bytes([0x93, 0x01]);
        let packet_id_raw = [0x93, 0x01];
        PacketCzReqnameBygid {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqnameBygid {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqnameBygid::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckReqnameBygid {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9401"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckReqnameBygid {
        let mut offset: usize = 0;
        PacketZcAckReqnameBygid {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            cname: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            cname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.cname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.cname_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.cname_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 30;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_cname(&mut self, value: [char; 24]) {
        self.cname = value;
    }
    pub fn set_cname_raw(&mut self, value: [u8; 24]) {
        self.cname_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckReqnameBygid {
        let packet_id = i16::from_le_bytes([0x94, 0x01]);
        let packet_id_raw = [0x94, 0x01];
        PacketZcAckReqnameBygid {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        cname: [0 as char; 24],
        cname_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcAckReqnameBygid {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckReqnameBygid::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckReqnameall {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9501"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckReqnameall {
        let mut offset: usize = 0;
        PacketZcAckReqnameall {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            cname: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            cname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            pname: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            pname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            gname: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            gname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            rname: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            rname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.cname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.cname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.gname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.gname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.rname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.rname_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.cname_raw.to_vec());
        wtr.append(&mut self.pname_raw.to_vec());
        wtr.append(&mut self.gname_raw.to_vec());
        wtr.append(&mut self.rname_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 102;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_cname(&mut self, value: [char; 24]) {
        self.cname = value;
    }
    pub fn set_cname_raw(&mut self, value: [u8; 24]) {
        self.cname_raw = value;
    }
    pub fn set_pname(&mut self, value: [char; 24]) {
        self.pname = value;
    }
    pub fn set_pname_raw(&mut self, value: [u8; 24]) {
        self.pname_raw = value;
    }
    pub fn set_gname(&mut self, value: [char; 24]) {
        self.gname = value;
    }
    pub fn set_gname_raw(&mut self, value: [u8; 24]) {
        self.gname_raw = value;
    }
    pub fn set_rname(&mut self, value: [char; 24]) {
        self.rname = value;
    }
    pub fn set_rname_raw(&mut self, value: [u8; 24]) {
        self.rname_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckReqnameall {
        let packet_id = i16::from_le_bytes([0x95, 0x01]);
        let packet_id_raw = [0x95, 0x01];
        PacketZcAckReqnameall {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        cname: [0 as char; 24],
        cname_raw: [0; 24],
        pname: [0 as char; 24],
        pname_raw: [0; 24],
        gname: [0 as char; 24],
        gname_raw: [0; 24],
        rname: [0 as char; 24],
        rname_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcAckReqnameall {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckReqnameall::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMsgStateChange {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9601"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMsgStateChange {
        let mut offset: usize = 0;
        PacketZcMsgStateChange {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            state: {
                let field = buffer[offset] == 1;
                field
            },
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state as u8).unwrap();
        self.state_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 9;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_state(&mut self, value: bool) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMsgStateChange {
        let packet_id = i16::from_le_bytes([0x96, 0x01]);
        let packet_id_raw = [0x96, 0x01];
        PacketZcMsgStateChange {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        state: false,
        state_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcMsgStateChange {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMsgStateChange::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReset {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9701"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReset {
        let mut offset: usize = 0;
        PacketCzReset {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReset {
        let packet_id = i16::from_le_bytes([0x97, 0x01]);
        let packet_id_raw = [0x97, 0x01];
        PacketCzReset {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReset {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReset::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzChangeMaptype {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9801"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzChangeMaptype {
        let mut offset: usize = 0;
        PacketCzChangeMaptype {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzChangeMaptype {
        let packet_id = i16::from_le_bytes([0x98, 0x01]);
        let packet_id_raw = [0x98, 0x01];
        PacketCzChangeMaptype {
        raw: vec![],
        packet_id,
        packet_id_raw,
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzChangeMaptype {
    fn id(&self, packetver: u32) -> &str {
       PacketCzChangeMaptype::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyMapproperty {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9901"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyMapproperty {
        let mut offset: usize = 0;
        PacketZcNotifyMapproperty {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyMapproperty {
        let packet_id = i16::from_le_bytes([0x99, 0x01]);
        let packet_id_raw = [0x99, 0x01];
        PacketZcNotifyMapproperty {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyMapproperty {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyMapproperty::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyRanking {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9a01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyRanking {
        let mut offset: usize = 0;
        PacketZcNotifyRanking {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            ranking: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            ranking_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            total: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            total_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.ranking).unwrap();
        self.ranking_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.total).unwrap();
        self.total_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.ranking_raw.to_vec());
        wtr.append(&mut self.total_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_ranking(&mut self, value: i32) {
        self.ranking = value;
    }
    pub fn set_ranking_raw(&mut self, value: [u8; 4]) {
        self.ranking_raw = value;
    }
    pub fn set_total(&mut self, value: i32) {
        self.total = value;
    }
    pub fn set_total_raw(&mut self, value: [u8; 4]) {
        self.total_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyRanking {
        let packet_id = i16::from_le_bytes([0x9a, 0x01]);
        let packet_id_raw = [0x9a, 0x01];
        PacketZcNotifyRanking {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        ranking: 0,
        ranking_raw: [0; 4],
        total: 0,
        total_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyRanking {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyRanking::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyEffect {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9b01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyEffect {
        let mut offset: usize = 0;
        PacketZcNotifyEffect {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            effect_id: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            effect_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_id).unwrap();
        self.effect_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.effect_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_effect_id(&mut self, value: i32) {
        self.effect_id = value;
    }
    pub fn set_effect_id_raw(&mut self, value: [u8; 4]) {
        self.effect_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyEffect {
        let packet_id = i16::from_le_bytes([0x9b, 0x01]);
        let packet_id_raw = [0x9b, 0x01];
        PacketZcNotifyEffect {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        effect_id: 0,
        effect_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyEffect {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyEffect::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzChangeEffectstate {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9d01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzChangeEffectstate {
        let mut offset: usize = 0;
        PacketCzChangeEffectstate {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzChangeEffectstate {
        let packet_id = i16::from_le_bytes([0x9d, 0x01]);
        let packet_id_raw = [0x9d, 0x01];
        PacketCzChangeEffectstate {
        raw: vec![],
        packet_id,
        packet_id_raw,
        effect_state: 0,
        effect_state_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzChangeEffectstate {
    fn id(&self, packetver: u32) -> &str {
       PacketCzChangeEffectstate::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcStartCapture {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9e01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcStartCapture {
        let mut offset: usize = 0;
        PacketZcStartCapture {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcStartCapture {
        let packet_id = i16::from_le_bytes([0x9e, 0x01]);
        let packet_id_raw = [0x9e, 0x01];
        PacketZcStartCapture {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketZcStartCapture {
    fn id(&self, packetver: u32) -> &str {
       PacketZcStartCapture::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzTrycaptureMonster {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9f01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzTrycaptureMonster {
        let mut offset: usize = 0;
        PacketCzTrycaptureMonster {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            target_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            target_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_aid).unwrap();
        self.target_aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.target_aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_target_aid(&mut self, value: u32) {
        self.target_aid = value;
    }
    pub fn set_target_aid_raw(&mut self, value: [u8; 4]) {
        self.target_aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzTrycaptureMonster {
        let packet_id = i16::from_le_bytes([0x9f, 0x01]);
        let packet_id_raw = [0x9f, 0x01];
        PacketCzTrycaptureMonster {
        raw: vec![],
        packet_id,
        packet_id_raw,
        target_aid: 0,
        target_aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzTrycaptureMonster {
    fn id(&self, packetver: u32) -> &str {
       PacketCzTrycaptureMonster::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcTrycaptureMonster {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa001"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcTrycaptureMonster {
        let mut offset: usize = 0;
        PacketZcTrycaptureMonster {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcTrycaptureMonster {
        let packet_id = i16::from_le_bytes([0xa0, 0x01]);
        let packet_id_raw = [0xa0, 0x01];
        PacketZcTrycaptureMonster {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcTrycaptureMonster {
    fn id(&self, packetver: u32) -> &str {
       PacketZcTrycaptureMonster::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzCommandPet {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa101"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzCommandPet {
        let mut offset: usize = 0;
        PacketCzCommandPet {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            c_sub: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            c_sub_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.c_sub).unwrap();
        self.c_sub_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.c_sub_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_c_sub(&mut self, value: i8) {
        self.c_sub = value;
    }
    pub fn set_c_sub_raw(&mut self, value: [u8; 1]) {
        self.c_sub_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzCommandPet {
        let packet_id = i16::from_le_bytes([0xa1, 0x01]);
        let packet_id_raw = [0xa1, 0x01];
        PacketCzCommandPet {
        raw: vec![],
        packet_id,
        packet_id_raw,
        c_sub: 0,
        c_sub_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzCommandPet {
    fn id(&self, packetver: u32) -> &str {
       PacketCzCommandPet::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPropertyPet {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa201"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPropertyPet {
        let mut offset: usize = 0;
        PacketZcPropertyPet {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            sz_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            sz_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            b_modified: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            b_modified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            n_level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            n_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            n_fullness: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            n_fullness_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            n_relationship: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            n_relationship_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.b_modified).unwrap();
        self.b_modified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.n_level).unwrap();
        self.n_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.n_fullness).unwrap();
        self.n_fullness_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.n_relationship).unwrap();
        self.n_relationship_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.sz_name_raw.to_vec());
        wtr.append(&mut self.b_modified_raw.to_vec());
        wtr.append(&mut self.n_level_raw.to_vec());
        wtr.append(&mut self.n_fullness_raw.to_vec());
        wtr.append(&mut self.n_relationship_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 37;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_sz_name(&mut self, value: [char; 24]) {
        self.sz_name = value;
    }
    pub fn set_sz_name_raw(&mut self, value: [u8; 24]) {
        self.sz_name_raw = value;
    }
    pub fn set_b_modified(&mut self, value: u8) {
        self.b_modified = value;
    }
    pub fn set_b_modified_raw(&mut self, value: [u8; 1]) {
        self.b_modified_raw = value;
    }
    pub fn set_n_level(&mut self, value: i16) {
        self.n_level = value;
    }
    pub fn set_n_level_raw(&mut self, value: [u8; 2]) {
        self.n_level_raw = value;
    }
    pub fn set_n_fullness(&mut self, value: i16) {
        self.n_fullness = value;
    }
    pub fn set_n_fullness_raw(&mut self, value: [u8; 2]) {
        self.n_fullness_raw = value;
    }
    pub fn set_n_relationship(&mut self, value: i16) {
        self.n_relationship = value;
    }
    pub fn set_n_relationship_raw(&mut self, value: [u8; 2]) {
        self.n_relationship_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPropertyPet {
        let packet_id = i16::from_le_bytes([0xa2, 0x01]);
        let packet_id_raw = [0xa2, 0x01];
        PacketZcPropertyPet {
        raw: vec![],
        packet_id,
        packet_id_raw,
        sz_name: [0 as char; 24],
        sz_name_raw: [0; 24],
        b_modified: 0,
        b_modified_raw: [0; 1],
        n_level: 0,
        n_level_raw: [0; 2],
        n_fullness: 0,
        n_fullness_raw: [0; 2],
        n_relationship: 0,
        n_relationship_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcPropertyPet {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPropertyPet::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcFeedPet {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa301"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcFeedPet {
        let mut offset: usize = 0;
        PacketZcFeedPet {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            c_ret: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            c_ret_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.c_ret).unwrap();
        self.c_ret_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.c_ret_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_c_ret(&mut self, value: i8) {
        self.c_ret = value;
    }
    pub fn set_c_ret_raw(&mut self, value: [u8; 1]) {
        self.c_ret_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcFeedPet {
        let packet_id = i16::from_le_bytes([0xa3, 0x01]);
        let packet_id_raw = [0xa3, 0x01];
        PacketZcFeedPet {
        raw: vec![],
        packet_id,
        packet_id_raw,
        c_ret: 0,
        c_ret_raw: [0; 1],
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcFeedPet {
    fn id(&self, packetver: u32) -> &str {
       PacketZcFeedPet::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcChangestatePet {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa401"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcChangestatePet {
        let mut offset: usize = 0;
        PacketZcChangestatePet {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            gid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            data: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.data).unwrap();
        self.data_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 11;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_gid(&mut self, value: i32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_data(&mut self, value: i32) {
        self.data = value;
    }
    pub fn set_data_raw(&mut self, value: [u8; 4]) {
        self.data_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcChangestatePet {
        let packet_id = i16::from_le_bytes([0xa4, 0x01]);
        let packet_id_raw = [0xa4, 0x01];
        PacketZcChangestatePet {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        data: 0,
        data_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcChangestatePet {
    fn id(&self, packetver: u32) -> &str {
       PacketZcChangestatePet::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRenamePet {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa501"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRenamePet {
        let mut offset: usize = 0;
        PacketCzRenamePet {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            sz_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            sz_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.sz_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_sz_name(&mut self, value: [char; 24]) {
        self.sz_name = value;
    }
    pub fn set_sz_name_raw(&mut self, value: [u8; 24]) {
        self.sz_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRenamePet {
        let packet_id = i16::from_le_bytes([0xa5, 0x01]);
        let packet_id_raw = [0xa5, 0x01];
        PacketCzRenamePet {
        raw: vec![],
        packet_id,
        packet_id_raw,
        sz_name: [0 as char; 24],
        sz_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzRenamePet {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRenamePet::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPeteggList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa601"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPeteggList {
        let mut offset: usize = 0;
        let vec_type_len = PeteggitemInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<PeteggitemInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(PeteggitemInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcPeteggList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            egg_list: {
                let field = vec_field.clone();
                field
            },
            egg_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.egg_list_raw = {
            self.egg_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.egg_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.egg_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_egg_list(&mut self, value: Vec<PeteggitemInfo>) {
        self.egg_list = value;
    }
    pub fn set_egg_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.egg_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPeteggList {
        let packet_id = i16::from_le_bytes([0xa6, 0x01]);
        let packet_id_raw = [0xa6, 0x01];
        PacketZcPeteggList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        egg_list: vec![],
        egg_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcPeteggList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPeteggList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzSelectPetegg {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa701"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzSelectPetegg {
        let mut offset: usize = 0;
        PacketCzSelectPetegg {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzSelectPetegg {
        let packet_id = i16::from_le_bytes([0xa7, 0x01]);
        let packet_id_raw = [0xa7, 0x01];
        PacketCzSelectPetegg {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzSelectPetegg {
    fn id(&self, packetver: u32) -> &str {
       PacketCzSelectPetegg::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzPeteggInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa801"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzPeteggInfo {
        let mut offset: usize = 0;
        PacketCzPeteggInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzPeteggInfo {
        let packet_id = i16::from_le_bytes([0xa8, 0x01]);
        let packet_id_raw = [0xa8, 0x01];
        PacketCzPeteggInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzPeteggInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketCzPeteggInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzPetAct {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa901"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzPetAct {
        let mut offset: usize = 0;
        PacketCzPetAct {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            data: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.data).unwrap();
        self.data_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_data(&mut self, value: i32) {
        self.data = value;
    }
    pub fn set_data_raw(&mut self, value: [u8; 4]) {
        self.data_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzPetAct {
        let packet_id = i16::from_le_bytes([0xa9, 0x01]);
        let packet_id_raw = [0xa9, 0x01];
        PacketCzPetAct {
        raw: vec![],
        packet_id,
        packet_id_raw,
        data: 0,
        data_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzPetAct {
    fn id(&self, packetver: u32) -> &str {
       PacketCzPetAct::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPetAct {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xaa01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPetAct {
        let mut offset: usize = 0;
        PacketZcPetAct {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            data: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.data).unwrap();
        self.data_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: i32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_data(&mut self, value: i32) {
        self.data = value;
    }
    pub fn set_data_raw(&mut self, value: [u8; 4]) {
        self.data_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPetAct {
        let packet_id = i16::from_le_bytes([0xaa, 0x01]);
        let packet_id_raw = [0xaa, 0x01];
        PacketZcPetAct {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        data: 0,
        data_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcPetAct {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPetAct::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcParChangeUser {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xab01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcParChangeUser {
        let mut offset: usize = 0;
        PacketZcParChangeUser {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            var_id: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            var_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var_id).unwrap();
        self.var_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.var_id_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 12;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_var_id(&mut self, value: u16) {
        self.var_id = value;
    }
    pub fn set_var_id_raw(&mut self, value: [u8; 2]) {
        self.var_id_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcParChangeUser {
        let packet_id = i16::from_le_bytes([0xab, 0x01]);
        let packet_id_raw = [0xab, 0x01];
        PacketZcParChangeUser {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        var_id: 0,
        var_id_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcParChangeUser {
    fn id(&self, packetver: u32) -> &str {
       PacketZcParChangeUser::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSkillUpdate {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xac01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSkillUpdate {
        let mut offset: usize = 0;
        PacketZcSkillUpdate {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSkillUpdate {
        let packet_id = i16::from_le_bytes([0xac, 0x01]);
        let packet_id_raw = [0xac, 0x01];
        PacketZcSkillUpdate {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcSkillUpdate {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSkillUpdate::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMakingarrowList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xad01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMakingarrowList {
        let mut offset: usize = 0;
        let vec_type_len = ArrowitemInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<ArrowitemInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(ArrowitemInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcMakingarrowList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            arrow_list: {
                let field = vec_field.clone();
                field
            },
            arrow_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.arrow_list_raw = {
            self.arrow_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.arrow_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.arrow_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_arrow_list(&mut self, value: Vec<ArrowitemInfo>) {
        self.arrow_list = value;
    }
    pub fn set_arrow_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.arrow_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMakingarrowList {
        let packet_id = i16::from_le_bytes([0xad, 0x01]);
        let packet_id_raw = [0xad, 0x01];
        PacketZcMakingarrowList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        arrow_list: vec![],
        arrow_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcMakingarrowList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMakingarrowList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqMakingarrow {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xae01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqMakingarrow {
        let mut offset: usize = 0;
        PacketCzReqMakingarrow {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            id: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.id).unwrap();
        self.id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_id(&mut self, value: u16) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 2]) {
        self.id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqMakingarrow {
        let packet_id = i16::from_le_bytes([0xae, 0x01]);
        let packet_id_raw = [0xae, 0x01];
        PacketCzReqMakingarrow {
        raw: vec![],
        packet_id,
        packet_id_raw,
        id: 0,
        id_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqMakingarrow {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqMakingarrow::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqChangecart {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xaf01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqChangecart {
        let mut offset: usize = 0;
        PacketCzReqChangecart {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            num: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            num_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.num).unwrap();
        self.num_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.num_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_num(&mut self, value: i16) {
        self.num = value;
    }
    pub fn set_num_raw(&mut self, value: [u8; 2]) {
        self.num_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqChangecart {
        let packet_id = i16::from_le_bytes([0xaf, 0x01]);
        let packet_id_raw = [0xaf, 0x01];
        PacketCzReqChangecart {
        raw: vec![],
        packet_id,
        packet_id_raw,
        num: 0,
        num_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqChangecart {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqChangecart::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNpcspriteChange {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb001"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNpcspriteChange {
        let mut offset: usize = 0;
        PacketZcNpcspriteChange {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            value: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 11;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_value(&mut self, value: u32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNpcspriteChange {
        let packet_id = i16::from_le_bytes([0xb0, 0x01]);
        let packet_id_raw = [0xb0, 0x01];
        PacketZcNpcspriteChange {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNpcspriteChange {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNpcspriteChange::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcShowdigit {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb101"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcShowdigit {
        let mut offset: usize = 0;
        PacketZcShowdigit {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            value: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcShowdigit {
        let packet_id = i16::from_le_bytes([0xb1, 0x01]);
        let packet_id_raw = [0xb1, 0x01];
        PacketZcShowdigit {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 1],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcShowdigit {
    fn id(&self, packetver: u32) -> &str {
       PacketZcShowdigit::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqOpenstore2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb201"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqOpenstore2 {
        let mut offset: usize = 0;
        let vec_type_len = StoreItem::base_len(packetver);
        let iter_count = (&buffer.len() - 85) / vec_type_len;
        let mut vec_field: Vec<StoreItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 85 + (vec_type_len * (i - 1));
            let end_pos = 85 + vec_type_len * i;
            vec_field.push(StoreItem::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketCzReqOpenstore2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            store_name: {
                let field =  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[offset..offset + 80].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            store_name_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[offset..offset + 80]);
                offset += 80;
                dst
            },
            result: {
                let field = buffer[offset] == 1;
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            store_list: {
                let field = vec_field.clone();
                field
            },
            store_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.store_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.store_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        self.store_list_raw = {
            self.store_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.store_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.store_name_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.store_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 85;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_store_name(&mut self, value: [char; 80]) {
        self.store_name = value;
    }
    pub fn set_store_name_raw(&mut self, value: [u8; 80]) {
        self.store_name_raw = value;
    }
    pub fn set_result(&mut self, value: bool) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn set_store_list(&mut self, value: Vec<StoreItem>) {
        self.store_list = value;
    }
    pub fn set_store_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.store_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqOpenstore2 {
        let packet_id = i16::from_le_bytes([0xb2, 0x01]);
        let packet_id_raw = [0xb2, 0x01];
        PacketCzReqOpenstore2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        store_name: [0 as char; 80],
        store_name_raw: [0; 80],
        result: false,
        result_raw: [0; 1],
        store_list: vec![],
        store_list_raw: vec![],
        }
    }
}

impl Packet for PacketCzReqOpenstore2 {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqOpenstore2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcShowImage2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x01b3"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcShowImage2 {
        let mut offset: usize = 0;
        PacketZcShowImage2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            image_name: {
                let field =  {
                let mut dst: [char; 64] = [0 as char; 64];
                for (index, byte) in buffer[offset..offset + 64].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            image_name_raw: {
                let mut dst: [u8; 64] = [0u8; 64];
                dst.clone_from_slice(&buffer[offset..offset + 64]);
                offset += 64;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.image_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.image_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.image_name_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 67;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_image_name(&mut self, value: [char; 64]) {
        self.image_name = value;
    }
    pub fn set_image_name_raw(&mut self, value: [u8; 64]) {
        self.image_name_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcShowImage2 {
        let packet_id = i16::from_le_bytes([0x01, 0xb3]);
        let packet_id_raw = [0x01, 0xb3];
        PacketZcShowImage2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        image_name: [0 as char; 64],
        image_name_raw: [0; 64],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcShowImage2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcShowImage2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcChangeGuild {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb401"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcChangeGuild {
        let mut offset: usize = 0;
        PacketZcChangeGuild {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gdid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            emblem_version: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            emblem_version_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.emblem_version).unwrap();
        self.emblem_version_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.emblem_version_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 12;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gdid(&mut self, value: u32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_emblem_version(&mut self, value: i16) {
        self.emblem_version = value;
    }
    pub fn set_emblem_version_raw(&mut self, value: [u8; 2]) {
        self.emblem_version_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcChangeGuild {
        let packet_id = i16::from_le_bytes([0xb4, 0x01]);
        let packet_id_raw = [0xb4, 0x01];
        PacketZcChangeGuild {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        gdid: 0,
        gdid_raw: [0; 4],
        emblem_version: 0,
        emblem_version_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcChangeGuild {
    fn id(&self, packetver: u32) -> &str {
       PacketZcChangeGuild::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketScBillingInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb501"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketScBillingInfo {
        let mut offset: usize = 0;
        PacketScBillingInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            dw_amount_remain: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dw_amount_remain_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            dw_quantity_remain: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dw_quantity_remain_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            dw_reserved1: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dw_reserved1_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            dw_reserved2: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dw_reserved2_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_amount_remain).unwrap();
        self.dw_amount_remain_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_quantity_remain).unwrap();
        self.dw_quantity_remain_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_reserved1).unwrap();
        self.dw_reserved1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_reserved2).unwrap();
        self.dw_reserved2_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.dw_amount_remain_raw.to_vec());
        wtr.append(&mut self.dw_quantity_remain_raw.to_vec());
        wtr.append(&mut self.dw_reserved1_raw.to_vec());
        wtr.append(&mut self.dw_reserved2_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 18;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_dw_amount_remain(&mut self, value: u32) {
        self.dw_amount_remain = value;
    }
    pub fn set_dw_amount_remain_raw(&mut self, value: [u8; 4]) {
        self.dw_amount_remain_raw = value;
    }
    pub fn set_dw_quantity_remain(&mut self, value: u32) {
        self.dw_quantity_remain = value;
    }
    pub fn set_dw_quantity_remain_raw(&mut self, value: [u8; 4]) {
        self.dw_quantity_remain_raw = value;
    }
    pub fn set_dw_reserved1(&mut self, value: u32) {
        self.dw_reserved1 = value;
    }
    pub fn set_dw_reserved1_raw(&mut self, value: [u8; 4]) {
        self.dw_reserved1_raw = value;
    }
    pub fn set_dw_reserved2(&mut self, value: u32) {
        self.dw_reserved2 = value;
    }
    pub fn set_dw_reserved2_raw(&mut self, value: [u8; 4]) {
        self.dw_reserved2_raw = value;
    }
    pub fn new(packetver: u32) -> PacketScBillingInfo {
        let packet_id = i16::from_le_bytes([0xb5, 0x01]);
        let packet_id_raw = [0xb5, 0x01];
        PacketScBillingInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        dw_amount_remain: 0,
        dw_amount_remain_raw: [0; 4],
        dw_quantity_remain: 0,
        dw_quantity_remain_raw: [0; 4],
        dw_reserved1: 0,
        dw_reserved1_raw: [0; 4],
        dw_reserved2: 0,
        dw_reserved2_raw: [0; 4],
        }
    }
}

impl Packet for PacketScBillingInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketScBillingInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcGuildInfo2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb601"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcGuildInfo2 {
        let mut offset: usize = 0;
        PacketZcGuildInfo2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gdid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            level: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            user_num: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            user_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            max_user_num: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            max_user_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            user_average_level: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            user_average_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            exp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            max_exp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            max_exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            point: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            honor: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            virtue: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            emblem_version: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            emblem_version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            guildname: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            guildname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            master_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            master_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            manage_land: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            manage_land_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            zeny: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.user_num).unwrap();
        self.user_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_user_num).unwrap();
        self.max_user_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.user_average_level).unwrap();
        self.user_average_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.exp).unwrap();
        self.exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_exp).unwrap();
        self.max_exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.emblem_version).unwrap();
        self.emblem_version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.guildname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guildname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.master_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.master_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.manage_land {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.manage_land_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.zeny).unwrap();
        self.zeny_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.user_num_raw.to_vec());
        wtr.append(&mut self.max_user_num_raw.to_vec());
        wtr.append(&mut self.user_average_level_raw.to_vec());
        wtr.append(&mut self.exp_raw.to_vec());
        wtr.append(&mut self.max_exp_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.emblem_version_raw.to_vec());
        wtr.append(&mut self.guildname_raw.to_vec());
        wtr.append(&mut self.master_name_raw.to_vec());
        wtr.append(&mut self.manage_land_raw.to_vec());
        wtr.append(&mut self.zeny_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 114;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: i32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_level(&mut self, value: i32) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 4]) {
        self.level_raw = value;
    }
    pub fn set_user_num(&mut self, value: i32) {
        self.user_num = value;
    }
    pub fn set_user_num_raw(&mut self, value: [u8; 4]) {
        self.user_num_raw = value;
    }
    pub fn set_max_user_num(&mut self, value: i32) {
        self.max_user_num = value;
    }
    pub fn set_max_user_num_raw(&mut self, value: [u8; 4]) {
        self.max_user_num_raw = value;
    }
    pub fn set_user_average_level(&mut self, value: i32) {
        self.user_average_level = value;
    }
    pub fn set_user_average_level_raw(&mut self, value: [u8; 4]) {
        self.user_average_level_raw = value;
    }
    pub fn set_exp(&mut self, value: i32) {
        self.exp = value;
    }
    pub fn set_exp_raw(&mut self, value: [u8; 4]) {
        self.exp_raw = value;
    }
    pub fn set_max_exp(&mut self, value: i32) {
        self.max_exp = value;
    }
    pub fn set_max_exp_raw(&mut self, value: [u8; 4]) {
        self.max_exp_raw = value;
    }
    pub fn set_point(&mut self, value: i32) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 4]) {
        self.point_raw = value;
    }
    pub fn set_honor(&mut self, value: i32) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 4]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_emblem_version(&mut self, value: i32) {
        self.emblem_version = value;
    }
    pub fn set_emblem_version_raw(&mut self, value: [u8; 4]) {
        self.emblem_version_raw = value;
    }
    pub fn set_guildname(&mut self, value: [char; 24]) {
        self.guildname = value;
    }
    pub fn set_guildname_raw(&mut self, value: [u8; 24]) {
        self.guildname_raw = value;
    }
    pub fn set_master_name(&mut self, value: [char; 24]) {
        self.master_name = value;
    }
    pub fn set_master_name_raw(&mut self, value: [u8; 24]) {
        self.master_name_raw = value;
    }
    pub fn set_manage_land(&mut self, value: [char; 16]) {
        self.manage_land = value;
    }
    pub fn set_manage_land_raw(&mut self, value: [u8; 16]) {
        self.manage_land_raw = value;
    }
    pub fn set_zeny(&mut self, value: i32) {
        self.zeny = value;
    }
    pub fn set_zeny_raw(&mut self, value: [u8; 4]) {
        self.zeny_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcGuildInfo2 {
        let packet_id = i16::from_le_bytes([0xb6, 0x01]);
        let packet_id_raw = [0xb6, 0x01];
        PacketZcGuildInfo2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gdid: 0,
        gdid_raw: [0; 4],
        level: 0,
        level_raw: [0; 4],
        user_num: 0,
        user_num_raw: [0; 4],
        max_user_num: 0,
        max_user_num_raw: [0; 4],
        user_average_level: 0,
        user_average_level_raw: [0; 4],
        exp: 0,
        exp_raw: [0; 4],
        max_exp: 0,
        max_exp_raw: [0; 4],
        point: 0,
        point_raw: [0; 4],
        honor: 0,
        honor_raw: [0; 4],
        virtue: 0,
        virtue_raw: [0; 4],
        emblem_version: 0,
        emblem_version_raw: [0; 4],
        guildname: [0 as char; 24],
        guildname_raw: [0; 24],
        master_name: [0 as char; 24],
        master_name_raw: [0; 24],
        manage_land: [0 as char; 16],
        manage_land_raw: [0; 16],
        zeny: 0,
        zeny_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcGuildInfo2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcGuildInfo2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzGuildZeny {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb701"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzGuildZeny {
        let mut offset: usize = 0;
        PacketCzGuildZeny {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            zeny: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.zeny).unwrap();
        self.zeny_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.zeny_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_zeny(&mut self, value: i32) {
        self.zeny = value;
    }
    pub fn set_zeny_raw(&mut self, value: [u8; 4]) {
        self.zeny_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzGuildZeny {
        let packet_id = i16::from_le_bytes([0xb7, 0x01]);
        let packet_id_raw = [0xb7, 0x01];
        PacketCzGuildZeny {
        raw: vec![],
        packet_id,
        packet_id_raw,
        zeny: 0,
        zeny_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzGuildZeny {
    fn id(&self, packetver: u32) -> &str {
       PacketCzGuildZeny::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcGuildZenyAck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb801"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcGuildZenyAck {
        let mut offset: usize = 0;
        PacketZcGuildZenyAck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            ret: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            ret_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.ret).unwrap();
        self.ret_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.ret_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_ret(&mut self, value: u8) {
        self.ret = value;
    }
    pub fn set_ret_raw(&mut self, value: [u8; 1]) {
        self.ret_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcGuildZenyAck {
        let packet_id = i16::from_le_bytes([0xb8, 0x01]);
        let packet_id_raw = [0xb8, 0x01];
        PacketZcGuildZenyAck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        ret: 0,
        ret_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcGuildZenyAck {
    fn id(&self, packetver: u32) -> &str {
       PacketZcGuildZenyAck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcDispel {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb901"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcDispel {
        let mut offset: usize = 0;
        PacketZcDispel {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcDispel {
        let packet_id = i16::from_le_bytes([0xb9, 0x01]);
        let packet_id_raw = [0xb9, 0x01];
        PacketZcDispel {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDispel {
    fn id(&self, packetver: u32) -> &str {
       PacketZcDispel::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRemoveAid {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xba01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRemoveAid {
        let mut offset: usize = 0;
        PacketCzRemoveAid {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            account_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            account_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.account_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.account_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.account_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_account_name(&mut self, value: [char; 24]) {
        self.account_name = value;
    }
    pub fn set_account_name_raw(&mut self, value: [u8; 24]) {
        self.account_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRemoveAid {
        let packet_id = i16::from_le_bytes([0xba, 0x01]);
        let packet_id_raw = [0xba, 0x01];
        PacketCzRemoveAid {
        raw: vec![],
        packet_id,
        packet_id_raw,
        account_name: [0 as char; 24],
        account_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzRemoveAid {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRemoveAid::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzShift {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xbb01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzShift {
        let mut offset: usize = 0;
        PacketCzShift {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            character_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzShift {
        let packet_id = i16::from_le_bytes([0xbb, 0x01]);
        let packet_id_raw = [0xbb, 0x01];
        PacketCzShift {
        raw: vec![],
        packet_id,
        packet_id_raw,
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzShift {
    fn id(&self, packetver: u32) -> &str {
       PacketCzShift::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRecall {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xbc01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRecall {
        let mut offset: usize = 0;
        PacketCzRecall {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            account_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            account_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.account_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.account_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.account_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_account_name(&mut self, value: [char; 24]) {
        self.account_name = value;
    }
    pub fn set_account_name_raw(&mut self, value: [u8; 24]) {
        self.account_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRecall {
        let packet_id = i16::from_le_bytes([0xbc, 0x01]);
        let packet_id_raw = [0xbc, 0x01];
        PacketCzRecall {
        raw: vec![],
        packet_id,
        packet_id_raw,
        account_name: [0 as char; 24],
        account_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzRecall {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRecall::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRecallGid {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xbd01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRecallGid {
        let mut offset: usize = 0;
        PacketCzRecallGid {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            character_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRecallGid {
        let packet_id = i16::from_le_bytes([0xbd, 0x01]);
        let packet_id_raw = [0xbd, 0x01];
        PacketCzRecallGid {
        raw: vec![],
        packet_id,
        packet_id_raw,
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzRecallGid {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRecallGid::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcAskPngameroom {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xbe01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcAskPngameroom {
        let mut offset: usize = 0;
        PacketAcAskPngameroom {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcAskPngameroom {
        let packet_id = i16::from_le_bytes([0xbe, 0x01]);
        let packet_id_raw = [0xbe, 0x01];
        PacketAcAskPngameroom {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketAcAskPngameroom {
    fn id(&self, packetver: u32) -> &str {
       PacketAcAskPngameroom::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCaReplyPngameroom {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xbf01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaReplyPngameroom {
        let mut offset: usize = 0;
        PacketCaReplyPngameroom {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            permission: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            permission_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.permission).unwrap();
        self.permission_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.permission_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_permission(&mut self, value: u8) {
        self.permission = value;
    }
    pub fn set_permission_raw(&mut self, value: [u8; 1]) {
        self.permission_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaReplyPngameroom {
        let packet_id = i16::from_le_bytes([0xbf, 0x01]);
        let packet_id_raw = [0xbf, 0x01];
        PacketCaReplyPngameroom {
        raw: vec![],
        packet_id,
        packet_id_raw,
        permission: 0,
        permission_raw: [0; 1],
        }
    }
}

impl Packet for PacketCaReplyPngameroom {
    fn id(&self, packetver: u32) -> &str {
       PacketCaReplyPngameroom::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqRemaintime {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc001"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqRemaintime {
        let mut offset: usize = 0;
        PacketCzReqRemaintime {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqRemaintime {
        let packet_id = i16::from_le_bytes([0xc0, 0x01]);
        let packet_id_raw = [0xc0, 0x01];
        PacketCzReqRemaintime {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzReqRemaintime {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqRemaintime::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcReplyRemaintime {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc101"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcReplyRemaintime {
        let mut offset: usize = 0;
        PacketZcReplyRemaintime {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            expiration_date: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            expiration_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            remain_time: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            remain_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.expiration_date).unwrap();
        self.expiration_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.remain_time).unwrap();
        self.remain_time_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.expiration_date_raw.to_vec());
        wtr.append(&mut self.remain_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i32) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 4]) {
        self.result_raw = value;
    }
    pub fn set_expiration_date(&mut self, value: i32) {
        self.expiration_date = value;
    }
    pub fn set_expiration_date_raw(&mut self, value: [u8; 4]) {
        self.expiration_date_raw = value;
    }
    pub fn set_remain_time(&mut self, value: i32) {
        self.remain_time = value;
    }
    pub fn set_remain_time_raw(&mut self, value: [u8; 4]) {
        self.remain_time_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcReplyRemaintime {
        let packet_id = i16::from_le_bytes([0xc1, 0x01]);
        let packet_id_raw = [0xc1, 0x01];
        PacketZcReplyRemaintime {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 4],
        expiration_date: 0,
        expiration_date_raw: [0; 4],
        remain_time: 0,
        remain_time_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcReplyRemaintime {
    fn id(&self, packetver: u32) -> &str {
       PacketZcReplyRemaintime::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcInfoRemaintime {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc201"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcInfoRemaintime {
        let mut offset: usize = 0;
        PacketZcInfoRemaintime {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            remain_time: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            remain_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.remain_time).unwrap();
        self.remain_time_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.remain_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn set_remain_time(&mut self, value: i32) {
        self.remain_time = value;
    }
    pub fn set_remain_time_raw(&mut self, value: [u8; 4]) {
        self.remain_time_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcInfoRemaintime {
        let packet_id = i16::from_le_bytes([0xc2, 0x01]);
        let packet_id_raw = [0xc2, 0x01];
        PacketZcInfoRemaintime {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 4],
        remain_time: 0,
        remain_time_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcInfoRemaintime {
    fn id(&self, packetver: u32) -> &str {
       PacketZcInfoRemaintime::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcBroadcast2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc301"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcBroadcast2 {
        let mut offset: usize = 0;
        PacketZcBroadcast2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            font_color: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            font_color_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            font_type: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            font_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            font_size: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            font_size_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            font_align: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            font_align_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            font_y: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            font_y_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.font_color).unwrap();
        self.font_color_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font_type).unwrap();
        self.font_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font_size).unwrap();
        self.font_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font_align).unwrap();
        self.font_align_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font_y).unwrap();
        self.font_y_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.font_color_raw.to_vec());
        wtr.append(&mut self.font_type_raw.to_vec());
        wtr.append(&mut self.font_size_raw.to_vec());
        wtr.append(&mut self.font_align_raw.to_vec());
        wtr.append(&mut self.font_y_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 15;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_font_color(&mut self, value: u32) {
        self.font_color = value;
    }
    pub fn set_font_color_raw(&mut self, value: [u8; 4]) {
        self.font_color_raw = value;
    }
    pub fn set_font_type(&mut self, value: i16) {
        self.font_type = value;
    }
    pub fn set_font_type_raw(&mut self, value: [u8; 2]) {
        self.font_type_raw = value;
    }
    pub fn set_font_size(&mut self, value: i16) {
        self.font_size = value;
    }
    pub fn set_font_size_raw(&mut self, value: [u8; 2]) {
        self.font_size_raw = value;
    }
    pub fn set_font_align(&mut self, value: i16) {
        self.font_align = value;
    }
    pub fn set_font_align_raw(&mut self, value: [u8; 2]) {
        self.font_align_raw = value;
    }
    pub fn set_font_y(&mut self, value: i16) {
        self.font_y = value;
    }
    pub fn set_font_y_raw(&mut self, value: [u8; 2]) {
        self.font_y_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcBroadcast2 {
        let packet_id = i16::from_le_bytes([0xc3, 0x01]);
        let packet_id_raw = [0xc3, 0x01];
        PacketZcBroadcast2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        font_color: 0,
        font_color_raw: [0; 4],
        font_type: 0,
        font_type_raw: [0; 2],
        font_size: 0,
        font_size_raw: [0; 2],
        font_align: 0,
        font_align_raw: [0; 2],
        font_y: 0,
        font_y_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcBroadcast2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcBroadcast2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAddItemToStore2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc401"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAddItemToStore2 {
        let mut offset: usize = 0;
        PacketZcAddItemToStore2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_damaged: {
                let field = buffer[offset] == 1;
                field
            },
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            refining_level: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 22;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAddItemToStore2 {
        let packet_id = i16::from_le_bytes([0xc4, 0x01]);
        let packet_id_raw = [0xc4, 0x01];
        PacketZcAddItemToStore2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        }
    }
}

impl Packet for PacketZcAddItemToStore2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAddItemToStore2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAddItemToCart2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc501"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAddItemToCart2 {
        let mut offset: usize = 0;
        PacketZcAddItemToCart2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_damaged: {
                let field = buffer[offset] == 1;
                field
            },
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            refining_level: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 22;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAddItemToCart2 {
        let packet_id = i16::from_le_bytes([0xc5, 0x01]);
        let packet_id_raw = [0xc5, 0x01];
        PacketZcAddItemToCart2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        }
    }
}

impl Packet for PacketZcAddItemToCart2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAddItemToCart2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCsReqEncryption {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc601"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCsReqEncryption {
        let mut offset: usize = 0;
        PacketCsReqEncryption {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            enc_count: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            enc_count_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            dec_count: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            dec_count_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.enc_count).unwrap();
        self.enc_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.dec_count).unwrap();
        self.dec_count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.enc_count_raw.to_vec());
        wtr.append(&mut self.dec_count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_enc_count(&mut self, value: i8) {
        self.enc_count = value;
    }
    pub fn set_enc_count_raw(&mut self, value: [u8; 1]) {
        self.enc_count_raw = value;
    }
    pub fn set_dec_count(&mut self, value: i8) {
        self.dec_count = value;
    }
    pub fn set_dec_count_raw(&mut self, value: [u8; 1]) {
        self.dec_count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCsReqEncryption {
        let packet_id = i16::from_le_bytes([0xc6, 0x01]);
        let packet_id_raw = [0xc6, 0x01];
        PacketCsReqEncryption {
        raw: vec![],
        packet_id,
        packet_id_raw,
        enc_count: 0,
        enc_count_raw: [0; 1],
        dec_count: 0,
        dec_count_raw: [0; 1],
        }
    }
}

impl Packet for PacketCsReqEncryption {
    fn id(&self, packetver: u32) -> &str {
       PacketCsReqEncryption::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketScAckEncryption {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc701"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketScAckEncryption {
        let mut offset: usize = 0;
        PacketScAckEncryption {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketScAckEncryption {
        let packet_id = i16::from_le_bytes([0xc7, 0x01]);
        let packet_id_raw = [0xc7, 0x01];
        PacketScAckEncryption {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketScAckEncryption {
    fn id(&self, packetver: u32) -> &str {
       PacketScAckEncryption::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcUseItemAck2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc801"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcUseItemAck2 {
        let mut offset: usize = 0;
        PacketZcUseItemAck2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            id: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = buffer[offset] == 1;
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.id).unwrap();
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 13;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_id(&mut self, value: u16) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 2]) {
        self.id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_result(&mut self, value: bool) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcUseItemAck2 {
        let packet_id = i16::from_le_bytes([0xc8, 0x01]);
        let packet_id_raw = [0xc8, 0x01];
        PacketZcUseItemAck2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        id: 0,
        id_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        count: 0,
        count_raw: [0; 2],
        result: false,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcUseItemAck2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcUseItemAck2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSkillEntry2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc901"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSkillEntry2 {
        let mut offset: usize = 0;
        PacketZcSkillEntry2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            creator_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            creator_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_visible: {
                let field = buffer[offset] == 1;
                field
            },
            is_visible_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_contens: {
                let field = buffer[offset] == 1;
                field
            },
            is_contens_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            msg: {
                let field =  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[offset..offset + 80].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            msg_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[offset..offset + 80]);
                offset += 80;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.creator_aid).unwrap();
        self.creator_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_visible as u8).unwrap();
        self.is_visible_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_contens as u8).unwrap();
        self.is_contens_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.msg {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.msg_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.creator_aid_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.is_visible_raw.to_vec());
        wtr.append(&mut self.is_contens_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 97;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_creator_aid(&mut self, value: u32) {
        self.creator_aid = value;
    }
    pub fn set_creator_aid_raw(&mut self, value: [u8; 4]) {
        self.creator_aid_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_job(&mut self, value: u8) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 1]) {
        self.job_raw = value;
    }
    pub fn set_is_visible(&mut self, value: bool) {
        self.is_visible = value;
    }
    pub fn set_is_visible_raw(&mut self, value: [u8; 1]) {
        self.is_visible_raw = value;
    }
    pub fn set_is_contens(&mut self, value: bool) {
        self.is_contens = value;
    }
    pub fn set_is_contens_raw(&mut self, value: [u8; 1]) {
        self.is_contens_raw = value;
    }
    pub fn set_msg(&mut self, value: [char; 80]) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: [u8; 80]) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSkillEntry2 {
        let packet_id = i16::from_le_bytes([0xc9, 0x01]);
        let packet_id_raw = [0xc9, 0x01];
        PacketZcSkillEntry2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        creator_aid: 0,
        creator_aid_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        job: 0,
        job_raw: [0; 1],
        is_visible: false,
        is_visible_raw: [0; 1],
        is_contens: false,
        is_contens_raw: [0; 1],
        msg: [0 as char; 80],
        msg_raw: [0; 80],
        }
    }
}

impl Packet for PacketZcSkillEntry2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSkillEntry2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqmakinghomun {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xca01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqmakinghomun {
        let mut offset: usize = 0;
        PacketCzReqmakinghomun {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = buffer[offset] == 1;
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result as u8).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: bool) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqmakinghomun {
        let packet_id = i16::from_le_bytes([0xca, 0x01]);
        let packet_id_raw = [0xca, 0x01];
        PacketCzReqmakinghomun {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: false,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzReqmakinghomun {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqmakinghomun::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzMonsterTalk {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xcb01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzMonsterTalk {
        let mut offset: usize = 0;
        PacketCzMonsterTalk {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            state_id: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            state_id_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            skill_id: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            skill_id_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            arg1: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            arg1_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state_id).unwrap();
        self.state_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.skill_id).unwrap();
        self.skill_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.arg1).unwrap();
        self.arg1_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.state_id_raw.to_vec());
        wtr.append(&mut self.skill_id_raw.to_vec());
        wtr.append(&mut self.arg1_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 9;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_state_id(&mut self, value: u8) {
        self.state_id = value;
    }
    pub fn set_state_id_raw(&mut self, value: [u8; 1]) {
        self.state_id_raw = value;
    }
    pub fn set_skill_id(&mut self, value: u8) {
        self.skill_id = value;
    }
    pub fn set_skill_id_raw(&mut self, value: [u8; 1]) {
        self.skill_id_raw = value;
    }
    pub fn set_arg1(&mut self, value: u8) {
        self.arg1 = value;
    }
    pub fn set_arg1_raw(&mut self, value: [u8; 1]) {
        self.arg1_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzMonsterTalk {
        let packet_id = i16::from_le_bytes([0xcb, 0x01]);
        let packet_id_raw = [0xcb, 0x01];
        PacketCzMonsterTalk {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        state_id: 0,
        state_id_raw: [0; 1],
        skill_id: 0,
        skill_id_raw: [0; 1],
        arg1: 0,
        arg1_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzMonsterTalk {
    fn id(&self, packetver: u32) -> &str {
       PacketCzMonsterTalk::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMonsterTalk {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xcc01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMonsterTalk {
        let mut offset: usize = 0;
        PacketZcMonsterTalk {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            state_id: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            state_id_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            skill_id: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            skill_id_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            arg1: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            arg1_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state_id).unwrap();
        self.state_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.skill_id).unwrap();
        self.skill_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.arg1).unwrap();
        self.arg1_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.state_id_raw.to_vec());
        wtr.append(&mut self.skill_id_raw.to_vec());
        wtr.append(&mut self.arg1_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 9;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_state_id(&mut self, value: u8) {
        self.state_id = value;
    }
    pub fn set_state_id_raw(&mut self, value: [u8; 1]) {
        self.state_id_raw = value;
    }
    pub fn set_skill_id(&mut self, value: u8) {
        self.skill_id = value;
    }
    pub fn set_skill_id_raw(&mut self, value: [u8; 1]) {
        self.skill_id_raw = value;
    }
    pub fn set_arg1(&mut self, value: u8) {
        self.arg1 = value;
    }
    pub fn set_arg1_raw(&mut self, value: [u8; 1]) {
        self.arg1_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMonsterTalk {
        let packet_id = i16::from_le_bytes([0xcc, 0x01]);
        let packet_id_raw = [0xcc, 0x01];
        PacketZcMonsterTalk {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        state_id: 0,
        state_id_raw: [0; 1],
        skill_id: 0,
        skill_id_raw: [0; 1],
        arg1: 0,
        arg1_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcMonsterTalk {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMonsterTalk::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAutospelllist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xcd01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAutospelllist {
        let mut offset: usize = 0;
        PacketZcAutospelllist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field =  {
                let mut dst: [i32; 7] = [0_i32; 7];
                for (index, byte) in buffer[offset..offset + 7].iter().enumerate() {
                    dst[index] = *byte as i32;
                }
                dst
            };
                field
            },
            skid_raw: {
                let mut dst: [u8; 28] = [0u8; 28];
                dst.clone_from_slice(&buffer[offset..offset + 28]);
                offset += 28;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.skid {
            wtr.write_i32::<LittleEndian>(item).unwrap();
        }
        self.skid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 9;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: [i32; 7]) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 28]) {
        self.skid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAutospelllist {
        let packet_id = i16::from_le_bytes([0xcd, 0x01]);
        let packet_id_raw = [0xcd, 0x01];
        PacketZcAutospelllist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        skid: [0; 7],
        skid_raw: [0; 28],
        }
    }
}

impl Packet for PacketZcAutospelllist {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAutospelllist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzSelectautospell {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xce01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzSelectautospell {
        let mut offset: usize = 0;
        PacketCzSelectautospell {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: i32) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 4]) {
        self.skid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzSelectautospell {
        let packet_id = i16::from_le_bytes([0xce, 0x01]);
        let packet_id_raw = [0xce, 0x01];
        PacketCzSelectautospell {
        raw: vec![],
        packet_id,
        packet_id_raw,
        skid: 0,
        skid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzSelectautospell {
    fn id(&self, packetver: u32) -> &str {
       PacketCzSelectautospell::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcDevotionlist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xcf01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcDevotionlist {
        let mut offset: usize = 0;
        PacketZcDevotionlist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            my_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            my_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            aid: {
                let field =  {
                let mut dst: [u32; 5] = [0_u32; 5];
                for (index, byte) in buffer[offset..offset + 5].iter().enumerate() {
                    dst[index] = *byte as u32;
                }
                dst
            };
                field
            },
            aid_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[offset..offset + 20]);
                offset += 20;
                dst
            },
            range: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.my_aid).unwrap();
        self.my_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.aid {
            wtr.write_u32::<LittleEndian>(item).unwrap();
        }
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.range).unwrap();
        self.range_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.my_aid_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.range_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 13;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_my_aid(&mut self, value: u32) {
        self.my_aid = value;
    }
    pub fn set_my_aid_raw(&mut self, value: [u8; 4]) {
        self.my_aid_raw = value;
    }
    pub fn set_aid(&mut self, value: [u32; 5]) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 20]) {
        self.aid_raw = value;
    }
    pub fn set_range(&mut self, value: i16) {
        self.range = value;
    }
    pub fn set_range_raw(&mut self, value: [u8; 2]) {
        self.range_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcDevotionlist {
        let packet_id = i16::from_le_bytes([0xcf, 0x01]);
        let packet_id_raw = [0xcf, 0x01];
        PacketZcDevotionlist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        my_aid: 0,
        my_aid_raw: [0; 4],
        aid: [0; 5],
        aid_raw: [0; 20],
        range: 0,
        range_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcDevotionlist {
    fn id(&self, packetver: u32) -> &str {
       PacketZcDevotionlist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSpirits {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd001"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSpirits {
        let mut offset: usize = 0;
        PacketZcSpirits {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            num: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            num_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.num).unwrap();
        self.num_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.num_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_num(&mut self, value: i16) {
        self.num = value;
    }
    pub fn set_num_raw(&mut self, value: [u8; 2]) {
        self.num_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSpirits {
        let packet_id = i16::from_le_bytes([0xd0, 0x01]);
        let packet_id_raw = [0xd0, 0x01];
        PacketZcSpirits {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        num: 0,
        num_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcSpirits {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSpirits::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcBladestop {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd101"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcBladestop {
        let mut offset: usize = 0;
        PacketZcBladestop {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            src_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            src_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            dest_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dest_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            flag: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            flag_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.src_aid).unwrap();
        self.src_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dest_aid).unwrap();
        self.dest_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.flag).unwrap();
        self.flag_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.src_aid_raw.to_vec());
        wtr.append(&mut self.dest_aid_raw.to_vec());
        wtr.append(&mut self.flag_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_src_aid(&mut self, value: u32) {
        self.src_aid = value;
    }
    pub fn set_src_aid_raw(&mut self, value: [u8; 4]) {
        self.src_aid_raw = value;
    }
    pub fn set_dest_aid(&mut self, value: u32) {
        self.dest_aid = value;
    }
    pub fn set_dest_aid_raw(&mut self, value: [u8; 4]) {
        self.dest_aid_raw = value;
    }
    pub fn set_flag(&mut self, value: i32) {
        self.flag = value;
    }
    pub fn set_flag_raw(&mut self, value: [u8; 4]) {
        self.flag_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcBladestop {
        let packet_id = i16::from_le_bytes([0xd1, 0x01]);
        let packet_id_raw = [0xd1, 0x01];
        PacketZcBladestop {
        raw: vec![],
        packet_id,
        packet_id_raw,
        src_aid: 0,
        src_aid_raw: [0; 4],
        dest_aid: 0,
        dest_aid_raw: [0; 4],
        flag: 0,
        flag_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcBladestop {
    fn id(&self, packetver: u32) -> &str {
       PacketZcBladestop::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcCombodelay {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd201"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcCombodelay {
        let mut offset: usize = 0;
        PacketZcCombodelay {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            delay_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            delay_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.delay_time).unwrap();
        self.delay_time_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.delay_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_delay_time(&mut self, value: u32) {
        self.delay_time = value;
    }
    pub fn set_delay_time_raw(&mut self, value: [u8; 4]) {
        self.delay_time_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcCombodelay {
        let packet_id = i16::from_le_bytes([0xd2, 0x01]);
        let packet_id_raw = [0xd2, 0x01];
        PacketZcCombodelay {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        delay_time: 0,
        delay_time_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcCombodelay {
    fn id(&self, packetver: u32) -> &str {
       PacketZcCombodelay::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSound {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd301"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSound {
        let mut offset: usize = 0;
        PacketZcSound {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            file_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            file_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            act: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            act_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            term: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            term_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            naid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.file_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.file_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.act).unwrap();
        self.act_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.term).unwrap();
        self.term_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.file_name_raw.to_vec());
        wtr.append(&mut self.act_raw.to_vec());
        wtr.append(&mut self.term_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 35;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_file_name(&mut self, value: [char; 24]) {
        self.file_name = value;
    }
    pub fn set_file_name_raw(&mut self, value: [u8; 24]) {
        self.file_name_raw = value;
    }
    pub fn set_act(&mut self, value: u8) {
        self.act = value;
    }
    pub fn set_act_raw(&mut self, value: [u8; 1]) {
        self.act_raw = value;
    }
    pub fn set_term(&mut self, value: u32) {
        self.term = value;
    }
    pub fn set_term_raw(&mut self, value: [u8; 4]) {
        self.term_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSound {
        let packet_id = i16::from_le_bytes([0xd3, 0x01]);
        let packet_id_raw = [0xd3, 0x01];
        PacketZcSound {
        raw: vec![],
        packet_id,
        packet_id_raw,
        file_name: [0 as char; 24],
        file_name_raw: [0; 24],
        act: 0,
        act_raw: [0; 1],
        term: 0,
        term_raw: [0; 4],
        naid: 0,
        naid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcSound {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSound::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcOpenEditdlgstr {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x01d4"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcOpenEditdlgstr {
        let mut offset: usize = 0;
        PacketZcOpenEditdlgstr {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            naid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcOpenEditdlgstr {
        let packet_id = i16::from_le_bytes([0x01, 0xd4]);
        let packet_id_raw = [0x01, 0xd4];
        PacketZcOpenEditdlgstr {
        raw: vec![],
        packet_id,
        packet_id_raw,
        naid: 0,
        naid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcOpenEditdlgstr {
    fn id(&self, packetver: u32) -> &str {
       PacketZcOpenEditdlgstr::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzInputEditdlgstr {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x01d5"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzInputEditdlgstr {
        let mut offset: usize = 0;
        PacketCzInputEditdlgstr {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            naid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            naid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.naid).unwrap();
        self.naid_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.naid_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_naid(&mut self, value: u32) {
        self.naid = value;
    }
    pub fn set_naid_raw(&mut self, value: [u8; 4]) {
        self.naid_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzInputEditdlgstr {
        let packet_id = i16::from_le_bytes([0x01, 0xd5]);
        let packet_id_raw = [0x01, 0xd5];
        PacketCzInputEditdlgstr {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        naid: 0,
        naid_raw: [0; 4],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketCzInputEditdlgstr {
    fn id(&self, packetver: u32) -> &str {
       PacketCzInputEditdlgstr::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyMaptypeproperty2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd601"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyMaptypeproperty2 {
        let mut offset: usize = 0;
        PacketZcNotifyMaptypeproperty2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyMaptypeproperty2 {
        let packet_id = i16::from_le_bytes([0xd6, 0x01]);
        let packet_id_raw = [0xd6, 0x01];
        PacketZcNotifyMaptypeproperty2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyMaptypeproperty2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyMaptypeproperty2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSpriteChange2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd701"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSpriteChange2 {
        let mut offset: usize = 0;
        PacketZcSpriteChange2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            value: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            value2: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            value2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.value2).unwrap();
        self.value2_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        wtr.append(&mut self.value2_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 11;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_value(&mut self, value: u16) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 2]) {
        self.value_raw = value;
    }
    pub fn set_value2(&mut self, value: u16) {
        self.value2 = value;
    }
    pub fn set_value2_raw(&mut self, value: [u8; 2]) {
        self.value2_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSpriteChange2 {
        let packet_id = i16::from_le_bytes([0xd7, 0x01]);
        let packet_id_raw = [0xd7, 0x01];
        PacketZcSpriteChange2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        value: 0,
        value_raw: [0; 2],
        value2: 0,
        value2_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcSpriteChange2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSpriteChange2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyStandentry2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd801"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyStandentry2 {
        let mut offset: usize = 0;
        PacketZcNotifyStandentry2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory2: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gemblem_ver: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            honor: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            virtue: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            pos_dir: {
                let field =  {
                let mut dst: [u8; 3] = [0_u8; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[offset..offset + 3]);
                offset += 3;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            state: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            clevel: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 54;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i16) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 2]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i16) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 2]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [u8; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_state(&mut self, value: u8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyStandentry2 {
        let packet_id = i16::from_le_bytes([0xd8, 0x01]);
        let packet_id_raw = [0xd8, 0x01];
        PacketZcNotifyStandentry2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 2],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        state: 0,
        state_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyStandentry2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyStandentry2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyNewentry2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd901"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyNewentry2 {
        let mut offset: usize = 0;
        PacketZcNotifyNewentry2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory2: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gemblem_ver: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            honor: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            virtue: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            pos_dir: {
                let field =  {
                let mut dst: [u8; 3] = [0_u8; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[offset..offset + 3]);
                offset += 3;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            clevel: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 53;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i16) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 2]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i16) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 2]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [u8; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyNewentry2 {
        let packet_id = i16::from_le_bytes([0xd9, 0x01]);
        let packet_id_raw = [0xd9, 0x01];
        PacketZcNotifyNewentry2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 2],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyNewentry2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyNewentry2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyMoveentry2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xda01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyMoveentry2 {
        let mut offset: usize = 0;
        PacketZcNotifyMoveentry2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            move_start_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory2: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gemblem_ver: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            honor: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            virtue: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            move_data: {
                let field =  {
                let mut dst: [u16; 6] = [0_u16; 6];
                for (index, byte) in buffer[offset..offset + 6].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            };
                field
            },
            move_data_raw: {
                let mut dst: [u8; 12] = [0u8; 12];
                dst.clone_from_slice(&buffer[offset..offset + 12]);
                offset += 12;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            clevel: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.move_start_time_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.move_data_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 60;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i16) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 2]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_move_start_time(&mut self, value: u32) {
        self.move_start_time = value;
    }
    pub fn set_move_start_time_raw(&mut self, value: [u8; 4]) {
        self.move_start_time_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i16) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 2]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_move_data(&mut self, value: [u16; 6]) {
        self.move_data = value;
    }
    pub fn set_move_data_raw(&mut self, value: [u8; 12]) {
        self.move_data_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyMoveentry2 {
        let packet_id = i16::from_le_bytes([0xda, 0x01]);
        let packet_id_raw = [0xda, 0x01];
        PacketZcNotifyMoveentry2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        move_start_time: 0,
        move_start_time_raw: [0; 4],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 2],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        move_data: [0; 6],
        move_data_raw: [0; 12],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyMoveentry2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyMoveentry2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCaReqHash {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xdb01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaReqHash {
        let mut offset: usize = 0;
        PacketCaReqHash {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaReqHash {
        let packet_id = i16::from_le_bytes([0xdb, 0x01]);
        let packet_id_raw = [0xdb, 0x01];
        PacketCaReqHash {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCaReqHash {
    fn id(&self, packetver: u32) -> &str {
       PacketCaReqHash::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcAckHash {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xdc01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcAckHash {
        let mut offset: usize = 0;
        PacketAcAckHash {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            secret: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            secret_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.secret_raw = self.secret.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.secret_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_secret(&mut self, value: String) {
        self.secret = value;
    }
    pub fn set_secret_raw(&mut self, value: Vec<u8>) {
        self.secret_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcAckHash {
        let packet_id = i16::from_le_bytes([0xdc, 0x01]);
        let packet_id_raw = [0xdc, 0x01];
        PacketAcAckHash {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        secret: String::new(),
        secret_raw: vec![],
        }
    }
}

impl Packet for PacketAcAckHash {
    fn id(&self, packetver: u32) -> &str {
       PacketAcAckHash::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCaLogin2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xdd01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaLogin2 {
        let mut offset: usize = 0;
        PacketCaLogin2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            version: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            id: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            passwd_md5: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            passwd_md5_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            clienttype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd_md5 {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_md5_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.version_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.passwd_md5_raw.to_vec());
        wtr.append(&mut self.clienttype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 47;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_version(&mut self, value: u32) {
        self.version = value;
    }
    pub fn set_version_raw(&mut self, value: [u8; 4]) {
        self.version_raw = value;
    }
    pub fn set_id(&mut self, value: [char; 24]) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 24]) {
        self.id_raw = value;
    }
    pub fn set_passwd_md5(&mut self, value: [char; 16]) {
        self.passwd_md5 = value;
    }
    pub fn set_passwd_md5_raw(&mut self, value: [u8; 16]) {
        self.passwd_md5_raw = value;
    }
    pub fn set_clienttype(&mut self, value: u8) {
        self.clienttype = value;
    }
    pub fn set_clienttype_raw(&mut self, value: [u8; 1]) {
        self.clienttype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaLogin2 {
        let packet_id = i16::from_le_bytes([0xdd, 0x01]);
        let packet_id_raw = [0xdd, 0x01];
        PacketCaLogin2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        version: 0,
        version_raw: [0; 4],
        id: [0 as char; 24],
        id_raw: [0; 24],
        passwd_md5: [0 as char; 16],
        passwd_md5_raw: [0; 16],
        clienttype: 0,
        clienttype_raw: [0; 1],
        }
    }
}

impl Packet for PacketCaLogin2 {
    fn id(&self, packetver: u32) -> &str {
       PacketCaLogin2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifySkill2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xde01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifySkill2 {
        let mut offset: usize = 0;
        PacketZcNotifySkill2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            target_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            start_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            attack_mt: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            attack_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            attacked_mt: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            attacked_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            damage: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            damage_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            action: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attack_mt).unwrap();
        self.attack_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attacked_mt).unwrap();
        self.attacked_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.damage).unwrap();
        self.damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.target_id_raw.to_vec());
        wtr.append(&mut self.start_time_raw.to_vec());
        wtr.append(&mut self.attack_mt_raw.to_vec());
        wtr.append(&mut self.attacked_mt_raw.to_vec());
        wtr.append(&mut self.damage_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 33;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_target_id(&mut self, value: u32) {
        self.target_id = value;
    }
    pub fn set_target_id_raw(&mut self, value: [u8; 4]) {
        self.target_id_raw = value;
    }
    pub fn set_start_time(&mut self, value: u32) {
        self.start_time = value;
    }
    pub fn set_start_time_raw(&mut self, value: [u8; 4]) {
        self.start_time_raw = value;
    }
    pub fn set_attack_mt(&mut self, value: i32) {
        self.attack_mt = value;
    }
    pub fn set_attack_mt_raw(&mut self, value: [u8; 4]) {
        self.attack_mt_raw = value;
    }
    pub fn set_attacked_mt(&mut self, value: i32) {
        self.attacked_mt = value;
    }
    pub fn set_attacked_mt_raw(&mut self, value: [u8; 4]) {
        self.attacked_mt_raw = value;
    }
    pub fn set_damage(&mut self, value: i32) {
        self.damage = value;
    }
    pub fn set_damage_raw(&mut self, value: [u8; 4]) {
        self.damage_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifySkill2 {
        let packet_id = i16::from_le_bytes([0xde, 0x01]);
        let packet_id_raw = [0xde, 0x01];
        PacketZcNotifySkill2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        skid: 0,
        skid_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        target_id: 0,
        target_id_raw: [0; 4],
        start_time: 0,
        start_time_raw: [0; 4],
        attack_mt: 0,
        attack_mt_raw: [0; 4],
        attacked_mt: 0,
        attacked_mt_raw: [0; 4],
        damage: 0,
        damage_raw: [0; 4],
        level: 0,
        level_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        action: 0,
        action_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcNotifySkill2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifySkill2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqAccountname {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xdf01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqAccountname {
        let mut offset: usize = 0;
        PacketCzReqAccountname {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqAccountname {
        let packet_id = i16::from_le_bytes([0xdf, 0x01]);
        let packet_id_raw = [0xdf, 0x01];
        PacketCzReqAccountname {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqAccountname {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqAccountname::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckAccountname {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe001"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckAccountname {
        let mut offset: usize = 0;
        PacketZcAckAccountname {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 30;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckAccountname {
        let packet_id = i16::from_le_bytes([0xe0, 0x01]);
        let packet_id_raw = [0xe0, 0x01];
        PacketZcAckAccountname {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcAckAccountname {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckAccountname::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSpirits2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe101"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSpirits2 {
        let mut offset: usize = 0;
        PacketZcSpirits2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            num: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            num_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.num).unwrap();
        self.num_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.num_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_num(&mut self, value: i16) {
        self.num = value;
    }
    pub fn set_num_raw(&mut self, value: [u8; 2]) {
        self.num_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSpirits2 {
        let packet_id = i16::from_le_bytes([0xe1, 0x01]);
        let packet_id_raw = [0xe1, 0x01];
        PacketZcSpirits2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        num: 0,
        num_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcSpirits2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSpirits2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcReqCouple {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe201"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcReqCouple {
        let mut offset: usize = 0;
        PacketZcReqCouple {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 34;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcReqCouple {
        let packet_id = i16::from_le_bytes([0xe2, 0x01]);
        let packet_id_raw = [0xe2, 0x01];
        PacketZcReqCouple {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcReqCouple {
    fn id(&self, packetver: u32) -> &str {
       PacketZcReqCouple::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzJoinCouple {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe301"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzJoinCouple {
        let mut offset: usize = 0;
        PacketCzJoinCouple {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            answer: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            answer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_answer(&mut self, value: i32) {
        self.answer = value;
    }
    pub fn set_answer_raw(&mut self, value: [u8; 4]) {
        self.answer_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzJoinCouple {
        let packet_id = i16::from_le_bytes([0xe3, 0x01]);
        let packet_id_raw = [0xe3, 0x01];
        PacketCzJoinCouple {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        answer: 0,
        answer_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzJoinCouple {
    fn id(&self, packetver: u32) -> &str {
       PacketCzJoinCouple::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcStartCouple {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe401"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcStartCouple {
        let mut offset: usize = 0;
        PacketZcStartCouple {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcStartCouple {
        let packet_id = i16::from_le_bytes([0xe4, 0x01]);
        let packet_id_raw = [0xe4, 0x01];
        PacketZcStartCouple {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketZcStartCouple {
    fn id(&self, packetver: u32) -> &str {
       PacketZcStartCouple::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqJoinCouple {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe501"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqJoinCouple {
        let mut offset: usize = 0;
        PacketCzReqJoinCouple {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqJoinCouple {
        let packet_id = i16::from_le_bytes([0xe5, 0x01]);
        let packet_id_raw = [0xe5, 0x01];
        PacketCzReqJoinCouple {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqJoinCouple {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqJoinCouple::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcCouplename {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe601"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcCouplename {
        let mut offset: usize = 0;
        PacketZcCouplename {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            couple_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            couple_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.couple_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.couple_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.couple_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_couple_name(&mut self, value: [char; 24]) {
        self.couple_name = value;
    }
    pub fn set_couple_name_raw(&mut self, value: [u8; 24]) {
        self.couple_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcCouplename {
        let packet_id = i16::from_le_bytes([0xe6, 0x01]);
        let packet_id_raw = [0xe6, 0x01];
        PacketZcCouplename {
        raw: vec![],
        packet_id,
        packet_id_raw,
        couple_name: [0 as char; 24],
        couple_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcCouplename {
    fn id(&self, packetver: u32) -> &str {
       PacketZcCouplename::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzDoridori {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe701"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzDoridori {
        let mut offset: usize = 0;
        PacketCzDoridori {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzDoridori {
        let packet_id = i16::from_le_bytes([0xe7, 0x01]);
        let packet_id_raw = [0xe7, 0x01];
        PacketCzDoridori {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzDoridori {
    fn id(&self, packetver: u32) -> &str {
       PacketCzDoridori::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzMakeGroup2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe801"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzMakeGroup2 {
        let mut offset: usize = 0;
        PacketCzMakeGroup2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            group_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            item_pickup_rule: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            item_pickup_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            item_division_rule: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            item_division_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_pickup_rule).unwrap();
        self.item_pickup_rule_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_division_rule).unwrap();
        self.item_division_rule_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.group_name_raw.to_vec());
        wtr.append(&mut self.item_pickup_rule_raw.to_vec());
        wtr.append(&mut self.item_division_rule_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 28;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_group_name(&mut self, value: [char; 24]) {
        self.group_name = value;
    }
    pub fn set_group_name_raw(&mut self, value: [u8; 24]) {
        self.group_name_raw = value;
    }
    pub fn set_item_pickup_rule(&mut self, value: u8) {
        self.item_pickup_rule = value;
    }
    pub fn set_item_pickup_rule_raw(&mut self, value: [u8; 1]) {
        self.item_pickup_rule_raw = value;
    }
    pub fn set_item_division_rule(&mut self, value: u8) {
        self.item_division_rule = value;
    }
    pub fn set_item_division_rule_raw(&mut self, value: [u8; 1]) {
        self.item_division_rule_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzMakeGroup2 {
        let packet_id = i16::from_le_bytes([0xe8, 0x01]);
        let packet_id_raw = [0xe8, 0x01];
        PacketCzMakeGroup2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        group_name: [0 as char; 24],
        group_name_raw: [0; 24],
        item_pickup_rule: 0,
        item_pickup_rule_raw: [0; 1],
        item_division_rule: 0,
        item_division_rule_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzMakeGroup2 {
    fn id(&self, packetver: u32) -> &str {
       PacketCzMakeGroup2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAddMemberToGroup2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe901"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAddMemberToGroup2 {
        let mut offset: usize = 0;
        PacketZcAddMemberToGroup2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            role: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            role_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            state: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            group_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            character_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            map_name: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            item_pickup_rule: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            item_pickup_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            item_division_rule: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            item_division_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.role).unwrap();
        self.role_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_pickup_rule).unwrap();
        self.item_pickup_rule_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_division_rule).unwrap();
        self.item_division_rule_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.role_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.group_name_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.item_pickup_rule_raw.to_vec());
        wtr.append(&mut self.item_division_rule_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 81;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_role(&mut self, value: u32) {
        self.role = value;
    }
    pub fn set_role_raw(&mut self, value: [u8; 4]) {
        self.role_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_state(&mut self, value: u8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_group_name(&mut self, value: [char; 24]) {
        self.group_name = value;
    }
    pub fn set_group_name_raw(&mut self, value: [u8; 24]) {
        self.group_name_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_item_pickup_rule(&mut self, value: u8) {
        self.item_pickup_rule = value;
    }
    pub fn set_item_pickup_rule_raw(&mut self, value: [u8; 1]) {
        self.item_pickup_rule_raw = value;
    }
    pub fn set_item_division_rule(&mut self, value: u8) {
        self.item_division_rule = value;
    }
    pub fn set_item_division_rule_raw(&mut self, value: [u8; 1]) {
        self.item_division_rule_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAddMemberToGroup2 {
        let packet_id = i16::from_le_bytes([0xe9, 0x01]);
        let packet_id_raw = [0xe9, 0x01];
        PacketZcAddMemberToGroup2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        role: 0,
        role_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        state: 0,
        state_raw: [0; 1],
        group_name: [0 as char; 24],
        group_name_raw: [0; 24],
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        item_pickup_rule: 0,
        item_pickup_rule_raw: [0; 1],
        item_division_rule: 0,
        item_division_rule_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAddMemberToGroup2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAddMemberToGroup2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcCongratulation {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xea01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcCongratulation {
        let mut offset: usize = 0;
        PacketZcCongratulation {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcCongratulation {
        let packet_id = i16::from_le_bytes([0xea, 0x01]);
        let packet_id_raw = [0xea, 0x01];
        PacketZcCongratulation {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcCongratulation {
    fn id(&self, packetver: u32) -> &str {
       PacketZcCongratulation::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyPositionToGuildm {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xeb01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyPositionToGuildm {
        let mut offset: usize = 0;
        PacketZcNotifyPositionToGuildm {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyPositionToGuildm {
        let packet_id = i16::from_le_bytes([0xeb, 0x01]);
        let packet_id_raw = [0xeb, 0x01];
        PacketZcNotifyPositionToGuildm {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyPositionToGuildm {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyPositionToGuildm::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcGuildMemberMapChange {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xec01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcGuildMemberMapChange {
        let mut offset: usize = 0;
        PacketZcGuildMemberMapChange {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gdid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            map_name: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gdid(&mut self, value: u32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcGuildMemberMapChange {
        let packet_id = i16::from_le_bytes([0xec, 0x01]);
        let packet_id_raw = [0xec, 0x01];
        PacketZcGuildMemberMapChange {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gdid: 0,
        gdid_raw: [0; 4],
        aid: 0,
        aid_raw: [0; 4],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        }
    }
}

impl Packet for PacketZcGuildMemberMapChange {
    fn id(&self, packetver: u32) -> &str {
       PacketZcGuildMemberMapChange::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzChopokgi {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xed01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzChopokgi {
        let mut offset: usize = 0;
        PacketCzChopokgi {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzChopokgi {
        let packet_id = i16::from_le_bytes([0xed, 0x01]);
        let packet_id_raw = [0xed, 0x01];
        PacketCzChopokgi {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzChopokgi {
    fn id(&self, packetver: u32) -> &str {
       PacketCzChopokgi::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNormalItemlist2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xee01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNormalItemlist2 {
        let mut offset: usize = 0;
        let vec_type_len = NormalitemExtrainfo2::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<NormalitemExtrainfo2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(NormalitemExtrainfo2::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcNormalItemlist2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_info: {
                let field = vec_field.clone();
                field
            },
            item_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<NormalitemExtrainfo2>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNormalItemlist2 {
        let packet_id = i16::from_le_bytes([0xee, 0x01]);
        let packet_id_raw = [0xee, 0x01];
        PacketZcNormalItemlist2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcNormalItemlist2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNormalItemlist2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcCartNormalItemlist2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xef01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcCartNormalItemlist2 {
        let mut offset: usize = 0;
        let vec_type_len = NormalitemExtrainfo2::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<NormalitemExtrainfo2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(NormalitemExtrainfo2::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcCartNormalItemlist2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_info: {
                let field = vec_field.clone();
                field
            },
            item_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<NormalitemExtrainfo2>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcCartNormalItemlist2 {
        let packet_id = i16::from_le_bytes([0xef, 0x01]);
        let packet_id_raw = [0xef, 0x01];
        PacketZcCartNormalItemlist2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcCartNormalItemlist2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcCartNormalItemlist2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcStoreNormalItemlist2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf001"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcStoreNormalItemlist2 {
        let mut offset: usize = 0;
        let vec_type_len = NormalitemExtrainfo2::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<NormalitemExtrainfo2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(NormalitemExtrainfo2::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcStoreNormalItemlist2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_info: {
                let field = vec_field.clone();
                field
            },
            item_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<NormalitemExtrainfo2>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcStoreNormalItemlist2 {
        let packet_id = i16::from_le_bytes([0xf0, 0x01]);
        let packet_id_raw = [0xf0, 0x01];
        PacketZcStoreNormalItemlist2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcStoreNormalItemlist2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcStoreNormalItemlist2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcNotifyError {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf101"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcNotifyError {
        let mut offset: usize = 0;
        PacketAcNotifyError {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcNotifyError {
        let packet_id = i16::from_le_bytes([0xf1, 0x01]);
        let packet_id_raw = [0xf1, 0x01];
        PacketAcNotifyError {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketAcNotifyError {
    fn id(&self, packetver: u32) -> &str {
       PacketAcNotifyError::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcUpdateCharstat2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf201"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcUpdateCharstat2 {
        let mut offset: usize = 0;
        PacketZcUpdateCharstat2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            status: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            status_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            sex: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_palette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_palette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.status).unwrap();
        self.status_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_palette).unwrap();
        self.head_palette_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.status_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.head_palette_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 20;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_status(&mut self, value: i32) {
        self.status = value;
    }
    pub fn set_status_raw(&mut self, value: [u8; 4]) {
        self.status_raw = value;
    }
    pub fn set_sex(&mut self, value: i16) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 2]) {
        self.sex_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_head_palette(&mut self, value: i16) {
        self.head_palette = value;
    }
    pub fn set_head_palette_raw(&mut self, value: [u8; 2]) {
        self.head_palette_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcUpdateCharstat2 {
        let packet_id = i16::from_le_bytes([0xf2, 0x01]);
        let packet_id_raw = [0xf2, 0x01];
        PacketZcUpdateCharstat2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        status: 0,
        status_raw: [0; 4],
        sex: 0,
        sex_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        head_palette: 0,
        head_palette_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcUpdateCharstat2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcUpdateCharstat2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyEffect2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf301"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyEffect2 {
        let mut offset: usize = 0;
        PacketZcNotifyEffect2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            effect_id: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            effect_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_id).unwrap();
        self.effect_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.effect_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_effect_id(&mut self, value: i32) {
        self.effect_id = value;
    }
    pub fn set_effect_id_raw(&mut self, value: [u8; 4]) {
        self.effect_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyEffect2 {
        let packet_id = i16::from_le_bytes([0xf3, 0x01]);
        let packet_id_raw = [0xf3, 0x01];
        PacketZcNotifyEffect2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        effect_id: 0,
        effect_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyEffect2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyEffect2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcReqExchangeItem2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf401"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcReqExchangeItem2 {
        let mut offset: usize = 0;
        PacketZcReqExchangeItem2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 32;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcReqExchangeItem2 {
        let packet_id = i16::from_le_bytes([0xf4, 0x01]);
        let packet_id_raw = [0xf4, 0x01];
        PacketZcReqExchangeItem2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        name: [0 as char; 24],
        name_raw: [0; 24],
        gid: 0,
        gid_raw: [0; 4],
        level: 0,
        level_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcReqExchangeItem2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcReqExchangeItem2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckExchangeItem2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf501"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckExchangeItem2 {
        let mut offset: usize = 0;
        PacketZcAckExchangeItem2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 9;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckExchangeItem2 {
        let packet_id = i16::from_le_bytes([0xf5, 0x01]);
        let packet_id_raw = [0xf5, 0x01];
        PacketZcAckExchangeItem2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        level: 0,
        level_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAckExchangeItem2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckExchangeItem2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcReqBaby {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf601"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcReqBaby {
        let mut offset: usize = 0;
        PacketZcReqBaby {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 34;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcReqBaby {
        let packet_id = i16::from_le_bytes([0xf6, 0x01]);
        let packet_id_raw = [0xf6, 0x01];
        PacketZcReqBaby {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcReqBaby {
    fn id(&self, packetver: u32) -> &str {
       PacketZcReqBaby::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzJoinBaby {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf701"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzJoinBaby {
        let mut offset: usize = 0;
        PacketCzJoinBaby {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            answer: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            answer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_answer(&mut self, value: i32) {
        self.answer = value;
    }
    pub fn set_answer_raw(&mut self, value: [u8; 4]) {
        self.answer_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzJoinBaby {
        let packet_id = i16::from_le_bytes([0xf7, 0x01]);
        let packet_id_raw = [0xf7, 0x01];
        PacketCzJoinBaby {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        answer: 0,
        answer_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzJoinBaby {
    fn id(&self, packetver: u32) -> &str {
       PacketCzJoinBaby::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcStartBaby {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf801"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcStartBaby {
        let mut offset: usize = 0;
        PacketZcStartBaby {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcStartBaby {
        let packet_id = i16::from_le_bytes([0xf8, 0x01]);
        let packet_id_raw = [0xf8, 0x01];
        PacketZcStartBaby {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketZcStartBaby {
    fn id(&self, packetver: u32) -> &str {
       PacketZcStartBaby::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqJoinBaby {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf901"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqJoinBaby {
        let mut offset: usize = 0;
        PacketCzReqJoinBaby {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqJoinBaby {
        let packet_id = i16::from_le_bytes([0xf9, 0x01]);
        let packet_id_raw = [0xf9, 0x01];
        PacketCzReqJoinBaby {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqJoinBaby {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqJoinBaby::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCaLogin3 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xfa01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaLogin3 {
        let mut offset: usize = 0;
        PacketCaLogin3 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            version: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            id: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            passwd_md5: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            passwd_md5_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            clienttype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            client_info: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            client_info_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd_md5 {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_md5_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.client_info).unwrap();
        self.client_info_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.version_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.passwd_md5_raw.to_vec());
        wtr.append(&mut self.clienttype_raw.to_vec());
        wtr.append(&mut self.client_info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 48;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_version(&mut self, value: u32) {
        self.version = value;
    }
    pub fn set_version_raw(&mut self, value: [u8; 4]) {
        self.version_raw = value;
    }
    pub fn set_id(&mut self, value: [char; 24]) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 24]) {
        self.id_raw = value;
    }
    pub fn set_passwd_md5(&mut self, value: [char; 16]) {
        self.passwd_md5 = value;
    }
    pub fn set_passwd_md5_raw(&mut self, value: [u8; 16]) {
        self.passwd_md5_raw = value;
    }
    pub fn set_clienttype(&mut self, value: u8) {
        self.clienttype = value;
    }
    pub fn set_clienttype_raw(&mut self, value: [u8; 1]) {
        self.clienttype_raw = value;
    }
    pub fn set_client_info(&mut self, value: u8) {
        self.client_info = value;
    }
    pub fn set_client_info_raw(&mut self, value: [u8; 1]) {
        self.client_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaLogin3 {
        let packet_id = i16::from_le_bytes([0xfa, 0x01]);
        let packet_id_raw = [0xfa, 0x01];
        PacketCaLogin3 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        version: 0,
        version_raw: [0; 4],
        id: [0 as char; 24],
        id_raw: [0; 24],
        passwd_md5: [0 as char; 16],
        passwd_md5_raw: [0; 16],
        clienttype: 0,
        clienttype_raw: [0; 1],
        client_info: 0,
        client_info_raw: [0; 1],
        }
    }
}

impl Packet for PacketCaLogin3 {
    fn id(&self, packetver: u32) -> &str {
       PacketCaLogin3::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketChDeleteChar2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xfb01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketChDeleteChar2 {
        let mut offset: usize = 0;
        PacketChDeleteChar2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            key: {
                let field =  {
                let mut dst: [char; 50] = [0 as char; 50];
                for (index, byte) in buffer[offset..offset + 50].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            key_raw: {
                let mut dst: [u8; 50] = [0u8; 50];
                dst.clone_from_slice(&buffer[offset..offset + 50]);
                offset += 50;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.key {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.key_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.key_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 56;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_key(&mut self, value: [char; 50]) {
        self.key = value;
    }
    pub fn set_key_raw(&mut self, value: [u8; 50]) {
        self.key_raw = value;
    }
    pub fn new(packetver: u32) -> PacketChDeleteChar2 {
        let packet_id = i16::from_le_bytes([0xfb, 0x01]);
        let packet_id_raw = [0xfb, 0x01];
        PacketChDeleteChar2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        key: [0 as char; 50],
        key_raw: [0; 50],
        }
    }
}

impl Packet for PacketChDeleteChar2 {
    fn id(&self, packetver: u32) -> &str {
       PacketChDeleteChar2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcRepairitemlist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xfc01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcRepairitemlist {
        let mut offset: usize = 0;
        let vec_type_len = RepairitemInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<RepairitemInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(RepairitemInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcRepairitemlist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_list: {
                let field = vec_field.clone();
                field
            },
            item_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<RepairitemInfo>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcRepairitemlist {
        let packet_id = i16::from_le_bytes([0xfc, 0x01]);
        let packet_id_raw = [0xfc, 0x01];
        PacketZcRepairitemlist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcRepairitemlist {
    fn id(&self, packetver: u32) -> &str {
       PacketZcRepairitemlist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqItemrepair {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xfd01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqItemrepair {
        let mut offset: usize = 0;
        PacketCzReqItemrepair {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            target_item_info: {
                let field = RepairitemInfo::from(&buffer[offset..offset + RepairitemInfo::base_len(packetver)], packetver);
                field
            },
            target_item_info_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.target_item_info.fill_raw_with_packetver(packetver);
        self.target_item_info_raw = self.target_item_info.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.target_item_info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 1;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_target_item_info(&mut self, value: RepairitemInfo) {
        self.target_item_info = value;
    }
    pub fn set_target_item_info_raw(&mut self, value: Vec<u8>) {
        self.target_item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqItemrepair {
        let packet_id = i16::from_le_bytes([0xfd, 0x01]);
        let packet_id_raw = [0xfd, 0x01];
        PacketCzReqItemrepair {
        raw: vec![],
        packet_id,
        packet_id_raw,
        target_item_info: RepairitemInfo::new(packetver),
        target_item_info_raw: vec![],
        }
    }
}

impl Packet for PacketCzReqItemrepair {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqItemrepair::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckItemrepair {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xfe01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckItemrepair {
        let mut offset: usize = 0;
        PacketZcAckItemrepair {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckItemrepair {
        let packet_id = i16::from_le_bytes([0xfe, 0x01]);
        let packet_id_raw = [0xfe, 0x01];
        PacketZcAckItemrepair {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckItemrepair {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckItemrepair::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcHighjump {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xff01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcHighjump {
        let mut offset: usize = 0;
        PacketZcHighjump {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcHighjump {
        let packet_id = i16::from_le_bytes([0xff, 0x01]);
        let packet_id_raw = [0xff, 0x01];
        PacketZcHighjump {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcHighjump {
    fn id(&self, packetver: u32) -> &str {
       PacketZcHighjump::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCaConnectInfoChanged {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0002"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaConnectInfoChanged {
        let mut offset: usize = 0;
        PacketCaConnectInfoChanged {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            id: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_id(&mut self, value: [char; 24]) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 24]) {
        self.id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaConnectInfoChanged {
        let packet_id = i16::from_le_bytes([0x00, 0x02]);
        let packet_id_raw = [0x00, 0x02];
        PacketCaConnectInfoChanged {
        raw: vec![],
        packet_id,
        packet_id_raw,
        id: [0 as char; 24],
        id_raw: [0; 24],
        }
    }
}

impl Packet for PacketCaConnectInfoChanged {
    fn id(&self, packetver: u32) -> &str {
       PacketCaConnectInfoChanged::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcFriendsList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0102"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcFriendsList {
        let mut offset: usize = 0;
        let vec_type_len = FRIEND::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<FRIEND> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(FRIEND::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcFriendsList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            friend_list: {
                let field = vec_field.clone();
                field
            },
            friend_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.friend_list_raw = {
            self.friend_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.friend_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.friend_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_friend_list(&mut self, value: Vec<FRIEND>) {
        self.friend_list = value;
    }
    pub fn set_friend_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.friend_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcFriendsList {
        let packet_id = i16::from_le_bytes([0x01, 0x02]);
        let packet_id_raw = [0x01, 0x02];
        PacketZcFriendsList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        friend_list: vec![],
        friend_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcFriendsList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcFriendsList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzAddFriends {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0202"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzAddFriends {
        let mut offset: usize = 0;
        PacketCzAddFriends {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzAddFriends {
        let packet_id = i16::from_le_bytes([0x02, 0x02]);
        let packet_id_raw = [0x02, 0x02];
        PacketCzAddFriends {
        raw: vec![],
        packet_id,
        packet_id_raw,
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzAddFriends {
    fn id(&self, packetver: u32) -> &str {
       PacketCzAddFriends::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzDeleteFriends {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0302"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzDeleteFriends {
        let mut offset: usize = 0;
        PacketCzDeleteFriends {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzDeleteFriends {
        let packet_id = i16::from_le_bytes([0x03, 0x02]);
        let packet_id_raw = [0x03, 0x02];
        PacketCzDeleteFriends {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzDeleteFriends {
    fn id(&self, packetver: u32) -> &str {
       PacketCzDeleteFriends::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCaExeHashcheck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0402"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaExeHashcheck {
        let mut offset: usize = 0;
        PacketCaExeHashcheck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            hash_value: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            hash_value_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.hash_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.hash_value_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.hash_value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 18;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_hash_value(&mut self, value: [char; 16]) {
        self.hash_value = value;
    }
    pub fn set_hash_value_raw(&mut self, value: [u8; 16]) {
        self.hash_value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaExeHashcheck {
        let packet_id = i16::from_le_bytes([0x04, 0x02]);
        let packet_id_raw = [0x04, 0x02];
        PacketCaExeHashcheck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        hash_value: [0 as char; 16],
        hash_value_raw: [0; 16],
        }
    }
}

impl Packet for PacketCaExeHashcheck {
    fn id(&self, packetver: u32) -> &str {
       PacketCaExeHashcheck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcDivorce {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0502"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcDivorce {
        let mut offset: usize = 0;
        PacketZcDivorce {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcDivorce {
        let packet_id = i16::from_le_bytes([0x05, 0x02]);
        let packet_id_raw = [0x05, 0x02];
        PacketZcDivorce {
        raw: vec![],
        packet_id,
        packet_id_raw,
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcDivorce {
    fn id(&self, packetver: u32) -> &str {
       PacketZcDivorce::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcFriendsState {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0602"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcFriendsState {
        let mut offset: usize = 0;
        PacketZcFriendsState {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            state: {
                let field = buffer[offset] == 1;
                field
            },
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state as u8).unwrap();
        self.state_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 11;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_state(&mut self, value: bool) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcFriendsState {
        let packet_id = i16::from_le_bytes([0x06, 0x02]);
        let packet_id_raw = [0x06, 0x02];
        PacketZcFriendsState {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        state: false,
        state_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcFriendsState {
    fn id(&self, packetver: u32) -> &str {
       PacketZcFriendsState::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcReqAddFriends {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0702"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcReqAddFriends {
        let mut offset: usize = 0;
        PacketZcReqAddFriends {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            req_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            req_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            req_gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            req_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.req_aid).unwrap();
        self.req_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.req_gid).unwrap();
        self.req_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.req_aid_raw.to_vec());
        wtr.append(&mut self.req_gid_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 34;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_req_aid(&mut self, value: u32) {
        self.req_aid = value;
    }
    pub fn set_req_aid_raw(&mut self, value: [u8; 4]) {
        self.req_aid_raw = value;
    }
    pub fn set_req_gid(&mut self, value: u32) {
        self.req_gid = value;
    }
    pub fn set_req_gid_raw(&mut self, value: [u8; 4]) {
        self.req_gid_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcReqAddFriends {
        let packet_id = i16::from_le_bytes([0x07, 0x02]);
        let packet_id_raw = [0x07, 0x02];
        PacketZcReqAddFriends {
        raw: vec![],
        packet_id,
        packet_id_raw,
        req_aid: 0,
        req_aid_raw: [0; 4],
        req_gid: 0,
        req_gid_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcReqAddFriends {
    fn id(&self, packetver: u32) -> &str {
       PacketZcReqAddFriends::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzAckReqAddFriends {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0802"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzAckReqAddFriends {
        let mut offset: usize = 0;
        PacketCzAckReqAddFriends {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            req_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            req_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            req_gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            req_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            result: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.req_aid).unwrap();
        self.req_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.req_gid).unwrap();
        self.req_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.req_aid_raw.to_vec());
        wtr.append(&mut self.req_gid_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_req_aid(&mut self, value: u32) {
        self.req_aid = value;
    }
    pub fn set_req_aid_raw(&mut self, value: [u8; 4]) {
        self.req_aid_raw = value;
    }
    pub fn set_req_gid(&mut self, value: u32) {
        self.req_gid = value;
    }
    pub fn set_req_gid_raw(&mut self, value: [u8; 4]) {
        self.req_gid_raw = value;
    }
    pub fn set_result(&mut self, value: i32) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 4]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzAckReqAddFriends {
        let packet_id = i16::from_le_bytes([0x08, 0x02]);
        let packet_id_raw = [0x08, 0x02];
        PacketCzAckReqAddFriends {
        raw: vec![],
        packet_id,
        packet_id_raw,
        req_aid: 0,
        req_aid_raw: [0; 4],
        req_gid: 0,
        req_gid_raw: [0; 4],
        result: 0,
        result_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzAckReqAddFriends {
    fn id(&self, packetver: u32) -> &str {
       PacketCzAckReqAddFriends::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAddFriendsList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0902"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAddFriendsList {
        let mut offset: usize = 0;
        PacketZcAddFriendsList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 36;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAddFriendsList {
        let packet_id = i16::from_le_bytes([0x09, 0x02]);
        let packet_id_raw = [0x09, 0x02];
        PacketZcAddFriendsList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcAddFriendsList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAddFriendsList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcDeleteFriends {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0a02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcDeleteFriends {
        let mut offset: usize = 0;
        PacketZcDeleteFriends {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcDeleteFriends {
        let packet_id = i16::from_le_bytes([0x0a, 0x02]);
        let packet_id_raw = [0x0a, 0x02];
        PacketZcDeleteFriends {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDeleteFriends {
    fn id(&self, packetver: u32) -> &str {
       PacketZcDeleteFriends::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcRefuseLoginR3 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0b02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcRefuseLoginR3 {
        let mut offset: usize = 0;
        PacketAcRefuseLoginR3 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_code: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            error_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            block_date: {
                let field =  {
                let mut dst: [char; 20] = [0 as char; 20];
                for (index, byte) in buffer[offset..offset + 20].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            block_date_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[offset..offset + 20]);
                offset += 20;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.block_date {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.block_date_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        wtr.append(&mut self.block_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u32) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 4]) {
        self.error_code_raw = value;
    }
    pub fn set_block_date(&mut self, value: [char; 20]) {
        self.block_date = value;
    }
    pub fn set_block_date_raw(&mut self, value: [u8; 20]) {
        self.block_date_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcRefuseLoginR3 {
        let packet_id = i16::from_le_bytes([0x0b, 0x02]);
        let packet_id_raw = [0x0b, 0x02];
        PacketAcRefuseLoginR3 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_code: 0,
        error_code_raw: [0; 4],
        block_date: [0 as char; 20],
        block_date_raw: [0; 20],
        }
    }
}

impl Packet for PacketAcRefuseLoginR3 {
    fn id(&self, packetver: u32) -> &str {
       PacketAcRefuseLoginR3::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzExeHashcheck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0c02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzExeHashcheck {
        let mut offset: usize = 0;
        PacketCzExeHashcheck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            client_type: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            client_type_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            hash_value: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            hash_value_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.client_type).unwrap();
        self.client_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.hash_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.hash_value_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.client_type_raw.to_vec());
        wtr.append(&mut self.hash_value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 19;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_client_type(&mut self, value: u8) {
        self.client_type = value;
    }
    pub fn set_client_type_raw(&mut self, value: [u8; 1]) {
        self.client_type_raw = value;
    }
    pub fn set_hash_value(&mut self, value: [char; 16]) {
        self.hash_value = value;
    }
    pub fn set_hash_value_raw(&mut self, value: [u8; 16]) {
        self.hash_value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzExeHashcheck {
        let packet_id = i16::from_le_bytes([0x0c, 0x02]);
        let packet_id_raw = [0x0c, 0x02];
        PacketCzExeHashcheck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        client_type: 0,
        client_type_raw: [0; 1],
        hash_value: [0 as char; 16],
        hash_value_raw: [0; 16],
        }
    }
}

impl Packet for PacketCzExeHashcheck {
    fn id(&self, packetver: u32) -> &str {
       PacketCzExeHashcheck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcBlockCharacter {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0d02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcBlockCharacter {
        let mut offset: usize = 0;
        let vec_type_len = TagCharacterBlockInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<TagCharacterBlockInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(TagCharacterBlockInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketHcBlockCharacter {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            character_list: {
                let field = vec_field.clone();
                field
            },
            character_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.character_list_raw = {
            self.character_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.character_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.character_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_character_list(&mut self, value: Vec<TagCharacterBlockInfo>) {
        self.character_list = value;
    }
    pub fn set_character_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.character_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcBlockCharacter {
        let packet_id = i16::from_le_bytes([0x0d, 0x02]);
        let packet_id_raw = [0x0d, 0x02];
        PacketHcBlockCharacter {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        character_list: vec![],
        character_list_raw: vec![],
        }
    }
}

impl Packet for PacketHcBlockCharacter {
    fn id(&self, packetver: u32) -> &str {
       PacketHcBlockCharacter::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcStarskill {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0e02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcStarskill {
        let mut offset: usize = 0;
        PacketZcStarskill {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            map_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            map_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            monster_id: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            monster_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            star: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            star_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.monster_id).unwrap();
        self.monster_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.star).unwrap();
        self.star_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.monster_id_raw.to_vec());
        wtr.append(&mut self.star_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 32;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 24]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 24]) {
        self.map_name_raw = value;
    }
    pub fn set_monster_id(&mut self, value: i32) {
        self.monster_id = value;
    }
    pub fn set_monster_id_raw(&mut self, value: [u8; 4]) {
        self.monster_id_raw = value;
    }
    pub fn set_star(&mut self, value: u8) {
        self.star = value;
    }
    pub fn set_star_raw(&mut self, value: [u8; 1]) {
        self.star_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcStarskill {
        let packet_id = i16::from_le_bytes([0x0e, 0x02]);
        let packet_id_raw = [0x0e, 0x02];
        PacketZcStarskill {
        raw: vec![],
        packet_id,
        packet_id_raw,
        map_name: [0 as char; 24],
        map_name_raw: [0; 24],
        monster_id: 0,
        monster_id_raw: [0; 4],
        star: 0,
        star_raw: [0; 1],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcStarskill {
    fn id(&self, packetver: u32) -> &str {
       PacketZcStarskill::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqPvppoint {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0f02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqPvppoint {
        let mut offset: usize = 0;
        PacketCzReqPvppoint {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqPvppoint {
        let packet_id = i16::from_le_bytes([0x0f, 0x02]);
        let packet_id_raw = [0x0f, 0x02];
        PacketCzReqPvppoint {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqPvppoint {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqPvppoint::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckPvppoint {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1002"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckPvppoint {
        let mut offset: usize = 0;
        PacketZcAckPvppoint {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            pvp: {
                let field = PVPINFO::from(&buffer[offset..offset + PVPINFO::base_len(packetver)], packetver);
                field
            },
            pvp_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        self.pvp.fill_raw_with_packetver(packetver);
        self.pvp_raw = self.pvp.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.pvp_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 9;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_pvp(&mut self, value: PVPINFO) {
        self.pvp = value;
    }
    pub fn set_pvp_raw(&mut self, value: Vec<u8>) {
        self.pvp_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckPvppoint {
        let packet_id = i16::from_le_bytes([0x10, 0x02]);
        let packet_id_raw = [0x10, 0x02];
        PacketZcAckPvppoint {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        pvp: PVPINFO::new(packetver),
        pvp_raw: vec![],
        }
    }
}

impl Packet for PacketZcAckPvppoint {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckPvppoint::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZhMovePvpworld {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1102"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZhMovePvpworld {
        let mut offset: usize = 0;
        PacketZhMovePvpworld {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZhMovePvpworld {
        let packet_id = i16::from_le_bytes([0x11, 0x02]);
        let packet_id_raw = [0x11, 0x02];
        PacketZhMovePvpworld {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZhMovePvpworld {
    fn id(&self, packetver: u32) -> &str {
       PacketZhMovePvpworld::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqGiveMannerByname {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1202"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqGiveMannerByname {
        let mut offset: usize = 0;
        PacketCzReqGiveMannerByname {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            char_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.char_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_char_name(&mut self, value: [char; 24]) {
        self.char_name = value;
    }
    pub fn set_char_name_raw(&mut self, value: [u8; 24]) {
        self.char_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqGiveMannerByname {
        let packet_id = i16::from_le_bytes([0x12, 0x02]);
        let packet_id_raw = [0x12, 0x02];
        PacketCzReqGiveMannerByname {
        raw: vec![],
        packet_id,
        packet_id_raw,
        char_name: [0 as char; 24],
        char_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzReqGiveMannerByname {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqGiveMannerByname::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqStatusGm {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1302"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqStatusGm {
        let mut offset: usize = 0;
        PacketCzReqStatusGm {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            char_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.char_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_char_name(&mut self, value: [char; 24]) {
        self.char_name = value;
    }
    pub fn set_char_name_raw(&mut self, value: [u8; 24]) {
        self.char_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqStatusGm {
        let packet_id = i16::from_le_bytes([0x13, 0x02]);
        let packet_id_raw = [0x13, 0x02];
        PacketCzReqStatusGm {
        raw: vec![],
        packet_id,
        packet_id_raw,
        char_name: [0 as char; 24],
        char_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzReqStatusGm {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqStatusGm::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckStatusGm {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1402"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckStatusGm {
        let mut offset: usize = 0;
        PacketZcAckStatusGm {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            str: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            str_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            standard_str: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            standard_str_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            agi: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            agi_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            standard_agi: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            standard_agi_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            vit: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            vit_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            standard_vit: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            standard_vit_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            int: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            int_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            standard_int: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            standard_int_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            dex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            dex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            standard_dex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            standard_dex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            luk: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            luk_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            standard_luk: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            standard_luk_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            att_power: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            att_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            refining_power: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            refining_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            max_matt_power: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            max_matt_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            min_matt_power: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            min_matt_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itemdef_power: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itemdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            plusdef_power: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            plusdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mdef_power: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            mdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            plusmdef_power: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            plusmdef_power_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            hit_success_value: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            hit_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            avoid_success_value: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            avoid_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            plus_avoid_success_value: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            plus_avoid_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            critical_success_value: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            critical_success_value_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aspd: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            plus_aspd: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            plus_aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.str).unwrap();
        self.str_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_str).unwrap();
        self.standard_str_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.agi).unwrap();
        self.agi_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_agi).unwrap();
        self.standard_agi_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.vit).unwrap();
        self.vit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_vit).unwrap();
        self.standard_vit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.int).unwrap();
        self.int_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_int).unwrap();
        self.standard_int_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dex).unwrap();
        self.dex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_dex).unwrap();
        self.standard_dex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.luk).unwrap();
        self.luk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.standard_luk).unwrap();
        self.standard_luk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.att_power).unwrap();
        self.att_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.refining_power).unwrap();
        self.refining_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_matt_power).unwrap();
        self.max_matt_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.min_matt_power).unwrap();
        self.min_matt_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.itemdef_power).unwrap();
        self.itemdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plusdef_power).unwrap();
        self.plusdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef_power).unwrap();
        self.mdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plusmdef_power).unwrap();
        self.plusmdef_power_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hit_success_value).unwrap();
        self.hit_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.avoid_success_value).unwrap();
        self.avoid_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plus_avoid_success_value).unwrap();
        self.plus_avoid_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.critical_success_value).unwrap();
        self.critical_success_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.aspd).unwrap();
        self.aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.plus_aspd).unwrap();
        self.plus_aspd_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.str_raw.to_vec());
        wtr.append(&mut self.standard_str_raw.to_vec());
        wtr.append(&mut self.agi_raw.to_vec());
        wtr.append(&mut self.standard_agi_raw.to_vec());
        wtr.append(&mut self.vit_raw.to_vec());
        wtr.append(&mut self.standard_vit_raw.to_vec());
        wtr.append(&mut self.int_raw.to_vec());
        wtr.append(&mut self.standard_int_raw.to_vec());
        wtr.append(&mut self.dex_raw.to_vec());
        wtr.append(&mut self.standard_dex_raw.to_vec());
        wtr.append(&mut self.luk_raw.to_vec());
        wtr.append(&mut self.standard_luk_raw.to_vec());
        wtr.append(&mut self.att_power_raw.to_vec());
        wtr.append(&mut self.refining_power_raw.to_vec());
        wtr.append(&mut self.max_matt_power_raw.to_vec());
        wtr.append(&mut self.min_matt_power_raw.to_vec());
        wtr.append(&mut self.itemdef_power_raw.to_vec());
        wtr.append(&mut self.plusdef_power_raw.to_vec());
        wtr.append(&mut self.mdef_power_raw.to_vec());
        wtr.append(&mut self.plusmdef_power_raw.to_vec());
        wtr.append(&mut self.hit_success_value_raw.to_vec());
        wtr.append(&mut self.avoid_success_value_raw.to_vec());
        wtr.append(&mut self.plus_avoid_success_value_raw.to_vec());
        wtr.append(&mut self.critical_success_value_raw.to_vec());
        wtr.append(&mut self.aspd_raw.to_vec());
        wtr.append(&mut self.plus_aspd_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 42;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_str(&mut self, value: u8) {
        self.str = value;
    }
    pub fn set_str_raw(&mut self, value: [u8; 1]) {
        self.str_raw = value;
    }
    pub fn set_standard_str(&mut self, value: u8) {
        self.standard_str = value;
    }
    pub fn set_standard_str_raw(&mut self, value: [u8; 1]) {
        self.standard_str_raw = value;
    }
    pub fn set_agi(&mut self, value: u8) {
        self.agi = value;
    }
    pub fn set_agi_raw(&mut self, value: [u8; 1]) {
        self.agi_raw = value;
    }
    pub fn set_standard_agi(&mut self, value: u8) {
        self.standard_agi = value;
    }
    pub fn set_standard_agi_raw(&mut self, value: [u8; 1]) {
        self.standard_agi_raw = value;
    }
    pub fn set_vit(&mut self, value: u8) {
        self.vit = value;
    }
    pub fn set_vit_raw(&mut self, value: [u8; 1]) {
        self.vit_raw = value;
    }
    pub fn set_standard_vit(&mut self, value: u8) {
        self.standard_vit = value;
    }
    pub fn set_standard_vit_raw(&mut self, value: [u8; 1]) {
        self.standard_vit_raw = value;
    }
    pub fn set_int(&mut self, value: u8) {
        self.int = value;
    }
    pub fn set_int_raw(&mut self, value: [u8; 1]) {
        self.int_raw = value;
    }
    pub fn set_standard_int(&mut self, value: u8) {
        self.standard_int = value;
    }
    pub fn set_standard_int_raw(&mut self, value: [u8; 1]) {
        self.standard_int_raw = value;
    }
    pub fn set_dex(&mut self, value: u8) {
        self.dex = value;
    }
    pub fn set_dex_raw(&mut self, value: [u8; 1]) {
        self.dex_raw = value;
    }
    pub fn set_standard_dex(&mut self, value: u8) {
        self.standard_dex = value;
    }
    pub fn set_standard_dex_raw(&mut self, value: [u8; 1]) {
        self.standard_dex_raw = value;
    }
    pub fn set_luk(&mut self, value: u8) {
        self.luk = value;
    }
    pub fn set_luk_raw(&mut self, value: [u8; 1]) {
        self.luk_raw = value;
    }
    pub fn set_standard_luk(&mut self, value: u8) {
        self.standard_luk = value;
    }
    pub fn set_standard_luk_raw(&mut self, value: [u8; 1]) {
        self.standard_luk_raw = value;
    }
    pub fn set_att_power(&mut self, value: i16) {
        self.att_power = value;
    }
    pub fn set_att_power_raw(&mut self, value: [u8; 2]) {
        self.att_power_raw = value;
    }
    pub fn set_refining_power(&mut self, value: i16) {
        self.refining_power = value;
    }
    pub fn set_refining_power_raw(&mut self, value: [u8; 2]) {
        self.refining_power_raw = value;
    }
    pub fn set_max_matt_power(&mut self, value: i16) {
        self.max_matt_power = value;
    }
    pub fn set_max_matt_power_raw(&mut self, value: [u8; 2]) {
        self.max_matt_power_raw = value;
    }
    pub fn set_min_matt_power(&mut self, value: i16) {
        self.min_matt_power = value;
    }
    pub fn set_min_matt_power_raw(&mut self, value: [u8; 2]) {
        self.min_matt_power_raw = value;
    }
    pub fn set_itemdef_power(&mut self, value: i16) {
        self.itemdef_power = value;
    }
    pub fn set_itemdef_power_raw(&mut self, value: [u8; 2]) {
        self.itemdef_power_raw = value;
    }
    pub fn set_plusdef_power(&mut self, value: i16) {
        self.plusdef_power = value;
    }
    pub fn set_plusdef_power_raw(&mut self, value: [u8; 2]) {
        self.plusdef_power_raw = value;
    }
    pub fn set_mdef_power(&mut self, value: i16) {
        self.mdef_power = value;
    }
    pub fn set_mdef_power_raw(&mut self, value: [u8; 2]) {
        self.mdef_power_raw = value;
    }
    pub fn set_plusmdef_power(&mut self, value: i16) {
        self.plusmdef_power = value;
    }
    pub fn set_plusmdef_power_raw(&mut self, value: [u8; 2]) {
        self.plusmdef_power_raw = value;
    }
    pub fn set_hit_success_value(&mut self, value: i16) {
        self.hit_success_value = value;
    }
    pub fn set_hit_success_value_raw(&mut self, value: [u8; 2]) {
        self.hit_success_value_raw = value;
    }
    pub fn set_avoid_success_value(&mut self, value: i16) {
        self.avoid_success_value = value;
    }
    pub fn set_avoid_success_value_raw(&mut self, value: [u8; 2]) {
        self.avoid_success_value_raw = value;
    }
    pub fn set_plus_avoid_success_value(&mut self, value: i16) {
        self.plus_avoid_success_value = value;
    }
    pub fn set_plus_avoid_success_value_raw(&mut self, value: [u8; 2]) {
        self.plus_avoid_success_value_raw = value;
    }
    pub fn set_critical_success_value(&mut self, value: i16) {
        self.critical_success_value = value;
    }
    pub fn set_critical_success_value_raw(&mut self, value: [u8; 2]) {
        self.critical_success_value_raw = value;
    }
    pub fn set_aspd(&mut self, value: i16) {
        self.aspd = value;
    }
    pub fn set_aspd_raw(&mut self, value: [u8; 2]) {
        self.aspd_raw = value;
    }
    pub fn set_plus_aspd(&mut self, value: i16) {
        self.plus_aspd = value;
    }
    pub fn set_plus_aspd_raw(&mut self, value: [u8; 2]) {
        self.plus_aspd_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckStatusGm {
        let packet_id = i16::from_le_bytes([0x14, 0x02]);
        let packet_id_raw = [0x14, 0x02];
        PacketZcAckStatusGm {
        raw: vec![],
        packet_id,
        packet_id_raw,
        str: 0,
        str_raw: [0; 1],
        standard_str: 0,
        standard_str_raw: [0; 1],
        agi: 0,
        agi_raw: [0; 1],
        standard_agi: 0,
        standard_agi_raw: [0; 1],
        vit: 0,
        vit_raw: [0; 1],
        standard_vit: 0,
        standard_vit_raw: [0; 1],
        int: 0,
        int_raw: [0; 1],
        standard_int: 0,
        standard_int_raw: [0; 1],
        dex: 0,
        dex_raw: [0; 1],
        standard_dex: 0,
        standard_dex_raw: [0; 1],
        luk: 0,
        luk_raw: [0; 1],
        standard_luk: 0,
        standard_luk_raw: [0; 1],
        att_power: 0,
        att_power_raw: [0; 2],
        refining_power: 0,
        refining_power_raw: [0; 2],
        max_matt_power: 0,
        max_matt_power_raw: [0; 2],
        min_matt_power: 0,
        min_matt_power_raw: [0; 2],
        itemdef_power: 0,
        itemdef_power_raw: [0; 2],
        plusdef_power: 0,
        plusdef_power_raw: [0; 2],
        mdef_power: 0,
        mdef_power_raw: [0; 2],
        plusmdef_power: 0,
        plusmdef_power_raw: [0; 2],
        hit_success_value: 0,
        hit_success_value_raw: [0; 2],
        avoid_success_value: 0,
        avoid_success_value_raw: [0; 2],
        plus_avoid_success_value: 0,
        plus_avoid_success_value_raw: [0; 2],
        critical_success_value: 0,
        critical_success_value_raw: [0; 2],
        aspd: 0,
        aspd_raw: [0; 2],
        plus_aspd: 0,
        plus_aspd_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAckStatusGm {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckStatusGm::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSkillmsg {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1502"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSkillmsg {
        let mut offset: usize = 0;
        PacketZcSkillmsg {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msg_no: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            msg_no_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.msg_no).unwrap();
        self.msg_no_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.msg_no_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_msg_no(&mut self, value: i32) {
        self.msg_no = value;
    }
    pub fn set_msg_no_raw(&mut self, value: [u8; 4]) {
        self.msg_no_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSkillmsg {
        let packet_id = i16::from_le_bytes([0x15, 0x02]);
        let packet_id_raw = [0x15, 0x02];
        PacketZcSkillmsg {
        raw: vec![],
        packet_id,
        packet_id_raw,
        msg_no: 0,
        msg_no_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcSkillmsg {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSkillmsg::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcBabymsg {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1602"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcBabymsg {
        let mut offset: usize = 0;
        PacketZcBabymsg {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msg_no: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            msg_no_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.msg_no).unwrap();
        self.msg_no_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.msg_no_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_msg_no(&mut self, value: i32) {
        self.msg_no = value;
    }
    pub fn set_msg_no_raw(&mut self, value: [u8; 4]) {
        self.msg_no_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcBabymsg {
        let packet_id = i16::from_le_bytes([0x16, 0x02]);
        let packet_id_raw = [0x16, 0x02];
        PacketZcBabymsg {
        raw: vec![],
        packet_id,
        packet_id_raw,
        msg_no: 0,
        msg_no_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcBabymsg {
    fn id(&self, packetver: u32) -> &str {
       PacketZcBabymsg::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzBlacksmithRank {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1702"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzBlacksmithRank {
        let mut offset: usize = 0;
        PacketCzBlacksmithRank {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzBlacksmithRank {
        let packet_id = i16::from_le_bytes([0x17, 0x02]);
        let packet_id_raw = [0x17, 0x02];
        PacketCzBlacksmithRank {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzBlacksmithRank {
    fn id(&self, packetver: u32) -> &str {
       PacketCzBlacksmithRank::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzAlchemistRank {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1802"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzAlchemistRank {
        let mut offset: usize = 0;
        PacketCzAlchemistRank {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzAlchemistRank {
        let packet_id = i16::from_le_bytes([0x18, 0x02]);
        let packet_id_raw = [0x18, 0x02];
        PacketCzAlchemistRank {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzAlchemistRank {
    fn id(&self, packetver: u32) -> &str {
       PacketCzAlchemistRank::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcBlacksmithRank {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1902"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcBlacksmithRank {
        let mut offset: usize = 0;
        PacketZcBlacksmithRank {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 10] = [0 as char; 10];
                for (index, byte) in buffer[offset..offset + 10].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[offset..offset + 10]);
                offset += 10;
                dst
            },
            point: {
                let field =  {
                let mut dst: [i32; 10] = [0_i32; 10];
                for (index, byte) in buffer[offset..offset + 10].iter().enumerate() {
                    dst[index] = *byte as i32;
                }
                dst
            };
                field
            },
            point_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[offset..offset + 40]);
                offset += 40;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.point {
            wtr.write_i32::<LittleEndian>(item).unwrap();
        }
        self.point_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 22;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 10]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 10]) {
        self.name_raw = value;
    }
    pub fn set_point(&mut self, value: [i32; 10]) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 40]) {
        self.point_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcBlacksmithRank {
        let packet_id = i16::from_le_bytes([0x19, 0x02]);
        let packet_id_raw = [0x19, 0x02];
        PacketZcBlacksmithRank {
        raw: vec![],
        packet_id,
        packet_id_raw,
        name: [0 as char; 10],
        name_raw: [0; 10],
        point: [0; 10],
        point_raw: [0; 40],
        }
    }
}

impl Packet for PacketZcBlacksmithRank {
    fn id(&self, packetver: u32) -> &str {
       PacketZcBlacksmithRank::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAlchemistRank {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1a02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAlchemistRank {
        let mut offset: usize = 0;
        PacketZcAlchemistRank {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 10] = [0 as char; 10];
                for (index, byte) in buffer[offset..offset + 10].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[offset..offset + 10]);
                offset += 10;
                dst
            },
            point: {
                let field =  {
                let mut dst: [i32; 10] = [0_i32; 10];
                for (index, byte) in buffer[offset..offset + 10].iter().enumerate() {
                    dst[index] = *byte as i32;
                }
                dst
            };
                field
            },
            point_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[offset..offset + 40]);
                offset += 40;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.point {
            wtr.write_i32::<LittleEndian>(item).unwrap();
        }
        self.point_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 22;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 10]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 10]) {
        self.name_raw = value;
    }
    pub fn set_point(&mut self, value: [i32; 10]) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 40]) {
        self.point_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAlchemistRank {
        let packet_id = i16::from_le_bytes([0x1a, 0x02]);
        let packet_id_raw = [0x1a, 0x02];
        PacketZcAlchemistRank {
        raw: vec![],
        packet_id,
        packet_id_raw,
        name: [0 as char; 10],
        name_raw: [0; 10],
        point: [0; 10],
        point_raw: [0; 40],
        }
    }
}

impl Packet for PacketZcAlchemistRank {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAlchemistRank::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcBlacksmithPoint {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1b02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcBlacksmithPoint {
        let mut offset: usize = 0;
        PacketZcBlacksmithPoint {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            point: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            total_point: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            total_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.total_point).unwrap();
        self.total_point_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        wtr.append(&mut self.total_point_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_point(&mut self, value: i32) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 4]) {
        self.point_raw = value;
    }
    pub fn set_total_point(&mut self, value: i32) {
        self.total_point = value;
    }
    pub fn set_total_point_raw(&mut self, value: [u8; 4]) {
        self.total_point_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcBlacksmithPoint {
        let packet_id = i16::from_le_bytes([0x1b, 0x02]);
        let packet_id_raw = [0x1b, 0x02];
        PacketZcBlacksmithPoint {
        raw: vec![],
        packet_id,
        packet_id_raw,
        point: 0,
        point_raw: [0; 4],
        total_point: 0,
        total_point_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcBlacksmithPoint {
    fn id(&self, packetver: u32) -> &str {
       PacketZcBlacksmithPoint::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAlchemistPoint {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1c02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAlchemistPoint {
        let mut offset: usize = 0;
        PacketZcAlchemistPoint {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            point: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            total_point: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            total_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.total_point).unwrap();
        self.total_point_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        wtr.append(&mut self.total_point_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_point(&mut self, value: i32) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 4]) {
        self.point_raw = value;
    }
    pub fn set_total_point(&mut self, value: i32) {
        self.total_point = value;
    }
    pub fn set_total_point_raw(&mut self, value: [u8; 4]) {
        self.total_point_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAlchemistPoint {
        let packet_id = i16::from_le_bytes([0x1c, 0x02]);
        let packet_id_raw = [0x1c, 0x02];
        PacketZcAlchemistPoint {
        raw: vec![],
        packet_id,
        packet_id_raw,
        point: 0,
        point_raw: [0; 4],
        total_point: 0,
        total_point_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcAlchemistPoint {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAlchemistPoint::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzLesseffect {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1d02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzLesseffect {
        let mut offset: usize = 0;
        PacketCzLesseffect {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_less: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            is_less_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.is_less).unwrap();
        self.is_less_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.is_less_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_is_less(&mut self, value: i32) {
        self.is_less = value;
    }
    pub fn set_is_less_raw(&mut self, value: [u8; 4]) {
        self.is_less_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzLesseffect {
        let packet_id = i16::from_le_bytes([0x1d, 0x02]);
        let packet_id_raw = [0x1d, 0x02];
        PacketCzLesseffect {
        raw: vec![],
        packet_id,
        packet_id_raw,
        is_less: 0,
        is_less_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzLesseffect {
    fn id(&self, packetver: u32) -> &str {
       PacketCzLesseffect::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcLesseffect {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1e02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcLesseffect {
        let mut offset: usize = 0;
        PacketZcLesseffect {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_less: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            is_less_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.is_less).unwrap();
        self.is_less_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.is_less_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_is_less(&mut self, value: i32) {
        self.is_less = value;
    }
    pub fn set_is_less_raw(&mut self, value: [u8; 4]) {
        self.is_less_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcLesseffect {
        let packet_id = i16::from_le_bytes([0x1e, 0x02]);
        let packet_id_raw = [0x1e, 0x02];
        PacketZcLesseffect {
        raw: vec![],
        packet_id,
        packet_id_raw,
        is_less: 0,
        is_less_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcLesseffect {
    fn id(&self, packetver: u32) -> &str {
       PacketZcLesseffect::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyPkinfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1f02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyPkinfo {
        let mut offset: usize = 0;
        PacketZcNotifyPkinfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            win_point: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            win_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            lose_point: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            lose_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            kill_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            kill_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            killed_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            killed_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            expire_time: {
                let field = Filetime::from(&buffer[offset..offset + Filetime::base_len(packetver)], packetver);
                field
            },
            expire_time_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.win_point).unwrap();
        self.win_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.lose_point).unwrap();
        self.lose_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.kill_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.kill_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.killed_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.killed_name_raw = wtr.try_into().unwrap();
        self.expire_time.fill_raw_with_packetver(packetver);
        self.expire_time_raw = self.expire_time.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.win_point_raw.to_vec());
        wtr.append(&mut self.lose_point_raw.to_vec());
        wtr.append(&mut self.kill_name_raw.to_vec());
        wtr.append(&mut self.killed_name_raw.to_vec());
        wtr.append(&mut self.expire_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 57;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_win_point(&mut self, value: i32) {
        self.win_point = value;
    }
    pub fn set_win_point_raw(&mut self, value: [u8; 4]) {
        self.win_point_raw = value;
    }
    pub fn set_lose_point(&mut self, value: i32) {
        self.lose_point = value;
    }
    pub fn set_lose_point_raw(&mut self, value: [u8; 4]) {
        self.lose_point_raw = value;
    }
    pub fn set_kill_name(&mut self, value: [char; 24]) {
        self.kill_name = value;
    }
    pub fn set_kill_name_raw(&mut self, value: [u8; 24]) {
        self.kill_name_raw = value;
    }
    pub fn set_killed_name(&mut self, value: [char; 24]) {
        self.killed_name = value;
    }
    pub fn set_killed_name_raw(&mut self, value: [u8; 24]) {
        self.killed_name_raw = value;
    }
    pub fn set_expire_time(&mut self, value: Filetime) {
        self.expire_time = value;
    }
    pub fn set_expire_time_raw(&mut self, value: Vec<u8>) {
        self.expire_time_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyPkinfo {
        let packet_id = i16::from_le_bytes([0x1f, 0x02]);
        let packet_id_raw = [0x1f, 0x02];
        PacketZcNotifyPkinfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        win_point: 0,
        win_point_raw: [0; 4],
        lose_point: 0,
        lose_point_raw: [0; 4],
        kill_name: [0 as char; 24],
        kill_name_raw: [0; 24],
        killed_name: [0 as char; 24],
        killed_name_raw: [0; 24],
        expire_time: Filetime::new(packetver),
        expire_time_raw: vec![],
        }
    }
}

impl Packet for PacketZcNotifyPkinfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyPkinfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyCrazykiller {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2002"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyCrazykiller {
        let mut offset: usize = 0;
        PacketZcNotifyCrazykiller {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_crazy_killer: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            is_crazy_killer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.is_crazy_killer).unwrap();
        self.is_crazy_killer_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.is_crazy_killer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_is_crazy_killer(&mut self, value: i32) {
        self.is_crazy_killer = value;
    }
    pub fn set_is_crazy_killer_raw(&mut self, value: [u8; 4]) {
        self.is_crazy_killer_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyCrazykiller {
        let packet_id = i16::from_le_bytes([0x20, 0x02]);
        let packet_id_raw = [0x20, 0x02];
        PacketZcNotifyCrazykiller {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        is_crazy_killer: 0,
        is_crazy_killer_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyCrazykiller {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyCrazykiller::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyWeaponitemlist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2102"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyWeaponitemlist {
        let mut offset: usize = 0;
        let vec_type_len = RepairitemInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<RepairitemInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(RepairitemInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcNotifyWeaponitemlist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_list: {
                let field = vec_field.clone();
                field
            },
            item_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<RepairitemInfo>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyWeaponitemlist {
        let packet_id = i16::from_le_bytes([0x21, 0x02]);
        let packet_id_raw = [0x21, 0x02];
        PacketZcNotifyWeaponitemlist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcNotifyWeaponitemlist {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyWeaponitemlist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqWeaponrefine {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2202"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqWeaponrefine {
        let mut offset: usize = 0;
        PacketCzReqWeaponrefine {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i32) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 4]) {
        self.index_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqWeaponrefine {
        let packet_id = i16::from_le_bytes([0x22, 0x02]);
        let packet_id_raw = [0x22, 0x02];
        PacketCzReqWeaponrefine {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqWeaponrefine {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqWeaponrefine::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckWeaponrefine {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2302"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckWeaponrefine {
        let mut offset: usize = 0;
        PacketZcAckWeaponrefine {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msg: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            msg_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.msg).unwrap();
        self.msg_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_msg(&mut self, value: i32) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: [u8; 4]) {
        self.msg_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckWeaponrefine {
        let packet_id = i16::from_le_bytes([0x23, 0x02]);
        let packet_id_raw = [0x23, 0x02];
        PacketZcAckWeaponrefine {
        raw: vec![],
        packet_id,
        packet_id_raw,
        msg: 0,
        msg_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAckWeaponrefine {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckWeaponrefine::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcTaekwonPoint {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2402"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcTaekwonPoint {
        let mut offset: usize = 0;
        PacketZcTaekwonPoint {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            point: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            total_point: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            total_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.total_point).unwrap();
        self.total_point_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        wtr.append(&mut self.total_point_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_point(&mut self, value: i32) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 4]) {
        self.point_raw = value;
    }
    pub fn set_total_point(&mut self, value: i32) {
        self.total_point = value;
    }
    pub fn set_total_point_raw(&mut self, value: [u8; 4]) {
        self.total_point_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcTaekwonPoint {
        let packet_id = i16::from_le_bytes([0x24, 0x02]);
        let packet_id_raw = [0x24, 0x02];
        PacketZcTaekwonPoint {
        raw: vec![],
        packet_id,
        packet_id_raw,
        point: 0,
        point_raw: [0; 4],
        total_point: 0,
        total_point_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcTaekwonPoint {
    fn id(&self, packetver: u32) -> &str {
       PacketZcTaekwonPoint::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzTaekwonRank {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2502"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzTaekwonRank {
        let mut offset: usize = 0;
        PacketCzTaekwonRank {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzTaekwonRank {
        let packet_id = i16::from_le_bytes([0x25, 0x02]);
        let packet_id_raw = [0x25, 0x02];
        PacketCzTaekwonRank {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzTaekwonRank {
    fn id(&self, packetver: u32) -> &str {
       PacketCzTaekwonRank::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcTaekwonRank {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2602"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcTaekwonRank {
        let mut offset: usize = 0;
        PacketZcTaekwonRank {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 10] = [0 as char; 10];
                for (index, byte) in buffer[offset..offset + 10].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[offset..offset + 10]);
                offset += 10;
                dst
            },
            point: {
                let field =  {
                let mut dst: [i32; 10] = [0_i32; 10];
                for (index, byte) in buffer[offset..offset + 10].iter().enumerate() {
                    dst[index] = *byte as i32;
                }
                dst
            };
                field
            },
            point_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[offset..offset + 40]);
                offset += 40;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.point {
            wtr.write_i32::<LittleEndian>(item).unwrap();
        }
        self.point_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 22;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 10]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 10]) {
        self.name_raw = value;
    }
    pub fn set_point(&mut self, value: [i32; 10]) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 40]) {
        self.point_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcTaekwonRank {
        let packet_id = i16::from_le_bytes([0x26, 0x02]);
        let packet_id_raw = [0x26, 0x02];
        PacketZcTaekwonRank {
        raw: vec![],
        packet_id,
        packet_id_raw,
        name: [0 as char; 10],
        name_raw: [0; 10],
        point: [0; 10],
        point_raw: [0; 40],
        }
    }
}

impl Packet for PacketZcTaekwonRank {
    fn id(&self, packetver: u32) -> &str {
       PacketZcTaekwonRank::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcGameGuard {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2702"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcGameGuard {
        let mut offset: usize = 0;
        PacketZcGameGuard {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            auth_data: {
                let field =  {
                let mut dst: [u32; 4] = [0_u32; 4];
                for (index, byte) in buffer[offset..offset + 4].iter().enumerate() {
                    dst[index] = *byte as u32;
                }
                dst
            };
                field
            },
            auth_data_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.auth_data {
            wtr.write_u32::<LittleEndian>(item).unwrap();
        }
        self.auth_data_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.auth_data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_auth_data(&mut self, value: [u32; 4]) {
        self.auth_data = value;
    }
    pub fn set_auth_data_raw(&mut self, value: [u8; 16]) {
        self.auth_data_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcGameGuard {
        let packet_id = i16::from_le_bytes([0x27, 0x02]);
        let packet_id_raw = [0x27, 0x02];
        PacketZcGameGuard {
        raw: vec![],
        packet_id,
        packet_id_raw,
        auth_data: [0; 4],
        auth_data_raw: [0; 16],
        }
    }
}

impl Packet for PacketZcGameGuard {
    fn id(&self, packetver: u32) -> &str {
       PacketZcGameGuard::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzAckGameGuard {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2802"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzAckGameGuard {
        let mut offset: usize = 0;
        PacketCzAckGameGuard {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            auth_data: {
                let field =  {
                let mut dst: [u32; 4] = [0_u32; 4];
                for (index, byte) in buffer[offset..offset + 4].iter().enumerate() {
                    dst[index] = *byte as u32;
                }
                dst
            };
                field
            },
            auth_data_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.auth_data {
            wtr.write_u32::<LittleEndian>(item).unwrap();
        }
        self.auth_data_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.auth_data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_auth_data(&mut self, value: [u32; 4]) {
        self.auth_data = value;
    }
    pub fn set_auth_data_raw(&mut self, value: [u8; 16]) {
        self.auth_data_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzAckGameGuard {
        let packet_id = i16::from_le_bytes([0x28, 0x02]);
        let packet_id_raw = [0x28, 0x02];
        PacketCzAckGameGuard {
        raw: vec![],
        packet_id,
        packet_id_raw,
        auth_data: [0; 4],
        auth_data_raw: [0; 16],
        }
    }
}

impl Packet for PacketCzAckGameGuard {
    fn id(&self, packetver: u32) -> &str {
       PacketCzAckGameGuard::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcStateChange3 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2902"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcStateChange3 {
        let mut offset: usize = 0;
        PacketZcStateChange3 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 15;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcStateChange3 {
        let packet_id = i16::from_le_bytes([0x29, 0x02]);
        let packet_id_raw = [0x29, 0x02];
        PacketZcStateChange3 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcStateChange3 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcStateChange3::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyStandentry3 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2a02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyStandentry3 {
        let mut offset: usize = 0;
        PacketZcNotifyStandentry3 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory2: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gemblem_ver: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            honor: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            virtue: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            pos_dir: {
                let field =  {
                let mut dst: [u8; 3] = [0_u8; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[offset..offset + 3]);
                offset += 3;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            state: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            clevel: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 58;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [u8; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_state(&mut self, value: u8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyStandentry3 {
        let packet_id = i16::from_le_bytes([0x2a, 0x02]);
        let packet_id_raw = [0x2a, 0x02];
        PacketZcNotifyStandentry3 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        state: 0,
        state_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyStandentry3 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyStandentry3::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyNewentry3 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2b02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyNewentry3 {
        let mut offset: usize = 0;
        PacketZcNotifyNewentry3 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory2: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gemblem_ver: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            honor: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            virtue: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            pos_dir: {
                let field =  {
                let mut dst: [u8; 3] = [0_u8; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[offset..offset + 3]);
                offset += 3;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            clevel: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 57;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [u8; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyNewentry3 {
        let packet_id = i16::from_le_bytes([0x2b, 0x02]);
        let packet_id_raw = [0x2b, 0x02];
        PacketZcNotifyNewentry3 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyNewentry3 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyNewentry3::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyMoveentry3 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2c02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyMoveentry3 {
        let mut offset: usize = 0;
        PacketZcNotifyMoveentry3 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            objecttype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            move_start_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory2: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gemblem_ver: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            honor: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            virtue: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            move_data: {
                let field =  {
                let mut dst: [u16; 6] = [0_u16; 6];
                for (index, byte) in buffer[offset..offset + 6].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            };
                field
            },
            move_data_raw: {
                let mut dst: [u8; 12] = [0u8; 12];
                dst.clone_from_slice(&buffer[offset..offset + 12]);
                offset += 12;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            clevel: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.objecttype_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.move_start_time_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.move_data_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 65;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_objecttype(&mut self, value: u8) {
        self.objecttype = value;
    }
    pub fn set_objecttype_raw(&mut self, value: [u8; 1]) {
        self.objecttype_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_move_start_time(&mut self, value: u32) {
        self.move_start_time = value;
    }
    pub fn set_move_start_time_raw(&mut self, value: [u8; 4]) {
        self.move_start_time_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_move_data(&mut self, value: [u16; 6]) {
        self.move_data = value;
    }
    pub fn set_move_data_raw(&mut self, value: [u8; 12]) {
        self.move_data_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyMoveentry3 {
        let packet_id = i16::from_le_bytes([0x2c, 0x02]);
        let packet_id_raw = [0x2c, 0x02];
        PacketZcNotifyMoveentry3 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        objecttype: 0,
        objecttype_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        move_start_time: 0,
        move_start_time_raw: [0; 4],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        move_data: [0; 6],
        move_data_raw: [0; 12],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyMoveentry3 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyMoveentry3::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzCommandMer {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2d02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzCommandMer {
        let mut offset: usize = 0;
        PacketCzCommandMer {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            command: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            command_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.command).unwrap();
        self.command_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.command_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn set_command(&mut self, value: i8) {
        self.command = value;
    }
    pub fn set_command_raw(&mut self, value: [u8; 1]) {
        self.command_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzCommandMer {
        let packet_id = i16::from_le_bytes([0x2d, 0x02]);
        let packet_id_raw = [0x2d, 0x02];
        PacketCzCommandMer {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 2],
        command: 0,
        command_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzCommandMer {
    fn id(&self, packetver: u32) -> &str {
       PacketCzCommandMer::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPropertyHomun {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2e02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPropertyHomun {
        let mut offset: usize = 0;
        PacketZcPropertyHomun {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            sz_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            sz_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            b_modified: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            b_modified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            n_level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            n_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            n_fullness: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            n_fullness_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            n_relationship: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            n_relationship_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atk: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            matk: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            matk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            hit: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            hit_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            critical: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            critical_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            def: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            def_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mdef: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            mdef_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            flee: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            flee_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aspd: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            hp: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            max_hp: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            max_hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            sp: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            max_sp: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            max_sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            exp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            max_exp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            max_exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            skpoint: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skpoint_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atkrange: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atkrange_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.b_modified).unwrap();
        self.b_modified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.n_level).unwrap();
        self.n_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.n_fullness).unwrap();
        self.n_fullness_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.n_relationship).unwrap();
        self.n_relationship_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atk).unwrap();
        self.atk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.matk).unwrap();
        self.matk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hit).unwrap();
        self.hit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.critical).unwrap();
        self.critical_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.def).unwrap();
        self.def_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef).unwrap();
        self.mdef_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.flee).unwrap();
        self.flee_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.aspd).unwrap();
        self.aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sp).unwrap();
        self.sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_sp).unwrap();
        self.max_sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.exp).unwrap();
        self.exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_exp).unwrap();
        self.max_exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.skpoint).unwrap();
        self.skpoint_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atkrange).unwrap();
        self.atkrange_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.sz_name_raw.to_vec());
        wtr.append(&mut self.b_modified_raw.to_vec());
        wtr.append(&mut self.n_level_raw.to_vec());
        wtr.append(&mut self.n_fullness_raw.to_vec());
        wtr.append(&mut self.n_relationship_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atk_raw.to_vec());
        wtr.append(&mut self.matk_raw.to_vec());
        wtr.append(&mut self.hit_raw.to_vec());
        wtr.append(&mut self.critical_raw.to_vec());
        wtr.append(&mut self.def_raw.to_vec());
        wtr.append(&mut self.mdef_raw.to_vec());
        wtr.append(&mut self.flee_raw.to_vec());
        wtr.append(&mut self.aspd_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.max_hp_raw.to_vec());
        wtr.append(&mut self.sp_raw.to_vec());
        wtr.append(&mut self.max_sp_raw.to_vec());
        wtr.append(&mut self.exp_raw.to_vec());
        wtr.append(&mut self.max_exp_raw.to_vec());
        wtr.append(&mut self.skpoint_raw.to_vec());
        wtr.append(&mut self.atkrange_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 71;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_sz_name(&mut self, value: [char; 24]) {
        self.sz_name = value;
    }
    pub fn set_sz_name_raw(&mut self, value: [u8; 24]) {
        self.sz_name_raw = value;
    }
    pub fn set_b_modified(&mut self, value: u8) {
        self.b_modified = value;
    }
    pub fn set_b_modified_raw(&mut self, value: [u8; 1]) {
        self.b_modified_raw = value;
    }
    pub fn set_n_level(&mut self, value: i16) {
        self.n_level = value;
    }
    pub fn set_n_level_raw(&mut self, value: [u8; 2]) {
        self.n_level_raw = value;
    }
    pub fn set_n_fullness(&mut self, value: i16) {
        self.n_fullness = value;
    }
    pub fn set_n_fullness_raw(&mut self, value: [u8; 2]) {
        self.n_fullness_raw = value;
    }
    pub fn set_n_relationship(&mut self, value: i16) {
        self.n_relationship = value;
    }
    pub fn set_n_relationship_raw(&mut self, value: [u8; 2]) {
        self.n_relationship_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atk(&mut self, value: i16) {
        self.atk = value;
    }
    pub fn set_atk_raw(&mut self, value: [u8; 2]) {
        self.atk_raw = value;
    }
    pub fn set_matk(&mut self, value: i16) {
        self.matk = value;
    }
    pub fn set_matk_raw(&mut self, value: [u8; 2]) {
        self.matk_raw = value;
    }
    pub fn set_hit(&mut self, value: i16) {
        self.hit = value;
    }
    pub fn set_hit_raw(&mut self, value: [u8; 2]) {
        self.hit_raw = value;
    }
    pub fn set_critical(&mut self, value: i16) {
        self.critical = value;
    }
    pub fn set_critical_raw(&mut self, value: [u8; 2]) {
        self.critical_raw = value;
    }
    pub fn set_def(&mut self, value: i16) {
        self.def = value;
    }
    pub fn set_def_raw(&mut self, value: [u8; 2]) {
        self.def_raw = value;
    }
    pub fn set_mdef(&mut self, value: i16) {
        self.mdef = value;
    }
    pub fn set_mdef_raw(&mut self, value: [u8; 2]) {
        self.mdef_raw = value;
    }
    pub fn set_flee(&mut self, value: i16) {
        self.flee = value;
    }
    pub fn set_flee_raw(&mut self, value: [u8; 2]) {
        self.flee_raw = value;
    }
    pub fn set_aspd(&mut self, value: i16) {
        self.aspd = value;
    }
    pub fn set_aspd_raw(&mut self, value: [u8; 2]) {
        self.aspd_raw = value;
    }
    pub fn set_hp(&mut self, value: i16) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 2]) {
        self.hp_raw = value;
    }
    pub fn set_max_hp(&mut self, value: i16) {
        self.max_hp = value;
    }
    pub fn set_max_hp_raw(&mut self, value: [u8; 2]) {
        self.max_hp_raw = value;
    }
    pub fn set_sp(&mut self, value: i16) {
        self.sp = value;
    }
    pub fn set_sp_raw(&mut self, value: [u8; 2]) {
        self.sp_raw = value;
    }
    pub fn set_max_sp(&mut self, value: i16) {
        self.max_sp = value;
    }
    pub fn set_max_sp_raw(&mut self, value: [u8; 2]) {
        self.max_sp_raw = value;
    }
    pub fn set_exp(&mut self, value: i32) {
        self.exp = value;
    }
    pub fn set_exp_raw(&mut self, value: [u8; 4]) {
        self.exp_raw = value;
    }
    pub fn set_max_exp(&mut self, value: i32) {
        self.max_exp = value;
    }
    pub fn set_max_exp_raw(&mut self, value: [u8; 4]) {
        self.max_exp_raw = value;
    }
    pub fn set_skpoint(&mut self, value: i16) {
        self.skpoint = value;
    }
    pub fn set_skpoint_raw(&mut self, value: [u8; 2]) {
        self.skpoint_raw = value;
    }
    pub fn set_atkrange(&mut self, value: i16) {
        self.atkrange = value;
    }
    pub fn set_atkrange_raw(&mut self, value: [u8; 2]) {
        self.atkrange_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPropertyHomun {
        let packet_id = i16::from_le_bytes([0x2e, 0x02]);
        let packet_id_raw = [0x2e, 0x02];
        PacketZcPropertyHomun {
        raw: vec![],
        packet_id,
        packet_id_raw,
        sz_name: [0 as char; 24],
        sz_name_raw: [0; 24],
        b_modified: 0,
        b_modified_raw: [0; 1],
        n_level: 0,
        n_level_raw: [0; 2],
        n_fullness: 0,
        n_fullness_raw: [0; 2],
        n_relationship: 0,
        n_relationship_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        atk: 0,
        atk_raw: [0; 2],
        matk: 0,
        matk_raw: [0; 2],
        hit: 0,
        hit_raw: [0; 2],
        critical: 0,
        critical_raw: [0; 2],
        def: 0,
        def_raw: [0; 2],
        mdef: 0,
        mdef_raw: [0; 2],
        flee: 0,
        flee_raw: [0; 2],
        aspd: 0,
        aspd_raw: [0; 2],
        hp: 0,
        hp_raw: [0; 2],
        max_hp: 0,
        max_hp_raw: [0; 2],
        sp: 0,
        sp_raw: [0; 2],
        max_sp: 0,
        max_sp_raw: [0; 2],
        exp: 0,
        exp_raw: [0; 4],
        max_exp: 0,
        max_exp_raw: [0; 4],
        skpoint: 0,
        skpoint_raw: [0; 2],
        atkrange: 0,
        atkrange_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcPropertyHomun {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPropertyHomun::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcChangestateMer {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3002"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcChangestateMer {
        let mut offset: usize = 0;
        PacketZcChangestateMer {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            state: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            gid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            data: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            data_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.data).unwrap();
        self.data_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 12;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_state(&mut self, value: i8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_gid(&mut self, value: i32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_data(&mut self, value: i32) {
        self.data = value;
    }
    pub fn set_data_raw(&mut self, value: [u8; 4]) {
        self.data_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcChangestateMer {
        let packet_id = i16::from_le_bytes([0x30, 0x02]);
        let packet_id_raw = [0x30, 0x02];
        PacketZcChangestateMer {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 1],
        state: 0,
        state_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        data: 0,
        data_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcChangestateMer {
    fn id(&self, packetver: u32) -> &str {
       PacketZcChangestateMer::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRenameMer {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3102"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRenameMer {
        let mut offset: usize = 0;
        PacketCzRenameMer {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRenameMer {
        let packet_id = i16::from_le_bytes([0x31, 0x02]);
        let packet_id_raw = [0x31, 0x02];
        PacketCzRenameMer {
        raw: vec![],
        packet_id,
        packet_id_raw,
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzRenameMer {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRenameMer::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRequestMovenpc {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3202"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRequestMovenpc {
        let mut offset: usize = 0;
        PacketCzRequestMovenpc {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            dest: {
                let field =  {
                let mut dst: [char; 3] = [0 as char; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            dest_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[offset..offset + 3]);
                offset += 3;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.dest {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.dest_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.dest_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 9;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_dest(&mut self, value: [char; 3]) {
        self.dest = value;
    }
    pub fn set_dest_raw(&mut self, value: [u8; 3]) {
        self.dest_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRequestMovenpc {
        let packet_id = i16::from_le_bytes([0x32, 0x02]);
        let packet_id_raw = [0x32, 0x02];
        PacketCzRequestMovenpc {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        dest: [0 as char; 3],
        dest_raw: [0; 3],
        }
    }
}

impl Packet for PacketCzRequestMovenpc {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRequestMovenpc::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRequestActnpc {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3302"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRequestActnpc {
        let mut offset: usize = 0;
        PacketCzRequestActnpc {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            target_gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            target_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            action: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_gid).unwrap();
        self.target_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.target_gid_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 11;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_target_gid(&mut self, value: u32) {
        self.target_gid = value;
    }
    pub fn set_target_gid_raw(&mut self, value: [u8; 4]) {
        self.target_gid_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRequestActnpc {
        let packet_id = i16::from_le_bytes([0x33, 0x02]);
        let packet_id_raw = [0x33, 0x02];
        PacketCzRequestActnpc {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        target_gid: 0,
        target_gid_raw: [0; 4],
        action: 0,
        action_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzRequestActnpc {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRequestActnpc::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRequestMovetoowner {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3402"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRequestMovetoowner {
        let mut offset: usize = 0;
        PacketCzRequestMovetoowner {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRequestMovetoowner {
        let packet_id = i16::from_le_bytes([0x34, 0x02]);
        let packet_id_raw = [0x34, 0x02];
        PacketCzRequestMovetoowner {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzRequestMovetoowner {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRequestMovetoowner::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcReqStorePassword {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3a02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcReqStorePassword {
        let mut offset: usize = 0;
        PacketZcReqStorePassword {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            info: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            info_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.info).unwrap();
        self.info_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_info(&mut self, value: i16) {
        self.info = value;
    }
    pub fn set_info_raw(&mut self, value: [u8; 2]) {
        self.info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcReqStorePassword {
        let packet_id = i16::from_le_bytes([0x3a, 0x02]);
        let packet_id_raw = [0x3a, 0x02];
        PacketZcReqStorePassword {
        raw: vec![],
        packet_id,
        packet_id_raw,
        info: 0,
        info_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcReqStorePassword {
    fn id(&self, packetver: u32) -> &str {
       PacketZcReqStorePassword::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzAckStorePassword {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3b02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzAckStorePassword {
        let mut offset: usize = 0;
        PacketCzAckStorePassword {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            password: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            password_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            new_password: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            new_password_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.password {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.password_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.new_password {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.new_password_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.password_raw.to_vec());
        wtr.append(&mut self.new_password_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 36;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn set_password(&mut self, value: [char; 16]) {
        self.password = value;
    }
    pub fn set_password_raw(&mut self, value: [u8; 16]) {
        self.password_raw = value;
    }
    pub fn set_new_password(&mut self, value: [char; 16]) {
        self.new_password = value;
    }
    pub fn set_new_password_raw(&mut self, value: [u8; 16]) {
        self.new_password_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzAckStorePassword {
        let packet_id = i16::from_le_bytes([0x3b, 0x02]);
        let packet_id_raw = [0x3b, 0x02];
        PacketCzAckStorePassword {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 2],
        password: [0 as char; 16],
        password_raw: [0; 16],
        new_password: [0 as char; 16],
        new_password_raw: [0; 16],
        }
    }
}

impl Packet for PacketCzAckStorePassword {
    fn id(&self, packetver: u32) -> &str {
       PacketCzAckStorePassword::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcResultStorePassword {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3c02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcResultStorePassword {
        let mut offset: usize = 0;
        PacketZcResultStorePassword {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            error_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_count).unwrap();
        self.error_count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.error_count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn set_error_count(&mut self, value: i16) {
        self.error_count = value;
    }
    pub fn set_error_count_raw(&mut self, value: [u8; 2]) {
        self.error_count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcResultStorePassword {
        let packet_id = i16::from_le_bytes([0x3c, 0x02]);
        let packet_id_raw = [0x3c, 0x02];
        PacketZcResultStorePassword {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 2],
        error_count: 0,
        error_count_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcResultStorePassword {
    fn id(&self, packetver: u32) -> &str {
       PacketZcResultStorePassword::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcEventResult {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3d02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcEventResult {
        let mut offset: usize = 0;
        PacketAcEventResult {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            event_item_count: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            event_item_count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.event_item_count).unwrap();
        self.event_item_count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.event_item_count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_event_item_count(&mut self, value: u32) {
        self.event_item_count = value;
    }
    pub fn set_event_item_count_raw(&mut self, value: [u8; 4]) {
        self.event_item_count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcEventResult {
        let packet_id = i16::from_le_bytes([0x3d, 0x02]);
        let packet_id_raw = [0x3d, 0x02];
        PacketAcEventResult {
        raw: vec![],
        packet_id,
        packet_id_raw,
        event_item_count: 0,
        event_item_count_raw: [0; 4],
        }
    }
}

impl Packet for PacketAcEventResult {
    fn id(&self, packetver: u32) -> &str {
       PacketAcEventResult::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcRequestCharacterPassword {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3e02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcRequestCharacterPassword {
        let mut offset: usize = 0;
        PacketHcRequestCharacterPassword {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            dummy_value: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dummy_value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dummy_value).unwrap();
        self.dummy_value_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.dummy_value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn set_dummy_value(&mut self, value: u32) {
        self.dummy_value = value;
    }
    pub fn set_dummy_value_raw(&mut self, value: [u8; 4]) {
        self.dummy_value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcRequestCharacterPassword {
        let packet_id = i16::from_le_bytes([0x3e, 0x02]);
        let packet_id_raw = [0x3e, 0x02];
        PacketHcRequestCharacterPassword {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 2],
        dummy_value: 0,
        dummy_value_raw: [0; 4],
        }
    }
}

impl Packet for PacketHcRequestCharacterPassword {
    fn id(&self, packetver: u32) -> &str {
       PacketHcRequestCharacterPassword::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzMailGetList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3f02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzMailGetList {
        let mut offset: usize = 0;
        PacketCzMailGetList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzMailGetList {
        let packet_id = i16::from_le_bytes([0x3f, 0x02]);
        let packet_id_raw = [0x3f, 0x02];
        PacketCzMailGetList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzMailGetList {
    fn id(&self, packetver: u32) -> &str {
       PacketCzMailGetList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMailReqGetList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4002"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMailReqGetList {
        let mut offset: usize = 0;
        let vec_type_len = MailList::base_len(packetver);
        let iter_count = (&buffer.len() - 8) / vec_type_len;
        let mut vec_field: Vec<MailList> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (vec_type_len * (i - 1));
            let end_pos = 8 + vec_type_len * i;
            vec_field.push(MailList::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcMailReqGetList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mail_number: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            mail_number_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            mail_list: {
                let field = vec_field.clone();
                field
            },
            mail_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_number).unwrap();
        self.mail_number_raw = wtr.try_into().unwrap();
        self.mail_list_raw = {
            self.mail_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.mail_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.mail_number_raw.to_vec());
        self.mail_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_mail_number(&mut self, value: i32) {
        self.mail_number = value;
    }
    pub fn set_mail_number_raw(&mut self, value: [u8; 4]) {
        self.mail_number_raw = value;
    }
    pub fn set_mail_list(&mut self, value: Vec<MailList>) {
        self.mail_list = value;
    }
    pub fn set_mail_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.mail_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMailReqGetList {
        let packet_id = i16::from_le_bytes([0x40, 0x02]);
        let packet_id_raw = [0x40, 0x02];
        PacketZcMailReqGetList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        mail_number: 0,
        mail_number_raw: [0; 4],
        mail_list: vec![],
        mail_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcMailReqGetList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMailReqGetList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzMailOpen {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4102"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzMailOpen {
        let mut offset: usize = 0;
        PacketCzMailOpen {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mail_id: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.mail_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_mail_id(&mut self, value: i32) {
        self.mail_id = value;
    }
    pub fn set_mail_id_raw(&mut self, value: [u8; 4]) {
        self.mail_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzMailOpen {
        let packet_id = i16::from_le_bytes([0x41, 0x02]);
        let packet_id_raw = [0x41, 0x02];
        PacketCzMailOpen {
        raw: vec![],
        packet_id,
        packet_id_raw,
        mail_id: 0,
        mail_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMailOpen {
    fn id(&self, packetver: u32) -> &str {
       PacketCzMailOpen::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMailReqOpen {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4202"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMailReqOpen {
        let mut offset: usize = 0;
        PacketZcMailReqOpen {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mail_id: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            header: {
                let field =  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[offset..offset + 40].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            header_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[offset..offset + 40]);
                offset += 40;
                dst
            },
            from_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            from_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            delete_time: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            delete_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            money: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            money_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_damaged: {
                let field = buffer[offset] == 1;
                field
            },
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            refining_level: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            msg_len: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            msg_len_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.header {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.header_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.from_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.from_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.delete_time).unwrap();
        self.delete_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.money).unwrap();
        self.money_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.write_u8(self.msg_len).unwrap();
        self.msg_len_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.mail_id_raw.to_vec());
        wtr.append(&mut self.header_raw.to_vec());
        wtr.append(&mut self.from_name_raw.to_vec());
        wtr.append(&mut self.delete_time_raw.to_vec());
        wtr.append(&mut self.money_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        wtr.append(&mut self.msg_len_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 99;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_mail_id(&mut self, value: i32) {
        self.mail_id = value;
    }
    pub fn set_mail_id_raw(&mut self, value: [u8; 4]) {
        self.mail_id_raw = value;
    }
    pub fn set_header(&mut self, value: [char; 40]) {
        self.header = value;
    }
    pub fn set_header_raw(&mut self, value: [u8; 40]) {
        self.header_raw = value;
    }
    pub fn set_from_name(&mut self, value: [char; 24]) {
        self.from_name = value;
    }
    pub fn set_from_name_raw(&mut self, value: [u8; 24]) {
        self.from_name_raw = value;
    }
    pub fn set_delete_time(&mut self, value: i32) {
        self.delete_time = value;
    }
    pub fn set_delete_time_raw(&mut self, value: [u8; 4]) {
        self.delete_time_raw = value;
    }
    pub fn set_money(&mut self, value: u32) {
        self.money = value;
    }
    pub fn set_money_raw(&mut self, value: [u8; 4]) {
        self.money_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn set_msg_len(&mut self, value: u8) {
        self.msg_len = value;
    }
    pub fn set_msg_len_raw(&mut self, value: [u8; 1]) {
        self.msg_len_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMailReqOpen {
        let packet_id = i16::from_le_bytes([0x42, 0x02]);
        let packet_id_raw = [0x42, 0x02];
        PacketZcMailReqOpen {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        mail_id: 0,
        mail_id_raw: [0; 4],
        header: [0 as char; 40],
        header_raw: [0; 40],
        from_name: [0 as char; 24],
        from_name_raw: [0; 24],
        delete_time: 0,
        delete_time_raw: [0; 4],
        money: 0,
        money_raw: [0; 4],
        count: 0,
        count_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        msg_len: 0,
        msg_len_raw: [0; 1],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcMailReqOpen {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMailReqOpen::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzMailDelete {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4302"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzMailDelete {
        let mut offset: usize = 0;
        PacketCzMailDelete {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mail_id: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.mail_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_mail_id(&mut self, value: i32) {
        self.mail_id = value;
    }
    pub fn set_mail_id_raw(&mut self, value: [u8; 4]) {
        self.mail_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzMailDelete {
        let packet_id = i16::from_le_bytes([0x43, 0x02]);
        let packet_id_raw = [0x43, 0x02];
        PacketCzMailDelete {
        raw: vec![],
        packet_id,
        packet_id_raw,
        mail_id: 0,
        mail_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMailDelete {
    fn id(&self, packetver: u32) -> &str {
       PacketCzMailDelete::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzMailGetItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4402"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzMailGetItem {
        let mut offset: usize = 0;
        PacketCzMailGetItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mail_id: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.mail_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_mail_id(&mut self, value: i32) {
        self.mail_id = value;
    }
    pub fn set_mail_id_raw(&mut self, value: [u8; 4]) {
        self.mail_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzMailGetItem {
        let packet_id = i16::from_le_bytes([0x44, 0x02]);
        let packet_id_raw = [0x44, 0x02];
        PacketCzMailGetItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        mail_id: 0,
        mail_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMailGetItem {
    fn id(&self, packetver: u32) -> &str {
       PacketCzMailGetItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMailReqGetItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4502"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMailReqGetItem {
        let mut offset: usize = 0;
        PacketZcMailReqGetItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMailReqGetItem {
        let packet_id = i16::from_le_bytes([0x45, 0x02]);
        let packet_id_raw = [0x45, 0x02];
        PacketZcMailReqGetItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcMailReqGetItem {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMailReqGetItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzMailResetItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4602"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzMailResetItem {
        let mut offset: usize = 0;
        PacketCzMailResetItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzMailResetItem {
        let packet_id = i16::from_le_bytes([0x46, 0x02]);
        let packet_id_raw = [0x46, 0x02];
        PacketCzMailResetItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzMailResetItem {
    fn id(&self, packetver: u32) -> &str {
       PacketCzMailResetItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzMailAddItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4702"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzMailAddItem {
        let mut offset: usize = 0;
        PacketCzMailAddItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzMailAddItem {
        let packet_id = i16::from_le_bytes([0x47, 0x02]);
        let packet_id_raw = [0x47, 0x02];
        PacketCzMailAddItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMailAddItem {
    fn id(&self, packetver: u32) -> &str {
       PacketCzMailAddItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzMailSend {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4802"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzMailSend {
        let mut offset: usize = 0;
        PacketCzMailSend {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            receive_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            receive_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            header: {
                let field =  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[offset..offset + 40].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            header_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[offset..offset + 40]);
                offset += 40;
                dst
            },
            msg_len: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            msg_len_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.receive_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.receive_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.header {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.header_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.msg_len).unwrap();
        self.msg_len_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.receive_name_raw.to_vec());
        wtr.append(&mut self.header_raw.to_vec());
        wtr.append(&mut self.msg_len_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 71;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_receive_name(&mut self, value: [char; 24]) {
        self.receive_name = value;
    }
    pub fn set_receive_name_raw(&mut self, value: [u8; 24]) {
        self.receive_name_raw = value;
    }
    pub fn set_header(&mut self, value: [char; 40]) {
        self.header = value;
    }
    pub fn set_header_raw(&mut self, value: [u8; 40]) {
        self.header_raw = value;
    }
    pub fn set_msg_len(&mut self, value: u32) {
        self.msg_len = value;
    }
    pub fn set_msg_len_raw(&mut self, value: [u8; 4]) {
        self.msg_len_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzMailSend {
        let packet_id = i16::from_le_bytes([0x48, 0x02]);
        let packet_id_raw = [0x48, 0x02];
        PacketCzMailSend {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        receive_name: [0 as char; 24],
        receive_name_raw: [0; 24],
        header: [0 as char; 40],
        header_raw: [0; 40],
        msg_len: 0,
        msg_len_raw: [0; 4],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketCzMailSend {
    fn id(&self, packetver: u32) -> &str {
       PacketCzMailSend::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMailReqSend {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4902"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMailReqSend {
        let mut offset: usize = 0;
        PacketZcMailReqSend {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMailReqSend {
        let packet_id = i16::from_le_bytes([0x49, 0x02]);
        let packet_id_raw = [0x49, 0x02];
        PacketZcMailReqSend {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcMailReqSend {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMailReqSend::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMailReceive {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4a02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMailReceive {
        let mut offset: usize = 0;
        PacketZcMailReceive {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mail_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            header: {
                let field =  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[offset..offset + 40].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            header_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[offset..offset + 40]);
                offset += 40;
                dst
            },
            from_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            from_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.header {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.header_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.from_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.from_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.mail_id_raw.to_vec());
        wtr.append(&mut self.header_raw.to_vec());
        wtr.append(&mut self.from_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 70;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_mail_id(&mut self, value: u32) {
        self.mail_id = value;
    }
    pub fn set_mail_id_raw(&mut self, value: [u8; 4]) {
        self.mail_id_raw = value;
    }
    pub fn set_header(&mut self, value: [char; 40]) {
        self.header = value;
    }
    pub fn set_header_raw(&mut self, value: [u8; 40]) {
        self.header_raw = value;
    }
    pub fn set_from_name(&mut self, value: [char; 24]) {
        self.from_name = value;
    }
    pub fn set_from_name_raw(&mut self, value: [u8; 24]) {
        self.from_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMailReceive {
        let packet_id = i16::from_le_bytes([0x4a, 0x02]);
        let packet_id_raw = [0x4a, 0x02];
        PacketZcMailReceive {
        raw: vec![],
        packet_id,
        packet_id_raw,
        mail_id: 0,
        mail_id_raw: [0; 4],
        header: [0 as char; 40],
        header_raw: [0; 40],
        from_name: [0 as char; 24],
        from_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcMailReceive {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMailReceive::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzAuctionCreate {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4b02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzAuctionCreate {
        let mut offset: usize = 0;
        PacketCzAuctionCreate {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzAuctionCreate {
        let packet_id = i16::from_le_bytes([0x4b, 0x02]);
        let packet_id_raw = [0x4b, 0x02];
        PacketCzAuctionCreate {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzAuctionCreate {
    fn id(&self, packetver: u32) -> &str {
       PacketCzAuctionCreate::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzAuctionAddItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4c02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzAuctionAddItem {
        let mut offset: usize = 0;
        PacketCzAuctionAddItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzAuctionAddItem {
        let packet_id = i16::from_le_bytes([0x4c, 0x02]);
        let packet_id_raw = [0x4c, 0x02];
        PacketCzAuctionAddItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzAuctionAddItem {
    fn id(&self, packetver: u32) -> &str {
       PacketCzAuctionAddItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzAuctionAdd {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4d02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzAuctionAdd {
        let mut offset: usize = 0;
        PacketCzAuctionAdd {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            now_money: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            now_money_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            max_money: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            max_money_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            delete_hour: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            delete_hour_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.now_money).unwrap();
        self.now_money_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.max_money).unwrap();
        self.max_money_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.delete_hour).unwrap();
        self.delete_hour_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.now_money_raw.to_vec());
        wtr.append(&mut self.max_money_raw.to_vec());
        wtr.append(&mut self.delete_hour_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 12;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_now_money(&mut self, value: u32) {
        self.now_money = value;
    }
    pub fn set_now_money_raw(&mut self, value: [u8; 4]) {
        self.now_money_raw = value;
    }
    pub fn set_max_money(&mut self, value: u32) {
        self.max_money = value;
    }
    pub fn set_max_money_raw(&mut self, value: [u8; 4]) {
        self.max_money_raw = value;
    }
    pub fn set_delete_hour(&mut self, value: i16) {
        self.delete_hour = value;
    }
    pub fn set_delete_hour_raw(&mut self, value: [u8; 2]) {
        self.delete_hour_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzAuctionAdd {
        let packet_id = i16::from_le_bytes([0x4d, 0x02]);
        let packet_id_raw = [0x4d, 0x02];
        PacketCzAuctionAdd {
        raw: vec![],
        packet_id,
        packet_id_raw,
        now_money: 0,
        now_money_raw: [0; 4],
        max_money: 0,
        max_money_raw: [0; 4],
        delete_hour: 0,
        delete_hour_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzAuctionAdd {
    fn id(&self, packetver: u32) -> &str {
       PacketCzAuctionAdd::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzAuctionAddCancel {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4e02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzAuctionAddCancel {
        let mut offset: usize = 0;
        PacketCzAuctionAddCancel {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            auction_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            auction_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.auction_id).unwrap();
        self.auction_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.auction_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_auction_id(&mut self, value: u32) {
        self.auction_id = value;
    }
    pub fn set_auction_id_raw(&mut self, value: [u8; 4]) {
        self.auction_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzAuctionAddCancel {
        let packet_id = i16::from_le_bytes([0x4e, 0x02]);
        let packet_id_raw = [0x4e, 0x02];
        PacketCzAuctionAddCancel {
        raw: vec![],
        packet_id,
        packet_id_raw,
        auction_id: 0,
        auction_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzAuctionAddCancel {
    fn id(&self, packetver: u32) -> &str {
       PacketCzAuctionAddCancel::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzAuctionBuy {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4f02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzAuctionBuy {
        let mut offset: usize = 0;
        PacketCzAuctionBuy {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            auction_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            auction_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            money: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            money_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.auction_id).unwrap();
        self.auction_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.money).unwrap();
        self.money_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.auction_id_raw.to_vec());
        wtr.append(&mut self.money_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_auction_id(&mut self, value: u32) {
        self.auction_id = value;
    }
    pub fn set_auction_id_raw(&mut self, value: [u8; 4]) {
        self.auction_id_raw = value;
    }
    pub fn set_money(&mut self, value: u32) {
        self.money = value;
    }
    pub fn set_money_raw(&mut self, value: [u8; 4]) {
        self.money_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzAuctionBuy {
        let packet_id = i16::from_le_bytes([0x4f, 0x02]);
        let packet_id_raw = [0x4f, 0x02];
        PacketCzAuctionBuy {
        raw: vec![],
        packet_id,
        packet_id_raw,
        auction_id: 0,
        auction_id_raw: [0; 4],
        money: 0,
        money_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzAuctionBuy {
    fn id(&self, packetver: u32) -> &str {
       PacketCzAuctionBuy::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAuctionResult {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5002"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAuctionResult {
        let mut offset: usize = 0;
        PacketZcAuctionResult {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAuctionResult {
        let packet_id = i16::from_le_bytes([0x50, 0x02]);
        let packet_id_raw = [0x50, 0x02];
        PacketZcAuctionResult {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAuctionResult {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAuctionResult::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzAuctionItemSearch {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5102"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzAuctionItemSearch {
        let mut offset: usize = 0;
        PacketCzAuctionItemSearch {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            auction_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            auction_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            page: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            page_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.auction_id).unwrap();
        self.auction_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.page).unwrap();
        self.page_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.auction_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.page_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 34;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn set_auction_id(&mut self, value: u32) {
        self.auction_id = value;
    }
    pub fn set_auction_id_raw(&mut self, value: [u8; 4]) {
        self.auction_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_page(&mut self, value: u16) {
        self.page = value;
    }
    pub fn set_page_raw(&mut self, value: [u8; 2]) {
        self.page_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzAuctionItemSearch {
        let packet_id = i16::from_le_bytes([0x51, 0x02]);
        let packet_id_raw = [0x51, 0x02];
        PacketCzAuctionItemSearch {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 2],
        auction_id: 0,
        auction_id_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        page: 0,
        page_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzAuctionItemSearch {
    fn id(&self, packetver: u32) -> &str {
       PacketCzAuctionItemSearch::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAuctionItemReqSearch {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5202"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAuctionItemReqSearch {
        let mut offset: usize = 0;
        let vec_type_len = AuctionItemSearchInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 12) / vec_type_len;
        let mut vec_field: Vec<AuctionItemSearchInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 12 + (vec_type_len * (i - 1));
            let end_pos = 12 + vec_type_len * i;
            vec_field.push(AuctionItemSearchInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcAuctionItemReqSearch {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            max_page: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            max_page_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            number: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            number_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            auction_item_list: {
                let field = vec_field.clone();
                field
            },
            auction_item_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_page).unwrap();
        self.max_page_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.number).unwrap();
        self.number_raw = wtr.try_into().unwrap();
        self.auction_item_list_raw = {
            self.auction_item_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.auction_item_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.max_page_raw.to_vec());
        wtr.append(&mut self.number_raw.to_vec());
        self.auction_item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 12;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_max_page(&mut self, value: i32) {
        self.max_page = value;
    }
    pub fn set_max_page_raw(&mut self, value: [u8; 4]) {
        self.max_page_raw = value;
    }
    pub fn set_number(&mut self, value: i32) {
        self.number = value;
    }
    pub fn set_number_raw(&mut self, value: [u8; 4]) {
        self.number_raw = value;
    }
    pub fn set_auction_item_list(&mut self, value: Vec<AuctionItemSearchInfo>) {
        self.auction_item_list = value;
    }
    pub fn set_auction_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.auction_item_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAuctionItemReqSearch {
        let packet_id = i16::from_le_bytes([0x52, 0x02]);
        let packet_id_raw = [0x52, 0x02];
        PacketZcAuctionItemReqSearch {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        max_page: 0,
        max_page_raw: [0; 4],
        number: 0,
        number_raw: [0; 4],
        auction_item_list: vec![],
        auction_item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcAuctionItemReqSearch {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAuctionItemReqSearch::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcStarplace {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5302"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcStarplace {
        let mut offset: usize = 0;
        PacketZcStarplace {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            which: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            which_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.which).unwrap();
        self.which_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.which_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_which(&mut self, value: i8) {
        self.which = value;
    }
    pub fn set_which_raw(&mut self, value: [u8; 1]) {
        self.which_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcStarplace {
        let packet_id = i16::from_le_bytes([0x53, 0x02]);
        let packet_id_raw = [0x53, 0x02];
        PacketZcStarplace {
        raw: vec![],
        packet_id,
        packet_id_raw,
        which: 0,
        which_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcStarplace {
    fn id(&self, packetver: u32) -> &str {
       PacketZcStarplace::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzAgreeStarplace {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5402"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzAgreeStarplace {
        let mut offset: usize = 0;
        PacketCzAgreeStarplace {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            which: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            which_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.which).unwrap();
        self.which_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.which_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_which(&mut self, value: i8) {
        self.which = value;
    }
    pub fn set_which_raw(&mut self, value: [u8; 1]) {
        self.which_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzAgreeStarplace {
        let packet_id = i16::from_le_bytes([0x54, 0x02]);
        let packet_id_raw = [0x54, 0x02];
        PacketCzAgreeStarplace {
        raw: vec![],
        packet_id,
        packet_id_raw,
        which: 0,
        which_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzAgreeStarplace {
    fn id(&self, packetver: u32) -> &str {
       PacketCzAgreeStarplace::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckMailAddItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5502"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckMailAddItem {
        let mut offset: usize = 0;
        PacketZcAckMailAddItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckMailAddItem {
        let packet_id = i16::from_le_bytes([0x55, 0x02]);
        let packet_id_raw = [0x55, 0x02];
        PacketZcAckMailAddItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckMailAddItem {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckMailAddItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckAuctionAddItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5602"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckAuctionAddItem {
        let mut offset: usize = 0;
        PacketZcAckAuctionAddItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckAuctionAddItem {
        let packet_id = i16::from_le_bytes([0x56, 0x02]);
        let packet_id_raw = [0x56, 0x02];
        PacketZcAckAuctionAddItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcAckAuctionAddItem {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckAuctionAddItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckMailDelete {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5702"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckMailDelete {
        let mut offset: usize = 0;
        PacketZcAckMailDelete {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mail_id: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            result: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.mail_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_mail_id(&mut self, value: i32) {
        self.mail_id = value;
    }
    pub fn set_mail_id_raw(&mut self, value: [u8; 4]) {
        self.mail_id_raw = value;
    }
    pub fn set_result(&mut self, value: u16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckMailDelete {
        let packet_id = i16::from_le_bytes([0x57, 0x02]);
        let packet_id_raw = [0x57, 0x02];
        PacketZcAckMailDelete {
        raw: vec![],
        packet_id,
        packet_id_raw,
        mail_id: 0,
        mail_id_raw: [0; 4],
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAckMailDelete {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckMailDelete::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCaReqGameGuardCheck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5802"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaReqGameGuardCheck {
        let mut offset: usize = 0;
        PacketCaReqGameGuardCheck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaReqGameGuardCheck {
        let packet_id = i16::from_le_bytes([0x58, 0x02]);
        let packet_id_raw = [0x58, 0x02];
        PacketCaReqGameGuardCheck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCaReqGameGuardCheck {
    fn id(&self, packetver: u32) -> &str {
       PacketCaReqGameGuardCheck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcAckGameGuard {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5902"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcAckGameGuard {
        let mut offset: usize = 0;
        PacketAcAckGameGuard {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            uc_answer: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            uc_answer_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.uc_answer).unwrap();
        self.uc_answer_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.uc_answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_uc_answer(&mut self, value: u8) {
        self.uc_answer = value;
    }
    pub fn set_uc_answer_raw(&mut self, value: [u8; 1]) {
        self.uc_answer_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcAckGameGuard {
        let packet_id = i16::from_le_bytes([0x59, 0x02]);
        let packet_id_raw = [0x59, 0x02];
        PacketAcAckGameGuard {
        raw: vec![],
        packet_id,
        packet_id_raw,
        uc_answer: 0,
        uc_answer_raw: [0; 1],
        }
    }
}

impl Packet for PacketAcAckGameGuard {
    fn id(&self, packetver: u32) -> &str {
       PacketAcAckGameGuard::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMakingitemList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5a02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMakingitemList {
        let mut offset: usize = 0;
        PacketZcMakingitemList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            id_list: {
                let field =  {
                let dst: Vec<u8> = buffer[offset..buffer.len()].to_vec();
                dst
            };
                field
            },
            id_list_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.id_list_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_id_list(&mut self, value: Vec<u8>) {
        self.id_list = value;
    }
    pub fn set_id_list_raw(&mut self, value: Vec<u8>) {
        self.id_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMakingitemList {
        let packet_id = i16::from_le_bytes([0x5a, 0x02]);
        let packet_id_raw = [0x5a, 0x02];
        PacketZcMakingitemList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        id_list: vec![],
        id_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcMakingitemList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMakingitemList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqMakingitem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5b02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqMakingitem {
        let mut offset: usize = 0;
        PacketCzReqMakingitem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mk_type: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            mk_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            id: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mk_type).unwrap();
        self.mk_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.id).unwrap();
        self.id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.mk_type_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_mk_type(&mut self, value: i16) {
        self.mk_type = value;
    }
    pub fn set_mk_type_raw(&mut self, value: [u8; 2]) {
        self.mk_type_raw = value;
    }
    pub fn set_id(&mut self, value: u16) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 2]) {
        self.id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqMakingitem {
        let packet_id = i16::from_le_bytes([0x5b, 0x02]);
        let packet_id_raw = [0x5b, 0x02];
        PacketCzReqMakingitem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        mk_type: 0,
        mk_type_raw: [0; 2],
        id: 0,
        id_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqMakingitem {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqMakingitem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzAuctionReqMyInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5c02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzAuctionReqMyInfo {
        let mut offset: usize = 0;
        PacketCzAuctionReqMyInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzAuctionReqMyInfo {
        let packet_id = i16::from_le_bytes([0x5c, 0x02]);
        let packet_id_raw = [0x5c, 0x02];
        PacketCzAuctionReqMyInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzAuctionReqMyInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketCzAuctionReqMyInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzAuctionReqMySellStop {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5d02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzAuctionReqMySellStop {
        let mut offset: usize = 0;
        PacketCzAuctionReqMySellStop {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            auction_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            auction_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.auction_id).unwrap();
        self.auction_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.auction_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_auction_id(&mut self, value: u32) {
        self.auction_id = value;
    }
    pub fn set_auction_id_raw(&mut self, value: [u8; 4]) {
        self.auction_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzAuctionReqMySellStop {
        let packet_id = i16::from_le_bytes([0x5d, 0x02]);
        let packet_id_raw = [0x5d, 0x02];
        PacketCzAuctionReqMySellStop {
        raw: vec![],
        packet_id,
        packet_id_raw,
        auction_id: 0,
        auction_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzAuctionReqMySellStop {
    fn id(&self, packetver: u32) -> &str {
       PacketCzAuctionReqMySellStop::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAuctionAckMySellStop {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5e02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAuctionAckMySellStop {
        let mut offset: usize = 0;
        PacketZcAuctionAckMySellStop {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAuctionAckMySellStop {
        let packet_id = i16::from_le_bytes([0x5e, 0x02]);
        let packet_id_raw = [0x5e, 0x02];
        PacketZcAuctionAckMySellStop {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAuctionAckMySellStop {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAuctionAckMySellStop::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAuctionWindows {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5f02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAuctionWindows {
        let mut offset: usize = 0;
        PacketZcAuctionWindows {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAuctionWindows {
        let packet_id = i16::from_le_bytes([0x5f, 0x02]);
        let packet_id_raw = [0x5f, 0x02];
        PacketZcAuctionWindows {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcAuctionWindows {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAuctionWindows::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMailWindows {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6002"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMailWindows {
        let mut offset: usize = 0;
        PacketZcMailWindows {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMailWindows {
        let packet_id = i16::from_le_bytes([0x60, 0x02]);
        let packet_id_raw = [0x60, 0x02];
        PacketZcMailWindows {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcMailWindows {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMailWindows::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcReqLoginOldekey {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6102"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcReqLoginOldekey {
        let mut offset: usize = 0;
        PacketAcReqLoginOldekey {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            m_seed_value: {
                let field =  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[offset..offset + 9].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            m_seed_value_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[offset..offset + 9]);
                offset += 9;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_seed_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_seed_value_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.m_seed_value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 11;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_m_seed_value(&mut self, value: [char; 9]) {
        self.m_seed_value = value;
    }
    pub fn set_m_seed_value_raw(&mut self, value: [u8; 9]) {
        self.m_seed_value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcReqLoginOldekey {
        let packet_id = i16::from_le_bytes([0x61, 0x02]);
        let packet_id_raw = [0x61, 0x02];
        PacketAcReqLoginOldekey {
        raw: vec![],
        packet_id,
        packet_id_raw,
        m_seed_value: [0 as char; 9],
        m_seed_value_raw: [0; 9],
        }
    }
}

impl Packet for PacketAcReqLoginOldekey {
    fn id(&self, packetver: u32) -> &str {
       PacketAcReqLoginOldekey::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcReqLoginNewekey {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6202"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcReqLoginNewekey {
        let mut offset: usize = 0;
        PacketAcReqLoginNewekey {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            m_seed_value: {
                let field =  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[offset..offset + 9].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            m_seed_value_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[offset..offset + 9]);
                offset += 9;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_seed_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_seed_value_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.m_seed_value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 11;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_m_seed_value(&mut self, value: [char; 9]) {
        self.m_seed_value = value;
    }
    pub fn set_m_seed_value_raw(&mut self, value: [u8; 9]) {
        self.m_seed_value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcReqLoginNewekey {
        let packet_id = i16::from_le_bytes([0x62, 0x02]);
        let packet_id_raw = [0x62, 0x02];
        PacketAcReqLoginNewekey {
        raw: vec![],
        packet_id,
        packet_id_raw,
        m_seed_value: [0 as char; 9],
        m_seed_value_raw: [0; 9],
        }
    }
}

impl Packet for PacketAcReqLoginNewekey {
    fn id(&self, packetver: u32) -> &str {
       PacketAcReqLoginNewekey::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcReqLoginCardpass {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6302"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcReqLoginCardpass {
        let mut offset: usize = 0;
        PacketAcReqLoginCardpass {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            m_seed_value: {
                let field =  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[offset..offset + 9].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            m_seed_value_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[offset..offset + 9]);
                offset += 9;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_seed_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_seed_value_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.m_seed_value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 11;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_m_seed_value(&mut self, value: [char; 9]) {
        self.m_seed_value = value;
    }
    pub fn set_m_seed_value_raw(&mut self, value: [u8; 9]) {
        self.m_seed_value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcReqLoginCardpass {
        let packet_id = i16::from_le_bytes([0x63, 0x02]);
        let packet_id_raw = [0x63, 0x02];
        PacketAcReqLoginCardpass {
        raw: vec![],
        packet_id,
        packet_id_raw,
        m_seed_value: [0 as char; 9],
        m_seed_value_raw: [0; 9],
        }
    }
}

impl Packet for PacketAcReqLoginCardpass {
    fn id(&self, packetver: u32) -> &str {
       PacketAcReqLoginCardpass::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCaAckLoginOldekey {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6402"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaAckLoginOldekey {
        let mut offset: usize = 0;
        PacketCaAckLoginOldekey {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            m_seed_value: {
                let field =  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[offset..offset + 9].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            m_seed_value_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[offset..offset + 9]);
                offset += 9;
                dst
            },
            m_ekey: {
                let field =  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[offset..offset + 9].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            m_ekey_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[offset..offset + 9]);
                offset += 9;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_seed_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_seed_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_ekey {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_ekey_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.m_seed_value_raw.to_vec());
        wtr.append(&mut self.m_ekey_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 20;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_m_seed_value(&mut self, value: [char; 9]) {
        self.m_seed_value = value;
    }
    pub fn set_m_seed_value_raw(&mut self, value: [u8; 9]) {
        self.m_seed_value_raw = value;
    }
    pub fn set_m_ekey(&mut self, value: [char; 9]) {
        self.m_ekey = value;
    }
    pub fn set_m_ekey_raw(&mut self, value: [u8; 9]) {
        self.m_ekey_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaAckLoginOldekey {
        let packet_id = i16::from_le_bytes([0x64, 0x02]);
        let packet_id_raw = [0x64, 0x02];
        PacketCaAckLoginOldekey {
        raw: vec![],
        packet_id,
        packet_id_raw,
        m_seed_value: [0 as char; 9],
        m_seed_value_raw: [0; 9],
        m_ekey: [0 as char; 9],
        m_ekey_raw: [0; 9],
        }
    }
}

impl Packet for PacketCaAckLoginOldekey {
    fn id(&self, packetver: u32) -> &str {
       PacketCaAckLoginOldekey::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCaAckLoginNewekey {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6502"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaAckLoginNewekey {
        let mut offset: usize = 0;
        PacketCaAckLoginNewekey {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            m_seed_value: {
                let field =  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[offset..offset + 9].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            m_seed_value_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[offset..offset + 9]);
                offset += 9;
                dst
            },
            m_ekey: {
                let field =  {
                let mut dst: [char; 9] = [0 as char; 9];
                for (index, byte) in buffer[offset..offset + 9].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            m_ekey_raw: {
                let mut dst: [u8; 9] = [0u8; 9];
                dst.clone_from_slice(&buffer[offset..offset + 9]);
                offset += 9;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_seed_value {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_seed_value_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_ekey {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_ekey_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.m_seed_value_raw.to_vec());
        wtr.append(&mut self.m_ekey_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 20;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_m_seed_value(&mut self, value: [char; 9]) {
        self.m_seed_value = value;
    }
    pub fn set_m_seed_value_raw(&mut self, value: [u8; 9]) {
        self.m_seed_value_raw = value;
    }
    pub fn set_m_ekey(&mut self, value: [char; 9]) {
        self.m_ekey = value;
    }
    pub fn set_m_ekey_raw(&mut self, value: [u8; 9]) {
        self.m_ekey_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaAckLoginNewekey {
        let packet_id = i16::from_le_bytes([0x65, 0x02]);
        let packet_id_raw = [0x65, 0x02];
        PacketCaAckLoginNewekey {
        raw: vec![],
        packet_id,
        packet_id_raw,
        m_seed_value: [0 as char; 9],
        m_seed_value_raw: [0; 9],
        m_ekey: [0 as char; 9],
        m_ekey_raw: [0; 9],
        }
    }
}

impl Packet for PacketCaAckLoginNewekey {
    fn id(&self, packetver: u32) -> &str {
       PacketCaAckLoginNewekey::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCaAckLoginCardpass {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6602"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaAckLoginCardpass {
        let mut offset: usize = 0;
        PacketCaAckLoginCardpass {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mcard_pass: {
                let field =  {
                let mut dst: [char; 28] = [0 as char; 28];
                for (index, byte) in buffer[offset..offset + 28].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            mcard_pass_raw: {
                let mut dst: [u8; 28] = [0u8; 28];
                dst.clone_from_slice(&buffer[offset..offset + 28]);
                offset += 28;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mcard_pass {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mcard_pass_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.mcard_pass_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 30;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_mcard_pass(&mut self, value: [char; 28]) {
        self.mcard_pass = value;
    }
    pub fn set_mcard_pass_raw(&mut self, value: [u8; 28]) {
        self.mcard_pass_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaAckLoginCardpass {
        let packet_id = i16::from_le_bytes([0x66, 0x02]);
        let packet_id_raw = [0x66, 0x02];
        PacketCaAckLoginCardpass {
        raw: vec![],
        packet_id,
        packet_id_raw,
        mcard_pass: [0 as char; 28],
        mcard_pass_raw: [0; 28],
        }
    }
}

impl Packet for PacketCaAckLoginCardpass {
    fn id(&self, packetver: u32) -> &str {
       PacketCaAckLoginCardpass::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcAckEkeyFailNotexist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6702"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcAckEkeyFailNotexist {
        let mut offset: usize = 0;
        PacketAcAckEkeyFailNotexist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_code: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: i16) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 2]) {
        self.error_code_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcAckEkeyFailNotexist {
        let packet_id = i16::from_le_bytes([0x67, 0x02]);
        let packet_id_raw = [0x67, 0x02];
        PacketAcAckEkeyFailNotexist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_code: 0,
        error_code_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcAckEkeyFailNotexist {
    fn id(&self, packetver: u32) -> &str {
       PacketAcAckEkeyFailNotexist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcAckEkeyFailNotusesekey {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6802"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcAckEkeyFailNotusesekey {
        let mut offset: usize = 0;
        PacketAcAckEkeyFailNotusesekey {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_code: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: i16) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 2]) {
        self.error_code_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcAckEkeyFailNotusesekey {
        let packet_id = i16::from_le_bytes([0x68, 0x02]);
        let packet_id_raw = [0x68, 0x02];
        PacketAcAckEkeyFailNotusesekey {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_code: 0,
        error_code_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcAckEkeyFailNotusesekey {
    fn id(&self, packetver: u32) -> &str {
       PacketAcAckEkeyFailNotusesekey::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcAckEkeyFailNotusedekey {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6902"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcAckEkeyFailNotusedekey {
        let mut offset: usize = 0;
        PacketAcAckEkeyFailNotusedekey {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_code: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: i16) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 2]) {
        self.error_code_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcAckEkeyFailNotusedekey {
        let packet_id = i16::from_le_bytes([0x69, 0x02]);
        let packet_id_raw = [0x69, 0x02];
        PacketAcAckEkeyFailNotusedekey {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_code: 0,
        error_code_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcAckEkeyFailNotusedekey {
    fn id(&self, packetver: u32) -> &str {
       PacketAcAckEkeyFailNotusedekey::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcAckEkeyFailAuthrefuse {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6a02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcAckEkeyFailAuthrefuse {
        let mut offset: usize = 0;
        PacketAcAckEkeyFailAuthrefuse {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_code: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: i16) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 2]) {
        self.error_code_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcAckEkeyFailAuthrefuse {
        let packet_id = i16::from_le_bytes([0x6a, 0x02]);
        let packet_id_raw = [0x6a, 0x02];
        PacketAcAckEkeyFailAuthrefuse {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_code: 0,
        error_code_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcAckEkeyFailAuthrefuse {
    fn id(&self, packetver: u32) -> &str {
       PacketAcAckEkeyFailAuthrefuse::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcAckEkeyFailInputekey {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6b02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcAckEkeyFailInputekey {
        let mut offset: usize = 0;
        PacketAcAckEkeyFailInputekey {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_code: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: i16) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 2]) {
        self.error_code_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcAckEkeyFailInputekey {
        let packet_id = i16::from_le_bytes([0x6b, 0x02]);
        let packet_id_raw = [0x6b, 0x02];
        PacketAcAckEkeyFailInputekey {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_code: 0,
        error_code_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcAckEkeyFailInputekey {
    fn id(&self, packetver: u32) -> &str {
       PacketAcAckEkeyFailInputekey::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcAckEkeyFailNotice {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6c02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcAckEkeyFailNotice {
        let mut offset: usize = 0;
        PacketAcAckEkeyFailNotice {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_code: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: i16) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 2]) {
        self.error_code_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcAckEkeyFailNotice {
        let packet_id = i16::from_le_bytes([0x6c, 0x02]);
        let packet_id_raw = [0x6c, 0x02];
        PacketAcAckEkeyFailNotice {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_code: 0,
        error_code_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcAckEkeyFailNotice {
    fn id(&self, packetver: u32) -> &str {
       PacketAcAckEkeyFailNotice::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcAckEkeyFailNeedcardpass {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6d02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcAckEkeyFailNeedcardpass {
        let mut offset: usize = 0;
        PacketAcAckEkeyFailNeedcardpass {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_code: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: i16) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 2]) {
        self.error_code_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcAckEkeyFailNeedcardpass {
        let packet_id = i16::from_le_bytes([0x6d, 0x02]);
        let packet_id_raw = [0x6d, 0x02];
        PacketAcAckEkeyFailNeedcardpass {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_code: 0,
        error_code_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcAckEkeyFailNeedcardpass {
    fn id(&self, packetver: u32) -> &str {
       PacketAcAckEkeyFailNeedcardpass::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcAckAuthekeyFailNotmatchcardpass {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6e02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcAckAuthekeyFailNotmatchcardpass {
        let mut offset: usize = 0;
        PacketAcAckAuthekeyFailNotmatchcardpass {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_code: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            error_code_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: i16) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 2]) {
        self.error_code_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcAckAuthekeyFailNotmatchcardpass {
        let packet_id = i16::from_le_bytes([0x6e, 0x02]);
        let packet_id_raw = [0x6e, 0x02];
        PacketAcAckAuthekeyFailNotmatchcardpass {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_code: 0,
        error_code_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcAckAuthekeyFailNotmatchcardpass {
    fn id(&self, packetver: u32) -> &str {
       PacketAcAckAuthekeyFailNotmatchcardpass::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcAckFirstLogin {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6f02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcAckFirstLogin {
        let mut offset: usize = 0;
        PacketAcAckFirstLogin {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcAckFirstLogin {
        let packet_id = i16::from_le_bytes([0x6f, 0x02]);
        let packet_id_raw = [0x6f, 0x02];
        PacketAcAckFirstLogin {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketAcAckFirstLogin {
    fn id(&self, packetver: u32) -> &str {
       PacketAcAckFirstLogin::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcReqLoginAccountInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7002"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcReqLoginAccountInfo {
        let mut offset: usize = 0;
        PacketAcReqLoginAccountInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcReqLoginAccountInfo {
        let packet_id = i16::from_le_bytes([0x70, 0x02]);
        let packet_id_raw = [0x70, 0x02];
        PacketAcReqLoginAccountInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketAcReqLoginAccountInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketAcReqLoginAccountInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCaAckLoginAccountInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7102"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaAckLoginAccountInfo {
        let mut offset: usize = 0;
        PacketCaAckLoginAccountInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            sex: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            b_point: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            b_point_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            email: {
                let field =  {
                let mut dst: [char; 34] = [0 as char; 34];
                for (index, byte) in buffer[offset..offset + 34].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            email_raw: {
                let mut dst: [u8; 34] = [0u8; 34];
                dst.clone_from_slice(&buffer[offset..offset + 34]);
                offset += 34;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.b_point).unwrap();
        self.b_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.email {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.email_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.b_point_raw.to_vec());
        wtr.append(&mut self.email_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 40;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_sex(&mut self, value: i16) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 2]) {
        self.sex_raw = value;
    }
    pub fn set_b_point(&mut self, value: i16) {
        self.b_point = value;
    }
    pub fn set_b_point_raw(&mut self, value: [u8; 2]) {
        self.b_point_raw = value;
    }
    pub fn set_email(&mut self, value: [char; 34]) {
        self.email = value;
    }
    pub fn set_email_raw(&mut self, value: [u8; 34]) {
        self.email_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaAckLoginAccountInfo {
        let packet_id = i16::from_le_bytes([0x71, 0x02]);
        let packet_id_raw = [0x71, 0x02];
        PacketCaAckLoginAccountInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        sex: 0,
        sex_raw: [0; 2],
        b_point: 0,
        b_point_raw: [0; 2],
        email: [0 as char; 34],
        email_raw: [0; 34],
        }
    }
}

impl Packet for PacketCaAckLoginAccountInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketCaAckLoginAccountInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcAckPtIdInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7202"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcAckPtIdInfo {
        let mut offset: usize = 0;
        PacketAcAckPtIdInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            sz_ptid: {
                let field =  {
                let mut dst: [char; 21] = [0 as char; 21];
                for (index, byte) in buffer[offset..offset + 21].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            sz_ptid_raw: {
                let mut dst: [u8; 21] = [0u8; 21];
                dst.clone_from_slice(&buffer[offset..offset + 21]);
                offset += 21;
                dst
            },
            sz_ptnum_id: {
                let field =  {
                let mut dst: [char; 21] = [0 as char; 21];
                for (index, byte) in buffer[offset..offset + 21].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            sz_ptnum_id_raw: {
                let mut dst: [u8; 21] = [0u8; 21];
                dst.clone_from_slice(&buffer[offset..offset + 21]);
                offset += 21;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_ptid {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_ptid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_ptnum_id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_ptnum_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.sz_ptid_raw.to_vec());
        wtr.append(&mut self.sz_ptnum_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 44;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_sz_ptid(&mut self, value: [char; 21]) {
        self.sz_ptid = value;
    }
    pub fn set_sz_ptid_raw(&mut self, value: [u8; 21]) {
        self.sz_ptid_raw = value;
    }
    pub fn set_sz_ptnum_id(&mut self, value: [char; 21]) {
        self.sz_ptnum_id = value;
    }
    pub fn set_sz_ptnum_id_raw(&mut self, value: [u8; 21]) {
        self.sz_ptnum_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcAckPtIdInfo {
        let packet_id = i16::from_le_bytes([0x72, 0x02]);
        let packet_id_raw = [0x72, 0x02];
        PacketAcAckPtIdInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        sz_ptid: [0 as char; 21],
        sz_ptid_raw: [0; 21],
        sz_ptnum_id: [0 as char; 21],
        sz_ptnum_id_raw: [0; 21],
        }
    }
}

impl Packet for PacketAcAckPtIdInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketAcAckPtIdInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqMailReturn {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7302"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqMailReturn {
        let mut offset: usize = 0;
        PacketCzReqMailReturn {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mail_id: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            receive_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            receive_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.receive_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.receive_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.mail_id_raw.to_vec());
        wtr.append(&mut self.receive_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 30;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_mail_id(&mut self, value: i32) {
        self.mail_id = value;
    }
    pub fn set_mail_id_raw(&mut self, value: [u8; 4]) {
        self.mail_id_raw = value;
    }
    pub fn set_receive_name(&mut self, value: [char; 24]) {
        self.receive_name = value;
    }
    pub fn set_receive_name_raw(&mut self, value: [u8; 24]) {
        self.receive_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqMailReturn {
        let packet_id = i16::from_le_bytes([0x73, 0x02]);
        let packet_id_raw = [0x73, 0x02];
        PacketCzReqMailReturn {
        raw: vec![],
        packet_id,
        packet_id_raw,
        mail_id: 0,
        mail_id_raw: [0; 4],
        receive_name: [0 as char; 24],
        receive_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzReqMailReturn {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqMailReturn::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckMailReturn {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7402"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckMailReturn {
        let mut offset: usize = 0;
        PacketZcAckMailReturn {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mail_id: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.mail_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_mail_id(&mut self, value: i32) {
        self.mail_id = value;
    }
    pub fn set_mail_id_raw(&mut self, value: [u8; 4]) {
        self.mail_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckMailReturn {
        let packet_id = i16::from_le_bytes([0x74, 0x02]);
        let packet_id_raw = [0x74, 0x02];
        PacketZcAckMailReturn {
        raw: vec![],
        packet_id,
        packet_id_raw,
        mail_id: 0,
        mail_id_raw: [0; 4],
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAckMailReturn {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckMailReturn::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketChEnter2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7502"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketChEnter2 {
        let mut offset: usize = 0;
        PacketChEnter2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            auth_code: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            user_level: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            user_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            client_type: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            client_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            mac_data: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            mac_data_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            i_account_sid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            i_account_sid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.user_level).unwrap();
        self.user_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.client_type).unwrap();
        self.client_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mac_data {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mac_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.i_account_sid).unwrap();
        self.i_account_sid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.auth_code_raw.to_vec());
        wtr.append(&mut self.user_level_raw.to_vec());
        wtr.append(&mut self.client_type_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.mac_data_raw.to_vec());
        wtr.append(&mut self.i_account_sid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 37;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_auth_code(&mut self, value: i32) {
        self.auth_code = value;
    }
    pub fn set_auth_code_raw(&mut self, value: [u8; 4]) {
        self.auth_code_raw = value;
    }
    pub fn set_user_level(&mut self, value: u32) {
        self.user_level = value;
    }
    pub fn set_user_level_raw(&mut self, value: [u8; 4]) {
        self.user_level_raw = value;
    }
    pub fn set_client_type(&mut self, value: u16) {
        self.client_type = value;
    }
    pub fn set_client_type_raw(&mut self, value: [u8; 2]) {
        self.client_type_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_mac_data(&mut self, value: [char; 16]) {
        self.mac_data = value;
    }
    pub fn set_mac_data_raw(&mut self, value: [u8; 16]) {
        self.mac_data_raw = value;
    }
    pub fn set_i_account_sid(&mut self, value: i32) {
        self.i_account_sid = value;
    }
    pub fn set_i_account_sid_raw(&mut self, value: [u8; 4]) {
        self.i_account_sid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketChEnter2 {
        let packet_id = i16::from_le_bytes([0x75, 0x02]);
        let packet_id_raw = [0x75, 0x02];
        PacketChEnter2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        auth_code: 0,
        auth_code_raw: [0; 4],
        user_level: 0,
        user_level_raw: [0; 4],
        client_type: 0,
        client_type_raw: [0; 2],
        sex: 0,
        sex_raw: [0; 1],
        mac_data: [0 as char; 16],
        mac_data_raw: [0; 16],
        i_account_sid: 0,
        i_account_sid_raw: [0; 4],
        }
    }
}

impl Packet for PacketChEnter2 {
    fn id(&self, packetver: u32) -> &str {
       PacketChEnter2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCaAcceptLogin2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7602"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaAcceptLogin2 {
        let mut offset: usize = 0;
        PacketCaAcceptLogin2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            auth_code: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            user_level: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            user_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            last_login_ip: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            last_login_ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            last_login_time: {
                let field =  {
                let mut dst: [char; 26] = [0 as char; 26];
                for (index, byte) in buffer[offset..offset + 26].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            last_login_time_raw: {
                let mut dst: [u8; 26] = [0u8; 26];
                dst.clone_from_slice(&buffer[offset..offset + 26]);
                offset += 26;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            i_account_sid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            i_account_sid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.user_level).unwrap();
        self.user_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.last_login_ip).unwrap();
        self.last_login_ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.last_login_time {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.last_login_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.i_account_sid).unwrap();
        self.i_account_sid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.auth_code_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.user_level_raw.to_vec());
        wtr.append(&mut self.last_login_ip_raw.to_vec());
        wtr.append(&mut self.last_login_time_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.i_account_sid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 51;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_auth_code(&mut self, value: i32) {
        self.auth_code = value;
    }
    pub fn set_auth_code_raw(&mut self, value: [u8; 4]) {
        self.auth_code_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_user_level(&mut self, value: u32) {
        self.user_level = value;
    }
    pub fn set_user_level_raw(&mut self, value: [u8; 4]) {
        self.user_level_raw = value;
    }
    pub fn set_last_login_ip(&mut self, value: u32) {
        self.last_login_ip = value;
    }
    pub fn set_last_login_ip_raw(&mut self, value: [u8; 4]) {
        self.last_login_ip_raw = value;
    }
    pub fn set_last_login_time(&mut self, value: [char; 26]) {
        self.last_login_time = value;
    }
    pub fn set_last_login_time_raw(&mut self, value: [u8; 26]) {
        self.last_login_time_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_i_account_sid(&mut self, value: i32) {
        self.i_account_sid = value;
    }
    pub fn set_i_account_sid_raw(&mut self, value: [u8; 4]) {
        self.i_account_sid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaAcceptLogin2 {
        let packet_id = i16::from_le_bytes([0x76, 0x02]);
        let packet_id_raw = [0x76, 0x02];
        PacketCaAcceptLogin2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        auth_code: 0,
        auth_code_raw: [0; 4],
        aid: 0,
        aid_raw: [0; 4],
        user_level: 0,
        user_level_raw: [0; 4],
        last_login_ip: 0,
        last_login_ip_raw: [0; 4],
        last_login_time: [0 as char; 26],
        last_login_time_raw: [0; 26],
        sex: 0,
        sex_raw: [0; 1],
        i_account_sid: 0,
        i_account_sid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCaAcceptLogin2 {
    fn id(&self, packetver: u32) -> &str {
       PacketCaAcceptLogin2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCaLoginPcbang {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7702"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaLoginPcbang {
        let mut offset: usize = 0;
        PacketCaLoginPcbang {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            version: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            id: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            passwd: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            passwd_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            clienttype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            ip: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            ip_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            mac_adress: {
                let field =  {
                let mut dst: [char; 13] = [0 as char; 13];
                for (index, byte) in buffer[offset..offset + 13].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            mac_adress_raw: {
                let mut dst: [u8; 13] = [0u8; 13];
                dst.clone_from_slice(&buffer[offset..offset + 13]);
                offset += 13;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.ip {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mac_adress {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mac_adress_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.version_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.passwd_raw.to_vec());
        wtr.append(&mut self.clienttype_raw.to_vec());
        wtr.append(&mut self.ip_raw.to_vec());
        wtr.append(&mut self.mac_adress_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 84;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_version(&mut self, value: u32) {
        self.version = value;
    }
    pub fn set_version_raw(&mut self, value: [u8; 4]) {
        self.version_raw = value;
    }
    pub fn set_id(&mut self, value: [char; 24]) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 24]) {
        self.id_raw = value;
    }
    pub fn set_passwd(&mut self, value: [char; 24]) {
        self.passwd = value;
    }
    pub fn set_passwd_raw(&mut self, value: [u8; 24]) {
        self.passwd_raw = value;
    }
    pub fn set_clienttype(&mut self, value: u8) {
        self.clienttype = value;
    }
    pub fn set_clienttype_raw(&mut self, value: [u8; 1]) {
        self.clienttype_raw = value;
    }
    pub fn set_ip(&mut self, value: [char; 16]) {
        self.ip = value;
    }
    pub fn set_ip_raw(&mut self, value: [u8; 16]) {
        self.ip_raw = value;
    }
    pub fn set_mac_adress(&mut self, value: [char; 13]) {
        self.mac_adress = value;
    }
    pub fn set_mac_adress_raw(&mut self, value: [u8; 13]) {
        self.mac_adress_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaLoginPcbang {
        let packet_id = i16::from_le_bytes([0x77, 0x02]);
        let packet_id_raw = [0x77, 0x02];
        PacketCaLoginPcbang {
        raw: vec![],
        packet_id,
        packet_id_raw,
        version: 0,
        version_raw: [0; 4],
        id: [0 as char; 24],
        id_raw: [0; 24],
        passwd: [0 as char; 24],
        passwd_raw: [0; 24],
        clienttype: 0,
        clienttype_raw: [0; 1],
        ip: [0 as char; 16],
        ip_raw: [0; 16],
        mac_adress: [0 as char; 13],
        mac_adress_raw: [0; 13],
        }
    }
}

impl Packet for PacketCaLoginPcbang {
    fn id(&self, packetver: u32) -> &str {
       PacketCaLoginPcbang::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyPcbang {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7802"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyPcbang {
        let mut offset: usize = 0;
        PacketZcNotifyPcbang {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyPcbang {
        let packet_id = i16::from_le_bytes([0x78, 0x02]);
        let packet_id_raw = [0x78, 0x02];
        PacketZcNotifyPcbang {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketZcNotifyPcbang {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyPcbang::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzHuntinglist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7902"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzHuntinglist {
        let mut offset: usize = 0;
        PacketCzHuntinglist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzHuntinglist {
        let packet_id = i16::from_le_bytes([0x79, 0x02]);
        let packet_id_raw = [0x79, 0x02];
        PacketCzHuntinglist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzHuntinglist {
    fn id(&self, packetver: u32) -> &str {
       PacketCzHuntinglist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcHuntinglist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7a02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcHuntinglist {
        let mut offset: usize = 0;
        let vec_type_len = PacketMobHunting::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<PacketMobHunting> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(PacketMobHunting::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcHuntinglist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            hunting_list: {
                let field = vec_field.clone();
                field
            },
            hunting_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.hunting_list_raw = {
            self.hunting_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.hunting_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.hunting_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_hunting_list(&mut self, value: Vec<PacketMobHunting>) {
        self.hunting_list = value;
    }
    pub fn set_hunting_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.hunting_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcHuntinglist {
        let packet_id = i16::from_le_bytes([0x7a, 0x02]);
        let packet_id_raw = [0x7a, 0x02];
        PacketZcHuntinglist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        hunting_list: vec![],
        hunting_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcHuntinglist {
    fn id(&self, packetver: u32) -> &str {
       PacketZcHuntinglist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPcbangEffect {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7b02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPcbangEffect {
        let mut offset: usize = 0;
        PacketZcPcbangEffect {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            exp_factor: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            exp_factor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            exp_factor2: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            exp_factor2_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            drop_factor: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            drop_factor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.exp_factor).unwrap();
        self.exp_factor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.exp_factor2).unwrap();
        self.exp_factor2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.drop_factor).unwrap();
        self.drop_factor_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.exp_factor_raw.to_vec());
        wtr.append(&mut self.exp_factor2_raw.to_vec());
        wtr.append(&mut self.drop_factor_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_exp_factor(&mut self, value: i32) {
        self.exp_factor = value;
    }
    pub fn set_exp_factor_raw(&mut self, value: [u8; 4]) {
        self.exp_factor_raw = value;
    }
    pub fn set_exp_factor2(&mut self, value: i32) {
        self.exp_factor2 = value;
    }
    pub fn set_exp_factor2_raw(&mut self, value: [u8; 4]) {
        self.exp_factor2_raw = value;
    }
    pub fn set_drop_factor(&mut self, value: i32) {
        self.drop_factor = value;
    }
    pub fn set_drop_factor_raw(&mut self, value: [u8; 4]) {
        self.drop_factor_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPcbangEffect {
        let packet_id = i16::from_le_bytes([0x7b, 0x02]);
        let packet_id_raw = [0x7b, 0x02];
        PacketZcPcbangEffect {
        raw: vec![],
        packet_id,
        packet_id_raw,
        exp_factor: 0,
        exp_factor_raw: [0; 4],
        exp_factor2: 0,
        exp_factor2_raw: [0; 4],
        drop_factor: 0,
        drop_factor_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcPcbangEffect {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPcbangEffect::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCaLogin4 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7c02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaLogin4 {
        let mut offset: usize = 0;
        PacketCaLogin4 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            version: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            id: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            passwd_md5: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            passwd_md5_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            clienttype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            mac_data: {
                let field =  {
                let mut dst: [char; 13] = [0 as char; 13];
                for (index, byte) in buffer[offset..offset + 13].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            mac_data_raw: {
                let mut dst: [u8; 13] = [0u8; 13];
                dst.clone_from_slice(&buffer[offset..offset + 13]);
                offset += 13;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd_md5 {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_md5_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mac_data {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mac_data_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.version_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.passwd_md5_raw.to_vec());
        wtr.append(&mut self.clienttype_raw.to_vec());
        wtr.append(&mut self.mac_data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 60;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_version(&mut self, value: u32) {
        self.version = value;
    }
    pub fn set_version_raw(&mut self, value: [u8; 4]) {
        self.version_raw = value;
    }
    pub fn set_id(&mut self, value: [char; 24]) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 24]) {
        self.id_raw = value;
    }
    pub fn set_passwd_md5(&mut self, value: [char; 16]) {
        self.passwd_md5 = value;
    }
    pub fn set_passwd_md5_raw(&mut self, value: [u8; 16]) {
        self.passwd_md5_raw = value;
    }
    pub fn set_clienttype(&mut self, value: u8) {
        self.clienttype = value;
    }
    pub fn set_clienttype_raw(&mut self, value: [u8; 1]) {
        self.clienttype_raw = value;
    }
    pub fn set_mac_data(&mut self, value: [char; 13]) {
        self.mac_data = value;
    }
    pub fn set_mac_data_raw(&mut self, value: [u8; 13]) {
        self.mac_data_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaLogin4 {
        let packet_id = i16::from_le_bytes([0x7c, 0x02]);
        let packet_id_raw = [0x7c, 0x02];
        PacketCaLogin4 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        version: 0,
        version_raw: [0; 4],
        id: [0 as char; 24],
        id_raw: [0; 24],
        passwd_md5: [0 as char; 16],
        passwd_md5_raw: [0; 16],
        clienttype: 0,
        clienttype_raw: [0; 1],
        mac_data: [0 as char; 13],
        mac_data_raw: [0; 13],
        }
    }
}

impl Packet for PacketCaLogin4 {
    fn id(&self, packetver: u32) -> &str {
       PacketCaLogin4::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPropertyMerce {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7d02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPropertyMerce {
        let mut offset: usize = 0;
        PacketZcPropertyMerce {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            faith: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            faith_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            summon_count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            summon_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atk: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            matk: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            matk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            hit: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            hit_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            critical: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            critical_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            def: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            def_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mdef: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            mdef_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            flee: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            flee_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aspd: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            hp: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            max_hp: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            max_hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            sp: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            max_sp: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            max_sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atkrange: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atkrange_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            exp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.faith).unwrap();
        self.faith_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.summon_count).unwrap();
        self.summon_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atk).unwrap();
        self.atk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.matk).unwrap();
        self.matk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hit).unwrap();
        self.hit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.critical).unwrap();
        self.critical_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.def).unwrap();
        self.def_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef).unwrap();
        self.mdef_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.flee).unwrap();
        self.flee_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.aspd).unwrap();
        self.aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sp).unwrap();
        self.sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_sp).unwrap();
        self.max_sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atkrange).unwrap();
        self.atkrange_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.exp).unwrap();
        self.exp_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.faith_raw.to_vec());
        wtr.append(&mut self.summon_count_raw.to_vec());
        wtr.append(&mut self.atk_raw.to_vec());
        wtr.append(&mut self.matk_raw.to_vec());
        wtr.append(&mut self.hit_raw.to_vec());
        wtr.append(&mut self.critical_raw.to_vec());
        wtr.append(&mut self.def_raw.to_vec());
        wtr.append(&mut self.mdef_raw.to_vec());
        wtr.append(&mut self.flee_raw.to_vec());
        wtr.append(&mut self.aspd_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.max_hp_raw.to_vec());
        wtr.append(&mut self.sp_raw.to_vec());
        wtr.append(&mut self.max_sp_raw.to_vec());
        wtr.append(&mut self.atkrange_raw.to_vec());
        wtr.append(&mut self.exp_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 62;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_faith(&mut self, value: i16) {
        self.faith = value;
    }
    pub fn set_faith_raw(&mut self, value: [u8; 2]) {
        self.faith_raw = value;
    }
    pub fn set_summon_count(&mut self, value: i16) {
        self.summon_count = value;
    }
    pub fn set_summon_count_raw(&mut self, value: [u8; 2]) {
        self.summon_count_raw = value;
    }
    pub fn set_atk(&mut self, value: i16) {
        self.atk = value;
    }
    pub fn set_atk_raw(&mut self, value: [u8; 2]) {
        self.atk_raw = value;
    }
    pub fn set_matk(&mut self, value: i16) {
        self.matk = value;
    }
    pub fn set_matk_raw(&mut self, value: [u8; 2]) {
        self.matk_raw = value;
    }
    pub fn set_hit(&mut self, value: i16) {
        self.hit = value;
    }
    pub fn set_hit_raw(&mut self, value: [u8; 2]) {
        self.hit_raw = value;
    }
    pub fn set_critical(&mut self, value: i16) {
        self.critical = value;
    }
    pub fn set_critical_raw(&mut self, value: [u8; 2]) {
        self.critical_raw = value;
    }
    pub fn set_def(&mut self, value: i16) {
        self.def = value;
    }
    pub fn set_def_raw(&mut self, value: [u8; 2]) {
        self.def_raw = value;
    }
    pub fn set_mdef(&mut self, value: i16) {
        self.mdef = value;
    }
    pub fn set_mdef_raw(&mut self, value: [u8; 2]) {
        self.mdef_raw = value;
    }
    pub fn set_flee(&mut self, value: i16) {
        self.flee = value;
    }
    pub fn set_flee_raw(&mut self, value: [u8; 2]) {
        self.flee_raw = value;
    }
    pub fn set_aspd(&mut self, value: i16) {
        self.aspd = value;
    }
    pub fn set_aspd_raw(&mut self, value: [u8; 2]) {
        self.aspd_raw = value;
    }
    pub fn set_hp(&mut self, value: i16) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 2]) {
        self.hp_raw = value;
    }
    pub fn set_max_hp(&mut self, value: i16) {
        self.max_hp = value;
    }
    pub fn set_max_hp_raw(&mut self, value: [u8; 2]) {
        self.max_hp_raw = value;
    }
    pub fn set_sp(&mut self, value: i16) {
        self.sp = value;
    }
    pub fn set_sp_raw(&mut self, value: [u8; 2]) {
        self.sp_raw = value;
    }
    pub fn set_max_sp(&mut self, value: i16) {
        self.max_sp = value;
    }
    pub fn set_max_sp_raw(&mut self, value: [u8; 2]) {
        self.max_sp_raw = value;
    }
    pub fn set_atkrange(&mut self, value: i16) {
        self.atkrange = value;
    }
    pub fn set_atkrange_raw(&mut self, value: [u8; 2]) {
        self.atkrange_raw = value;
    }
    pub fn set_exp(&mut self, value: i32) {
        self.exp = value;
    }
    pub fn set_exp_raw(&mut self, value: [u8; 4]) {
        self.exp_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPropertyMerce {
        let packet_id = i16::from_le_bytes([0x7d, 0x02]);
        let packet_id_raw = [0x7d, 0x02];
        PacketZcPropertyMerce {
        raw: vec![],
        packet_id,
        packet_id_raw,
        name: [0 as char; 24],
        name_raw: [0; 24],
        level: 0,
        level_raw: [0; 2],
        faith: 0,
        faith_raw: [0; 2],
        summon_count: 0,
        summon_count_raw: [0; 2],
        atk: 0,
        atk_raw: [0; 2],
        matk: 0,
        matk_raw: [0; 2],
        hit: 0,
        hit_raw: [0; 2],
        critical: 0,
        critical_raw: [0; 2],
        def: 0,
        def_raw: [0; 2],
        mdef: 0,
        mdef_raw: [0; 2],
        flee: 0,
        flee_raw: [0; 2],
        aspd: 0,
        aspd_raw: [0; 2],
        hp: 0,
        hp_raw: [0; 2],
        max_hp: 0,
        max_hp_raw: [0; 2],
        sp: 0,
        sp_raw: [0; 2],
        max_sp: 0,
        max_sp_raw: [0; 2],
        atkrange: 0,
        atkrange_raw: [0; 2],
        exp: 0,
        exp_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcPropertyMerce {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPropertyMerce::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcShandaProtect {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7e02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcShandaProtect {
        let mut offset: usize = 0;
        PacketZcShandaProtect {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            code_len: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            code_len_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            code: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            code_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.code_len).unwrap();
        self.code_len_raw = wtr.try_into().unwrap();
        self.code_raw = self.code.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.code_len_raw.to_vec());
        wtr.append(&mut self.code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_code_len(&mut self, value: i16) {
        self.code_len = value;
    }
    pub fn set_code_len_raw(&mut self, value: [u8; 2]) {
        self.code_len_raw = value;
    }
    pub fn set_code(&mut self, value: String) {
        self.code = value;
    }
    pub fn set_code_raw(&mut self, value: Vec<u8>) {
        self.code_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcShandaProtect {
        let packet_id = i16::from_le_bytes([0x7e, 0x02]);
        let packet_id_raw = [0x7e, 0x02];
        PacketZcShandaProtect {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        code_len: 0,
        code_len_raw: [0; 2],
        code: String::new(),
        code_raw: vec![],
        }
    }
}

impl Packet for PacketZcShandaProtect {
    fn id(&self, packetver: u32) -> &str {
       PacketZcShandaProtect::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCaClientType {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x7f02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaClientType {
        let mut offset: usize = 0;
        PacketCaClientType {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            client_type: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            client_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            n_ver: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            n_ver_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.client_type).unwrap();
        self.client_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.n_ver).unwrap();
        self.n_ver_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.client_type_raw.to_vec());
        wtr.append(&mut self.n_ver_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_client_type(&mut self, value: i16) {
        self.client_type = value;
    }
    pub fn set_client_type_raw(&mut self, value: [u8; 2]) {
        self.client_type_raw = value;
    }
    pub fn set_n_ver(&mut self, value: i32) {
        self.n_ver = value;
    }
    pub fn set_n_ver_raw(&mut self, value: [u8; 4]) {
        self.n_ver_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaClientType {
        let packet_id = i16::from_le_bytes([0x7f, 0x02]);
        let packet_id_raw = [0x7f, 0x02];
        PacketCaClientType {
        raw: vec![],
        packet_id,
        packet_id_raw,
        client_type: 0,
        client_type_raw: [0; 2],
        n_ver: 0,
        n_ver_raw: [0; 4],
        }
    }
}

impl Packet for PacketCaClientType {
    fn id(&self, packetver: u32) -> &str {
       PacketCaClientType::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcGangsiPoint {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8002"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcGangsiPoint {
        let mut offset: usize = 0;
        PacketZcGangsiPoint {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            point: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            total_point: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            total_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            packet_switch: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_switch_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.total_point).unwrap();
        self.total_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_switch).unwrap();
        self.packet_switch_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        wtr.append(&mut self.total_point_raw.to_vec());
        wtr.append(&mut self.packet_switch_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 12;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_point(&mut self, value: i32) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 4]) {
        self.point_raw = value;
    }
    pub fn set_total_point(&mut self, value: i32) {
        self.total_point = value;
    }
    pub fn set_total_point_raw(&mut self, value: [u8; 4]) {
        self.total_point_raw = value;
    }
    pub fn set_packet_switch(&mut self, value: i16) {
        self.packet_switch = value;
    }
    pub fn set_packet_switch_raw(&mut self, value: [u8; 2]) {
        self.packet_switch_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcGangsiPoint {
        let packet_id = i16::from_le_bytes([0x80, 0x02]);
        let packet_id_raw = [0x80, 0x02];
        PacketZcGangsiPoint {
        raw: vec![],
        packet_id,
        packet_id_raw,
        point: 0,
        point_raw: [0; 4],
        total_point: 0,
        total_point_raw: [0; 4],
        packet_switch: 0,
        packet_switch_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcGangsiPoint {
    fn id(&self, packetver: u32) -> &str {
       PacketZcGangsiPoint::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzGangsiRank {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8102"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzGangsiRank {
        let mut offset: usize = 0;
        PacketCzGangsiRank {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_switch: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_switch_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_switch).unwrap();
        self.packet_switch_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_switch_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_switch(&mut self, value: i16) {
        self.packet_switch = value;
    }
    pub fn set_packet_switch_raw(&mut self, value: [u8; 2]) {
        self.packet_switch_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzGangsiRank {
        let packet_id = i16::from_le_bytes([0x81, 0x02]);
        let packet_id_raw = [0x81, 0x02];
        PacketCzGangsiRank {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_switch: 0,
        packet_switch_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzGangsiRank {
    fn id(&self, packetver: u32) -> &str {
       PacketCzGangsiRank::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcGangsiRank {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8202"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcGangsiRank {
        let mut offset: usize = 0;
        PacketZcGangsiRank {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 10] = [0 as char; 10];
                for (index, byte) in buffer[offset..offset + 10].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 10] = [0u8; 10];
                dst.clone_from_slice(&buffer[offset..offset + 10]);
                offset += 10;
                dst
            },
            point: {
                let field =  {
                let mut dst: [i32; 10] = [0_i32; 10];
                for (index, byte) in buffer[offset..offset + 10].iter().enumerate() {
                    dst[index] = *byte as i32;
                }
                dst
            };
                field
            },
            point_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[offset..offset + 40]);
                offset += 40;
                dst
            },
            packet_switch: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_switch_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.point {
            wtr.write_i32::<LittleEndian>(item).unwrap();
        }
        self.point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_switch).unwrap();
        self.packet_switch_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        wtr.append(&mut self.packet_switch_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 24;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 10]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 10]) {
        self.name_raw = value;
    }
    pub fn set_point(&mut self, value: [i32; 10]) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 40]) {
        self.point_raw = value;
    }
    pub fn set_packet_switch(&mut self, value: i16) {
        self.packet_switch = value;
    }
    pub fn set_packet_switch_raw(&mut self, value: [u8; 2]) {
        self.packet_switch_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcGangsiRank {
        let packet_id = i16::from_le_bytes([0x82, 0x02]);
        let packet_id_raw = [0x82, 0x02];
        PacketZcGangsiRank {
        raw: vec![],
        packet_id,
        packet_id_raw,
        name: [0 as char; 10],
        name_raw: [0; 10],
        point: [0; 10],
        point_raw: [0; 40],
        packet_switch: 0,
        packet_switch_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcGangsiRank {
    fn id(&self, packetver: u32) -> &str {
       PacketZcGangsiRank::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAid {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8302"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAid {
        let mut offset: usize = 0;
        PacketZcAid {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAid {
        let packet_id = i16::from_le_bytes([0x83, 0x02]);
        let packet_id_raw = [0x83, 0x02];
        PacketZcAid {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcAid {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAid::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyEffect3 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8402"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyEffect3 {
        let mut offset: usize = 0;
        PacketZcNotifyEffect3 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            effect_id: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            effect_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            numdata: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            numdata_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_id).unwrap();
        self.effect_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.numdata).unwrap();
        self.numdata_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.effect_id_raw.to_vec());
        wtr.append(&mut self.numdata_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_effect_id(&mut self, value: i32) {
        self.effect_id = value;
    }
    pub fn set_effect_id_raw(&mut self, value: [u8; 4]) {
        self.effect_id_raw = value;
    }
    pub fn set_numdata(&mut self, value: i32) {
        self.numdata = value;
    }
    pub fn set_numdata_raw(&mut self, value: [u8; 4]) {
        self.numdata_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyEffect3 {
        let packet_id = i16::from_le_bytes([0x84, 0x02]);
        let packet_id_raw = [0x84, 0x02];
        PacketZcNotifyEffect3 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        effect_id: 0,
        effect_id_raw: [0; 4],
        numdata: 0,
        numdata_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyEffect3 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyEffect3::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcDeathQuestion {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8502"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcDeathQuestion {
        let mut offset: usize = 0;
        PacketZcDeathQuestion {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            qcategory: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            qcategory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            qnum: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            qnum_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.qcategory).unwrap();
        self.qcategory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.qnum).unwrap();
        self.qnum_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.qcategory_raw.to_vec());
        wtr.append(&mut self.qnum_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_qcategory(&mut self, value: i16) {
        self.qcategory = value;
    }
    pub fn set_qcategory_raw(&mut self, value: [u8; 2]) {
        self.qcategory_raw = value;
    }
    pub fn set_qnum(&mut self, value: i16) {
        self.qnum = value;
    }
    pub fn set_qnum_raw(&mut self, value: [u8; 2]) {
        self.qnum_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcDeathQuestion {
        let packet_id = i16::from_le_bytes([0x85, 0x02]);
        let packet_id_raw = [0x85, 0x02];
        PacketZcDeathQuestion {
        raw: vec![],
        packet_id,
        packet_id_raw,
        qcategory: 0,
        qcategory_raw: [0; 2],
        qnum: 0,
        qnum_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcDeathQuestion {
    fn id(&self, packetver: u32) -> &str {
       PacketZcDeathQuestion::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzDeathQuestion {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8602"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzDeathQuestion {
        let mut offset: usize = 0;
        PacketCzDeathQuestion {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            qanswer: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            qanswer_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.qanswer).unwrap();
        self.qanswer_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.qanswer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_qanswer(&mut self, value: i16) {
        self.qanswer = value;
    }
    pub fn set_qanswer_raw(&mut self, value: [u8; 2]) {
        self.qanswer_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzDeathQuestion {
        let packet_id = i16::from_le_bytes([0x86, 0x02]);
        let packet_id_raw = [0x86, 0x02];
        PacketCzDeathQuestion {
        raw: vec![],
        packet_id,
        packet_id_raw,
        qanswer: 0,
        qanswer_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzDeathQuestion {
    fn id(&self, packetver: u32) -> &str {
       PacketCzDeathQuestion::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPcCashPointItemlist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8702"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPcCashPointItemlist {
        let mut offset: usize = 0;
        let vec_type_len = PurchaseItem::base_len(packetver);
        let iter_count = (&buffer.len() - 8) / vec_type_len;
        let mut vec_field: Vec<PurchaseItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (vec_type_len * (i - 1));
            let end_pos = 8 + vec_type_len * i;
            vec_field.push(PurchaseItem::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcPcCashPointItemlist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            cash_point: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            cash_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            item_list: {
                let field = vec_field.clone();
                field
            },
            item_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.cash_point).unwrap();
        self.cash_point_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.cash_point_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_cash_point(&mut self, value: u32) {
        self.cash_point = value;
    }
    pub fn set_cash_point_raw(&mut self, value: [u8; 4]) {
        self.cash_point_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<PurchaseItem>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPcCashPointItemlist {
        let packet_id = i16::from_le_bytes([0x87, 0x02]);
        let packet_id_raw = [0x87, 0x02];
        PacketZcPcCashPointItemlist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        cash_point: 0,
        cash_point_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcPcCashPointItemlist {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPcCashPointItemlist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzPcBuyCashPointItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8802"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzPcBuyCashPointItem {
        let mut offset: usize = 0;
        PacketCzPcBuyCashPointItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzPcBuyCashPointItem {
        let packet_id = i16::from_le_bytes([0x88, 0x02]);
        let packet_id_raw = [0x88, 0x02];
        PacketCzPcBuyCashPointItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        itid: 0,
        itid_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzPcBuyCashPointItem {
    fn id(&self, packetver: u32) -> &str {
       PacketCzPcBuyCashPointItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPcCashPointUpdate {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8902"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPcCashPointUpdate {
        let mut offset: usize = 0;
        PacketZcPcCashPointUpdate {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            cash_point: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            cash_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            error: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            error_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.cash_point).unwrap();
        self.cash_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error).unwrap();
        self.error_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.cash_point_raw.to_vec());
        wtr.append(&mut self.error_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_cash_point(&mut self, value: u32) {
        self.cash_point = value;
    }
    pub fn set_cash_point_raw(&mut self, value: [u8; 4]) {
        self.cash_point_raw = value;
    }
    pub fn set_error(&mut self, value: i16) {
        self.error = value;
    }
    pub fn set_error_raw(&mut self, value: [u8; 2]) {
        self.error_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPcCashPointUpdate {
        let packet_id = i16::from_le_bytes([0x89, 0x02]);
        let packet_id_raw = [0x89, 0x02];
        PacketZcPcCashPointUpdate {
        raw: vec![],
        packet_id,
        packet_id_raw,
        cash_point: 0,
        cash_point_raw: [0; 4],
        error: 0,
        error_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcPcCashPointUpdate {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPcCashPointUpdate::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNpcShowefstUpdate {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8a02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNpcShowefstUpdate {
        let mut offset: usize = 0;
        PacketZcNpcShowefstUpdate {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            effect_state: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            clevel: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            show_efst: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            show_efst_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.show_efst).unwrap();
        self.show_efst_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        wtr.append(&mut self.show_efst_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 18;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_clevel(&mut self, value: i32) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 4]) {
        self.clevel_raw = value;
    }
    pub fn set_show_efst(&mut self, value: i32) {
        self.show_efst = value;
    }
    pub fn set_show_efst_raw(&mut self, value: [u8; 4]) {
        self.show_efst_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNpcShowefstUpdate {
        let packet_id = i16::from_le_bytes([0x8a, 0x02]);
        let packet_id_raw = [0x8a, 0x02];
        PacketZcNpcShowefstUpdate {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        effect_state: 0,
        effect_state_raw: [0; 4],
        clevel: 0,
        clevel_raw: [0; 4],
        show_efst: 0,
        show_efst_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNpcShowefstUpdate {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNpcShowefstUpdate::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketChSelectCharGoingtobeused {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8c02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketChSelectCharGoingtobeused {
        let mut offset: usize = 0;
        PacketChSelectCharGoingtobeused {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            dw_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dw_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            n_count_selected_char: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            n_count_selected_char_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            ardw_selected_gid: {
                let field =  {
                let mut dst: [u32; 9] = [0_u32; 9];
                for (index, byte) in buffer[offset..offset + 9].iter().enumerate() {
                    dst[index] = *byte as u32;
                }
                dst
            };
                field
            },
            ardw_selected_gid_raw: {
                let mut dst: [u8; 36] = [0u8; 36];
                dst.clone_from_slice(&buffer[offset..offset + 36]);
                offset += 36;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_aid).unwrap();
        self.dw_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.n_count_selected_char).unwrap();
        self.n_count_selected_char_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.ardw_selected_gid {
            wtr.write_u32::<LittleEndian>(item).unwrap();
        }
        self.ardw_selected_gid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.dw_aid_raw.to_vec());
        wtr.append(&mut self.n_count_selected_char_raw.to_vec());
        wtr.append(&mut self.ardw_selected_gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 19;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_dw_aid(&mut self, value: u32) {
        self.dw_aid = value;
    }
    pub fn set_dw_aid_raw(&mut self, value: [u8; 4]) {
        self.dw_aid_raw = value;
    }
    pub fn set_n_count_selected_char(&mut self, value: i32) {
        self.n_count_selected_char = value;
    }
    pub fn set_n_count_selected_char_raw(&mut self, value: [u8; 4]) {
        self.n_count_selected_char_raw = value;
    }
    pub fn set_ardw_selected_gid(&mut self, value: [u32; 9]) {
        self.ardw_selected_gid = value;
    }
    pub fn set_ardw_selected_gid_raw(&mut self, value: [u8; 36]) {
        self.ardw_selected_gid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketChSelectCharGoingtobeused {
        let packet_id = i16::from_le_bytes([0x8c, 0x02]);
        let packet_id_raw = [0x8c, 0x02];
        PacketChSelectCharGoingtobeused {
        raw: vec![],
        packet_id,
        packet_id_raw,
        dw_aid: 0,
        dw_aid_raw: [0; 4],
        n_count_selected_char: 0,
        n_count_selected_char_raw: [0; 4],
        ardw_selected_gid: [0; 9],
        ardw_selected_gid_raw: [0; 36],
        }
    }
}

impl Packet for PacketChSelectCharGoingtobeused {
    fn id(&self, packetver: u32) -> &str {
       PacketChSelectCharGoingtobeused::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketChReqIsValidCharname {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8d02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketChReqIsValidCharname {
        let mut offset: usize = 0;
        PacketChReqIsValidCharname {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            dw_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dw_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            dw_gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dw_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            sz_char_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            sz_char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_aid).unwrap();
        self.dw_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_gid).unwrap();
        self.dw_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_char_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.dw_aid_raw.to_vec());
        wtr.append(&mut self.dw_gid_raw.to_vec());
        wtr.append(&mut self.sz_char_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 34;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_dw_aid(&mut self, value: u32) {
        self.dw_aid = value;
    }
    pub fn set_dw_aid_raw(&mut self, value: [u8; 4]) {
        self.dw_aid_raw = value;
    }
    pub fn set_dw_gid(&mut self, value: u32) {
        self.dw_gid = value;
    }
    pub fn set_dw_gid_raw(&mut self, value: [u8; 4]) {
        self.dw_gid_raw = value;
    }
    pub fn set_sz_char_name(&mut self, value: [char; 24]) {
        self.sz_char_name = value;
    }
    pub fn set_sz_char_name_raw(&mut self, value: [u8; 24]) {
        self.sz_char_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketChReqIsValidCharname {
        let packet_id = i16::from_le_bytes([0x8d, 0x02]);
        let packet_id_raw = [0x8d, 0x02];
        PacketChReqIsValidCharname {
        raw: vec![],
        packet_id,
        packet_id_raw,
        dw_aid: 0,
        dw_aid_raw: [0; 4],
        dw_gid: 0,
        dw_gid_raw: [0; 4],
        sz_char_name: [0 as char; 24],
        sz_char_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketChReqIsValidCharname {
    fn id(&self, packetver: u32) -> &str {
       PacketChReqIsValidCharname::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcAckIsValidCharname {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8e02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcAckIsValidCharname {
        let mut offset: usize = 0;
        PacketHcAckIsValidCharname {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            s_result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            s_result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.s_result).unwrap();
        self.s_result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.s_result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_s_result(&mut self, value: i16) {
        self.s_result = value;
    }
    pub fn set_s_result_raw(&mut self, value: [u8; 2]) {
        self.s_result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcAckIsValidCharname {
        let packet_id = i16::from_le_bytes([0x8e, 0x02]);
        let packet_id_raw = [0x8e, 0x02];
        PacketHcAckIsValidCharname {
        raw: vec![],
        packet_id,
        packet_id_raw,
        s_result: 0,
        s_result_raw: [0; 2],
        }
    }
}

impl Packet for PacketHcAckIsValidCharname {
    fn id(&self, packetver: u32) -> &str {
       PacketHcAckIsValidCharname::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketChReqChangeCharname {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8f02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketChReqChangeCharname {
        let mut offset: usize = 0;
        PacketChReqChangeCharname {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            dw_gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dw_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_gid).unwrap();
        self.dw_gid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.dw_gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_dw_gid(&mut self, value: u32) {
        self.dw_gid = value;
    }
    pub fn set_dw_gid_raw(&mut self, value: [u8; 4]) {
        self.dw_gid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketChReqChangeCharname {
        let packet_id = i16::from_le_bytes([0x8f, 0x02]);
        let packet_id_raw = [0x8f, 0x02];
        PacketChReqChangeCharname {
        raw: vec![],
        packet_id,
        packet_id_raw,
        dw_gid: 0,
        dw_gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketChReqChangeCharname {
    fn id(&self, packetver: u32) -> &str {
       PacketChReqChangeCharname::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcAckChangeCharname {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9002"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcAckChangeCharname {
        let mut offset: usize = 0;
        PacketHcAckChangeCharname {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            s_result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            s_result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.s_result).unwrap();
        self.s_result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.s_result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_s_result(&mut self, value: i16) {
        self.s_result = value;
    }
    pub fn set_s_result_raw(&mut self, value: [u8; 2]) {
        self.s_result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcAckChangeCharname {
        let packet_id = i16::from_le_bytes([0x90, 0x02]);
        let packet_id_raw = [0x90, 0x02];
        PacketHcAckChangeCharname {
        raw: vec![],
        packet_id,
        packet_id_raw,
        s_result: 0,
        s_result_raw: [0; 2],
        }
    }
}

impl Packet for PacketHcAckChangeCharname {
    fn id(&self, packetver: u32) -> &str {
       PacketHcAckChangeCharname::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMsg {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9102"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMsg {
        let mut offset: usize = 0;
        PacketZcMsg {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msg: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            msg_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.msg).unwrap();
        self.msg_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_msg(&mut self, value: u16) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: [u8; 2]) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMsg {
        let packet_id = i16::from_le_bytes([0x91, 0x02]);
        let packet_id_raw = [0x91, 0x02];
        PacketZcMsg {
        raw: vec![],
        packet_id,
        packet_id_raw,
        msg: 0,
        msg_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcMsg {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMsg::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzStandingResurrection {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9202"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzStandingResurrection {
        let mut offset: usize = 0;
        PacketCzStandingResurrection {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzStandingResurrection {
        let packet_id = i16::from_le_bytes([0x92, 0x02]);
        let packet_id_raw = [0x92, 0x02];
        PacketCzStandingResurrection {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzStandingResurrection {
    fn id(&self, packetver: u32) -> &str {
       PacketCzStandingResurrection::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcBossInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9302"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcBossInfo {
        let mut offset: usize = 0;
        PacketZcBossInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            info_type: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            info_type_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            x_pos: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            y_pos: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            min_hour: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            min_hour_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            min_minute: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            min_minute_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            max_hour: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            max_hour_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            max_minute: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            max_minute_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 51] = [0 as char; 51];
                for (index, byte) in buffer[offset..offset + 51].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 51] = [0u8; 51];
                dst.clone_from_slice(&buffer[offset..offset + 51]);
                offset += 51;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.info_type).unwrap();
        self.info_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.min_hour).unwrap();
        self.min_hour_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.min_minute).unwrap();
        self.min_minute_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.max_hour).unwrap();
        self.max_hour_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.max_minute).unwrap();
        self.max_minute_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.info_type_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.min_hour_raw.to_vec());
        wtr.append(&mut self.min_minute_raw.to_vec());
        wtr.append(&mut self.max_hour_raw.to_vec());
        wtr.append(&mut self.max_minute_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 70;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_info_type(&mut self, value: u8) {
        self.info_type = value;
    }
    pub fn set_info_type_raw(&mut self, value: [u8; 1]) {
        self.info_type_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i32) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 4]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i32) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 4]) {
        self.y_pos_raw = value;
    }
    pub fn set_min_hour(&mut self, value: u16) {
        self.min_hour = value;
    }
    pub fn set_min_hour_raw(&mut self, value: [u8; 2]) {
        self.min_hour_raw = value;
    }
    pub fn set_min_minute(&mut self, value: u16) {
        self.min_minute = value;
    }
    pub fn set_min_minute_raw(&mut self, value: [u8; 2]) {
        self.min_minute_raw = value;
    }
    pub fn set_max_hour(&mut self, value: u16) {
        self.max_hour = value;
    }
    pub fn set_max_hour_raw(&mut self, value: [u8; 2]) {
        self.max_hour_raw = value;
    }
    pub fn set_max_minute(&mut self, value: u16) {
        self.max_minute = value;
    }
    pub fn set_max_minute_raw(&mut self, value: [u8; 2]) {
        self.max_minute_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 51]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 51]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcBossInfo {
        let packet_id = i16::from_le_bytes([0x93, 0x02]);
        let packet_id_raw = [0x93, 0x02];
        PacketZcBossInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        info_type: 0,
        info_type_raw: [0; 1],
        x_pos: 0,
        x_pos_raw: [0; 4],
        y_pos: 0,
        y_pos_raw: [0; 4],
        min_hour: 0,
        min_hour_raw: [0; 2],
        min_minute: 0,
        min_minute_raw: [0; 2],
        max_hour: 0,
        max_hour_raw: [0; 2],
        max_minute: 0,
        max_minute_raw: [0; 2],
        name: [0 as char; 51],
        name_raw: [0; 51],
        }
    }
}

impl Packet for PacketZcBossInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcBossInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcReadBook {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9402"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcReadBook {
        let mut offset: usize = 0;
        PacketZcReadBook {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            book_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            book_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            page: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            page_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.book_id).unwrap();
        self.book_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.page).unwrap();
        self.page_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.book_id_raw.to_vec());
        wtr.append(&mut self.page_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_book_id(&mut self, value: u32) {
        self.book_id = value;
    }
    pub fn set_book_id_raw(&mut self, value: [u8; 4]) {
        self.book_id_raw = value;
    }
    pub fn set_page(&mut self, value: u32) {
        self.page = value;
    }
    pub fn set_page_raw(&mut self, value: [u8; 4]) {
        self.page_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcReadBook {
        let packet_id = i16::from_le_bytes([0x94, 0x02]);
        let packet_id_raw = [0x94, 0x02];
        PacketZcReadBook {
        raw: vec![],
        packet_id,
        packet_id_raw,
        book_id: 0,
        book_id_raw: [0; 4],
        page: 0,
        page_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcReadBook {
    fn id(&self, packetver: u32) -> &str {
       PacketZcReadBook::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcEquipmentItemlist2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9502"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcEquipmentItemlist2 {
        let mut offset: usize = 0;
        let vec_type_len = EquipmentitemExtrainfo2::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<EquipmentitemExtrainfo2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(EquipmentitemExtrainfo2::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcEquipmentItemlist2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_info: {
                let field = vec_field.clone();
                field
            },
            item_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo2>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcEquipmentItemlist2 {
        let packet_id = i16::from_le_bytes([0x95, 0x02]);
        let packet_id_raw = [0x95, 0x02];
        PacketZcEquipmentItemlist2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcEquipmentItemlist2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcEquipmentItemlist2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcStoreEquipmentItemlist2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9602"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcStoreEquipmentItemlist2 {
        let mut offset: usize = 0;
        let vec_type_len = EquipmentitemExtrainfo2::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<EquipmentitemExtrainfo2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(EquipmentitemExtrainfo2::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcStoreEquipmentItemlist2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_info: {
                let field = vec_field.clone();
                field
            },
            item_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo2>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcStoreEquipmentItemlist2 {
        let packet_id = i16::from_le_bytes([0x96, 0x02]);
        let packet_id_raw = [0x96, 0x02];
        PacketZcStoreEquipmentItemlist2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcStoreEquipmentItemlist2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcStoreEquipmentItemlist2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcCartEquipmentItemlist2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9702"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcCartEquipmentItemlist2 {
        let mut offset: usize = 0;
        let vec_type_len = EquipmentitemExtrainfo2::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<EquipmentitemExtrainfo2> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(EquipmentitemExtrainfo2::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcCartEquipmentItemlist2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_info: {
                let field = vec_field.clone();
                field
            },
            item_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo2>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcCartEquipmentItemlist2 {
        let packet_id = i16::from_le_bytes([0x97, 0x02]);
        let packet_id_raw = [0x97, 0x02];
        PacketZcCartEquipmentItemlist2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcCartEquipmentItemlist2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcCartEquipmentItemlist2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcCashTimeCounter {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9802"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcCashTimeCounter {
        let mut offset: usize = 0;
        PacketZcCashTimeCounter {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            remain_second: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            remain_second_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.remain_second).unwrap();
        self.remain_second_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.remain_second_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_remain_second(&mut self, value: u32) {
        self.remain_second = value;
    }
    pub fn set_remain_second_raw(&mut self, value: [u8; 4]) {
        self.remain_second_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcCashTimeCounter {
        let packet_id = i16::from_le_bytes([0x98, 0x02]);
        let packet_id_raw = [0x98, 0x02];
        PacketZcCashTimeCounter {
        raw: vec![],
        packet_id,
        packet_id_raw,
        itid: 0,
        itid_raw: [0; 2],
        remain_second: 0,
        remain_second_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcCashTimeCounter {
    fn id(&self, packetver: u32) -> &str {
       PacketZcCashTimeCounter::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcCashItemDelete {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9902"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcCashItemDelete {
        let mut offset: usize = 0;
        PacketZcCashItemDelete {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcCashItemDelete {
        let packet_id = i16::from_le_bytes([0x99, 0x02]);
        let packet_id_raw = [0x99, 0x02];
        PacketZcCashItemDelete {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcCashItemDelete {
    fn id(&self, packetver: u32) -> &str {
       PacketZcCashItemDelete::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcItemPickupAck2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9a02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcItemPickupAck2 {
        let mut offset: usize = 0;
        PacketZcItemPickupAck2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_damaged: {
                let field = buffer[offset] == 1;
                field
            },
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            refining_level: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            location: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            hire_expire_date: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            hire_expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hire_expire_date).unwrap();
        self.hire_expire_date_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        wtr.append(&mut self.location_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.hire_expire_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 27;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: u16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn set_location(&mut self, value: u16) {
        self.location = value;
    }
    pub fn set_location_raw(&mut self, value: [u8; 2]) {
        self.location_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn set_hire_expire_date(&mut self, value: i32) {
        self.hire_expire_date = value;
    }
    pub fn set_hire_expire_date_raw(&mut self, value: [u8; 4]) {
        self.hire_expire_date_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcItemPickupAck2 {
        let packet_id = i16::from_le_bytes([0x9a, 0x02]);
        let packet_id_raw = [0x9a, 0x02];
        PacketZcItemPickupAck2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        location: 0,
        location_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        result: 0,
        result_raw: [0; 1],
        hire_expire_date: 0,
        hire_expire_date_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcItemPickupAck2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcItemPickupAck2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMerInit {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9b02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMerInit {
        let mut offset: usize = 0;
        PacketZcMerInit {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            atk: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            matk: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            matk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            hit: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            hit_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            critical: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            critical_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            def: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            def_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mdef: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            mdef_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            flee: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            flee_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aspd: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            hp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            max_hp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            max_hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            sp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            sp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            max_sp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            max_sp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            expire_date: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            faith: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            faith_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            toal_call_num: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            toal_call_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            approval_monster_kill_counter: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            approval_monster_kill_counter_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            atkrange: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atkrange_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atk).unwrap();
        self.atk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.matk).unwrap();
        self.matk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hit).unwrap();
        self.hit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.critical).unwrap();
        self.critical_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.def).unwrap();
        self.def_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef).unwrap();
        self.mdef_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.flee).unwrap();
        self.flee_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.aspd).unwrap();
        self.aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.sp).unwrap();
        self.sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_sp).unwrap();
        self.max_sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.expire_date).unwrap();
        self.expire_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.faith).unwrap();
        self.faith_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.toal_call_num).unwrap();
        self.toal_call_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.approval_monster_kill_counter).unwrap();
        self.approval_monster_kill_counter_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atkrange).unwrap();
        self.atkrange_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.atk_raw.to_vec());
        wtr.append(&mut self.matk_raw.to_vec());
        wtr.append(&mut self.hit_raw.to_vec());
        wtr.append(&mut self.critical_raw.to_vec());
        wtr.append(&mut self.def_raw.to_vec());
        wtr.append(&mut self.mdef_raw.to_vec());
        wtr.append(&mut self.flee_raw.to_vec());
        wtr.append(&mut self.aspd_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.max_hp_raw.to_vec());
        wtr.append(&mut self.sp_raw.to_vec());
        wtr.append(&mut self.max_sp_raw.to_vec());
        wtr.append(&mut self.expire_date_raw.to_vec());
        wtr.append(&mut self.faith_raw.to_vec());
        wtr.append(&mut self.toal_call_num_raw.to_vec());
        wtr.append(&mut self.approval_monster_kill_counter_raw.to_vec());
        wtr.append(&mut self.atkrange_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 80;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: i32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_atk(&mut self, value: i16) {
        self.atk = value;
    }
    pub fn set_atk_raw(&mut self, value: [u8; 2]) {
        self.atk_raw = value;
    }
    pub fn set_matk(&mut self, value: i16) {
        self.matk = value;
    }
    pub fn set_matk_raw(&mut self, value: [u8; 2]) {
        self.matk_raw = value;
    }
    pub fn set_hit(&mut self, value: i16) {
        self.hit = value;
    }
    pub fn set_hit_raw(&mut self, value: [u8; 2]) {
        self.hit_raw = value;
    }
    pub fn set_critical(&mut self, value: i16) {
        self.critical = value;
    }
    pub fn set_critical_raw(&mut self, value: [u8; 2]) {
        self.critical_raw = value;
    }
    pub fn set_def(&mut self, value: i16) {
        self.def = value;
    }
    pub fn set_def_raw(&mut self, value: [u8; 2]) {
        self.def_raw = value;
    }
    pub fn set_mdef(&mut self, value: i16) {
        self.mdef = value;
    }
    pub fn set_mdef_raw(&mut self, value: [u8; 2]) {
        self.mdef_raw = value;
    }
    pub fn set_flee(&mut self, value: i16) {
        self.flee = value;
    }
    pub fn set_flee_raw(&mut self, value: [u8; 2]) {
        self.flee_raw = value;
    }
    pub fn set_aspd(&mut self, value: i16) {
        self.aspd = value;
    }
    pub fn set_aspd_raw(&mut self, value: [u8; 2]) {
        self.aspd_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_hp(&mut self, value: i32) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 4]) {
        self.hp_raw = value;
    }
    pub fn set_max_hp(&mut self, value: i32) {
        self.max_hp = value;
    }
    pub fn set_max_hp_raw(&mut self, value: [u8; 4]) {
        self.max_hp_raw = value;
    }
    pub fn set_sp(&mut self, value: i32) {
        self.sp = value;
    }
    pub fn set_sp_raw(&mut self, value: [u8; 4]) {
        self.sp_raw = value;
    }
    pub fn set_max_sp(&mut self, value: i32) {
        self.max_sp = value;
    }
    pub fn set_max_sp_raw(&mut self, value: [u8; 4]) {
        self.max_sp_raw = value;
    }
    pub fn set_expire_date(&mut self, value: i32) {
        self.expire_date = value;
    }
    pub fn set_expire_date_raw(&mut self, value: [u8; 4]) {
        self.expire_date_raw = value;
    }
    pub fn set_faith(&mut self, value: i16) {
        self.faith = value;
    }
    pub fn set_faith_raw(&mut self, value: [u8; 2]) {
        self.faith_raw = value;
    }
    pub fn set_toal_call_num(&mut self, value: i32) {
        self.toal_call_num = value;
    }
    pub fn set_toal_call_num_raw(&mut self, value: [u8; 4]) {
        self.toal_call_num_raw = value;
    }
    pub fn set_approval_monster_kill_counter(&mut self, value: i32) {
        self.approval_monster_kill_counter = value;
    }
    pub fn set_approval_monster_kill_counter_raw(&mut self, value: [u8; 4]) {
        self.approval_monster_kill_counter_raw = value;
    }
    pub fn set_atkrange(&mut self, value: i16) {
        self.atkrange = value;
    }
    pub fn set_atkrange_raw(&mut self, value: [u8; 2]) {
        self.atkrange_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMerInit {
        let packet_id = i16::from_le_bytes([0x9b, 0x02]);
        let packet_id_raw = [0x9b, 0x02];
        PacketZcMerInit {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        atk: 0,
        atk_raw: [0; 2],
        matk: 0,
        matk_raw: [0; 2],
        hit: 0,
        hit_raw: [0; 2],
        critical: 0,
        critical_raw: [0; 2],
        def: 0,
        def_raw: [0; 2],
        mdef: 0,
        mdef_raw: [0; 2],
        flee: 0,
        flee_raw: [0; 2],
        aspd: 0,
        aspd_raw: [0; 2],
        name: [0 as char; 24],
        name_raw: [0; 24],
        level: 0,
        level_raw: [0; 2],
        hp: 0,
        hp_raw: [0; 4],
        max_hp: 0,
        max_hp_raw: [0; 4],
        sp: 0,
        sp_raw: [0; 4],
        max_sp: 0,
        max_sp_raw: [0; 4],
        expire_date: 0,
        expire_date_raw: [0; 4],
        faith: 0,
        faith_raw: [0; 2],
        toal_call_num: 0,
        toal_call_num_raw: [0; 4],
        approval_monster_kill_counter: 0,
        approval_monster_kill_counter_raw: [0; 4],
        atkrange: 0,
        atkrange_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcMerInit {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMerInit::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMerProperty {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9c02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMerProperty {
        let mut offset: usize = 0;
        PacketZcMerProperty {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atk: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            matk: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            matk_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            hit: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            hit_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            critical: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            critical_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            def: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            def_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mdef: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            mdef_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            flee: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            flee_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aspd: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            aspd_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            hp: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            max_hp: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            max_hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            sp: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            max_sp: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            max_sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            expire_date: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            faith: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            faith_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            toal_call_num: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            toal_call_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            approval_monster_kill_counter: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            approval_monster_kill_counter_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atk).unwrap();
        self.atk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.matk).unwrap();
        self.matk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hit).unwrap();
        self.hit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.critical).unwrap();
        self.critical_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.def).unwrap();
        self.def_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.mdef).unwrap();
        self.mdef_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.flee).unwrap();
        self.flee_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.aspd).unwrap();
        self.aspd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sp).unwrap();
        self.sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_sp).unwrap();
        self.max_sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.expire_date).unwrap();
        self.expire_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.faith).unwrap();
        self.faith_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.toal_call_num).unwrap();
        self.toal_call_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.approval_monster_kill_counter).unwrap();
        self.approval_monster_kill_counter_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atk_raw.to_vec());
        wtr.append(&mut self.matk_raw.to_vec());
        wtr.append(&mut self.hit_raw.to_vec());
        wtr.append(&mut self.critical_raw.to_vec());
        wtr.append(&mut self.def_raw.to_vec());
        wtr.append(&mut self.mdef_raw.to_vec());
        wtr.append(&mut self.flee_raw.to_vec());
        wtr.append(&mut self.aspd_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.max_hp_raw.to_vec());
        wtr.append(&mut self.sp_raw.to_vec());
        wtr.append(&mut self.max_sp_raw.to_vec());
        wtr.append(&mut self.expire_date_raw.to_vec());
        wtr.append(&mut self.faith_raw.to_vec());
        wtr.append(&mut self.toal_call_num_raw.to_vec());
        wtr.append(&mut self.approval_monster_kill_counter_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 66;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atk(&mut self, value: i16) {
        self.atk = value;
    }
    pub fn set_atk_raw(&mut self, value: [u8; 2]) {
        self.atk_raw = value;
    }
    pub fn set_matk(&mut self, value: i16) {
        self.matk = value;
    }
    pub fn set_matk_raw(&mut self, value: [u8; 2]) {
        self.matk_raw = value;
    }
    pub fn set_hit(&mut self, value: i16) {
        self.hit = value;
    }
    pub fn set_hit_raw(&mut self, value: [u8; 2]) {
        self.hit_raw = value;
    }
    pub fn set_critical(&mut self, value: i16) {
        self.critical = value;
    }
    pub fn set_critical_raw(&mut self, value: [u8; 2]) {
        self.critical_raw = value;
    }
    pub fn set_def(&mut self, value: i16) {
        self.def = value;
    }
    pub fn set_def_raw(&mut self, value: [u8; 2]) {
        self.def_raw = value;
    }
    pub fn set_mdef(&mut self, value: i16) {
        self.mdef = value;
    }
    pub fn set_mdef_raw(&mut self, value: [u8; 2]) {
        self.mdef_raw = value;
    }
    pub fn set_flee(&mut self, value: i16) {
        self.flee = value;
    }
    pub fn set_flee_raw(&mut self, value: [u8; 2]) {
        self.flee_raw = value;
    }
    pub fn set_aspd(&mut self, value: i16) {
        self.aspd = value;
    }
    pub fn set_aspd_raw(&mut self, value: [u8; 2]) {
        self.aspd_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_hp(&mut self, value: i16) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 2]) {
        self.hp_raw = value;
    }
    pub fn set_max_hp(&mut self, value: i16) {
        self.max_hp = value;
    }
    pub fn set_max_hp_raw(&mut self, value: [u8; 2]) {
        self.max_hp_raw = value;
    }
    pub fn set_sp(&mut self, value: i16) {
        self.sp = value;
    }
    pub fn set_sp_raw(&mut self, value: [u8; 2]) {
        self.sp_raw = value;
    }
    pub fn set_max_sp(&mut self, value: i16) {
        self.max_sp = value;
    }
    pub fn set_max_sp_raw(&mut self, value: [u8; 2]) {
        self.max_sp_raw = value;
    }
    pub fn set_expire_date(&mut self, value: i32) {
        self.expire_date = value;
    }
    pub fn set_expire_date_raw(&mut self, value: [u8; 4]) {
        self.expire_date_raw = value;
    }
    pub fn set_faith(&mut self, value: i16) {
        self.faith = value;
    }
    pub fn set_faith_raw(&mut self, value: [u8; 2]) {
        self.faith_raw = value;
    }
    pub fn set_toal_call_num(&mut self, value: i32) {
        self.toal_call_num = value;
    }
    pub fn set_toal_call_num_raw(&mut self, value: [u8; 4]) {
        self.toal_call_num_raw = value;
    }
    pub fn set_approval_monster_kill_counter(&mut self, value: i32) {
        self.approval_monster_kill_counter = value;
    }
    pub fn set_approval_monster_kill_counter_raw(&mut self, value: [u8; 4]) {
        self.approval_monster_kill_counter_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMerProperty {
        let packet_id = i16::from_le_bytes([0x9c, 0x02]);
        let packet_id_raw = [0x9c, 0x02];
        PacketZcMerProperty {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atk: 0,
        atk_raw: [0; 2],
        matk: 0,
        matk_raw: [0; 2],
        hit: 0,
        hit_raw: [0; 2],
        critical: 0,
        critical_raw: [0; 2],
        def: 0,
        def_raw: [0; 2],
        mdef: 0,
        mdef_raw: [0; 2],
        flee: 0,
        flee_raw: [0; 2],
        aspd: 0,
        aspd_raw: [0; 2],
        name: [0 as char; 24],
        name_raw: [0; 24],
        level: 0,
        level_raw: [0; 2],
        hp: 0,
        hp_raw: [0; 2],
        max_hp: 0,
        max_hp_raw: [0; 2],
        sp: 0,
        sp_raw: [0; 2],
        max_sp: 0,
        max_sp_raw: [0; 2],
        expire_date: 0,
        expire_date_raw: [0; 4],
        faith: 0,
        faith_raw: [0; 2],
        toal_call_num: 0,
        toal_call_num_raw: [0; 4],
        approval_monster_kill_counter: 0,
        approval_monster_kill_counter_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcMerProperty {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMerProperty::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMerSkillinfoList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9d02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMerSkillinfoList {
        let mut offset: usize = 0;
        let vec_type_len = SKILLINFO::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<SKILLINFO> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(SKILLINFO::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcMerSkillinfoList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skill_list: {
                let field = vec_field.clone();
                field
            },
            skill_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.skill_list_raw = {
            self.skill_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.skill_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.skill_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_skill_list(&mut self, value: Vec<SKILLINFO>) {
        self.skill_list = value;
    }
    pub fn set_skill_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.skill_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMerSkillinfoList {
        let packet_id = i16::from_le_bytes([0x9d, 0x02]);
        let packet_id_raw = [0x9d, 0x02];
        PacketZcMerSkillinfoList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        skill_list: vec![],
        skill_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcMerSkillinfoList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMerSkillinfoList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMerSkillinfoUpdate {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9e02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMerSkillinfoUpdate {
        let mut offset: usize = 0;
        PacketZcMerSkillinfoUpdate {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            spcost: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            spcost_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            attack_range: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            attack_range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            upgradable: {
                let field = buffer[offset] == 1;
                field
            },
            upgradable_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.spcost).unwrap();
        self.spcost_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.attack_range).unwrap();
        self.attack_range_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.upgradable as u8).unwrap();
        self.upgradable_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.spcost_raw.to_vec());
        wtr.append(&mut self.attack_range_raw.to_vec());
        wtr.append(&mut self.upgradable_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 11;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_spcost(&mut self, value: i16) {
        self.spcost = value;
    }
    pub fn set_spcost_raw(&mut self, value: [u8; 2]) {
        self.spcost_raw = value;
    }
    pub fn set_attack_range(&mut self, value: i16) {
        self.attack_range = value;
    }
    pub fn set_attack_range_raw(&mut self, value: [u8; 2]) {
        self.attack_range_raw = value;
    }
    pub fn set_upgradable(&mut self, value: bool) {
        self.upgradable = value;
    }
    pub fn set_upgradable_raw(&mut self, value: [u8; 1]) {
        self.upgradable_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMerSkillinfoUpdate {
        let packet_id = i16::from_le_bytes([0x9e, 0x02]);
        let packet_id_raw = [0x9e, 0x02];
        PacketZcMerSkillinfoUpdate {
        raw: vec![],
        packet_id,
        packet_id_raw,
        skid: 0,
        skid_raw: [0; 2],
        level: 0,
        level_raw: [0; 2],
        spcost: 0,
        spcost_raw: [0; 2],
        attack_range: 0,
        attack_range_raw: [0; 2],
        upgradable: false,
        upgradable_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcMerSkillinfoUpdate {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMerSkillinfoUpdate::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzMerCommand {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9f02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzMerCommand {
        let mut offset: usize = 0;
        PacketCzMerCommand {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            command: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            command_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.command).unwrap();
        self.command_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.command_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_command(&mut self, value: i8) {
        self.command = value;
    }
    pub fn set_command_raw(&mut self, value: [u8; 1]) {
        self.command_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzMerCommand {
        let packet_id = i16::from_le_bytes([0x9f, 0x02]);
        let packet_id_raw = [0x9f, 0x02];
        PacketCzMerCommand {
        raw: vec![],
        packet_id,
        packet_id_raw,
        command: 0,
        command_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzMerCommand {
    fn id(&self, packetver: u32) -> &str {
       PacketCzMerCommand::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl UnusedPacketCzMerUseSkill {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa002"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> UnusedPacketCzMerUseSkill {
        let mut offset: usize = 0;
        UnusedPacketCzMerUseSkill {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            selected_level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            selected_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            target_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.selected_level).unwrap();
        self.selected_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.selected_level_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.target_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_selected_level(&mut self, value: i16) {
        self.selected_level = value;
    }
    pub fn set_selected_level_raw(&mut self, value: [u8; 2]) {
        self.selected_level_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_target_id(&mut self, value: u32) {
        self.target_id = value;
    }
    pub fn set_target_id_raw(&mut self, value: [u8; 4]) {
        self.target_id_raw = value;
    }
    pub fn new(packetver: u32) -> UnusedPacketCzMerUseSkill {
        let packet_id = i16::from_le_bytes([0xa0, 0x02]);
        let packet_id_raw = [0xa0, 0x02];
        UnusedPacketCzMerUseSkill {
        raw: vec![],
        packet_id,
        packet_id_raw,
        selected_level: 0,
        selected_level_raw: [0; 2],
        skid: 0,
        skid_raw: [0; 2],
        target_id: 0,
        target_id_raw: [0; 4],
        }
    }
}

impl Packet for UnusedPacketCzMerUseSkill {
    fn id(&self, packetver: u32) -> &str {
       UnusedPacketCzMerUseSkill::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl UnusedPacketCzMerUpgradeSkilllevel {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa102"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> UnusedPacketCzMerUpgradeSkilllevel {
        let mut offset: usize = 0;
        UnusedPacketCzMerUpgradeSkilllevel {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn new(packetver: u32) -> UnusedPacketCzMerUpgradeSkilllevel {
        let packet_id = i16::from_le_bytes([0xa1, 0x02]);
        let packet_id_raw = [0xa1, 0x02];
        UnusedPacketCzMerUpgradeSkilllevel {
        raw: vec![],
        packet_id,
        packet_id_raw,
        skid: 0,
        skid_raw: [0; 2],
        }
    }
}

impl Packet for UnusedPacketCzMerUpgradeSkilllevel {
    fn id(&self, packetver: u32) -> &str {
       UnusedPacketCzMerUpgradeSkilllevel::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMerParChange {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa202"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMerParChange {
        let mut offset: usize = 0;
        PacketZcMerParChange {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            var: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            var_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            value: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var).unwrap();
        self.var_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.var_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_var(&mut self, value: u16) {
        self.var = value;
    }
    pub fn set_var_raw(&mut self, value: [u8; 2]) {
        self.var_raw = value;
    }
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMerParChange {
        let packet_id = i16::from_le_bytes([0xa2, 0x02]);
        let packet_id_raw = [0xa2, 0x02];
        PacketZcMerParChange {
        raw: vec![],
        packet_id,
        packet_id_raw,
        var: 0,
        var_raw: [0; 2],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcMerParChange {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMerParChange::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcGameguardLingoKey {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa302"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcGameguardLingoKey {
        let mut offset: usize = 0;
        PacketZcGameguardLingoKey {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            lingo_key: {
                let field = PggLingoKeyTemp::from(&buffer[offset..offset + PggLingoKeyTemp::base_len(packetver)], packetver);
                field
            },
            lingo_key_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.lingo_key.fill_raw_with_packetver(packetver);
        self.lingo_key_raw = self.lingo_key.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.lingo_key_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 1;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_lingo_key(&mut self, value: PggLingoKeyTemp) {
        self.lingo_key = value;
    }
    pub fn set_lingo_key_raw(&mut self, value: Vec<u8>) {
        self.lingo_key_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcGameguardLingoKey {
        let packet_id = i16::from_le_bytes([0xa3, 0x02]);
        let packet_id_raw = [0xa3, 0x02];
        PacketZcGameguardLingoKey {
        raw: vec![],
        packet_id,
        packet_id_raw,
        lingo_key: PggLingoKeyTemp::new(packetver),
        lingo_key_raw: vec![],
        }
    }
}

impl Packet for PacketZcGameguardLingoKey {
    fn id(&self, packetver: u32) -> &str {
       PacketZcGameguardLingoKey::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzKsyEvent {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xa502"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzKsyEvent {
        let mut offset: usize = 0;
        PacketCzKsyEvent {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzKsyEvent {
        let packet_id = i16::from_le_bytes([0xa5, 0x02]);
        let packet_id_raw = [0xa5, 0x02];
        PacketCzKsyEvent {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzKsyEvent {
    fn id(&self, packetver: u32) -> &str {
       PacketCzKsyEvent::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcReqCashPassword {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xaa02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcReqCashPassword {
        let mut offset: usize = 0;
        PacketZcReqCashPassword {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            info: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            info_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.info).unwrap();
        self.info_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_info(&mut self, value: i16) {
        self.info = value;
    }
    pub fn set_info_raw(&mut self, value: [u8; 2]) {
        self.info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcReqCashPassword {
        let packet_id = i16::from_le_bytes([0xaa, 0x02]);
        let packet_id_raw = [0xaa, 0x02];
        PacketZcReqCashPassword {
        raw: vec![],
        packet_id,
        packet_id_raw,
        info: 0,
        info_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcReqCashPassword {
    fn id(&self, packetver: u32) -> &str {
       PacketZcReqCashPassword::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzAckCashPassword {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xab02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzAckCashPassword {
        let mut offset: usize = 0;
        PacketCzAckCashPassword {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            password: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            password_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            new_password: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            new_password_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.password {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.password_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.new_password {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.new_password_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.password_raw.to_vec());
        wtr.append(&mut self.new_password_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 36;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn set_password(&mut self, value: [char; 16]) {
        self.password = value;
    }
    pub fn set_password_raw(&mut self, value: [u8; 16]) {
        self.password_raw = value;
    }
    pub fn set_new_password(&mut self, value: [char; 16]) {
        self.new_password = value;
    }
    pub fn set_new_password_raw(&mut self, value: [u8; 16]) {
        self.new_password_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzAckCashPassword {
        let packet_id = i16::from_le_bytes([0xab, 0x02]);
        let packet_id_raw = [0xab, 0x02];
        PacketCzAckCashPassword {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 2],
        password: [0 as char; 16],
        password_raw: [0; 16],
        new_password: [0 as char; 16],
        new_password_raw: [0; 16],
        }
    }
}

impl Packet for PacketCzAckCashPassword {
    fn id(&self, packetver: u32) -> &str {
       PacketCzAckCashPassword::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcResultCashPassword {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xac02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcResultCashPassword {
        let mut offset: usize = 0;
        PacketZcResultCashPassword {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            error_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_count).unwrap();
        self.error_count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.error_count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn set_error_count(&mut self, value: i16) {
        self.error_count = value;
    }
    pub fn set_error_count_raw(&mut self, value: [u8; 2]) {
        self.error_count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcResultCashPassword {
        let packet_id = i16::from_le_bytes([0xac, 0x02]);
        let packet_id_raw = [0xac, 0x02];
        PacketZcResultCashPassword {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 2],
        error_count: 0,
        error_count_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcResultCashPassword {
    fn id(&self, packetver: u32) -> &str {
       PacketZcResultCashPassword::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcRequestSecondPassword {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xad02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcRequestSecondPassword {
        let mut offset: usize = 0;
        PacketAcRequestSecondPassword {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            dw_seed: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dw_seed_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_seed).unwrap();
        self.dw_seed_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.dw_seed_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn set_dw_seed(&mut self, value: u32) {
        self.dw_seed = value;
    }
    pub fn set_dw_seed_raw(&mut self, value: [u8; 4]) {
        self.dw_seed_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcRequestSecondPassword {
        let packet_id = i16::from_le_bytes([0xad, 0x02]);
        let packet_id_raw = [0xad, 0x02];
        PacketAcRequestSecondPassword {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 2],
        dw_seed: 0,
        dw_seed_raw: [0; 4],
        }
    }
}

impl Packet for PacketAcRequestSecondPassword {
    fn id(&self, packetver: u32) -> &str {
       PacketAcRequestSecondPassword::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCaLoginHan {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb002"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaLoginHan {
        let mut offset: usize = 0;
        PacketCaLoginHan {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            version: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            id: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            passwd: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            passwd_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            clienttype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            m_sz_ip: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            m_sz_ip_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            m_sz_mac_addr: {
                let field =  {
                let mut dst: [char; 13] = [0 as char; 13];
                for (index, byte) in buffer[offset..offset + 13].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            m_sz_mac_addr_raw: {
                let mut dst: [u8; 13] = [0u8; 13];
                dst.clone_from_slice(&buffer[offset..offset + 13]);
                offset += 13;
                dst
            },
            is_han_game_user: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            is_han_game_user_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_sz_ip {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_sz_ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.m_sz_mac_addr {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.m_sz_mac_addr_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_han_game_user).unwrap();
        self.is_han_game_user_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.version_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.passwd_raw.to_vec());
        wtr.append(&mut self.clienttype_raw.to_vec());
        wtr.append(&mut self.m_sz_ip_raw.to_vec());
        wtr.append(&mut self.m_sz_mac_addr_raw.to_vec());
        wtr.append(&mut self.is_han_game_user_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 85;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_version(&mut self, value: u32) {
        self.version = value;
    }
    pub fn set_version_raw(&mut self, value: [u8; 4]) {
        self.version_raw = value;
    }
    pub fn set_id(&mut self, value: [char; 24]) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 24]) {
        self.id_raw = value;
    }
    pub fn set_passwd(&mut self, value: [char; 24]) {
        self.passwd = value;
    }
    pub fn set_passwd_raw(&mut self, value: [u8; 24]) {
        self.passwd_raw = value;
    }
    pub fn set_clienttype(&mut self, value: u8) {
        self.clienttype = value;
    }
    pub fn set_clienttype_raw(&mut self, value: [u8; 1]) {
        self.clienttype_raw = value;
    }
    pub fn set_m_sz_ip(&mut self, value: [char; 16]) {
        self.m_sz_ip = value;
    }
    pub fn set_m_sz_ip_raw(&mut self, value: [u8; 16]) {
        self.m_sz_ip_raw = value;
    }
    pub fn set_m_sz_mac_addr(&mut self, value: [char; 13]) {
        self.m_sz_mac_addr = value;
    }
    pub fn set_m_sz_mac_addr_raw(&mut self, value: [u8; 13]) {
        self.m_sz_mac_addr_raw = value;
    }
    pub fn set_is_han_game_user(&mut self, value: u8) {
        self.is_han_game_user = value;
    }
    pub fn set_is_han_game_user_raw(&mut self, value: [u8; 1]) {
        self.is_han_game_user_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaLoginHan {
        let packet_id = i16::from_le_bytes([0xb0, 0x02]);
        let packet_id_raw = [0xb0, 0x02];
        PacketCaLoginHan {
        raw: vec![],
        packet_id,
        packet_id_raw,
        version: 0,
        version_raw: [0; 4],
        id: [0 as char; 24],
        id_raw: [0; 24],
        passwd: [0 as char; 24],
        passwd_raw: [0; 24],
        clienttype: 0,
        clienttype_raw: [0; 1],
        m_sz_ip: [0 as char; 16],
        m_sz_ip_raw: [0; 16],
        m_sz_mac_addr: [0 as char; 13],
        m_sz_mac_addr_raw: [0; 13],
        is_han_game_user: 0,
        is_han_game_user_raw: [0; 1],
        }
    }
}

impl Packet for PacketCaLoginHan {
    fn id(&self, packetver: u32) -> &str {
       PacketCaLoginHan::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAllQuestList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb102"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAllQuestList {
        let mut offset: usize = 0;
        let vec_type_len = PacketZcQuestInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 8) / vec_type_len;
        let mut vec_field: Vec<PacketZcQuestInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (vec_type_len * (i - 1));
            let end_pos = 8 + vec_type_len * i;
            vec_field.push(PacketZcQuestInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcAllQuestList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            quest_count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            quest_count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            quest_list: {
                let field = vec_field.clone();
                field
            },
            quest_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.quest_count).unwrap();
        self.quest_count_raw = wtr.try_into().unwrap();
        self.quest_list_raw = {
            self.quest_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.quest_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.quest_count_raw.to_vec());
        self.quest_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_quest_count(&mut self, value: i32) {
        self.quest_count = value;
    }
    pub fn set_quest_count_raw(&mut self, value: [u8; 4]) {
        self.quest_count_raw = value;
    }
    pub fn set_quest_list(&mut self, value: Vec<PacketZcQuestInfo>) {
        self.quest_list = value;
    }
    pub fn set_quest_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.quest_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAllQuestList {
        let packet_id = i16::from_le_bytes([0xb1, 0x02]);
        let packet_id_raw = [0xb1, 0x02];
        PacketZcAllQuestList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        quest_count: 0,
        quest_count_raw: [0; 4],
        quest_list: vec![],
        quest_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcAllQuestList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAllQuestList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAllQuestMission {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb202"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAllQuestMission {
        let mut offset: usize = 0;
        let vec_type_len = PacketZcQuestMissionInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 8) / vec_type_len;
        let mut vec_field: Vec<PacketZcQuestMissionInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (vec_type_len * (i - 1));
            let end_pos = 8 + vec_type_len * i;
            vec_field.push(PacketZcQuestMissionInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcAllQuestMission {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            quest_mission_list: {
                let field = vec_field.clone();
                field
            },
            quest_mission_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        self.quest_mission_list_raw = {
            self.quest_mission_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.quest_mission_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.quest_mission_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn set_quest_mission_list(&mut self, value: Vec<PacketZcQuestMissionInfo>) {
        self.quest_mission_list = value;
    }
    pub fn set_quest_mission_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.quest_mission_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAllQuestMission {
        let packet_id = i16::from_le_bytes([0xb2, 0x02]);
        let packet_id_raw = [0xb2, 0x02];
        PacketZcAllQuestMission {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        count: 0,
        count_raw: [0; 4],
        quest_mission_list: vec![],
        quest_mission_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcAllQuestMission {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAllQuestMission::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAddQuest {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb302"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAddQuest {
        let mut offset: usize = 0;
        let vec_type_len = PacketZcMissionHunt::base_len(packetver);
        let iter_count = (&buffer.len() - 17) / vec_type_len;
        let mut vec_field: Vec<PacketZcMissionHunt> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 17 + (vec_type_len * (i - 1));
            let end_pos = 17 + vec_type_len * i;
            vec_field.push(PacketZcMissionHunt::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcAddQuest {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            quest_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            active: {
                let field = buffer[offset] == 1;
                field
            },
            active_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            quest_svr_time: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            quest_svr_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            quest_end_time: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            quest_end_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            hunt: {
                let field = vec_field.clone();
                field
            },
            hunt_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.active as u8).unwrap();
        self.active_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.quest_svr_time).unwrap();
        self.quest_svr_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.quest_end_time).unwrap();
        self.quest_end_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        self.hunt_raw = {
            self.hunt.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.hunt.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.quest_id_raw.to_vec());
        wtr.append(&mut self.active_raw.to_vec());
        wtr.append(&mut self.quest_svr_time_raw.to_vec());
        wtr.append(&mut self.quest_end_time_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.hunt.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 17;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_quest_id(&mut self, value: u32) {
        self.quest_id = value;
    }
    pub fn set_quest_id_raw(&mut self, value: [u8; 4]) {
        self.quest_id_raw = value;
    }
    pub fn set_active(&mut self, value: bool) {
        self.active = value;
    }
    pub fn set_active_raw(&mut self, value: [u8; 1]) {
        self.active_raw = value;
    }
    pub fn set_quest_svr_time(&mut self, value: i32) {
        self.quest_svr_time = value;
    }
    pub fn set_quest_svr_time_raw(&mut self, value: [u8; 4]) {
        self.quest_svr_time_raw = value;
    }
    pub fn set_quest_end_time(&mut self, value: i32) {
        self.quest_end_time = value;
    }
    pub fn set_quest_end_time_raw(&mut self, value: [u8; 4]) {
        self.quest_end_time_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_hunt(&mut self, value: Vec<PacketZcMissionHunt>) {
        self.hunt = value;
    }
    pub fn set_hunt_raw(&mut self, value: Vec<Vec<u8>>) {
        self.hunt_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAddQuest {
        let packet_id = i16::from_le_bytes([0xb3, 0x02]);
        let packet_id_raw = [0xb3, 0x02];
        PacketZcAddQuest {
        raw: vec![],
        packet_id,
        packet_id_raw,
        quest_id: 0,
        quest_id_raw: [0; 4],
        active: false,
        active_raw: [0; 1],
        quest_svr_time: 0,
        quest_svr_time_raw: [0; 4],
        quest_end_time: 0,
        quest_end_time_raw: [0; 4],
        count: 0,
        count_raw: [0; 2],
        hunt: vec![],
        hunt_raw: vec![],
        }
    }
}

impl Packet for PacketZcAddQuest {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAddQuest::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcDelQuest {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb402"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcDelQuest {
        let mut offset: usize = 0;
        PacketZcDelQuest {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            quest_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.quest_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_quest_id(&mut self, value: u32) {
        self.quest_id = value;
    }
    pub fn set_quest_id_raw(&mut self, value: [u8; 4]) {
        self.quest_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcDelQuest {
        let packet_id = i16::from_le_bytes([0xb4, 0x02]);
        let packet_id_raw = [0xb4, 0x02];
        PacketZcDelQuest {
        raw: vec![],
        packet_id,
        packet_id_raw,
        quest_id: 0,
        quest_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDelQuest {
    fn id(&self, packetver: u32) -> &str {
       PacketZcDelQuest::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcUpdateMissionHunt {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb502"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcUpdateMissionHunt {
        let mut offset: usize = 0;
        let vec_type_len = PacketMobHunting::base_len(packetver);
        let iter_count = (&buffer.len() - 6) / vec_type_len;
        let mut vec_field: Vec<PacketMobHunting> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 6 + (vec_type_len * (i - 1));
            let end_pos = 6 + vec_type_len * i;
            vec_field.push(PacketMobHunting::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcUpdateMissionHunt {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mob_hunt_list: {
                let field = vec_field.clone();
                field
            },
            mob_hunt_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        self.mob_hunt_list_raw = {
            self.mob_hunt_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.mob_hunt_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.mob_hunt_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_mob_hunt_list(&mut self, value: Vec<PacketMobHunting>) {
        self.mob_hunt_list = value;
    }
    pub fn set_mob_hunt_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.mob_hunt_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcUpdateMissionHunt {
        let packet_id = i16::from_le_bytes([0xb5, 0x02]);
        let packet_id_raw = [0xb5, 0x02];
        PacketZcUpdateMissionHunt {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        mob_hunt_list: vec![],
        mob_hunt_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcUpdateMissionHunt {
    fn id(&self, packetver: u32) -> &str {
       PacketZcUpdateMissionHunt::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzActiveQuest {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb602"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzActiveQuest {
        let mut offset: usize = 0;
        PacketCzActiveQuest {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            quest_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            active: {
                let field = buffer[offset] == 1;
                field
            },
            active_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.active as u8).unwrap();
        self.active_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.quest_id_raw.to_vec());
        wtr.append(&mut self.active_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_quest_id(&mut self, value: u32) {
        self.quest_id = value;
    }
    pub fn set_quest_id_raw(&mut self, value: [u8; 4]) {
        self.quest_id_raw = value;
    }
    pub fn set_active(&mut self, value: bool) {
        self.active = value;
    }
    pub fn set_active_raw(&mut self, value: [u8; 1]) {
        self.active_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzActiveQuest {
        let packet_id = i16::from_le_bytes([0xb6, 0x02]);
        let packet_id_raw = [0xb6, 0x02];
        PacketCzActiveQuest {
        raw: vec![],
        packet_id,
        packet_id_raw,
        quest_id: 0,
        quest_id_raw: [0; 4],
        active: false,
        active_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzActiveQuest {
    fn id(&self, packetver: u32) -> &str {
       PacketCzActiveQuest::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcActiveQuest {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb702"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcActiveQuest {
        let mut offset: usize = 0;
        PacketZcActiveQuest {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            quest_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            active: {
                let field = buffer[offset] == 1;
                field
            },
            active_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.active as u8).unwrap();
        self.active_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.quest_id_raw.to_vec());
        wtr.append(&mut self.active_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_quest_id(&mut self, value: u32) {
        self.quest_id = value;
    }
    pub fn set_quest_id_raw(&mut self, value: [u8; 4]) {
        self.quest_id_raw = value;
    }
    pub fn set_active(&mut self, value: bool) {
        self.active = value;
    }
    pub fn set_active_raw(&mut self, value: [u8; 1]) {
        self.active_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcActiveQuest {
        let packet_id = i16::from_le_bytes([0xb7, 0x02]);
        let packet_id_raw = [0xb7, 0x02];
        PacketZcActiveQuest {
        raw: vec![],
        packet_id,
        packet_id_raw,
        quest_id: 0,
        quest_id_raw: [0; 4],
        active: false,
        active_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcActiveQuest {
    fn id(&self, packetver: u32) -> &str {
       PacketZcActiveQuest::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcItemPickupParty {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb802"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcItemPickupParty {
        let mut offset: usize = 0;
        PacketZcItemPickupParty {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            account_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_damaged: {
                let field = buffer[offset] == 1;
                field
            },
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            refining_level: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            location: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.account_id_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        wtr.append(&mut self.location_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 22;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_account_id(&mut self, value: u32) {
        self.account_id = value;
    }
    pub fn set_account_id_raw(&mut self, value: [u8; 4]) {
        self.account_id_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn set_location(&mut self, value: u16) {
        self.location = value;
    }
    pub fn set_location_raw(&mut self, value: [u8; 2]) {
        self.location_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcItemPickupParty {
        let packet_id = i16::from_le_bytes([0xb8, 0x02]);
        let packet_id_raw = [0xb8, 0x02];
        PacketZcItemPickupParty {
        raw: vec![],
        packet_id,
        packet_id_raw,
        account_id: 0,
        account_id_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        location: 0,
        location_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcItemPickupParty {
    fn id(&self, packetver: u32) -> &str {
       PacketZcItemPickupParty::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcShortcutKeyList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb902"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcShortcutKeyList {
        let mut offset: usize = 0;
        let vec_type_len = ShortCutKey::base_len(packetver);
        let iter_count = (&buffer.len() - 2) / vec_type_len;
        let mut vec_field: Vec<ShortCutKey> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 2 + (vec_type_len * (i - 1));
            let end_pos = 2 + vec_type_len * i;
            vec_field.push(ShortCutKey::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcShortcutKeyList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            short_cut_key: {
                let field = vec_field.clone();
                field
            },
            short_cut_key_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.short_cut_key_raw = {
            self.short_cut_key.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.short_cut_key.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.short_cut_key.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_short_cut_key(&mut self, value: Vec<ShortCutKey>) {
        self.short_cut_key = value;
    }
    pub fn set_short_cut_key_raw(&mut self, value: Vec<Vec<u8>>) {
        self.short_cut_key_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcShortcutKeyList {
        let packet_id = i16::from_le_bytes([0xb9, 0x02]);
        let packet_id_raw = [0xb9, 0x02];
        PacketZcShortcutKeyList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        short_cut_key: vec![],
        short_cut_key_raw: vec![],
        }
    }
}

impl Packet for PacketZcShortcutKeyList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcShortcutKeyList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzShortcutKeyChange {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xba02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzShortcutKeyChange {
        let mut offset: usize = 0;
        PacketCzShortcutKeyChange {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            short_cut_key: {
                let field = ShortCutKey::from(&buffer[offset..offset + ShortCutKey::base_len(packetver)], packetver);
                field
            },
            short_cut_key_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        self.short_cut_key.fill_raw_with_packetver(packetver);
        self.short_cut_key_raw = self.short_cut_key.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.short_cut_key_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_short_cut_key(&mut self, value: ShortCutKey) {
        self.short_cut_key = value;
    }
    pub fn set_short_cut_key_raw(&mut self, value: Vec<u8>) {
        self.short_cut_key_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzShortcutKeyChange {
        let packet_id = i16::from_le_bytes([0xba, 0x02]);
        let packet_id_raw = [0xba, 0x02];
        PacketCzShortcutKeyChange {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        short_cut_key: ShortCutKey::new(packetver),
        short_cut_key_raw: vec![],
        }
    }
}

impl Packet for PacketCzShortcutKeyChange {
    fn id(&self, packetver: u32) -> &str {
       PacketCzShortcutKeyChange::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcEquipitemDamaged {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xbb02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcEquipitemDamaged {
        let mut offset: usize = 0;
        PacketZcEquipitemDamaged {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            wear_location: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            wear_location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            account_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_location).unwrap();
        self.wear_location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.wear_location_raw.to_vec());
        wtr.append(&mut self.account_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_wear_location(&mut self, value: u16) {
        self.wear_location = value;
    }
    pub fn set_wear_location_raw(&mut self, value: [u8; 2]) {
        self.wear_location_raw = value;
    }
    pub fn set_account_id(&mut self, value: u32) {
        self.account_id = value;
    }
    pub fn set_account_id_raw(&mut self, value: [u8; 4]) {
        self.account_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcEquipitemDamaged {
        let packet_id = i16::from_le_bytes([0xbb, 0x02]);
        let packet_id_raw = [0xbb, 0x02];
        PacketZcEquipitemDamaged {
        raw: vec![],
        packet_id,
        packet_id_raw,
        wear_location: 0,
        wear_location_raw: [0; 2],
        account_id: 0,
        account_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcEquipitemDamaged {
    fn id(&self, packetver: u32) -> &str {
       PacketZcEquipitemDamaged::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyPcbangPlayingTime {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xbc02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyPcbangPlayingTime {
        let mut offset: usize = 0;
        PacketZcNotifyPcbangPlayingTime {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            time_minute: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            time_minute_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.time_minute).unwrap();
        self.time_minute_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.time_minute_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_time_minute(&mut self, value: i32) {
        self.time_minute = value;
    }
    pub fn set_time_minute_raw(&mut self, value: [u8; 4]) {
        self.time_minute_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyPcbangPlayingTime {
        let packet_id = i16::from_le_bytes([0xbc, 0x02]);
        let packet_id_raw = [0xbc, 0x02];
        PacketZcNotifyPcbangPlayingTime {
        raw: vec![],
        packet_id,
        packet_id_raw,
        time_minute: 0,
        time_minute_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyPcbangPlayingTime {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyPcbangPlayingTime::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSrpacketr2Init {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xbf02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSrpacketr2Init {
        let mut offset: usize = 0;
        PacketZcSrpacketr2Init {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            protect_factor: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            protect_factor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            deform_seed_factor: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            deform_seed_factor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            deform_add_factor: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            deform_add_factor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.protect_factor).unwrap();
        self.protect_factor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.deform_seed_factor).unwrap();
        self.deform_seed_factor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.deform_add_factor).unwrap();
        self.deform_add_factor_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.protect_factor_raw.to_vec());
        wtr.append(&mut self.deform_seed_factor_raw.to_vec());
        wtr.append(&mut self.deform_add_factor_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 12;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_protect_factor(&mut self, value: u16) {
        self.protect_factor = value;
    }
    pub fn set_protect_factor_raw(&mut self, value: [u8; 2]) {
        self.protect_factor_raw = value;
    }
    pub fn set_deform_seed_factor(&mut self, value: u32) {
        self.deform_seed_factor = value;
    }
    pub fn set_deform_seed_factor_raw(&mut self, value: [u8; 4]) {
        self.deform_seed_factor_raw = value;
    }
    pub fn set_deform_add_factor(&mut self, value: u32) {
        self.deform_add_factor = value;
    }
    pub fn set_deform_add_factor_raw(&mut self, value: [u8; 4]) {
        self.deform_add_factor_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSrpacketr2Init {
        let packet_id = i16::from_le_bytes([0xbf, 0x02]);
        let packet_id_raw = [0xbf, 0x02];
        PacketZcSrpacketr2Init {
        raw: vec![],
        packet_id,
        packet_id_raw,
        protect_factor: 0,
        protect_factor_raw: [0; 2],
        deform_seed_factor: 0,
        deform_seed_factor_raw: [0; 4],
        deform_add_factor: 0,
        deform_add_factor_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcSrpacketr2Init {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSrpacketr2Init::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzSrpacketr2Start {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc002"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzSrpacketr2Start {
        let mut offset: usize = 0;
        PacketCzSrpacketr2Start {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            protect_factor: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            protect_factor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.protect_factor).unwrap();
        self.protect_factor_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.protect_factor_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_protect_factor(&mut self, value: u16) {
        self.protect_factor = value;
    }
    pub fn set_protect_factor_raw(&mut self, value: [u8; 2]) {
        self.protect_factor_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzSrpacketr2Start {
        let packet_id = i16::from_le_bytes([0xc0, 0x02]);
        let packet_id_raw = [0xc0, 0x02];
        PacketCzSrpacketr2Start {
        raw: vec![],
        packet_id,
        packet_id_raw,
        protect_factor: 0,
        protect_factor_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzSrpacketr2Start {
    fn id(&self, packetver: u32) -> &str {
       PacketCzSrpacketr2Start::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNpcChat {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc102"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNpcChat {
        let mut offset: usize = 0;
        PacketZcNpcChat {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            account_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            color: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            color_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.color).unwrap();
        self.color_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.account_id_raw.to_vec());
        wtr.append(&mut self.color_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 11;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_account_id(&mut self, value: u32) {
        self.account_id = value;
    }
    pub fn set_account_id_raw(&mut self, value: [u8; 4]) {
        self.account_id_raw = value;
    }
    pub fn set_color(&mut self, value: u32) {
        self.color = value;
    }
    pub fn set_color_raw(&mut self, value: [u8; 4]) {
        self.color_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNpcChat {
        let packet_id = i16::from_le_bytes([0xc1, 0x02]);
        let packet_id_raw = [0xc1, 0x02];
        PacketZcNpcChat {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        account_id: 0,
        account_id_raw: [0; 4],
        color: 0,
        color_raw: [0; 4],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcNpcChat {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNpcChat::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcFormatstringMsg {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc202"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcFormatstringMsg {
        let mut offset: usize = 0;
        PacketZcFormatstringMsg {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msg: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            msg_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            value: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            value_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.msg).unwrap();
        self.msg_raw = wtr.try_into().unwrap();
        self.value_raw = self.value.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: u16) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: [u8; 2]) {
        self.msg_raw = value;
    }
    pub fn set_value(&mut self, value: String) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: Vec<u8>) {
        self.value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcFormatstringMsg {
        let packet_id = i16::from_le_bytes([0xc2, 0x02]);
        let packet_id_raw = [0xc2, 0x02];
        PacketZcFormatstringMsg {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: 0,
        msg_raw: [0; 2],
        value: String::new(),
        value_raw: vec![],
        }
    }
}

impl Packet for PacketZcFormatstringMsg {
    fn id(&self, packetver: u32) -> &str {
       PacketZcFormatstringMsg::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzPartyJoinReq {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc402"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzPartyJoinReq {
        let mut offset: usize = 0;
        PacketCzPartyJoinReq {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            character_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzPartyJoinReq {
        let packet_id = i16::from_le_bytes([0xc4, 0x02]);
        let packet_id_raw = [0xc4, 0x02];
        PacketCzPartyJoinReq {
        raw: vec![],
        packet_id,
        packet_id_raw,
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketCzPartyJoinReq {
    fn id(&self, packetver: u32) -> &str {
       PacketCzPartyJoinReq::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPartyJoinReqAck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc502"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPartyJoinReqAck {
        let mut offset: usize = 0;
        PacketZcPartyJoinReqAck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            character_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            answer: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            answer_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.answer).unwrap();
        self.answer_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        wtr.append(&mut self.answer_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 30;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn set_answer(&mut self, value: i32) {
        self.answer = value;
    }
    pub fn set_answer_raw(&mut self, value: [u8; 4]) {
        self.answer_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPartyJoinReqAck {
        let packet_id = i16::from_le_bytes([0xc5, 0x02]);
        let packet_id_raw = [0xc5, 0x02];
        PacketZcPartyJoinReqAck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        answer: 0,
        answer_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcPartyJoinReqAck {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPartyJoinReqAck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPartyJoinReq {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc602"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPartyJoinReq {
        let mut offset: usize = 0;
        PacketZcPartyJoinReq {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            grid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            grid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            group_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            group_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.grid).unwrap();
        self.grid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.group_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.group_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.grid_raw.to_vec());
        wtr.append(&mut self.group_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 30;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_grid(&mut self, value: u32) {
        self.grid = value;
    }
    pub fn set_grid_raw(&mut self, value: [u8; 4]) {
        self.grid_raw = value;
    }
    pub fn set_group_name(&mut self, value: [char; 24]) {
        self.group_name = value;
    }
    pub fn set_group_name_raw(&mut self, value: [u8; 24]) {
        self.group_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPartyJoinReq {
        let packet_id = i16::from_le_bytes([0xc6, 0x02]);
        let packet_id_raw = [0xc6, 0x02];
        PacketZcPartyJoinReq {
        raw: vec![],
        packet_id,
        packet_id_raw,
        grid: 0,
        grid_raw: [0; 4],
        group_name: [0 as char; 24],
        group_name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcPartyJoinReq {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPartyJoinReq::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzPartyJoinReqAck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc702"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzPartyJoinReqAck {
        let mut offset: usize = 0;
        PacketCzPartyJoinReqAck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            grid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            grid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            b_accept: {
                let field = buffer[offset] == 1;
                field
            },
            b_accept_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.grid).unwrap();
        self.grid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.b_accept as u8).unwrap();
        self.b_accept_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.grid_raw.to_vec());
        wtr.append(&mut self.b_accept_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_grid(&mut self, value: u32) {
        self.grid = value;
    }
    pub fn set_grid_raw(&mut self, value: [u8; 4]) {
        self.grid_raw = value;
    }
    pub fn set_b_accept(&mut self, value: bool) {
        self.b_accept = value;
    }
    pub fn set_b_accept_raw(&mut self, value: [u8; 1]) {
        self.b_accept_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzPartyJoinReqAck {
        let packet_id = i16::from_le_bytes([0xc7, 0x02]);
        let packet_id_raw = [0xc7, 0x02];
        PacketCzPartyJoinReqAck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        grid: 0,
        grid_raw: [0; 4],
        b_accept: false,
        b_accept_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzPartyJoinReqAck {
    fn id(&self, packetver: u32) -> &str {
       PacketCzPartyJoinReqAck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzPartyConfig {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc802"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzPartyConfig {
        let mut offset: usize = 0;
        PacketCzPartyConfig {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            b_refuse_join_msg: {
                let field = buffer[offset] == 1;
                field
            },
            b_refuse_join_msg_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.b_refuse_join_msg as u8).unwrap();
        self.b_refuse_join_msg_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.b_refuse_join_msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_b_refuse_join_msg(&mut self, value: bool) {
        self.b_refuse_join_msg = value;
    }
    pub fn set_b_refuse_join_msg_raw(&mut self, value: [u8; 1]) {
        self.b_refuse_join_msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzPartyConfig {
        let packet_id = i16::from_le_bytes([0xc8, 0x02]);
        let packet_id_raw = [0xc8, 0x02];
        PacketCzPartyConfig {
        raw: vec![],
        packet_id,
        packet_id_raw,
        b_refuse_join_msg: false,
        b_refuse_join_msg_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzPartyConfig {
    fn id(&self, packetver: u32) -> &str {
       PacketCzPartyConfig::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPartyConfig {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc902"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPartyConfig {
        let mut offset: usize = 0;
        PacketZcPartyConfig {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            b_refuse_join_msg: {
                let field = buffer[offset] == 1;
                field
            },
            b_refuse_join_msg_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.b_refuse_join_msg as u8).unwrap();
        self.b_refuse_join_msg_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.b_refuse_join_msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_b_refuse_join_msg(&mut self, value: bool) {
        self.b_refuse_join_msg = value;
    }
    pub fn set_b_refuse_join_msg_raw(&mut self, value: [u8; 1]) {
        self.b_refuse_join_msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPartyConfig {
        let packet_id = i16::from_le_bytes([0xc9, 0x02]);
        let packet_id_raw = [0xc9, 0x02];
        PacketZcPartyConfig {
        raw: vec![],
        packet_id,
        packet_id_raw,
        b_refuse_join_msg: false,
        b_refuse_join_msg_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcPartyConfig {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPartyConfig::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcRefuseSelectchar {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xca02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcRefuseSelectchar {
        let mut offset: usize = 0;
        PacketHcRefuseSelectchar {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_code: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            error_code_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u8) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 1]) {
        self.error_code_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcRefuseSelectchar {
        let packet_id = i16::from_le_bytes([0xca, 0x02]);
        let packet_id_raw = [0xca, 0x02];
        PacketHcRefuseSelectchar {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_code: 0,
        error_code_raw: [0; 1],
        }
    }
}

impl Packet for PacketHcRefuseSelectchar {
    fn id(&self, packetver: u32) -> &str {
       PacketHcRefuseSelectchar::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMemorialdungeonSubscriptionInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xcb02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMemorialdungeonSubscriptionInfo {
        let mut offset: usize = 0;
        PacketZcMemorialdungeonSubscriptionInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            memorial_dungeon_name: {
                let field =  {
                let mut dst: [char; 61] = [0 as char; 61];
                for (index, byte) in buffer[offset..offset + 61].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            memorial_dungeon_name_raw: {
                let mut dst: [u8; 61] = [0u8; 61];
                dst.clone_from_slice(&buffer[offset..offset + 61]);
                offset += 61;
                dst
            },
            priority_order_num: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            priority_order_num_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.memorial_dungeon_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.memorial_dungeon_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.priority_order_num).unwrap();
        self.priority_order_num_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.memorial_dungeon_name_raw.to_vec());
        wtr.append(&mut self.priority_order_num_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 65;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_memorial_dungeon_name(&mut self, value: [char; 61]) {
        self.memorial_dungeon_name = value;
    }
    pub fn set_memorial_dungeon_name_raw(&mut self, value: [u8; 61]) {
        self.memorial_dungeon_name_raw = value;
    }
    pub fn set_priority_order_num(&mut self, value: i16) {
        self.priority_order_num = value;
    }
    pub fn set_priority_order_num_raw(&mut self, value: [u8; 2]) {
        self.priority_order_num_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMemorialdungeonSubscriptionInfo {
        let packet_id = i16::from_le_bytes([0xcb, 0x02]);
        let packet_id_raw = [0xcb, 0x02];
        PacketZcMemorialdungeonSubscriptionInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        memorial_dungeon_name: [0 as char; 61],
        memorial_dungeon_name_raw: [0; 61],
        priority_order_num: 0,
        priority_order_num_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcMemorialdungeonSubscriptionInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMemorialdungeonSubscriptionInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMemorialdungeonSubscriptionNotify {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xcc02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMemorialdungeonSubscriptionNotify {
        let mut offset: usize = 0;
        PacketZcMemorialdungeonSubscriptionNotify {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            priority_order_num: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            priority_order_num_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.priority_order_num).unwrap();
        self.priority_order_num_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.priority_order_num_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_priority_order_num(&mut self, value: i16) {
        self.priority_order_num = value;
    }
    pub fn set_priority_order_num_raw(&mut self, value: [u8; 2]) {
        self.priority_order_num_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMemorialdungeonSubscriptionNotify {
        let packet_id = i16::from_le_bytes([0xcc, 0x02]);
        let packet_id_raw = [0xcc, 0x02];
        PacketZcMemorialdungeonSubscriptionNotify {
        raw: vec![],
        packet_id,
        packet_id_raw,
        priority_order_num: 0,
        priority_order_num_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcMemorialdungeonSubscriptionNotify {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMemorialdungeonSubscriptionNotify::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMemorialdungeonInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xcd02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMemorialdungeonInfo {
        let mut offset: usize = 0;
        PacketZcMemorialdungeonInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            memorial_dungeon_name: {
                let field =  {
                let mut dst: [char; 61] = [0 as char; 61];
                for (index, byte) in buffer[offset..offset + 61].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            memorial_dungeon_name_raw: {
                let mut dst: [u8; 61] = [0u8; 61];
                dst.clone_from_slice(&buffer[offset..offset + 61]);
                offset += 61;
                dst
            },
            destroy_date: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            destroy_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            enter_time_out_date: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            enter_time_out_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.memorial_dungeon_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.memorial_dungeon_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.destroy_date).unwrap();
        self.destroy_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.enter_time_out_date).unwrap();
        self.enter_time_out_date_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.memorial_dungeon_name_raw.to_vec());
        wtr.append(&mut self.destroy_date_raw.to_vec());
        wtr.append(&mut self.enter_time_out_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 71;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_memorial_dungeon_name(&mut self, value: [char; 61]) {
        self.memorial_dungeon_name = value;
    }
    pub fn set_memorial_dungeon_name_raw(&mut self, value: [u8; 61]) {
        self.memorial_dungeon_name_raw = value;
    }
    pub fn set_destroy_date(&mut self, value: u32) {
        self.destroy_date = value;
    }
    pub fn set_destroy_date_raw(&mut self, value: [u8; 4]) {
        self.destroy_date_raw = value;
    }
    pub fn set_enter_time_out_date(&mut self, value: u32) {
        self.enter_time_out_date = value;
    }
    pub fn set_enter_time_out_date_raw(&mut self, value: [u8; 4]) {
        self.enter_time_out_date_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMemorialdungeonInfo {
        let packet_id = i16::from_le_bytes([0xcd, 0x02]);
        let packet_id_raw = [0xcd, 0x02];
        PacketZcMemorialdungeonInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        memorial_dungeon_name: [0 as char; 61],
        memorial_dungeon_name_raw: [0; 61],
        destroy_date: 0,
        destroy_date_raw: [0; 4],
        enter_time_out_date: 0,
        enter_time_out_date_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcMemorialdungeonInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMemorialdungeonInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMemorialdungeonNotify {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xce02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMemorialdungeonNotify {
        let mut offset: usize = 0;
        PacketZcMemorialdungeonNotify {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            enter_limit_date: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            enter_limit_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.enter_limit_date).unwrap();
        self.enter_limit_date_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.enter_limit_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn set_enter_limit_date(&mut self, value: u32) {
        self.enter_limit_date = value;
    }
    pub fn set_enter_limit_date_raw(&mut self, value: [u8; 4]) {
        self.enter_limit_date_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMemorialdungeonNotify {
        let packet_id = i16::from_le_bytes([0xce, 0x02]);
        let packet_id_raw = [0xce, 0x02];
        PacketZcMemorialdungeonNotify {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 4],
        enter_limit_date: 0,
        enter_limit_date_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcMemorialdungeonNotify {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMemorialdungeonNotify::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzMemorialdungeonCommand {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xcf02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzMemorialdungeonCommand {
        let mut offset: usize = 0;
        PacketCzMemorialdungeonCommand {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            command: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            command_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.command).unwrap();
        self.command_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.command_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_command(&mut self, value: i32) {
        self.command = value;
    }
    pub fn set_command_raw(&mut self, value: [u8; 4]) {
        self.command_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzMemorialdungeonCommand {
        let packet_id = i16::from_le_bytes([0xcf, 0x02]);
        let packet_id_raw = [0xcf, 0x02];
        PacketCzMemorialdungeonCommand {
        raw: vec![],
        packet_id,
        packet_id_raw,
        command: 0,
        command_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzMemorialdungeonCommand {
    fn id(&self, packetver: u32) -> &str {
       PacketCzMemorialdungeonCommand::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcEquipmentItemlist3 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd002"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcEquipmentItemlist3 {
        let mut offset: usize = 0;
        let vec_type_len = EquipmentitemExtrainfo301::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<EquipmentitemExtrainfo301> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(EquipmentitemExtrainfo301::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcEquipmentItemlist3 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_info: {
                let field = vec_field.clone();
                field
            },
            item_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo301>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcEquipmentItemlist3 {
        let packet_id = i16::from_le_bytes([0xd0, 0x02]);
        let packet_id_raw = [0xd0, 0x02];
        PacketZcEquipmentItemlist3 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcEquipmentItemlist3 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcEquipmentItemlist3::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcStoreEquipmentItemlist3 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd102"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcStoreEquipmentItemlist3 {
        let mut offset: usize = 0;
        let vec_type_len = EquipmentitemExtrainfo301::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<EquipmentitemExtrainfo301> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(EquipmentitemExtrainfo301::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcStoreEquipmentItemlist3 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_info: {
                let field = vec_field.clone();
                field
            },
            item_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo301>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcStoreEquipmentItemlist3 {
        let packet_id = i16::from_le_bytes([0xd1, 0x02]);
        let packet_id_raw = [0xd1, 0x02];
        PacketZcStoreEquipmentItemlist3 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcStoreEquipmentItemlist3 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcStoreEquipmentItemlist3::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcCartEquipmentItemlist3 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd202"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcCartEquipmentItemlist3 {
        let mut offset: usize = 0;
        let vec_type_len = EquipmentitemExtrainfo301::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<EquipmentitemExtrainfo301> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(EquipmentitemExtrainfo301::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcCartEquipmentItemlist3 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_info: {
                let field = vec_field.clone();
                field
            },
            item_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo301>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcCartEquipmentItemlist3 {
        let packet_id = i16::from_le_bytes([0xd2, 0x02]);
        let packet_id_raw = [0xd2, 0x02];
        PacketZcCartEquipmentItemlist3 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcCartEquipmentItemlist3 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcCartEquipmentItemlist3::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyBindOnEquip {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd302"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyBindOnEquip {
        let mut offset: usize = 0;
        PacketZcNotifyBindOnEquip {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyBindOnEquip {
        let packet_id = i16::from_le_bytes([0xd3, 0x02]);
        let packet_id_raw = [0xd3, 0x02];
        PacketZcNotifyBindOnEquip {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyBindOnEquip {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyBindOnEquip::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcItemPickupAck3 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd402"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcItemPickupAck3 {
        let mut offset: usize = 0;
        PacketZcItemPickupAck3 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_damaged: {
                let field = buffer[offset] == 1;
                field
            },
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            refining_level: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            location: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            hire_expire_date: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            hire_expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            bind_on_equip_type: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bind_on_equip_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hire_expire_date).unwrap();
        self.hire_expire_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.bind_on_equip_type).unwrap();
        self.bind_on_equip_type_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        wtr.append(&mut self.location_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.hire_expire_date_raw.to_vec());
        wtr.append(&mut self.bind_on_equip_type_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 29;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: u16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn set_location(&mut self, value: u16) {
        self.location = value;
    }
    pub fn set_location_raw(&mut self, value: [u8; 2]) {
        self.location_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn set_hire_expire_date(&mut self, value: i32) {
        self.hire_expire_date = value;
    }
    pub fn set_hire_expire_date_raw(&mut self, value: [u8; 4]) {
        self.hire_expire_date_raw = value;
    }
    pub fn set_bind_on_equip_type(&mut self, value: u16) {
        self.bind_on_equip_type = value;
    }
    pub fn set_bind_on_equip_type_raw(&mut self, value: [u8; 2]) {
        self.bind_on_equip_type_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcItemPickupAck3 {
        let packet_id = i16::from_le_bytes([0xd4, 0x02]);
        let packet_id_raw = [0xd4, 0x02];
        PacketZcItemPickupAck3 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        location: 0,
        location_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        result: 0,
        result_raw: [0; 1],
        hire_expire_date: 0,
        hire_expire_date_raw: [0; 4],
        bind_on_equip_type: 0,
        bind_on_equip_type_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcItemPickupAck3 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcItemPickupAck3::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcIsvrDisconnect {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd502"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcIsvrDisconnect {
        let mut offset: usize = 0;
        PacketZcIsvrDisconnect {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcIsvrDisconnect {
        let packet_id = i16::from_le_bytes([0xd5, 0x02]);
        let packet_id_raw = [0xd5, 0x02];
        PacketZcIsvrDisconnect {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketZcIsvrDisconnect {
    fn id(&self, packetver: u32) -> &str {
       PacketZcIsvrDisconnect::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzEquipwinMicroscope {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd602"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzEquipwinMicroscope {
        let mut offset: usize = 0;
        PacketCzEquipwinMicroscope {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzEquipwinMicroscope {
        let packet_id = i16::from_le_bytes([0xd6, 0x02]);
        let packet_id_raw = [0xd6, 0x02];
        PacketCzEquipwinMicroscope {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzEquipwinMicroscope {
    fn id(&self, packetver: u32) -> &str {
       PacketCzEquipwinMicroscope::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcEquipwinMicroscope {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd702"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcEquipwinMicroscope {
        let mut offset: usize = 0;
        let vec_type_len = EquipmentitemExtrainfo301::base_len(packetver);
        let iter_count = (&buffer.len() - 43) / vec_type_len;
        let mut vec_field: Vec<EquipmentitemExtrainfo301> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 43 + (vec_type_len * (i - 1));
            let end_pos = 43 + vec_type_len * i;
            vec_field.push(EquipmentitemExtrainfo301::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcEquipwinMicroscope {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            character_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory2: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            item_info: {
                let field = vec_field.clone();
                field
            },
            item_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 43;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<EquipmentitemExtrainfo301>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcEquipwinMicroscope {
        let packet_id = i16::from_le_bytes([0xd7, 0x02]);
        let packet_id_raw = [0xd7, 0x02];
        PacketZcEquipwinMicroscope {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        accessory: 0,
        accessory_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        sex: 0,
        sex_raw: [0; 1],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcEquipwinMicroscope {
    fn id(&self, packetver: u32) -> &str {
       PacketZcEquipwinMicroscope::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzConfig {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd802"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzConfig {
        let mut offset: usize = 0;
        PacketCzConfig {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            config: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            config_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            value: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.config).unwrap();
        self.config_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.config_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_config(&mut self, value: i32) {
        self.config = value;
    }
    pub fn set_config_raw(&mut self, value: [u8; 4]) {
        self.config_raw = value;
    }
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzConfig {
        let packet_id = i16::from_le_bytes([0xd8, 0x02]);
        let packet_id_raw = [0xd8, 0x02];
        PacketCzConfig {
        raw: vec![],
        packet_id,
        packet_id_raw,
        config: 0,
        config_raw: [0; 4],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzConfig {
    fn id(&self, packetver: u32) -> &str {
       PacketCzConfig::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcConfig {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd902"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcConfig {
        let mut offset: usize = 0;
        PacketZcConfig {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            config: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            config_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            value: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.config).unwrap();
        self.config_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.config_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_config(&mut self, value: i32) {
        self.config = value;
    }
    pub fn set_config_raw(&mut self, value: [u8; 4]) {
        self.config_raw = value;
    }
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcConfig {
        let packet_id = i16::from_le_bytes([0xd9, 0x02]);
        let packet_id_raw = [0xd9, 0x02];
        PacketZcConfig {
        raw: vec![],
        packet_id,
        packet_id_raw,
        config: 0,
        config_raw: [0; 4],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcConfig {
    fn id(&self, packetver: u32) -> &str {
       PacketZcConfig::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcConfigNotify {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xda02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcConfigNotify {
        let mut offset: usize = 0;
        PacketZcConfigNotify {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            b_open_equipment_win: {
                let field = buffer[offset] == 1;
                field
            },
            b_open_equipment_win_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.b_open_equipment_win as u8).unwrap();
        self.b_open_equipment_win_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.b_open_equipment_win_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_b_open_equipment_win(&mut self, value: bool) {
        self.b_open_equipment_win = value;
    }
    pub fn set_b_open_equipment_win_raw(&mut self, value: [u8; 1]) {
        self.b_open_equipment_win_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcConfigNotify {
        let packet_id = i16::from_le_bytes([0xda, 0x02]);
        let packet_id_raw = [0xda, 0x02];
        PacketZcConfigNotify {
        raw: vec![],
        packet_id,
        packet_id_raw,
        b_open_equipment_win: false,
        b_open_equipment_win_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcConfigNotify {
    fn id(&self, packetver: u32) -> &str {
       PacketZcConfigNotify::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzBattlefieldChat {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xdb02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzBattlefieldChat {
        let mut offset: usize = 0;
        PacketCzBattlefieldChat {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzBattlefieldChat {
        let packet_id = i16::from_le_bytes([0xdb, 0x02]);
        let packet_id_raw = [0xdb, 0x02];
        PacketCzBattlefieldChat {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketCzBattlefieldChat {
    fn id(&self, packetver: u32) -> &str {
       PacketCzBattlefieldChat::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcBattlefieldChat {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xdc02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcBattlefieldChat {
        let mut offset: usize = 0;
        PacketZcBattlefieldChat {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            account_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.account_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 31;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_account_id(&mut self, value: u32) {
        self.account_id = value;
    }
    pub fn set_account_id_raw(&mut self, value: [u8; 4]) {
        self.account_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcBattlefieldChat {
        let packet_id = i16::from_le_bytes([0xdc, 0x02]);
        let packet_id_raw = [0xdc, 0x02];
        PacketZcBattlefieldChat {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        account_id: 0,
        account_id_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcBattlefieldChat {
    fn id(&self, packetver: u32) -> &str {
       PacketZcBattlefieldChat::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcBattlefieldNotifyCampinfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xdd02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcBattlefieldNotifyCampinfo {
        let mut offset: usize = 0;
        PacketZcBattlefieldNotifyCampinfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            account_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            camp: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            camp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.camp).unwrap();
        self.camp_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.account_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.camp_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 32;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_account_id(&mut self, value: u32) {
        self.account_id = value;
    }
    pub fn set_account_id_raw(&mut self, value: [u8; 4]) {
        self.account_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_camp(&mut self, value: i16) {
        self.camp = value;
    }
    pub fn set_camp_raw(&mut self, value: [u8; 2]) {
        self.camp_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcBattlefieldNotifyCampinfo {
        let packet_id = i16::from_le_bytes([0xdd, 0x02]);
        let packet_id_raw = [0xdd, 0x02];
        PacketZcBattlefieldNotifyCampinfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        account_id: 0,
        account_id_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        camp: 0,
        camp_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcBattlefieldNotifyCampinfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcBattlefieldNotifyCampinfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcBattlefieldNotifyPoint {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xde02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcBattlefieldNotifyPoint {
        let mut offset: usize = 0;
        PacketZcBattlefieldNotifyPoint {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            point_camp_a: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            point_camp_a_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            point_camp_b: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            point_camp_b_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.point_camp_a).unwrap();
        self.point_camp_a_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.point_camp_b).unwrap();
        self.point_camp_b_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.point_camp_a_raw.to_vec());
        wtr.append(&mut self.point_camp_b_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_point_camp_a(&mut self, value: i16) {
        self.point_camp_a = value;
    }
    pub fn set_point_camp_a_raw(&mut self, value: [u8; 2]) {
        self.point_camp_a_raw = value;
    }
    pub fn set_point_camp_b(&mut self, value: i16) {
        self.point_camp_b = value;
    }
    pub fn set_point_camp_b_raw(&mut self, value: [u8; 2]) {
        self.point_camp_b_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcBattlefieldNotifyPoint {
        let packet_id = i16::from_le_bytes([0xde, 0x02]);
        let packet_id_raw = [0xde, 0x02];
        PacketZcBattlefieldNotifyPoint {
        raw: vec![],
        packet_id,
        packet_id_raw,
        point_camp_a: 0,
        point_camp_a_raw: [0; 2],
        point_camp_b: 0,
        point_camp_b_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcBattlefieldNotifyPoint {
    fn id(&self, packetver: u32) -> &str {
       PacketZcBattlefieldNotifyPoint::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcBattlefieldNotifyPosition {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xdf02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcBattlefieldNotifyPosition {
        let mut offset: usize = 0;
        PacketZcBattlefieldNotifyPosition {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            account_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            job: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            x: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x).unwrap();
        self.x_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y).unwrap();
        self.y_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.account_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.x_raw.to_vec());
        wtr.append(&mut self.y_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 36;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_account_id(&mut self, value: u32) {
        self.account_id = value;
    }
    pub fn set_account_id_raw(&mut self, value: [u8; 4]) {
        self.account_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_job(&mut self, value: u16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_x(&mut self, value: i16) {
        self.x = value;
    }
    pub fn set_x_raw(&mut self, value: [u8; 2]) {
        self.x_raw = value;
    }
    pub fn set_y(&mut self, value: i16) {
        self.y = value;
    }
    pub fn set_y_raw(&mut self, value: [u8; 2]) {
        self.y_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcBattlefieldNotifyPosition {
        let packet_id = i16::from_le_bytes([0xdf, 0x02]);
        let packet_id_raw = [0xdf, 0x02];
        PacketZcBattlefieldNotifyPosition {
        raw: vec![],
        packet_id,
        packet_id_raw,
        account_id: 0,
        account_id_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        job: 0,
        job_raw: [0; 2],
        x: 0,
        x_raw: [0; 2],
        y: 0,
        y_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcBattlefieldNotifyPosition {
    fn id(&self, packetver: u32) -> &str {
       PacketZcBattlefieldNotifyPosition::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcBattlefieldNotifyHp {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe002"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcBattlefieldNotifyHp {
        let mut offset: usize = 0;
        PacketZcBattlefieldNotifyHp {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            account_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            account_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            hp: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            max_hp: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            max_hp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.account_id).unwrap();
        self.account_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.account_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.max_hp_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 34;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_account_id(&mut self, value: u32) {
        self.account_id = value;
    }
    pub fn set_account_id_raw(&mut self, value: [u8; 4]) {
        self.account_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_hp(&mut self, value: i16) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 2]) {
        self.hp_raw = value;
    }
    pub fn set_max_hp(&mut self, value: i16) {
        self.max_hp = value;
    }
    pub fn set_max_hp_raw(&mut self, value: [u8; 2]) {
        self.max_hp_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcBattlefieldNotifyHp {
        let packet_id = i16::from_le_bytes([0xe0, 0x02]);
        let packet_id_raw = [0xe0, 0x02];
        PacketZcBattlefieldNotifyHp {
        raw: vec![],
        packet_id,
        packet_id_raw,
        account_id: 0,
        account_id_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        hp: 0,
        hp_raw: [0; 2],
        max_hp: 0,
        max_hp_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcBattlefieldNotifyHp {
    fn id(&self, packetver: u32) -> &str {
       PacketZcBattlefieldNotifyHp::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyAct2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe102"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyAct2 {
        let mut offset: usize = 0;
        PacketZcNotifyAct2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            target_gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            target_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            start_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            attack_mt: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            attack_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            attacked_mt: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            attacked_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            damage: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            damage_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            action: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            left_damage: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            left_damage_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_gid).unwrap();
        self.target_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attack_mt).unwrap();
        self.attack_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attacked_mt).unwrap();
        self.attacked_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.damage).unwrap();
        self.damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.left_damage).unwrap();
        self.left_damage_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.target_gid_raw.to_vec());
        wtr.append(&mut self.start_time_raw.to_vec());
        wtr.append(&mut self.attack_mt_raw.to_vec());
        wtr.append(&mut self.attacked_mt_raw.to_vec());
        wtr.append(&mut self.damage_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        wtr.append(&mut self.left_damage_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 33;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_target_gid(&mut self, value: u32) {
        self.target_gid = value;
    }
    pub fn set_target_gid_raw(&mut self, value: [u8; 4]) {
        self.target_gid_raw = value;
    }
    pub fn set_start_time(&mut self, value: u32) {
        self.start_time = value;
    }
    pub fn set_start_time_raw(&mut self, value: [u8; 4]) {
        self.start_time_raw = value;
    }
    pub fn set_attack_mt(&mut self, value: i32) {
        self.attack_mt = value;
    }
    pub fn set_attack_mt_raw(&mut self, value: [u8; 4]) {
        self.attack_mt_raw = value;
    }
    pub fn set_attacked_mt(&mut self, value: i32) {
        self.attacked_mt = value;
    }
    pub fn set_attacked_mt_raw(&mut self, value: [u8; 4]) {
        self.attacked_mt_raw = value;
    }
    pub fn set_damage(&mut self, value: i32) {
        self.damage = value;
    }
    pub fn set_damage_raw(&mut self, value: [u8; 4]) {
        self.damage_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn set_left_damage(&mut self, value: i32) {
        self.left_damage = value;
    }
    pub fn set_left_damage_raw(&mut self, value: [u8; 4]) {
        self.left_damage_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyAct2 {
        let packet_id = i16::from_le_bytes([0xe1, 0x02]);
        let packet_id_raw = [0xe1, 0x02];
        PacketZcNotifyAct2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        target_gid: 0,
        target_gid_raw: [0; 4],
        start_time: 0,
        start_time_raw: [0; 4],
        attack_mt: 0,
        attack_mt_raw: [0; 4],
        attacked_mt: 0,
        attacked_mt_raw: [0; 4],
        damage: 0,
        damage_raw: [0; 4],
        count: 0,
        count_raw: [0; 2],
        action: 0,
        action_raw: [0; 1],
        left_damage: 0,
        left_damage_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyAct2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyAct2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzBotCheck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe602"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzBotCheck {
        let mut offset: usize = 0;
        PacketCzBotCheck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_bot: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            is_bot_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.is_bot).unwrap();
        self.is_bot_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.is_bot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_is_bot(&mut self, value: i32) {
        self.is_bot = value;
    }
    pub fn set_is_bot_raw(&mut self, value: [u8; 4]) {
        self.is_bot_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzBotCheck {
        let packet_id = i16::from_le_bytes([0xe6, 0x02]);
        let packet_id_raw = [0xe6, 0x02];
        PacketCzBotCheck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        is_bot: 0,
        is_bot_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzBotCheck {
    fn id(&self, packetver: u32) -> &str {
       PacketCzBotCheck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMapproperty {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe702"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMapproperty {
        let mut offset: usize = 0;
        PacketZcMapproperty {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            map_info_table: {
                let field =  {
                let dst: Vec<u8> = buffer[offset..buffer.len()].to_vec();
                dst
            };
                field
            },
            map_info_table_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.map_info_table_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn set_map_info_table(&mut self, value: Vec<u8>) {
        self.map_info_table = value;
    }
    pub fn set_map_info_table_raw(&mut self, value: Vec<u8>) {
        self.map_info_table_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMapproperty {
        let packet_id = i16::from_le_bytes([0xe7, 0x02]);
        let packet_id_raw = [0xe7, 0x02];
        PacketZcMapproperty {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 2],
        map_info_table: vec![],
        map_info_table_raw: vec![],
        }
    }
}

impl Packet for PacketZcMapproperty {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMapproperty::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNormalItemlist3 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe802"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNormalItemlist3 {
        let mut offset: usize = 0;
        let vec_type_len = NormalitemExtrainfo3::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<NormalitemExtrainfo3> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(NormalitemExtrainfo3::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcNormalItemlist3 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_info: {
                let field = vec_field.clone();
                field
            },
            item_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<NormalitemExtrainfo3>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNormalItemlist3 {
        let packet_id = i16::from_le_bytes([0xe8, 0x02]);
        let packet_id_raw = [0xe8, 0x02];
        PacketZcNormalItemlist3 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcNormalItemlist3 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNormalItemlist3::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcCartNormalItemlist3 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe902"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcCartNormalItemlist3 {
        let mut offset: usize = 0;
        let vec_type_len = NormalitemExtrainfo3::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<NormalitemExtrainfo3> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(NormalitemExtrainfo3::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcCartNormalItemlist3 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_info: {
                let field = vec_field.clone();
                field
            },
            item_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<NormalitemExtrainfo3>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcCartNormalItemlist3 {
        let packet_id = i16::from_le_bytes([0xe9, 0x02]);
        let packet_id_raw = [0xe9, 0x02];
        PacketZcCartNormalItemlist3 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcCartNormalItemlist3 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcCartNormalItemlist3::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcStoreNormalItemlist3 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xea02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcStoreNormalItemlist3 {
        let mut offset: usize = 0;
        let vec_type_len = NormalitemExtrainfo3::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<NormalitemExtrainfo3> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(NormalitemExtrainfo3::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcStoreNormalItemlist3 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_info: {
                let field = vec_field.clone();
                field
            },
            item_info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.item_info_raw = {
            self.item_info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.item_info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_item_info(&mut self, value: Vec<NormalitemExtrainfo3>) {
        self.item_info = value;
    }
    pub fn set_item_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcStoreNormalItemlist3 {
        let packet_id = i16::from_le_bytes([0xea, 0x02]);
        let packet_id_raw = [0xea, 0x02];
        PacketZcStoreNormalItemlist3 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        item_info: vec![],
        item_info_raw: vec![],
        }
    }
}

impl Packet for PacketZcStoreNormalItemlist3 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcStoreNormalItemlist3::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAcceptEnter2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xeb02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAcceptEnter2 {
        let mut offset: usize = 0;
        PacketZcAcceptEnter2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            start_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            pos_dir: {
                let field =  {
                let mut dst: [u8; 3] = [0_u8; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[offset..offset + 3]);
                offset += 3;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            font: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.start_time_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.font_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 13;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_start_time(&mut self, value: u32) {
        self.start_time = value;
    }
    pub fn set_start_time_raw(&mut self, value: [u8; 4]) {
        self.start_time_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [u8; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_font(&mut self, value: i16) {
        self.font = value;
    }
    pub fn set_font_raw(&mut self, value: [u8; 2]) {
        self.font_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAcceptEnter2 {
        let packet_id = i16::from_le_bytes([0xeb, 0x02]);
        let packet_id_raw = [0xeb, 0x02];
        PacketZcAcceptEnter2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        start_time: 0,
        start_time_raw: [0; 4],
        pos_dir: [0; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        font: 0,
        font_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAcceptEnter2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAcceptEnter2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyMoveentry4 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xec02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyMoveentry4 {
        let mut offset: usize = 0;
        PacketZcNotifyMoveentry4 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            objecttype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            move_start_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory2: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gemblem_ver: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            honor: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            virtue: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            move_data: {
                let field =  {
                let mut dst: [u16; 6] = [0_u16; 6];
                for (index, byte) in buffer[offset..offset + 6].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            };
                field
            },
            move_data_raw: {
                let mut dst: [u8; 12] = [0u8; 12];
                dst.clone_from_slice(&buffer[offset..offset + 12]);
                offset += 12;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            clevel: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            font: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.objecttype_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.move_start_time_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.move_data_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        wtr.append(&mut self.font_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 67;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_objecttype(&mut self, value: u8) {
        self.objecttype = value;
    }
    pub fn set_objecttype_raw(&mut self, value: [u8; 1]) {
        self.objecttype_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_move_start_time(&mut self, value: u32) {
        self.move_start_time = value;
    }
    pub fn set_move_start_time_raw(&mut self, value: [u8; 4]) {
        self.move_start_time_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_move_data(&mut self, value: [u16; 6]) {
        self.move_data = value;
    }
    pub fn set_move_data_raw(&mut self, value: [u8; 12]) {
        self.move_data_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn set_font(&mut self, value: i16) {
        self.font = value;
    }
    pub fn set_font_raw(&mut self, value: [u8; 2]) {
        self.font_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyMoveentry4 {
        let packet_id = i16::from_le_bytes([0xec, 0x02]);
        let packet_id_raw = [0xec, 0x02];
        PacketZcNotifyMoveentry4 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        objecttype: 0,
        objecttype_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        move_start_time: 0,
        move_start_time_raw: [0; 4],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        move_data: [0; 6],
        move_data_raw: [0; 12],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        font: 0,
        font_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyMoveentry4 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyMoveentry4::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyNewentry4 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xed02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyNewentry4 {
        let mut offset: usize = 0;
        PacketZcNotifyNewentry4 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory2: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gemblem_ver: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            honor: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            virtue: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            pos_dir: {
                let field =  {
                let mut dst: [u8; 3] = [0_u8; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[offset..offset + 3]);
                offset += 3;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            clevel: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            font: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        wtr.append(&mut self.font_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 59;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [u8; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn set_font(&mut self, value: i16) {
        self.font = value;
    }
    pub fn set_font_raw(&mut self, value: [u8; 2]) {
        self.font_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyNewentry4 {
        let packet_id = i16::from_le_bytes([0xed, 0x02]);
        let packet_id_raw = [0xed, 0x02];
        PacketZcNotifyNewentry4 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        font: 0,
        font_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyNewentry4 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyNewentry4::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyStandentry4 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xee02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyStandentry4 {
        let mut offset: usize = 0;
        PacketZcNotifyStandentry4 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory2: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gemblem_ver: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            honor: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            virtue: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            pos_dir: {
                let field =  {
                let mut dst: [u8; 3] = [0_u8; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[offset..offset + 3]);
                offset += 3;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            state: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            clevel: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            font: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        wtr.append(&mut self.font_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 60;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [u8; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_state(&mut self, value: u8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn set_font(&mut self, value: i16) {
        self.font = value;
    }
    pub fn set_font_raw(&mut self, value: [u8; 2]) {
        self.font_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyStandentry4 {
        let packet_id = i16::from_le_bytes([0xee, 0x02]);
        let packet_id_raw = [0xee, 0x02];
        PacketZcNotifyStandentry4 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        state: 0,
        state_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        font: 0,
        font_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyStandentry4 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyStandentry4::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyFont {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xef02"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyFont {
        let mut offset: usize = 0;
        PacketZcNotifyFont {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            font: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.font_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_font(&mut self, value: i16) {
        self.font = value;
    }
    pub fn set_font_raw(&mut self, value: [u8; 2]) {
        self.font_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyFont {
        let packet_id = i16::from_le_bytes([0xef, 0x02]);
        let packet_id_raw = [0xef, 0x02];
        PacketZcNotifyFont {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        font: 0,
        font_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyFont {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyFont::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcProgress {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf002"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcProgress {
        let mut offset: usize = 0;
        PacketZcProgress {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            color: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            color_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.color).unwrap();
        self.color_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.time).unwrap();
        self.time_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.color_raw.to_vec());
        wtr.append(&mut self.time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_color(&mut self, value: u32) {
        self.color = value;
    }
    pub fn set_color_raw(&mut self, value: [u8; 4]) {
        self.color_raw = value;
    }
    pub fn set_time(&mut self, value: u32) {
        self.time = value;
    }
    pub fn set_time_raw(&mut self, value: [u8; 4]) {
        self.time_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcProgress {
        let packet_id = i16::from_le_bytes([0xf0, 0x02]);
        let packet_id_raw = [0xf0, 0x02];
        PacketZcProgress {
        raw: vec![],
        packet_id,
        packet_id_raw,
        color: 0,
        color_raw: [0; 4],
        time: 0,
        time_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcProgress {
    fn id(&self, packetver: u32) -> &str {
       PacketZcProgress::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzProgress {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf102"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzProgress {
        let mut offset: usize = 0;
        PacketCzProgress {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzProgress {
        let packet_id = i16::from_le_bytes([0xf1, 0x02]);
        let packet_id_raw = [0xf1, 0x02];
        PacketCzProgress {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzProgress {
    fn id(&self, packetver: u32) -> &str {
       PacketCzProgress::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcProgressCancel {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf202"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcProgressCancel {
        let mut offset: usize = 0;
        PacketZcProgressCancel {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcProgressCancel {
        let packet_id = i16::from_le_bytes([0xf2, 0x02]);
        let packet_id_raw = [0xf2, 0x02];
        PacketZcProgressCancel {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketZcProgressCancel {
    fn id(&self, packetver: u32) -> &str {
       PacketZcProgressCancel::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzOpenSimpleCashshopItemlist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5c03"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzOpenSimpleCashshopItemlist {
        let mut offset: usize = 0;
        PacketCzOpenSimpleCashshopItemlist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzOpenSimpleCashshopItemlist {
        let packet_id = i16::from_le_bytes([0x5c, 0x03]);
        let packet_id_raw = [0x5c, 0x03];
        PacketCzOpenSimpleCashshopItemlist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzOpenSimpleCashshopItemlist {
    fn id(&self, packetver: u32) -> &str {
       PacketCzOpenSimpleCashshopItemlist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSimpleCashshopPointItemlist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5d03"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSimpleCashshopPointItemlist {
        let mut offset: usize = 0;
        let vec_type_len = PurchaseItem::base_len(packetver);
        let iter_count = (&buffer.len() - 16) / vec_type_len;
        let mut vec_field: Vec<PurchaseItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 16 + (vec_type_len * (i - 1));
            let end_pos = 16 + vec_type_len * i;
            vec_field.push(PurchaseItem::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcSimpleCashshopPointItemlist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            cash_point: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            cash_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            md_itemcount: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            md_itemcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            md_item_size: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            md_item_size_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            best_itemcount: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            best_itemcount_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            best_itemsize: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            best_itemsize_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_list: {
                let field = vec_field.clone();
                field
            },
            item_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.cash_point).unwrap();
        self.cash_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.md_itemcount).unwrap();
        self.md_itemcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.md_item_size).unwrap();
        self.md_item_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.best_itemcount).unwrap();
        self.best_itemcount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.best_itemsize).unwrap();
        self.best_itemsize_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.cash_point_raw.to_vec());
        wtr.append(&mut self.md_itemcount_raw.to_vec());
        wtr.append(&mut self.md_item_size_raw.to_vec());
        wtr.append(&mut self.best_itemcount_raw.to_vec());
        wtr.append(&mut self.best_itemsize_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 16;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_cash_point(&mut self, value: u32) {
        self.cash_point = value;
    }
    pub fn set_cash_point_raw(&mut self, value: [u8; 4]) {
        self.cash_point_raw = value;
    }
    pub fn set_md_itemcount(&mut self, value: i16) {
        self.md_itemcount = value;
    }
    pub fn set_md_itemcount_raw(&mut self, value: [u8; 2]) {
        self.md_itemcount_raw = value;
    }
    pub fn set_md_item_size(&mut self, value: i16) {
        self.md_item_size = value;
    }
    pub fn set_md_item_size_raw(&mut self, value: [u8; 2]) {
        self.md_item_size_raw = value;
    }
    pub fn set_best_itemcount(&mut self, value: i16) {
        self.best_itemcount = value;
    }
    pub fn set_best_itemcount_raw(&mut self, value: [u8; 2]) {
        self.best_itemcount_raw = value;
    }
    pub fn set_best_itemsize(&mut self, value: i16) {
        self.best_itemsize = value;
    }
    pub fn set_best_itemsize_raw(&mut self, value: [u8; 2]) {
        self.best_itemsize_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<PurchaseItem>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSimpleCashshopPointItemlist {
        let packet_id = i16::from_le_bytes([0x5d, 0x03]);
        let packet_id_raw = [0x5d, 0x03];
        PacketZcSimpleCashshopPointItemlist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        cash_point: 0,
        cash_point_raw: [0; 4],
        md_itemcount: 0,
        md_itemcount_raw: [0; 2],
        md_item_size: 0,
        md_item_size_raw: [0; 2],
        best_itemcount: 0,
        best_itemcount_raw: [0; 2],
        best_itemsize: 0,
        best_itemsize_raw: [0; 2],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcSimpleCashshopPointItemlist {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSimpleCashshopPointItemlist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzCloseWindow {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5e03"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzCloseWindow {
        let mut offset: usize = 0;
        PacketCzCloseWindow {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzCloseWindow {
        let packet_id = i16::from_le_bytes([0x5e, 0x03]);
        let packet_id_raw = [0x5e, 0x03];
        PacketCzCloseWindow {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzCloseWindow {
    fn id(&self, packetver: u32) -> &str {
       PacketCzCloseWindow::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAhcGameGuard {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xdd03"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAhcGameGuard {
        let mut offset: usize = 0;
        PacketAhcGameGuard {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            auth_data: {
                let field =  {
                let mut dst: [u32; 4] = [0_u32; 4];
                for (index, byte) in buffer[offset..offset + 4].iter().enumerate() {
                    dst[index] = *byte as u32;
                }
                dst
            };
                field
            },
            auth_data_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.auth_data {
            wtr.write_u32::<LittleEndian>(item).unwrap();
        }
        self.auth_data_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.auth_data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_auth_data(&mut self, value: [u32; 4]) {
        self.auth_data = value;
    }
    pub fn set_auth_data_raw(&mut self, value: [u8; 16]) {
        self.auth_data_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAhcGameGuard {
        let packet_id = i16::from_le_bytes([0xdd, 0x03]);
        let packet_id_raw = [0xdd, 0x03];
        PacketAhcGameGuard {
        raw: vec![],
        packet_id,
        packet_id_raw,
        auth_data: [0; 4],
        auth_data_raw: [0; 16],
        }
    }
}

impl Packet for PacketAhcGameGuard {
    fn id(&self, packetver: u32) -> &str {
       PacketAhcGameGuard::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCahAckGameGuard {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xde03"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCahAckGameGuard {
        let mut offset: usize = 0;
        PacketCahAckGameGuard {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            auth_data: {
                let field =  {
                let mut dst: [u32; 4] = [0_u32; 4];
                for (index, byte) in buffer[offset..offset + 4].iter().enumerate() {
                    dst[index] = *byte as u32;
                }
                dst
            };
                field
            },
            auth_data_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.auth_data {
            wtr.write_u32::<LittleEndian>(item).unwrap();
        }
        self.auth_data_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.auth_data_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_auth_data(&mut self, value: [u32; 4]) {
        self.auth_data = value;
    }
    pub fn set_auth_data_raw(&mut self, value: [u8; 16]) {
        self.auth_data_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCahAckGameGuard {
        let packet_id = i16::from_le_bytes([0xde, 0x03]);
        let packet_id_raw = [0xde, 0x03];
        PacketCahAckGameGuard {
        raw: vec![],
        packet_id,
        packet_id_raw,
        auth_data: [0; 4],
        auth_data_raw: [0; 16],
        }
    }
}

impl Packet for PacketCahAckGameGuard {
    fn id(&self, packetver: u32) -> &str {
       PacketCahAckGameGuard::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzEnter2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        if packetver >= 20170607 {
            "0x0871"
        } else if packetver >= 20120307 {
            "0x086A"
        } else if packetver >= 20111102 {
            "0x083C"
        } else {
            "0x3604"
        }
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzEnter2 {
        let mut offset: usize = 0;
        PacketCzEnter2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            auth_code: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            auth_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            client_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            client_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.auth_code).unwrap();
        self.auth_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.client_time).unwrap();
        self.client_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.auth_code_raw.to_vec());
        wtr.append(&mut self.client_time_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 19;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_auth_code(&mut self, value: i32) {
        self.auth_code = value;
    }
    pub fn set_auth_code_raw(&mut self, value: [u8; 4]) {
        self.auth_code_raw = value;
    }
    pub fn set_client_time(&mut self, value: u32) {
        self.client_time = value;
    }
    pub fn set_client_time_raw(&mut self, value: [u8; 4]) {
        self.client_time_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzEnter2 {
        let (packet_id, packet_id_raw) = if packetver >= 20170607 {
            (i16::from_le_bytes([0x71, 0x08]), [0x71, 0x08])
        } else if packetver >= 20120307 {
            (i16::from_le_bytes([0x6A, 0x08]), [0x6A, 0x08])
        } else if packetver >= 20111102 {
            (i16::from_le_bytes([0x3C, 0x08]), [0x3C, 0x08])
        } else {
            (i16::from_le_bytes([0x36, 0x04]), [0x36, 0x04])
        };
        PacketCzEnter2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        auth_code: 0,
        auth_code_raw: [0; 4],
        client_time: 0,
        client_time_raw: [0; 4],
        sex: 0,
        sex_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzEnter2 {
    fn id(&self, packetver: u32) -> &str {
       PacketCzEnter2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzUseSkill2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3804"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzUseSkill2 {
        let mut offset: usize = 0;
        PacketCzUseSkill2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            selected_level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            selected_level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            target_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.selected_level).unwrap();
        self.selected_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.selected_level_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.target_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_selected_level(&mut self, value: i16) {
        self.selected_level = value;
    }
    pub fn set_selected_level_raw(&mut self, value: [u8; 2]) {
        self.selected_level_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_target_id(&mut self, value: u32) {
        self.target_id = value;
    }
    pub fn set_target_id_raw(&mut self, value: [u8; 4]) {
        self.target_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzUseSkill2 {
        let packet_id = i16::from_le_bytes([0x38, 0x04]);
        let packet_id_raw = [0x38, 0x04];
        PacketCzUseSkill2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        selected_level: 0,
        selected_level_raw: [0; 2],
        skid: 0,
        skid_raw: [0; 2],
        target_id: 0,
        target_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzUseSkill2 {
    fn id(&self, packetver: u32) -> &str {
       PacketCzUseSkill2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzUseItem2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3904"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzUseItem2 {
        let mut offset: usize = 0;
        PacketCzUseItem2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzUseItem2 {
        let packet_id = i16::from_le_bytes([0x39, 0x04]);
        let packet_id_raw = [0x39, 0x04];
        PacketCzUseItem2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzUseItem2 {
    fn id(&self, packetver: u32) -> &str {
       PacketCzUseItem2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSkillPostdelay {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3d04"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSkillPostdelay {
        let mut offset: usize = 0;
        PacketZcSkillPostdelay {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            delay_tm: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            delay_tm_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.delay_tm).unwrap();
        self.delay_tm_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.delay_tm_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_delay_tm(&mut self, value: u32) {
        self.delay_tm = value;
    }
    pub fn set_delay_tm_raw(&mut self, value: [u8; 4]) {
        self.delay_tm_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSkillPostdelay {
        let packet_id = i16::from_le_bytes([0x3d, 0x04]);
        let packet_id_raw = [0x3d, 0x04];
        PacketZcSkillPostdelay {
        raw: vec![],
        packet_id,
        packet_id_raw,
        skid: 0,
        skid_raw: [0; 2],
        delay_tm: 0,
        delay_tm_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcSkillPostdelay {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSkillPostdelay::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSkillPostdelayList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3e04"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSkillPostdelayList {
        let mut offset: usize = 0;
        let vec_type_len = SkillPostdelay::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<SkillPostdelay> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(SkillPostdelay::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcSkillPostdelayList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            delay_list: {
                let field = vec_field.clone();
                field
            },
            delay_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.delay_list_raw = {
            self.delay_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.delay_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.delay_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_delay_list(&mut self, value: Vec<SkillPostdelay>) {
        self.delay_list = value;
    }
    pub fn set_delay_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.delay_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSkillPostdelayList {
        let packet_id = i16::from_le_bytes([0x3e, 0x04]);
        let packet_id_raw = [0x3e, 0x04];
        PacketZcSkillPostdelayList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        delay_list: vec![],
        delay_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcSkillPostdelayList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSkillPostdelayList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMsgStateChange2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3f04"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMsgStateChange2 {
        let mut offset: usize = 0;
        PacketZcMsgStateChange2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            state: {
                let field = buffer[offset] == 1;
                field
            },
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            remain_ms: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            remain_ms_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            val: {
                let field =  {
                let mut dst: [i32; 3] = [0_i32; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as i32;
                }
                dst
            };
                field
            },
            val_raw: {
                let mut dst: [u8; 12] = [0u8; 12];
                dst.clone_from_slice(&buffer[offset..offset + 12]);
                offset += 12;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state as u8).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.remain_ms).unwrap();
        self.remain_ms_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.val {
            wtr.write_i32::<LittleEndian>(item).unwrap();
        }
        self.val_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.remain_ms_raw.to_vec());
        wtr.append(&mut self.val_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 16;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_state(&mut self, value: bool) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_remain_ms(&mut self, value: u32) {
        self.remain_ms = value;
    }
    pub fn set_remain_ms_raw(&mut self, value: [u8; 4]) {
        self.remain_ms_raw = value;
    }
    pub fn set_val(&mut self, value: [i32; 3]) {
        self.val = value;
    }
    pub fn set_val_raw(&mut self, value: [u8; 12]) {
        self.val_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMsgStateChange2 {
        let packet_id = i16::from_le_bytes([0x3f, 0x04]);
        let packet_id_raw = [0x3f, 0x04];
        PacketZcMsgStateChange2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        state: false,
        state_raw: [0; 1],
        remain_ms: 0,
        remain_ms_raw: [0; 4],
        val: [0; 3],
        val_raw: [0; 12],
        }
    }
}

impl Packet for PacketZcMsgStateChange2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMsgStateChange2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMillenniumshield {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4004"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMillenniumshield {
        let mut offset: usize = 0;
        PacketZcMillenniumshield {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            num: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            num_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.num).unwrap();
        self.num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.num_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_num(&mut self, value: i16) {
        self.num = value;
    }
    pub fn set_num_raw(&mut self, value: [u8; 2]) {
        self.num_raw = value;
    }
    pub fn set_state(&mut self, value: i16) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 2]) {
        self.state_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMillenniumshield {
        let packet_id = i16::from_le_bytes([0x40, 0x04]);
        let packet_id_raw = [0x40, 0x04];
        PacketZcMillenniumshield {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        num: 0,
        num_raw: [0; 2],
        state: 0,
        state_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcMillenniumshield {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMillenniumshield::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSkillinfoDelete {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4104"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSkillinfoDelete {
        let mut offset: usize = 0;
        PacketZcSkillinfoDelete {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSkillinfoDelete {
        let packet_id = i16::from_le_bytes([0x41, 0x04]);
        let packet_id_raw = [0x41, 0x04];
        PacketZcSkillinfoDelete {
        raw: vec![],
        packet_id,
        packet_id_raw,
        skid: 0,
        skid_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcSkillinfoDelete {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSkillinfoDelete::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSkillSelectRequest {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4204"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSkillSelectRequest {
        let mut offset: usize = 0;
        PacketZcSkillSelectRequest {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            why: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            why_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            skidlist: {
                let field =  {
                let dst: Vec<u8> = buffer[offset..buffer.len()].to_vec();
                dst
            };
                field
            },
            skidlist_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.why).unwrap();
        self.why_raw = wtr.try_into().unwrap();


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.why_raw.to_vec());
        wtr.append(&mut self.skidlist_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_why(&mut self, value: i32) {
        self.why = value;
    }
    pub fn set_why_raw(&mut self, value: [u8; 4]) {
        self.why_raw = value;
    }
    pub fn set_skidlist(&mut self, value: Vec<u8>) {
        self.skidlist = value;
    }
    pub fn set_skidlist_raw(&mut self, value: Vec<u8>) {
        self.skidlist_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSkillSelectRequest {
        let packet_id = i16::from_le_bytes([0x42, 0x04]);
        let packet_id_raw = [0x42, 0x04];
        PacketZcSkillSelectRequest {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        why: 0,
        why_raw: [0; 4],
        skidlist: vec![],
        skidlist_raw: vec![],
        }
    }
}

impl Packet for PacketZcSkillSelectRequest {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSkillSelectRequest::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzSkillSelectResponse {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4304"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzSkillSelectResponse {
        let mut offset: usize = 0;
        PacketCzSkillSelectResponse {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            why: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            why_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.why).unwrap();
        self.why_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.why_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_why(&mut self, value: i32) {
        self.why = value;
    }
    pub fn set_why_raw(&mut self, value: [u8; 4]) {
        self.why_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzSkillSelectResponse {
        let packet_id = i16::from_le_bytes([0x43, 0x04]);
        let packet_id_raw = [0x43, 0x04];
        PacketCzSkillSelectResponse {
        raw: vec![],
        packet_id,
        packet_id_raw,
        why: 0,
        why_raw: [0; 4],
        skid: 0,
        skid_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzSkillSelectResponse {
    fn id(&self, packetver: u32) -> &str {
       PacketCzSkillSelectResponse::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSimpleCashPointItemlist {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4404"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSimpleCashPointItemlist {
        let mut offset: usize = 0;
        let vec_type_len = PurchaseItem::base_len(packetver);
        let iter_count = (&buffer.len() - 8) / vec_type_len;
        let mut vec_field: Vec<PurchaseItem> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (vec_type_len * (i - 1));
            let end_pos = 8 + vec_type_len * i;
            vec_field.push(PurchaseItem::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcSimpleCashPointItemlist {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            cash_point: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            cash_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            item_list: {
                let field = vec_field.clone();
                field
            },
            item_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.cash_point).unwrap();
        self.cash_point_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.cash_point_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_cash_point(&mut self, value: u32) {
        self.cash_point = value;
    }
    pub fn set_cash_point_raw(&mut self, value: [u8; 4]) {
        self.cash_point_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<PurchaseItem>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSimpleCashPointItemlist {
        let packet_id = i16::from_le_bytes([0x44, 0x04]);
        let packet_id_raw = [0x44, 0x04];
        PacketZcSimpleCashPointItemlist {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        cash_point: 0,
        cash_point_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcSimpleCashPointItemlist {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSimpleCashPointItemlist::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzSimpleBuyCashPointItem {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4504"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzSimpleBuyCashPointItem {
        let mut offset: usize = 0;
        PacketCzSimpleBuyCashPointItem {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzSimpleBuyCashPointItem {
        let packet_id = i16::from_le_bytes([0x45, 0x04]);
        let packet_id_raw = [0x45, 0x04];
        PacketCzSimpleBuyCashPointItem {
        raw: vec![],
        packet_id,
        packet_id_raw,
        itid: 0,
        itid_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzSimpleBuyCashPointItem {
    fn id(&self, packetver: u32) -> &str {
       PacketCzSimpleBuyCashPointItem::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcQuestNotifyEffect {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4604"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcQuestNotifyEffect {
        let mut offset: usize = 0;
        PacketZcQuestNotifyEffect {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            npc_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            npc_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            effect_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.npc_id).unwrap();
        self.npc_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.effect).unwrap();
        self.effect_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.npc_id_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.effect_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_npc_id(&mut self, value: u32) {
        self.npc_id = value;
    }
    pub fn set_npc_id_raw(&mut self, value: [u8; 4]) {
        self.npc_id_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_effect(&mut self, value: i16) {
        self.effect = value;
    }
    pub fn set_effect_raw(&mut self, value: [u8; 2]) {
        self.effect_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcQuestNotifyEffect {
        let packet_id = i16::from_le_bytes([0x46, 0x04]);
        let packet_id_raw = [0x46, 0x04];
        PacketZcQuestNotifyEffect {
        raw: vec![],
        packet_id,
        packet_id_raw,
        npc_id: 0,
        npc_id_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        effect: 0,
        effect_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcQuestNotifyEffect {
    fn id(&self, packetver: u32) -> &str {
       PacketZcQuestNotifyEffect::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcCharacterList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4804"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcCharacterList {
        let mut offset: usize = 0;
        let vec_type_len = CharacterList::base_len(packetver);
        let iter_count = (&buffer.len() - 4) / vec_type_len;
        let mut vec_field: Vec<CharacterList> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 4 + (vec_type_len * (i - 1));
            let end_pos = 4 + vec_type_len * i;
            vec_field.push(CharacterList::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketHcCharacterList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            character_list: {
                let field = vec_field.clone();
                field
            },
            character_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.character_list_raw = {
            self.character_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.character_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        self.character_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_character_list(&mut self, value: Vec<CharacterList>) {
        self.character_list = value;
    }
    pub fn set_character_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.character_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcCharacterList {
        let packet_id = i16::from_le_bytes([0x48, 0x04]);
        let packet_id_raw = [0x48, 0x04];
        PacketHcCharacterList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        character_list: vec![],
        character_list_raw: vec![],
        }
    }
}

impl Packet for PacketHcCharacterList {
    fn id(&self, packetver: u32) -> &str {
       PacketHcCharacterList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcHackshErrorMsg {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4904"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcHackshErrorMsg {
        let mut offset: usize = 0;
        PacketZcHackshErrorMsg {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            error_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.error_id).unwrap();
        self.error_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_id(&mut self, value: i16) {
        self.error_id = value;
    }
    pub fn set_error_id_raw(&mut self, value: [u8; 2]) {
        self.error_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcHackshErrorMsg {
        let packet_id = i16::from_le_bytes([0x49, 0x04]);
        let packet_id_raw = [0x49, 0x04];
        PacketZcHackshErrorMsg {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_id: 0,
        error_id_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcHackshErrorMsg {
    fn id(&self, packetver: u32) -> &str {
       PacketZcHackshErrorMsg::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzClientVersion {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4a04"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzClientVersion {
        let mut offset: usize = 0;
        PacketCzClientVersion {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            client_ver: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            client_ver_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.client_ver).unwrap();
        self.client_ver_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.client_ver_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_client_ver(&mut self, value: i32) {
        self.client_ver = value;
    }
    pub fn set_client_ver_raw(&mut self, value: [u8; 4]) {
        self.client_ver_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzClientVersion {
        let packet_id = i16::from_le_bytes([0x4a, 0x04]);
        let packet_id_raw = [0x4a, 0x04];
        PacketCzClientVersion {
        raw: vec![],
        packet_id,
        packet_id_raw,
        client_ver: 0,
        client_ver_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzClientVersion {
    fn id(&self, packetver: u32) -> &str {
       PacketCzClientVersion::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzCloseSimplecashShop {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4b04"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzCloseSimplecashShop {
        let mut offset: usize = 0;
        PacketCzCloseSimplecashShop {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzCloseSimplecashShop {
        let packet_id = i16::from_le_bytes([0x4b, 0x04]);
        let packet_id_raw = [0x4b, 0x04];
        PacketCzCloseSimplecashShop {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzCloseSimplecashShop {
    fn id(&self, packetver: u32) -> &str {
       PacketCzCloseSimplecashShop::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcEsResult {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd007"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcEsResult {
        let mut offset: usize = 0;
        PacketZcEsResult {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            es_no: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            es_no_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            es_msg: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            es_msg_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_no).unwrap();
        self.es_no_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_msg).unwrap();
        self.es_msg_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.es_no_raw.to_vec());
        wtr.append(&mut self.es_msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_es_no(&mut self, value: i16) {
        self.es_no = value;
    }
    pub fn set_es_no_raw(&mut self, value: [u8; 2]) {
        self.es_no_raw = value;
    }
    pub fn set_es_msg(&mut self, value: i16) {
        self.es_msg = value;
    }
    pub fn set_es_msg_raw(&mut self, value: [u8; 2]) {
        self.es_msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcEsResult {
        let packet_id = i16::from_le_bytes([0xd0, 0x07]);
        let packet_id_raw = [0xd0, 0x07];
        PacketZcEsResult {
        raw: vec![],
        packet_id,
        packet_id_raw,
        es_no: 0,
        es_no_raw: [0; 2],
        es_msg: 0,
        es_msg_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcEsResult {
    fn id(&self, packetver: u32) -> &str {
       PacketZcEsResult::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzEsGetList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd107"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzEsGetList {
        let mut offset: usize = 0;
        PacketCzEsGetList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzEsGetList {
        let packet_id = i16::from_le_bytes([0xd1, 0x07]);
        let packet_id_raw = [0xd1, 0x07];
        PacketCzEsGetList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzEsGetList {
    fn id(&self, packetver: u32) -> &str {
       PacketCzEsGetList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcEsList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd207"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcEsList {
        let mut offset: usize = 0;
        PacketZcEsList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcEsList {
        let packet_id = i16::from_le_bytes([0xd2, 0x07]);
        let packet_id_raw = [0xd2, 0x07];
        PacketZcEsList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcEsList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcEsList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzEsChoose {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd307"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzEsChoose {
        let mut offset: usize = 0;
        PacketCzEsChoose {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            es_no: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            es_no_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_no).unwrap();
        self.es_no_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.es_no_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_es_no(&mut self, value: i16) {
        self.es_no = value;
    }
    pub fn set_es_no_raw(&mut self, value: [u8; 2]) {
        self.es_no_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzEsChoose {
        let packet_id = i16::from_le_bytes([0xd3, 0x07]);
        let packet_id_raw = [0xd3, 0x07];
        PacketCzEsChoose {
        raw: vec![],
        packet_id,
        packet_id_raw,
        es_no: 0,
        es_no_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzEsChoose {
    fn id(&self, packetver: u32) -> &str {
       PacketCzEsChoose::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzEsCancel {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd407"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzEsCancel {
        let mut offset: usize = 0;
        PacketCzEsCancel {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            es_no: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            es_no_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_no).unwrap();
        self.es_no_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.es_no_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_es_no(&mut self, value: i16) {
        self.es_no = value;
    }
    pub fn set_es_no_raw(&mut self, value: [u8; 2]) {
        self.es_no_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzEsCancel {
        let packet_id = i16::from_le_bytes([0xd4, 0x07]);
        let packet_id_raw = [0xd4, 0x07];
        PacketCzEsCancel {
        raw: vec![],
        packet_id,
        packet_id_raw,
        es_no: 0,
        es_no_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzEsCancel {
    fn id(&self, packetver: u32) -> &str {
       PacketCzEsCancel::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcEsReady {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd507"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcEsReady {
        let mut offset: usize = 0;
        PacketZcEsReady {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            es_no: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            es_no_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_no).unwrap();
        self.es_no_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.es_no_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_es_no(&mut self, value: i16) {
        self.es_no = value;
    }
    pub fn set_es_no_raw(&mut self, value: [u8; 2]) {
        self.es_no_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcEsReady {
        let packet_id = i16::from_le_bytes([0xd5, 0x07]);
        let packet_id_raw = [0xd5, 0x07];
        PacketZcEsReady {
        raw: vec![],
        packet_id,
        packet_id_raw,
        es_no: 0,
        es_no_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcEsReady {
    fn id(&self, packetver: u32) -> &str {
       PacketZcEsReady::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcEsGoto {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd607"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcEsGoto {
        let mut offset: usize = 0;
        PacketZcEsGoto {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            es_no: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            es_no_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_no).unwrap();
        self.es_no_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.es_no_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_es_no(&mut self, value: i16) {
        self.es_no = value;
    }
    pub fn set_es_no_raw(&mut self, value: [u8; 2]) {
        self.es_no_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcEsGoto {
        let packet_id = i16::from_le_bytes([0xd6, 0x07]);
        let packet_id_raw = [0xd6, 0x07];
        PacketZcEsGoto {
        raw: vec![],
        packet_id,
        packet_id_raw,
        es_no: 0,
        es_no_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcEsGoto {
    fn id(&self, packetver: u32) -> &str {
       PacketZcEsGoto::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzGroupinfoChangeV2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd707"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzGroupinfoChangeV2 {
        let mut offset: usize = 0;
        PacketCzGroupinfoChangeV2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            exp_option: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            exp_option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            item_pickup_rule: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            item_pickup_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            item_division_rule: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            item_division_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.exp_option).unwrap();
        self.exp_option_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_pickup_rule).unwrap();
        self.item_pickup_rule_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_division_rule).unwrap();
        self.item_division_rule_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.exp_option_raw.to_vec());
        wtr.append(&mut self.item_pickup_rule_raw.to_vec());
        wtr.append(&mut self.item_division_rule_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_exp_option(&mut self, value: u32) {
        self.exp_option = value;
    }
    pub fn set_exp_option_raw(&mut self, value: [u8; 4]) {
        self.exp_option_raw = value;
    }
    pub fn set_item_pickup_rule(&mut self, value: u8) {
        self.item_pickup_rule = value;
    }
    pub fn set_item_pickup_rule_raw(&mut self, value: [u8; 1]) {
        self.item_pickup_rule_raw = value;
    }
    pub fn set_item_division_rule(&mut self, value: u8) {
        self.item_division_rule = value;
    }
    pub fn set_item_division_rule_raw(&mut self, value: [u8; 1]) {
        self.item_division_rule_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzGroupinfoChangeV2 {
        let packet_id = i16::from_le_bytes([0xd7, 0x07]);
        let packet_id_raw = [0xd7, 0x07];
        PacketCzGroupinfoChangeV2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        exp_option: 0,
        exp_option_raw: [0; 4],
        item_pickup_rule: 0,
        item_pickup_rule_raw: [0; 1],
        item_division_rule: 0,
        item_division_rule_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzGroupinfoChangeV2 {
    fn id(&self, packetver: u32) -> &str {
       PacketCzGroupinfoChangeV2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcReqGroupinfoChangeV2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd807"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcReqGroupinfoChangeV2 {
        let mut offset: usize = 0;
        PacketZcReqGroupinfoChangeV2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            exp_option: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            exp_option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            item_pickup_rule: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            item_pickup_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            item_division_rule: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            item_division_rule_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.exp_option).unwrap();
        self.exp_option_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_pickup_rule).unwrap();
        self.item_pickup_rule_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_division_rule).unwrap();
        self.item_division_rule_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.exp_option_raw.to_vec());
        wtr.append(&mut self.item_pickup_rule_raw.to_vec());
        wtr.append(&mut self.item_division_rule_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_exp_option(&mut self, value: u32) {
        self.exp_option = value;
    }
    pub fn set_exp_option_raw(&mut self, value: [u8; 4]) {
        self.exp_option_raw = value;
    }
    pub fn set_item_pickup_rule(&mut self, value: u8) {
        self.item_pickup_rule = value;
    }
    pub fn set_item_pickup_rule_raw(&mut self, value: [u8; 1]) {
        self.item_pickup_rule_raw = value;
    }
    pub fn set_item_division_rule(&mut self, value: u8) {
        self.item_division_rule = value;
    }
    pub fn set_item_division_rule_raw(&mut self, value: [u8; 1]) {
        self.item_division_rule_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcReqGroupinfoChangeV2 {
        let packet_id = i16::from_le_bytes([0xd8, 0x07]);
        let packet_id_raw = [0xd8, 0x07];
        PacketZcReqGroupinfoChangeV2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        exp_option: 0,
        exp_option_raw: [0; 4],
        item_pickup_rule: 0,
        item_pickup_rule_raw: [0; 1],
        item_division_rule: 0,
        item_division_rule_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcReqGroupinfoChangeV2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcReqGroupinfoChangeV2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcShortcutKeyListV2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xd907"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcShortcutKeyListV2 {
        let mut offset: usize = 0;
        let vec_type_len = ShortCutKey::base_len(packetver);
        let iter_count = (&buffer.len() - 2) / vec_type_len;
        let mut vec_field: Vec<ShortCutKey> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 2 + (vec_type_len * (i - 1));
            let end_pos = 2 + vec_type_len * i;
            vec_field.push(ShortCutKey::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcShortcutKeyListV2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            short_cut_key: {
                let field = vec_field.clone();
                field
            },
            short_cut_key_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.short_cut_key_raw = {
            self.short_cut_key.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.short_cut_key.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.short_cut_key.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_short_cut_key(&mut self, value: Vec<ShortCutKey>) {
        self.short_cut_key = value;
    }
    pub fn set_short_cut_key_raw(&mut self, value: Vec<Vec<u8>>) {
        self.short_cut_key_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcShortcutKeyListV2 {
        let packet_id = i16::from_le_bytes([0xd9, 0x07]);
        let packet_id_raw = [0xd9, 0x07];
        PacketZcShortcutKeyListV2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        short_cut_key: vec![],
        short_cut_key_raw: vec![],
        }
    }
}

impl Packet for PacketZcShortcutKeyListV2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcShortcutKeyListV2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzChangeGroupMaster {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xda07"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzChangeGroupMaster {
        let mut offset: usize = 0;
        PacketCzChangeGroupMaster {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzChangeGroupMaster {
        let packet_id = i16::from_le_bytes([0xda, 0x07]);
        let packet_id_raw = [0xda, 0x07];
        PacketCzChangeGroupMaster {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzChangeGroupMaster {
    fn id(&self, packetver: u32) -> &str {
       PacketCzChangeGroupMaster::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcHoParChange {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xdb07"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcHoParChange {
        let mut offset: usize = 0;
        PacketZcHoParChange {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            var: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            var_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            value: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var).unwrap();
        self.var_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.var_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_var(&mut self, value: u16) {
        self.var = value;
    }
    pub fn set_var_raw(&mut self, value: [u8; 2]) {
        self.var_raw = value;
    }
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcHoParChange {
        let packet_id = i16::from_le_bytes([0xdb, 0x07]);
        let packet_id_raw = [0xdb, 0x07];
        PacketZcHoParChange {
        raw: vec![],
        packet_id,
        packet_id_raw,
        var: 0,
        var_raw: [0; 2],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcHoParChange {
    fn id(&self, packetver: u32) -> &str {
       PacketZcHoParChange::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzSeekParty {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xdc07"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzSeekParty {
        let mut offset: usize = 0;
        PacketCzSeekParty {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            option: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.option).unwrap();
        self.option_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.option_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_option(&mut self, value: u32) {
        self.option = value;
    }
    pub fn set_option_raw(&mut self, value: [u8; 4]) {
        self.option_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzSeekParty {
        let packet_id = i16::from_le_bytes([0xdc, 0x07]);
        let packet_id_raw = [0xdc, 0x07];
        PacketCzSeekParty {
        raw: vec![],
        packet_id,
        packet_id_raw,
        option: 0,
        option_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzSeekParty {
    fn id(&self, packetver: u32) -> &str {
       PacketCzSeekParty::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSeekParty {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xdd07"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSeekParty {
        let mut offset: usize = 0;
        PacketZcSeekParty {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            job: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            level: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            map_name: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            option: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.option).unwrap();
        self.option_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.option_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 54;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_job(&mut self, value: u32) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 4]) {
        self.job_raw = value;
    }
    pub fn set_level(&mut self, value: u32) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 4]) {
        self.level_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_option(&mut self, value: u32) {
        self.option = value;
    }
    pub fn set_option_raw(&mut self, value: [u8; 4]) {
        self.option_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSeekParty {
        let packet_id = i16::from_le_bytes([0xdd, 0x07]);
        let packet_id_raw = [0xdd, 0x07];
        PacketZcSeekParty {
        raw: vec![],
        packet_id,
        packet_id_raw,
        name: [0 as char; 24],
        name_raw: [0; 24],
        job: 0,
        job_raw: [0; 4],
        level: 0,
        level_raw: [0; 4],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        option: 0,
        option_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcSeekParty {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSeekParty::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzSeekPartyMember {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xde07"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzSeekPartyMember {
        let mut offset: usize = 0;
        PacketCzSeekPartyMember {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            level: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            map_name: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            option: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.option).unwrap();
        self.option_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.option_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 30;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_job(&mut self, value: u32) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 4]) {
        self.job_raw = value;
    }
    pub fn set_level(&mut self, value: u32) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 4]) {
        self.level_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_option(&mut self, value: u32) {
        self.option = value;
    }
    pub fn set_option_raw(&mut self, value: [u8; 4]) {
        self.option_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzSeekPartyMember {
        let packet_id = i16::from_le_bytes([0xde, 0x07]);
        let packet_id_raw = [0xde, 0x07];
        PacketCzSeekPartyMember {
        raw: vec![],
        packet_id,
        packet_id_raw,
        job: 0,
        job_raw: [0; 4],
        level: 0,
        level_raw: [0; 4],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        option: 0,
        option_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzSeekPartyMember {
    fn id(&self, packetver: u32) -> &str {
       PacketCzSeekPartyMember::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSeekPartyMember {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xdf07"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSeekPartyMember {
        let mut offset: usize = 0;
        PacketZcSeekPartyMember {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            job: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            level: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            map_name: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            option: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            option_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.option).unwrap();
        self.option_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.option_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 54;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_job(&mut self, value: u32) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 4]) {
        self.job_raw = value;
    }
    pub fn set_level(&mut self, value: u32) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 4]) {
        self.level_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_option(&mut self, value: u32) {
        self.option = value;
    }
    pub fn set_option_raw(&mut self, value: [u8; 4]) {
        self.option_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSeekPartyMember {
        let packet_id = i16::from_le_bytes([0xdf, 0x07]);
        let packet_id_raw = [0xdf, 0x07];
        PacketZcSeekPartyMember {
        raw: vec![],
        packet_id,
        packet_id_raw,
        name: [0 as char; 24],
        name_raw: [0; 24],
        job: 0,
        job_raw: [0; 4],
        level: 0,
        level_raw: [0; 4],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        option: 0,
        option_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcSeekPartyMember {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSeekPartyMember::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcEsNotiMyinfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe007"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcEsNotiMyinfo {
        let mut offset: usize = 0;
        PacketZcEsNotiMyinfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            es_no: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            es_no_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            esname: {
                let field =  {
                let mut dst: [char; 54] = [0 as char; 54];
                for (index, byte) in buffer[offset..offset + 54].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            esname_raw: {
                let mut dst: [u8; 54] = [0u8; 54];
                dst.clone_from_slice(&buffer[offset..offset + 54]);
                offset += 54;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.es_no).unwrap();
        self.es_no_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.esname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.esname_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.es_no_raw.to_vec());
        wtr.append(&mut self.esname_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 58;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_es_no(&mut self, value: i16) {
        self.es_no = value;
    }
    pub fn set_es_no_raw(&mut self, value: [u8; 2]) {
        self.es_no_raw = value;
    }
    pub fn set_esname(&mut self, value: [char; 54]) {
        self.esname = value;
    }
    pub fn set_esname_raw(&mut self, value: [u8; 54]) {
        self.esname_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcEsNotiMyinfo {
        let packet_id = i16::from_le_bytes([0xe0, 0x07]);
        let packet_id_raw = [0xe0, 0x07];
        PacketZcEsNotiMyinfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        es_no: 0,
        es_no_raw: [0; 2],
        esname: [0 as char; 54],
        esname_raw: [0; 54],
        }
    }
}

impl Packet for PacketZcEsNotiMyinfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcEsNotiMyinfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSkillinfoUpdate2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe107"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSkillinfoUpdate2 {
        let mut offset: usize = 0;
        PacketZcSkillinfoUpdate2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            spcost: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            spcost_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            attack_range: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            attack_range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            upgradable: {
                let field = buffer[offset] == 1;
                field
            },
            upgradable_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.spcost).unwrap();
        self.spcost_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.attack_range).unwrap();
        self.attack_range_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.upgradable as u8).unwrap();
        self.upgradable_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.spcost_raw.to_vec());
        wtr.append(&mut self.attack_range_raw.to_vec());
        wtr.append(&mut self.upgradable_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 15;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_spcost(&mut self, value: i16) {
        self.spcost = value;
    }
    pub fn set_spcost_raw(&mut self, value: [u8; 2]) {
        self.spcost_raw = value;
    }
    pub fn set_attack_range(&mut self, value: i16) {
        self.attack_range = value;
    }
    pub fn set_attack_range_raw(&mut self, value: [u8; 2]) {
        self.attack_range_raw = value;
    }
    pub fn set_upgradable(&mut self, value: bool) {
        self.upgradable = value;
    }
    pub fn set_upgradable_raw(&mut self, value: [u8; 1]) {
        self.upgradable_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSkillinfoUpdate2 {
        let packet_id = i16::from_le_bytes([0xe1, 0x07]);
        let packet_id_raw = [0xe1, 0x07];
        PacketZcSkillinfoUpdate2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        skid: 0,
        skid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 4],
        level: 0,
        level_raw: [0; 2],
        spcost: 0,
        spcost_raw: [0; 2],
        attack_range: 0,
        attack_range_raw: [0; 2],
        upgradable: false,
        upgradable_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcSkillinfoUpdate2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSkillinfoUpdate2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMsgValue {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe207"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMsgValue {
        let mut offset: usize = 0;
        PacketZcMsgValue {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msg: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            msg_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            value: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.msg).unwrap();
        self.msg_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_msg(&mut self, value: u16) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: [u8; 2]) {
        self.msg_raw = value;
    }
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMsgValue {
        let packet_id = i16::from_le_bytes([0xe2, 0x07]);
        let packet_id_raw = [0xe2, 0x07];
        PacketZcMsgValue {
        raw: vec![],
        packet_id,
        packet_id_raw,
        msg: 0,
        msg_raw: [0; 2],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcMsgValue {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMsgValue::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcItemlistwinOpen {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe307"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcItemlistwinOpen {
        let mut offset: usize = 0;
        PacketZcItemlistwinOpen {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcItemlistwinOpen {
        let packet_id = i16::from_le_bytes([0xe3, 0x07]);
        let packet_id_raw = [0xe3, 0x07];
        PacketZcItemlistwinOpen {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcItemlistwinOpen {
    fn id(&self, packetver: u32) -> &str {
       PacketZcItemlistwinOpen::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzItemlistwinRes {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe407"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzItemlistwinRes {
        let mut offset: usize = 0;
        PacketCzItemlistwinRes {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            action: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            action_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            material_list: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            material_list_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.material_list).unwrap();
        self.material_list_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        wtr.append(&mut self.material_list_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn set_action(&mut self, value: i32) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 4]) {
        self.action_raw = value;
    }
    pub fn set_material_list(&mut self, value: u16) {
        self.material_list = value;
    }
    pub fn set_material_list_raw(&mut self, value: [u8; 2]) {
        self.material_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzItemlistwinRes {
        let packet_id = i16::from_le_bytes([0xe4, 0x07]);
        let packet_id_raw = [0xe4, 0x07];
        PacketCzItemlistwinRes {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 4],
        action: 0,
        action_raw: [0; 4],
        material_list: 0,
        material_list_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzItemlistwinRes {
    fn id(&self, packetver: u32) -> &str {
       PacketCzItemlistwinRes::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketChEnterCheckbot {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe507"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketChEnterCheckbot {
        let mut offset: usize = 0;
        PacketChEnterCheckbot {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            dw_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dw_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            sz_string_info: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            sz_string_info_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_aid).unwrap();
        self.dw_aid_raw = wtr.try_into().unwrap();
        self.sz_string_info_raw = self.sz_string_info.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.dw_aid_raw.to_vec());
        wtr.append(&mut self.sz_string_info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_dw_aid(&mut self, value: u32) {
        self.dw_aid = value;
    }
    pub fn set_dw_aid_raw(&mut self, value: [u8; 4]) {
        self.dw_aid_raw = value;
    }
    pub fn set_sz_string_info(&mut self, value: String) {
        self.sz_string_info = value;
    }
    pub fn set_sz_string_info_raw(&mut self, value: Vec<u8>) {
        self.sz_string_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketChEnterCheckbot {
        let packet_id = i16::from_le_bytes([0xe5, 0x07]);
        let packet_id_raw = [0xe5, 0x07];
        PacketChEnterCheckbot {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        dw_aid: 0,
        dw_aid_raw: [0; 4],
        sz_string_info: String::new(),
        sz_string_info_raw: vec![],
        }
    }
}

impl Packet for PacketChEnterCheckbot {
    fn id(&self, packetver: u32) -> &str {
       PacketChEnterCheckbot::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMsgSkill {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe607"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMsgSkill {
        let mut offset: usize = 0;
        PacketZcMsgSkill {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msgid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            msgid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.msgid).unwrap();
        self.msgid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.msgid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_msgid(&mut self, value: i32) {
        self.msgid = value;
    }
    pub fn set_msgid_raw(&mut self, value: [u8; 4]) {
        self.msgid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMsgSkill {
        let packet_id = i16::from_le_bytes([0xe6, 0x07]);
        let packet_id_raw = [0xe6, 0x07];
        PacketZcMsgSkill {
        raw: vec![],
        packet_id,
        packet_id_raw,
        skid: 0,
        skid_raw: [0; 2],
        msgid: 0,
        msgid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcMsgSkill {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMsgSkill::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketChCheckbot {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe707"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketChCheckbot {
        let mut offset: usize = 0;
        PacketChCheckbot {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            dw_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dw_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            sz_string_info: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            sz_string_info_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_aid).unwrap();
        self.dw_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_string_info {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_string_info_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.dw_aid_raw.to_vec());
        wtr.append(&mut self.sz_string_info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 32;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_dw_aid(&mut self, value: u32) {
        self.dw_aid = value;
    }
    pub fn set_dw_aid_raw(&mut self, value: [u8; 4]) {
        self.dw_aid_raw = value;
    }
    pub fn set_sz_string_info(&mut self, value: [char; 24]) {
        self.sz_string_info = value;
    }
    pub fn set_sz_string_info_raw(&mut self, value: [u8; 24]) {
        self.sz_string_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketChCheckbot {
        let packet_id = i16::from_le_bytes([0xe7, 0x07]);
        let packet_id_raw = [0xe7, 0x07];
        PacketChCheckbot {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        dw_aid: 0,
        dw_aid_raw: [0; 4],
        sz_string_info: [0 as char; 24],
        sz_string_info_raw: [0; 24],
        }
    }
}

impl Packet for PacketChCheckbot {
    fn id(&self, packetver: u32) -> &str {
       PacketChCheckbot::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcCheckbot {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe807"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcCheckbot {
        let mut offset: usize = 0;
        PacketHcCheckbot {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            img: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            img_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        self.img_raw = self.img.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.img_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_img(&mut self, value: String) {
        self.img = value;
    }
    pub fn set_img_raw(&mut self, value: Vec<u8>) {
        self.img_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcCheckbot {
        let packet_id = i16::from_le_bytes([0xe8, 0x07]);
        let packet_id_raw = [0xe8, 0x07];
        PacketHcCheckbot {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        img: String::new(),
        img_raw: vec![],
        }
    }
}

impl Packet for PacketHcCheckbot {
    fn id(&self, packetver: u32) -> &str {
       PacketHcCheckbot::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcCheckbotResult {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xe907"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcCheckbotResult {
        let mut offset: usize = 0;
        PacketHcCheckbotResult {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcCheckbotResult {
        let packet_id = i16::from_le_bytes([0xe9, 0x07]);
        let packet_id_raw = [0xe9, 0x07];
        PacketHcCheckbotResult {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        result: 0,
        result_raw: [0; 1],
        }
    }
}

impl Packet for PacketHcCheckbotResult {
    fn id(&self, packetver: u32) -> &str {
       PacketHcCheckbotResult::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzBattleFieldList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xea07"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzBattleFieldList {
        let mut offset: usize = 0;
        PacketCzBattleFieldList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzBattleFieldList {
        let packet_id = i16::from_le_bytes([0xea, 0x07]);
        let packet_id_raw = [0xea, 0x07];
        PacketCzBattleFieldList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzBattleFieldList {
    fn id(&self, packetver: u32) -> &str {
       PacketCzBattleFieldList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcBattleFieldList {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xeb07"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcBattleFieldList {
        let mut offset: usize = 0;
        let vec_type_len = BattleFieldInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 8) / vec_type_len;
        let mut vec_field: Vec<BattleFieldInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 8 + (vec_type_len * (i - 1));
            let end_pos = 8 + vec_type_len * i;
            vec_field.push(BattleFieldInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcBattleFieldList {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            ack_type: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            ack_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            info_list: {
                let field = vec_field.clone();
                field
            },
            info_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.ack_type).unwrap();
        self.ack_type_raw = wtr.try_into().unwrap();
        self.info_list_raw = {
            self.info_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.info_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.ack_type_raw.to_vec());
        self.info_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_ack_type(&mut self, value: i16) {
        self.ack_type = value;
    }
    pub fn set_ack_type_raw(&mut self, value: [u8; 2]) {
        self.ack_type_raw = value;
    }
    pub fn set_info_list(&mut self, value: Vec<BattleFieldInfo>) {
        self.info_list = value;
    }
    pub fn set_info_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.info_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcBattleFieldList {
        let packet_id = i16::from_le_bytes([0xeb, 0x07]);
        let packet_id_raw = [0xeb, 0x07];
        PacketZcBattleFieldList {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        ack_type: 0,
        ack_type_raw: [0; 2],
        info_list: vec![],
        info_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcBattleFieldList {
    fn id(&self, packetver: u32) -> &str {
       PacketZcBattleFieldList::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzJoinBattleField {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xec07"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzJoinBattleField {
        let mut offset: usize = 0;
        PacketCzJoinBattleField {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bfno: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            join_team: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            join_team_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.join_team).unwrap();
        self.join_team_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.bfno_raw.to_vec());
        wtr.append(&mut self.join_team_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_bfno(&mut self, value: u32) {
        self.bfno = value;
    }
    pub fn set_bfno_raw(&mut self, value: [u8; 4]) {
        self.bfno_raw = value;
    }
    pub fn set_join_team(&mut self, value: i16) {
        self.join_team = value;
    }
    pub fn set_join_team_raw(&mut self, value: [u8; 2]) {
        self.join_team_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzJoinBattleField {
        let packet_id = i16::from_le_bytes([0xec, 0x07]);
        let packet_id_raw = [0xec, 0x07];
        PacketCzJoinBattleField {
        raw: vec![],
        packet_id,
        packet_id_raw,
        bfno: 0,
        bfno_raw: [0; 4],
        join_team: 0,
        join_team_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzJoinBattleField {
    fn id(&self, packetver: u32) -> &str {
       PacketCzJoinBattleField::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcJoinBattleField {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xed07"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcJoinBattleField {
        let mut offset: usize = 0;
        PacketZcJoinBattleField {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bfno: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            join_team: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            join_team_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.join_team).unwrap();
        self.join_team_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.bfno_raw.to_vec());
        wtr.append(&mut self.join_team_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_bfno(&mut self, value: u32) {
        self.bfno = value;
    }
    pub fn set_bfno_raw(&mut self, value: [u8; 4]) {
        self.bfno_raw = value;
    }
    pub fn set_join_team(&mut self, value: i16) {
        self.join_team = value;
    }
    pub fn set_join_team_raw(&mut self, value: [u8; 2]) {
        self.join_team_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcJoinBattleField {
        let packet_id = i16::from_le_bytes([0xed, 0x07]);
        let packet_id_raw = [0xed, 0x07];
        PacketZcJoinBattleField {
        raw: vec![],
        packet_id,
        packet_id_raw,
        bfno: 0,
        bfno_raw: [0; 4],
        join_team: 0,
        join_team_raw: [0; 2],
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcJoinBattleField {
    fn id(&self, packetver: u32) -> &str {
       PacketZcJoinBattleField::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzCancelBattleField {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xee07"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzCancelBattleField {
        let mut offset: usize = 0;
        PacketCzCancelBattleField {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bfno: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.bfno_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_bfno(&mut self, value: u32) {
        self.bfno = value;
    }
    pub fn set_bfno_raw(&mut self, value: [u8; 4]) {
        self.bfno_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzCancelBattleField {
        let packet_id = i16::from_le_bytes([0xee, 0x07]);
        let packet_id_raw = [0xee, 0x07];
        PacketCzCancelBattleField {
        raw: vec![],
        packet_id,
        packet_id_raw,
        bfno: 0,
        bfno_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzCancelBattleField {
    fn id(&self, packetver: u32) -> &str {
       PacketCzCancelBattleField::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcCancelBattleField {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xef07"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcCancelBattleField {
        let mut offset: usize = 0;
        PacketZcCancelBattleField {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bfno: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.bfno_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_bfno(&mut self, value: u32) {
        self.bfno = value;
    }
    pub fn set_bfno_raw(&mut self, value: [u8; 4]) {
        self.bfno_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcCancelBattleField {
        let packet_id = i16::from_le_bytes([0xef, 0x07]);
        let packet_id_raw = [0xef, 0x07];
        PacketZcCancelBattleField {
        raw: vec![],
        packet_id,
        packet_id_raw,
        bfno: 0,
        bfno_raw: [0; 4],
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcCancelBattleField {
    fn id(&self, packetver: u32) -> &str {
       PacketZcCancelBattleField::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqBattleStateMonitor {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf007"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqBattleStateMonitor {
        let mut offset: usize = 0;
        PacketCzReqBattleStateMonitor {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bfno: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            power_switch: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            power_switch_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.power_switch).unwrap();
        self.power_switch_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.bfno_raw.to_vec());
        wtr.append(&mut self.power_switch_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_bfno(&mut self, value: u32) {
        self.bfno = value;
    }
    pub fn set_bfno_raw(&mut self, value: [u8; 4]) {
        self.bfno_raw = value;
    }
    pub fn set_power_switch(&mut self, value: i16) {
        self.power_switch = value;
    }
    pub fn set_power_switch_raw(&mut self, value: [u8; 2]) {
        self.power_switch_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqBattleStateMonitor {
        let packet_id = i16::from_le_bytes([0xf0, 0x07]);
        let packet_id_raw = [0xf0, 0x07];
        PacketCzReqBattleStateMonitor {
        raw: vec![],
        packet_id,
        packet_id_raw,
        bfno: 0,
        bfno_raw: [0; 4],
        power_switch: 0,
        power_switch_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqBattleStateMonitor {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqBattleStateMonitor::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckBattleStateMonitor {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf107"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckBattleStateMonitor {
        let mut offset: usize = 0;
        PacketZcAckBattleStateMonitor {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bfno: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            play_count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            play_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            battle_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            battle_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            team_count_a: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            team_count_a_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            team_count_b: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            team_count_b_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            my_count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            my_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            join_team: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            join_team_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.play_count).unwrap();
        self.play_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.battle_state).unwrap();
        self.battle_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.team_count_a).unwrap();
        self.team_count_a_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.team_count_b).unwrap();
        self.team_count_b_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.my_count).unwrap();
        self.my_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.join_team).unwrap();
        self.join_team_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.bfno_raw.to_vec());
        wtr.append(&mut self.play_count_raw.to_vec());
        wtr.append(&mut self.battle_state_raw.to_vec());
        wtr.append(&mut self.team_count_a_raw.to_vec());
        wtr.append(&mut self.team_count_b_raw.to_vec());
        wtr.append(&mut self.my_count_raw.to_vec());
        wtr.append(&mut self.join_team_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 18;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_bfno(&mut self, value: u32) {
        self.bfno = value;
    }
    pub fn set_bfno_raw(&mut self, value: [u8; 4]) {
        self.bfno_raw = value;
    }
    pub fn set_play_count(&mut self, value: i16) {
        self.play_count = value;
    }
    pub fn set_play_count_raw(&mut self, value: [u8; 2]) {
        self.play_count_raw = value;
    }
    pub fn set_battle_state(&mut self, value: i16) {
        self.battle_state = value;
    }
    pub fn set_battle_state_raw(&mut self, value: [u8; 2]) {
        self.battle_state_raw = value;
    }
    pub fn set_team_count_a(&mut self, value: i16) {
        self.team_count_a = value;
    }
    pub fn set_team_count_a_raw(&mut self, value: [u8; 2]) {
        self.team_count_a_raw = value;
    }
    pub fn set_team_count_b(&mut self, value: i16) {
        self.team_count_b = value;
    }
    pub fn set_team_count_b_raw(&mut self, value: [u8; 2]) {
        self.team_count_b_raw = value;
    }
    pub fn set_my_count(&mut self, value: i16) {
        self.my_count = value;
    }
    pub fn set_my_count_raw(&mut self, value: [u8; 2]) {
        self.my_count_raw = value;
    }
    pub fn set_join_team(&mut self, value: i16) {
        self.join_team = value;
    }
    pub fn set_join_team_raw(&mut self, value: [u8; 2]) {
        self.join_team_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckBattleStateMonitor {
        let packet_id = i16::from_le_bytes([0xf1, 0x07]);
        let packet_id_raw = [0xf1, 0x07];
        PacketZcAckBattleStateMonitor {
        raw: vec![],
        packet_id,
        packet_id_raw,
        bfno: 0,
        bfno_raw: [0; 4],
        play_count: 0,
        play_count_raw: [0; 2],
        battle_state: 0,
        battle_state_raw: [0; 2],
        team_count_a: 0,
        team_count_a_raw: [0; 2],
        team_count_b: 0,
        team_count_b_raw: [0; 2],
        my_count: 0,
        my_count_raw: [0; 2],
        join_team: 0,
        join_team_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcAckBattleStateMonitor {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckBattleStateMonitor::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcBattleNotiStartStep {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf207"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcBattleNotiStartStep {
        let mut offset: usize = 0;
        PacketZcBattleNotiStartStep {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bfno: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.bfno_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_bfno(&mut self, value: u32) {
        self.bfno = value;
    }
    pub fn set_bfno_raw(&mut self, value: [u8; 4]) {
        self.bfno_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcBattleNotiStartStep {
        let packet_id = i16::from_le_bytes([0xf2, 0x07]);
        let packet_id_raw = [0xf2, 0x07];
        PacketZcBattleNotiStartStep {
        raw: vec![],
        packet_id,
        packet_id_raw,
        bfno: 0,
        bfno_raw: [0; 4],
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcBattleNotiStartStep {
    fn id(&self, packetver: u32) -> &str {
       PacketZcBattleNotiStartStep::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcBattleJoinNotiDefer {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf307"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcBattleJoinNotiDefer {
        let mut offset: usize = 0;
        PacketZcBattleJoinNotiDefer {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bfno: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.bfno_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_bfno(&mut self, value: u32) {
        self.bfno = value;
    }
    pub fn set_bfno_raw(&mut self, value: [u8; 4]) {
        self.bfno_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcBattleJoinNotiDefer {
        let packet_id = i16::from_le_bytes([0xf3, 0x07]);
        let packet_id_raw = [0xf3, 0x07];
        PacketZcBattleJoinNotiDefer {
        raw: vec![],
        packet_id,
        packet_id_raw,
        bfno: 0,
        bfno_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcBattleJoinNotiDefer {
    fn id(&self, packetver: u32) -> &str {
       PacketZcBattleJoinNotiDefer::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcBattleJoinDisableState {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf407"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcBattleJoinDisableState {
        let mut offset: usize = 0;
        PacketZcBattleJoinDisableState {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            enable: {
                let field = buffer[offset] == 1;
                field
            },
            enable_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.enable as u8).unwrap();
        self.enable_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.enable_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_enable(&mut self, value: bool) {
        self.enable = value;
    }
    pub fn set_enable_raw(&mut self, value: [u8; 1]) {
        self.enable_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcBattleJoinDisableState {
        let packet_id = i16::from_le_bytes([0xf4, 0x07]);
        let packet_id_raw = [0xf4, 0x07];
        PacketZcBattleJoinDisableState {
        raw: vec![],
        packet_id,
        packet_id_raw,
        enable: false,
        enable_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcBattleJoinDisableState {
    fn id(&self, packetver: u32) -> &str {
       PacketZcBattleJoinDisableState::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzGmFullstrip {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf507"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzGmFullstrip {
        let mut offset: usize = 0;
        PacketCzGmFullstrip {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            target_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            target_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_aid).unwrap();
        self.target_aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.target_aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_target_aid(&mut self, value: u32) {
        self.target_aid = value;
    }
    pub fn set_target_aid_raw(&mut self, value: [u8; 4]) {
        self.target_aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzGmFullstrip {
        let packet_id = i16::from_le_bytes([0xf5, 0x07]);
        let packet_id_raw = [0xf5, 0x07];
        PacketCzGmFullstrip {
        raw: vec![],
        packet_id,
        packet_id_raw,
        target_aid: 0,
        target_aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzGmFullstrip {
    fn id(&self, packetver: u32) -> &str {
       PacketCzGmFullstrip::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyExp {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf607"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyExp {
        let mut offset: usize = 0;
        PacketZcNotifyExp {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            amount: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            amount_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            var_id: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            var_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            exp_type: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            exp_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.amount).unwrap();
        self.amount_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var_id).unwrap();
        self.var_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.exp_type).unwrap();
        self.exp_type_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.amount_raw.to_vec());
        wtr.append(&mut self.var_id_raw.to_vec());
        wtr.append(&mut self.exp_type_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_amount(&mut self, value: i32) {
        self.amount = value;
    }
    pub fn set_amount_raw(&mut self, value: [u8; 4]) {
        self.amount_raw = value;
    }
    pub fn set_var_id(&mut self, value: u16) {
        self.var_id = value;
    }
    pub fn set_var_id_raw(&mut self, value: [u8; 2]) {
        self.var_id_raw = value;
    }
    pub fn set_exp_type(&mut self, value: i16) {
        self.exp_type = value;
    }
    pub fn set_exp_type_raw(&mut self, value: [u8; 2]) {
        self.exp_type_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyExp {
        let packet_id = i16::from_le_bytes([0xf6, 0x07]);
        let packet_id_raw = [0xf6, 0x07];
        PacketZcNotifyExp {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        amount: 0,
        amount_raw: [0; 4],
        var_id: 0,
        var_id_raw: [0; 2],
        exp_type: 0,
        exp_type_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyExp {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyExp::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyMoveentry7 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf707"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyMoveentry7 {
        let mut offset: usize = 0;
        PacketZcNotifyMoveentry7 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            objecttype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            move_start_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory2: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gemblem_ver: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            honor: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            virtue: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            move_data: {
                let field =  {
                let mut dst: [u16; 6] = [0_u16; 6];
                for (index, byte) in buffer[offset..offset + 6].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            };
                field
            },
            move_data_raw: {
                let mut dst: [u8; 12] = [0u8; 12];
                dst.clone_from_slice(&buffer[offset..offset + 12]);
                offset += 12;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            clevel: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            font: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.move_data {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.move_data_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.objecttype_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.move_start_time_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.move_data_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        wtr.append(&mut self.font_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 93;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_objecttype(&mut self, value: u8) {
        self.objecttype = value;
    }
    pub fn set_objecttype_raw(&mut self, value: [u8; 1]) {
        self.objecttype_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_move_start_time(&mut self, value: u32) {
        self.move_start_time = value;
    }
    pub fn set_move_start_time_raw(&mut self, value: [u8; 4]) {
        self.move_start_time_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_move_data(&mut self, value: [u16; 6]) {
        self.move_data = value;
    }
    pub fn set_move_data_raw(&mut self, value: [u8; 12]) {
        self.move_data_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn set_font(&mut self, value: i16) {
        self.font = value;
    }
    pub fn set_font_raw(&mut self, value: [u8; 2]) {
        self.font_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyMoveentry7 {
        let packet_id = i16::from_le_bytes([0xf7, 0x07]);
        let packet_id_raw = [0xf7, 0x07];
        PacketZcNotifyMoveentry7 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        objecttype: 0,
        objecttype_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        move_start_time: 0,
        move_start_time_raw: [0; 4],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        move_data: [0; 6],
        move_data_raw: [0; 12],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        font: 0,
        font_raw: [0; 2],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcNotifyMoveentry7 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyMoveentry7::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyNewentry5 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf807"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyNewentry5 {
        let mut offset: usize = 0;
        PacketZcNotifyNewentry5 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            objecttype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory2: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gemblem_ver: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            honor: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            virtue: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            pos_dir: {
                let field =  {
                let mut dst: [u8; 3] = [0_u8; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[offset..offset + 3]);
                offset += 3;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            clevel: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            font: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.objecttype_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        wtr.append(&mut self.font_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 86;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_objecttype(&mut self, value: u8) {
        self.objecttype = value;
    }
    pub fn set_objecttype_raw(&mut self, value: [u8; 1]) {
        self.objecttype_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [u8; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn set_font(&mut self, value: i16) {
        self.font = value;
    }
    pub fn set_font_raw(&mut self, value: [u8; 2]) {
        self.font_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyNewentry5 {
        let packet_id = i16::from_le_bytes([0xf8, 0x07]);
        let packet_id_raw = [0xf8, 0x07];
        PacketZcNotifyNewentry5 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        objecttype: 0,
        objecttype_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        font: 0,
        font_raw: [0; 2],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcNotifyNewentry5 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyNewentry5::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyStandentry5 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xf907"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyStandentry5 {
        let mut offset: usize = 0;
        PacketZcNotifyStandentry5 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            objecttype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory2: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gemblem_ver: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            honor: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            virtue: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            pos_dir: {
                let field =  {
                let mut dst: [u8; 3] = [0_u8; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[offset..offset + 3]);
                offset += 3;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            state: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            clevel: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            font: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.objecttype_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        wtr.append(&mut self.font_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 87;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_objecttype(&mut self, value: u8) {
        self.objecttype = value;
    }
    pub fn set_objecttype_raw(&mut self, value: [u8; 1]) {
        self.objecttype_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: i32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: i16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_accessory2(&mut self, value: i16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: i16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: i16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: i16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: i16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [u8; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_state(&mut self, value: u8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn set_font(&mut self, value: i16) {
        self.font = value;
    }
    pub fn set_font_raw(&mut self, value: [u8; 2]) {
        self.font_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyStandentry5 {
        let packet_id = i16::from_le_bytes([0xf9, 0x07]);
        let packet_id_raw = [0xf9, 0x07];
        PacketZcNotifyStandentry5 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        objecttype: 0,
        objecttype_raw: [0; 1],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        state: 0,
        state_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        font: 0,
        font_raw: [0; 2],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcNotifyStandentry5 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyStandentry5::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcDeleteItemFromBody {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xfa07"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcDeleteItemFromBody {
        let mut offset: usize = 0;
        PacketZcDeleteItemFromBody {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            delete_type: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            delete_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.delete_type).unwrap();
        self.delete_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.delete_type_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_delete_type(&mut self, value: i16) {
        self.delete_type = value;
    }
    pub fn set_delete_type_raw(&mut self, value: [u8; 2]) {
        self.delete_type_raw = value;
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcDeleteItemFromBody {
        let packet_id = i16::from_le_bytes([0xfa, 0x07]);
        let packet_id_raw = [0xfa, 0x07];
        PacketZcDeleteItemFromBody {
        raw: vec![],
        packet_id,
        packet_id_raw,
        delete_type: 0,
        delete_type_raw: [0; 2],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcDeleteItemFromBody {
    fn id(&self, packetver: u32) -> &str {
       PacketZcDeleteItemFromBody::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcUseskillAck2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xfb07"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcUseskillAck2 {
        let mut offset: usize = 0;
        PacketZcUseskillAck2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            target_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            target_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            x_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y_pos: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_pos_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            property: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            property_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            delay_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            delay_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_disposable: {
                let field = buffer[offset] == 1;
                field
            },
            is_disposable_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_id).unwrap();
        self.target_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x_pos).unwrap();
        self.x_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y_pos).unwrap();
        self.y_pos_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.property).unwrap();
        self.property_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.delay_time).unwrap();
        self.delay_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_disposable as u8).unwrap();
        self.is_disposable_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.target_id_raw.to_vec());
        wtr.append(&mut self.x_pos_raw.to_vec());
        wtr.append(&mut self.y_pos_raw.to_vec());
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.property_raw.to_vec());
        wtr.append(&mut self.delay_time_raw.to_vec());
        wtr.append(&mut self.is_disposable_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 25;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_target_id(&mut self, value: u32) {
        self.target_id = value;
    }
    pub fn set_target_id_raw(&mut self, value: [u8; 4]) {
        self.target_id_raw = value;
    }
    pub fn set_x_pos(&mut self, value: i16) {
        self.x_pos = value;
    }
    pub fn set_x_pos_raw(&mut self, value: [u8; 2]) {
        self.x_pos_raw = value;
    }
    pub fn set_y_pos(&mut self, value: i16) {
        self.y_pos = value;
    }
    pub fn set_y_pos_raw(&mut self, value: [u8; 2]) {
        self.y_pos_raw = value;
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_property(&mut self, value: u32) {
        self.property = value;
    }
    pub fn set_property_raw(&mut self, value: [u8; 4]) {
        self.property_raw = value;
    }
    pub fn set_delay_time(&mut self, value: u32) {
        self.delay_time = value;
    }
    pub fn set_delay_time_raw(&mut self, value: [u8; 4]) {
        self.delay_time_raw = value;
    }
    pub fn set_is_disposable(&mut self, value: bool) {
        self.is_disposable = value;
    }
    pub fn set_is_disposable_raw(&mut self, value: [u8; 1]) {
        self.is_disposable_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcUseskillAck2 {
        let packet_id = i16::from_le_bytes([0xfb, 0x07]);
        let packet_id_raw = [0xfb, 0x07];
        PacketZcUseskillAck2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        target_id: 0,
        target_id_raw: [0; 4],
        x_pos: 0,
        x_pos_raw: [0; 2],
        y_pos: 0,
        y_pos_raw: [0; 2],
        skid: 0,
        skid_raw: [0; 2],
        property: 0,
        property_raw: [0; 4],
        delay_time: 0,
        delay_time_raw: [0; 4],
        is_disposable: false,
        is_disposable_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcUseskillAck2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcUseskillAck2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcChangeGroupMaster {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xfc07"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcChangeGroupMaster {
        let mut offset: usize = 0;
        PacketZcChangeGroupMaster {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            old_master_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            old_master_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            new_master_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            new_master_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.old_master_aid).unwrap();
        self.old_master_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.new_master_aid).unwrap();
        self.new_master_aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.old_master_aid_raw.to_vec());
        wtr.append(&mut self.new_master_aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_old_master_aid(&mut self, value: u32) {
        self.old_master_aid = value;
    }
    pub fn set_old_master_aid_raw(&mut self, value: [u8; 4]) {
        self.old_master_aid_raw = value;
    }
    pub fn set_new_master_aid(&mut self, value: u32) {
        self.new_master_aid = value;
    }
    pub fn set_new_master_aid_raw(&mut self, value: [u8; 4]) {
        self.new_master_aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcChangeGroupMaster {
        let packet_id = i16::from_le_bytes([0xfc, 0x07]);
        let packet_id_raw = [0xfc, 0x07];
        PacketZcChangeGroupMaster {
        raw: vec![],
        packet_id,
        packet_id_raw,
        old_master_aid: 0,
        old_master_aid_raw: [0; 4],
        new_master_aid: 0,
        new_master_aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcChangeGroupMaster {
    fn id(&self, packetver: u32) -> &str {
       PacketZcChangeGroupMaster::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPlayNpcBgm {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xfe07"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPlayNpcBgm {
        let mut offset: usize = 0;
        PacketZcPlayNpcBgm {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bgm: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            bgm_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.bgm {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.bgm_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.bgm_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_bgm(&mut self, value: [char; 24]) {
        self.bgm = value;
    }
    pub fn set_bgm_raw(&mut self, value: [u8; 24]) {
        self.bgm_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPlayNpcBgm {
        let packet_id = i16::from_le_bytes([0xfe, 0x07]);
        let packet_id_raw = [0xfe, 0x07];
        PacketZcPlayNpcBgm {
        raw: vec![],
        packet_id,
        packet_id_raw,
        bgm: [0 as char; 24],
        bgm_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcPlayNpcBgm {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPlayNpcBgm::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcDefineCheck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xff07"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcDefineCheck {
        let mut offset: usize = 0;
        PacketZcDefineCheck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_result(&mut self, value: i32) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 4]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcDefineCheck {
        let packet_id = i16::from_le_bytes([0xff, 0x07]);
        let packet_id_raw = [0xff, 0x07];
        PacketZcDefineCheck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        result: 0,
        result_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDefineCheck {
    fn id(&self, packetver: u32) -> &str {
       PacketZcDefineCheck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPcPurchaseItemlistFrommc2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0008"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPcPurchaseItemlistFrommc2 {
        let mut offset: usize = 0;
        let vec_type_len = PurchaseItemFrommc::base_len(packetver);
        let iter_count = (&buffer.len() - 12) / vec_type_len;
        let mut vec_field: Vec<PurchaseItemFrommc> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 12 + (vec_type_len * (i - 1));
            let end_pos = 12 + vec_type_len * i;
            vec_field.push(PurchaseItemFrommc::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcPcPurchaseItemlistFrommc2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            unique_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            unique_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            item_list: {
                let field = vec_field.clone();
                field
            },
            item_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.unique_id).unwrap();
        self.unique_id_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.unique_id_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 12;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_unique_id(&mut self, value: u32) {
        self.unique_id = value;
    }
    pub fn set_unique_id_raw(&mut self, value: [u8; 4]) {
        self.unique_id_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<PurchaseItemFrommc>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPcPurchaseItemlistFrommc2 {
        let packet_id = i16::from_le_bytes([0x00, 0x08]);
        let packet_id_raw = [0x00, 0x08];
        PacketZcPcPurchaseItemlistFrommc2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        unique_id: 0,
        unique_id_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcPcPurchaseItemlistFrommc2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPcPurchaseItemlistFrommc2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzPcPurchaseItemlistFrommc2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0108"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzPcPurchaseItemlistFrommc2 {
        let mut offset: usize = 0;
        let vec_type_len = CzPurchaseItemFrommc::base_len(packetver);
        let iter_count = (&buffer.len() - 12) / vec_type_len;
        let mut vec_field: Vec<CzPurchaseItemFrommc> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 12 + (vec_type_len * (i - 1));
            let end_pos = 12 + vec_type_len * i;
            vec_field.push(CzPurchaseItemFrommc::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketCzPcPurchaseItemlistFrommc2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            unique_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            unique_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            item_list: {
                let field = vec_field.clone();
                field
            },
            item_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.unique_id).unwrap();
        self.unique_id_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.unique_id_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 12;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_unique_id(&mut self, value: u32) {
        self.unique_id = value;
    }
    pub fn set_unique_id_raw(&mut self, value: [u8; 4]) {
        self.unique_id_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<CzPurchaseItemFrommc>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzPcPurchaseItemlistFrommc2 {
        let packet_id = i16::from_le_bytes([0x01, 0x08]);
        let packet_id_raw = [0x01, 0x08];
        PacketCzPcPurchaseItemlistFrommc2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        unique_id: 0,
        unique_id_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketCzPcPurchaseItemlistFrommc2 {
    fn id(&self, packetver: u32) -> &str {
       PacketCzPcPurchaseItemlistFrommc2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzPartyBookingReqRegister {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0208"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzPartyBookingReqRegister {
        let mut offset: usize = 0;
        PacketCzPartyBookingReqRegister {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            register_info: {
                let field = PartyBookingDetail::from(&buffer[offset..offset + PartyBookingDetail::base_len(packetver)], packetver);
                field
            },
            register_info_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.register_info.fill_raw_with_packetver(packetver);
        self.register_info_raw = self.register_info.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.register_info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 1;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_register_info(&mut self, value: PartyBookingDetail) {
        self.register_info = value;
    }
    pub fn set_register_info_raw(&mut self, value: Vec<u8>) {
        self.register_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzPartyBookingReqRegister {
        let packet_id = i16::from_le_bytes([0x02, 0x08]);
        let packet_id_raw = [0x02, 0x08];
        PacketCzPartyBookingReqRegister {
        raw: vec![],
        packet_id,
        packet_id_raw,
        register_info: PartyBookingDetail::new(packetver),
        register_info_raw: vec![],
        }
    }
}

impl Packet for PacketCzPartyBookingReqRegister {
    fn id(&self, packetver: u32) -> &str {
       PacketCzPartyBookingReqRegister::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPartyBookingAckRegister {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0308"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPartyBookingAckRegister {
        let mut offset: usize = 0;
        PacketZcPartyBookingAckRegister {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPartyBookingAckRegister {
        let packet_id = i16::from_le_bytes([0x03, 0x08]);
        let packet_id_raw = [0x03, 0x08];
        PacketZcPartyBookingAckRegister {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcPartyBookingAckRegister {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPartyBookingAckRegister::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzPartyBookingReqSearch {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0408"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzPartyBookingReqSearch {
        let mut offset: usize = 0;
        PacketCzPartyBookingReqSearch {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            map_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            map_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            last_index: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            last_index_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            result_count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.map_id).unwrap();
        self.map_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.last_index).unwrap();
        self.last_index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result_count).unwrap();
        self.result_count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.map_id_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.last_index_raw.to_vec());
        wtr.append(&mut self.result_count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_map_id(&mut self, value: i16) {
        self.map_id = value;
    }
    pub fn set_map_id_raw(&mut self, value: [u8; 2]) {
        self.map_id_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_last_index(&mut self, value: u32) {
        self.last_index = value;
    }
    pub fn set_last_index_raw(&mut self, value: [u8; 4]) {
        self.last_index_raw = value;
    }
    pub fn set_result_count(&mut self, value: i16) {
        self.result_count = value;
    }
    pub fn set_result_count_raw(&mut self, value: [u8; 2]) {
        self.result_count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzPartyBookingReqSearch {
        let packet_id = i16::from_le_bytes([0x04, 0x08]);
        let packet_id_raw = [0x04, 0x08];
        PacketCzPartyBookingReqSearch {
        raw: vec![],
        packet_id,
        packet_id_raw,
        level: 0,
        level_raw: [0; 2],
        map_id: 0,
        map_id_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        last_index: 0,
        last_index_raw: [0; 4],
        result_count: 0,
        result_count_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzPartyBookingReqSearch {
    fn id(&self, packetver: u32) -> &str {
       PacketCzPartyBookingReqSearch::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPartyBookingAckSearch {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0508"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPartyBookingAckSearch {
        let mut offset: usize = 0;
        let vec_type_len = PartyBookingAdInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 5) / vec_type_len;
        let mut vec_field: Vec<PartyBookingAdInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 5 + (vec_type_len * (i - 1));
            let end_pos = 5 + vec_type_len * i;
            vec_field.push(PartyBookingAdInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcPartyBookingAckSearch {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_exist_more_result: {
                let field = buffer[offset] == 1;
                field
            },
            is_exist_more_result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            info: {
                let field = vec_field.clone();
                field
            },
            info_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_exist_more_result as u8).unwrap();
        self.is_exist_more_result_raw = wtr.try_into().unwrap();
        self.info_raw = {
            self.info.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.info.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.is_exist_more_result_raw.to_vec());
        self.info.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_is_exist_more_result(&mut self, value: bool) {
        self.is_exist_more_result = value;
    }
    pub fn set_is_exist_more_result_raw(&mut self, value: [u8; 1]) {
        self.is_exist_more_result_raw = value;
    }
    pub fn set_info(&mut self, value: Vec<PartyBookingAdInfo>) {
        self.info = value;
    }
    pub fn set_info_raw(&mut self, value: Vec<Vec<u8>>) {
        self.info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPartyBookingAckSearch {
        let packet_id = i16::from_le_bytes([0x05, 0x08]);
        let packet_id_raw = [0x05, 0x08];
        PacketZcPartyBookingAckSearch {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        is_exist_more_result: false,
        is_exist_more_result_raw: [0; 1],
        info: vec![],
        info_raw: vec![],
        }
    }
}

impl Packet for PacketZcPartyBookingAckSearch {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPartyBookingAckSearch::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzPartyBookingReqDelete {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0608"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzPartyBookingReqDelete {
        let mut offset: usize = 0;
        PacketCzPartyBookingReqDelete {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzPartyBookingReqDelete {
        let packet_id = i16::from_le_bytes([0x06, 0x08]);
        let packet_id_raw = [0x06, 0x08];
        PacketCzPartyBookingReqDelete {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzPartyBookingReqDelete {
    fn id(&self, packetver: u32) -> &str {
       PacketCzPartyBookingReqDelete::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPartyBookingAckDelete {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0708"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPartyBookingAckDelete {
        let mut offset: usize = 0;
        PacketZcPartyBookingAckDelete {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPartyBookingAckDelete {
        let packet_id = i16::from_le_bytes([0x07, 0x08]);
        let packet_id_raw = [0x07, 0x08];
        PacketZcPartyBookingAckDelete {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcPartyBookingAckDelete {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPartyBookingAckDelete::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzPartyBookingReqUpdate {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0808"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzPartyBookingReqUpdate {
        let mut offset: usize = 0;
        PacketCzPartyBookingReqUpdate {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job: {
                let field =  {
                let mut dst: [i16; 6] = [0_i16; 6];
                for (index, byte) in buffer[offset..offset + 6].iter().enumerate() {
                    dst[index] = *byte as i16;
                }
                dst
            };
                field
            },
            job_raw: {
                let mut dst: [u8; 12] = [0u8; 12];
                dst.clone_from_slice(&buffer[offset..offset + 12]);
                offset += 12;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.job {
            wtr.write_i16::<LittleEndian>(item).unwrap();
        }
        self.job_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_job(&mut self, value: [i16; 6]) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 12]) {
        self.job_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzPartyBookingReqUpdate {
        let packet_id = i16::from_le_bytes([0x08, 0x08]);
        let packet_id_raw = [0x08, 0x08];
        PacketCzPartyBookingReqUpdate {
        raw: vec![],
        packet_id,
        packet_id_raw,
        job: [0; 6],
        job_raw: [0; 12],
        }
    }
}

impl Packet for PacketCzPartyBookingReqUpdate {
    fn id(&self, packetver: u32) -> &str {
       PacketCzPartyBookingReqUpdate::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPartyBookingNotifyInsert {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0908"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPartyBookingNotifyInsert {
        let mut offset: usize = 0;
        PacketZcPartyBookingNotifyInsert {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            info: {
                let field = PartyBookingAdInfo::from(&buffer[offset..offset + PartyBookingAdInfo::base_len(packetver)], packetver);
                field
            },
            info_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        self.info.fill_raw_with_packetver(packetver);
        self.info_raw = self.info.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 1;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_info(&mut self, value: PartyBookingAdInfo) {
        self.info = value;
    }
    pub fn set_info_raw(&mut self, value: Vec<u8>) {
        self.info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPartyBookingNotifyInsert {
        let packet_id = i16::from_le_bytes([0x09, 0x08]);
        let packet_id_raw = [0x09, 0x08];
        PacketZcPartyBookingNotifyInsert {
        raw: vec![],
        packet_id,
        packet_id_raw,
        info: PartyBookingAdInfo::new(packetver),
        info_raw: vec![],
        }
    }
}

impl Packet for PacketZcPartyBookingNotifyInsert {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPartyBookingNotifyInsert::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPartyBookingNotifyUpdate {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0a08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPartyBookingNotifyUpdate {
        let mut offset: usize = 0;
        PacketZcPartyBookingNotifyUpdate {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            job1: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job1_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job2: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job3: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job4: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job4_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job5: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job5_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job6: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job6_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job1).unwrap();
        self.job1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job2).unwrap();
        self.job2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job3).unwrap();
        self.job3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job4).unwrap();
        self.job4_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job5).unwrap();
        self.job5_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job6).unwrap();
        self.job6_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.job1_raw.to_vec());
        wtr.append(&mut self.job2_raw.to_vec());
        wtr.append(&mut self.job3_raw.to_vec());
        wtr.append(&mut self.job4_raw.to_vec());
        wtr.append(&mut self.job5_raw.to_vec());
        wtr.append(&mut self.job6_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 18;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u32) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 4]) {
        self.index_raw = value;
    }
    pub fn set_job1(&mut self, value: i16) {
        self.job1 = value;
    }
    pub fn set_job1_raw(&mut self, value: [u8; 2]) {
        self.job1_raw = value;
    }
    pub fn set_job2(&mut self, value: i16) {
        self.job2 = value;
    }
    pub fn set_job2_raw(&mut self, value: [u8; 2]) {
        self.job2_raw = value;
    }
    pub fn set_job3(&mut self, value: i16) {
        self.job3 = value;
    }
    pub fn set_job3_raw(&mut self, value: [u8; 2]) {
        self.job3_raw = value;
    }
    pub fn set_job4(&mut self, value: i16) {
        self.job4 = value;
    }
    pub fn set_job4_raw(&mut self, value: [u8; 2]) {
        self.job4_raw = value;
    }
    pub fn set_job5(&mut self, value: i16) {
        self.job5 = value;
    }
    pub fn set_job5_raw(&mut self, value: [u8; 2]) {
        self.job5_raw = value;
    }
    pub fn set_job6(&mut self, value: i16) {
        self.job6 = value;
    }
    pub fn set_job6_raw(&mut self, value: [u8; 2]) {
        self.job6_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPartyBookingNotifyUpdate {
        let packet_id = i16::from_le_bytes([0x0a, 0x08]);
        let packet_id_raw = [0x0a, 0x08];
        PacketZcPartyBookingNotifyUpdate {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 4],
        job1: 0,
        job1_raw: [0; 2],
        job2: 0,
        job2_raw: [0; 2],
        job3: 0,
        job3_raw: [0; 2],
        job4: 0,
        job4_raw: [0; 2],
        job5: 0,
        job5_raw: [0; 2],
        job6: 0,
        job6_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcPartyBookingNotifyUpdate {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPartyBookingNotifyUpdate::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcPartyBookingNotifyDelete {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0b08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcPartyBookingNotifyDelete {
        let mut offset: usize = 0;
        PacketZcPartyBookingNotifyDelete {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: u32) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 4]) {
        self.index_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcPartyBookingNotifyDelete {
        let packet_id = i16::from_le_bytes([0x0b, 0x08]);
        let packet_id_raw = [0x0b, 0x08];
        PacketZcPartyBookingNotifyDelete {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcPartyBookingNotifyDelete {
    fn id(&self, packetver: u32) -> &str {
       PacketZcPartyBookingNotifyDelete::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzSimpleCashBtnshow {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0c08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzSimpleCashBtnshow {
        let mut offset: usize = 0;
        PacketCzSimpleCashBtnshow {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzSimpleCashBtnshow {
        let packet_id = i16::from_le_bytes([0x0c, 0x08]);
        let packet_id_raw = [0x0c, 0x08];
        PacketCzSimpleCashBtnshow {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzSimpleCashBtnshow {
    fn id(&self, packetver: u32) -> &str {
       PacketCzSimpleCashBtnshow::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSimpleCashBtnshow {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0d08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSimpleCashBtnshow {
        let mut offset: usize = 0;
        PacketZcSimpleCashBtnshow {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            show: {
                let field = buffer[offset] == 1;
                field
            },
            show_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.show as u8).unwrap();
        self.show_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.show_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_show(&mut self, value: bool) {
        self.show = value;
    }
    pub fn set_show_raw(&mut self, value: [u8; 1]) {
        self.show_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSimpleCashBtnshow {
        let packet_id = i16::from_le_bytes([0x0d, 0x08]);
        let packet_id_raw = [0x0d, 0x08];
        PacketZcSimpleCashBtnshow {
        raw: vec![],
        packet_id,
        packet_id_raw,
        show: false,
        show_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcSimpleCashBtnshow {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSimpleCashBtnshow::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyHpToGroupmR2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x080e"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyHpToGroupmR2 {
        let mut offset: usize = 0;
        PacketZcNotifyHpToGroupmR2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            hp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            maxhp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            maxhp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.maxhp).unwrap();
        self.maxhp_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.maxhp_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_hp(&mut self, value: i32) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 4]) {
        self.hp_raw = value;
    }
    pub fn set_maxhp(&mut self, value: i32) {
        self.maxhp = value;
    }
    pub fn set_maxhp_raw(&mut self, value: [u8; 4]) {
        self.maxhp_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyHpToGroupmR2 {
        let packet_id = i16::from_le_bytes([0x08, 0x0e]);
        let packet_id_raw = [0x08, 0x0e];
        PacketZcNotifyHpToGroupmR2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        hp: 0,
        hp_raw: [0; 4],
        maxhp: 0,
        maxhp_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyHpToGroupmR2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyHpToGroupmR2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAddExchangeItem2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x0f08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAddExchangeItem2 {
        let mut offset: usize = 0;
        PacketZcAddExchangeItem2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            count: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_damaged: {
                let field = buffer[offset] == 1;
                field
            },
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            refining_level: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 20;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_count(&mut self, value: i32) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 4]) {
        self.count_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAddExchangeItem2 {
        let packet_id = i16::from_le_bytes([0x0f, 0x08]);
        let packet_id_raw = [0x0f, 0x08];
        PacketZcAddExchangeItem2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        count: 0,
        count_raw: [0; 4],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        }
    }
}

impl Packet for PacketZcAddExchangeItem2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAddExchangeItem2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcOpenBuyingStore {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1008"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcOpenBuyingStore {
        let mut offset: usize = 0;
        PacketZcOpenBuyingStore {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_count(&mut self, value: u8) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 1]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcOpenBuyingStore {
        let packet_id = i16::from_le_bytes([0x10, 0x08]);
        let packet_id_raw = [0x10, 0x08];
        PacketZcOpenBuyingStore {
        raw: vec![],
        packet_id,
        packet_id_raw,
        count: 0,
        count_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcOpenBuyingStore {
    fn id(&self, packetver: u32) -> &str {
       PacketZcOpenBuyingStore::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqOpenBuyingStore {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1108"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqOpenBuyingStore {
        let mut offset: usize = 0;
        let vec_type_len = ProductinfoInBuyingStore::base_len(packetver);
        let iter_count = (&buffer.len() - 89) / vec_type_len;
        let mut vec_field: Vec<ProductinfoInBuyingStore> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 89 + (vec_type_len * (i - 1));
            let end_pos = 89 + vec_type_len * i;
            vec_field.push(ProductinfoInBuyingStore::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketCzReqOpenBuyingStore {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            limit_zeny: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            limit_zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            result: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            store_name: {
                let field =  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[offset..offset + 80].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            store_name_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[offset..offset + 80]);
                offset += 80;
                dst
            },
            item_list: {
                let field = vec_field.clone();
                field
            },
            item_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.limit_zeny).unwrap();
        self.limit_zeny_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.store_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.store_name_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.limit_zeny_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.store_name_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 89;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_limit_zeny(&mut self, value: u32) {
        self.limit_zeny = value;
    }
    pub fn set_limit_zeny_raw(&mut self, value: [u8; 4]) {
        self.limit_zeny_raw = value;
    }
    pub fn set_result(&mut self, value: u8) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 1]) {
        self.result_raw = value;
    }
    pub fn set_store_name(&mut self, value: [char; 80]) {
        self.store_name = value;
    }
    pub fn set_store_name_raw(&mut self, value: [u8; 80]) {
        self.store_name_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<ProductinfoInBuyingStore>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqOpenBuyingStore {
        let packet_id = i16::from_le_bytes([0x11, 0x08]);
        let packet_id_raw = [0x11, 0x08];
        PacketCzReqOpenBuyingStore {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        limit_zeny: 0,
        limit_zeny_raw: [0; 4],
        result: 0,
        result_raw: [0; 1],
        store_name: [0 as char; 80],
        store_name_raw: [0; 80],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketCzReqOpenBuyingStore {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqOpenBuyingStore::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcFailedOpenBuyingStoreToBuyer {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1208"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcFailedOpenBuyingStoreToBuyer {
        let mut offset: usize = 0;
        PacketZcFailedOpenBuyingStoreToBuyer {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            total_weight: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            total_weight_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.total_weight).unwrap();
        self.total_weight_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.total_weight_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn set_total_weight(&mut self, value: i32) {
        self.total_weight = value;
    }
    pub fn set_total_weight_raw(&mut self, value: [u8; 4]) {
        self.total_weight_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcFailedOpenBuyingStoreToBuyer {
        let packet_id = i16::from_le_bytes([0x12, 0x08]);
        let packet_id_raw = [0x12, 0x08];
        PacketZcFailedOpenBuyingStoreToBuyer {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 2],
        total_weight: 0,
        total_weight_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcFailedOpenBuyingStoreToBuyer {
    fn id(&self, packetver: u32) -> &str {
       PacketZcFailedOpenBuyingStoreToBuyer::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMyitemlistBuyingStore {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1308"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMyitemlistBuyingStore {
        let mut offset: usize = 0;
        let vec_type_len = BuyingStoreItemlist::base_len(packetver);
        let iter_count = (&buffer.len() - 12) / vec_type_len;
        let mut vec_field: Vec<BuyingStoreItemlist> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 12 + (vec_type_len * (i - 1));
            let end_pos = 12 + vec_type_len * i;
            vec_field.push(BuyingStoreItemlist::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcMyitemlistBuyingStore {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            limit_zeny: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            limit_zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            item_list: {
                let field = vec_field.clone();
                field
            },
            item_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.limit_zeny).unwrap();
        self.limit_zeny_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.limit_zeny_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 12;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_limit_zeny(&mut self, value: i32) {
        self.limit_zeny = value;
    }
    pub fn set_limit_zeny_raw(&mut self, value: [u8; 4]) {
        self.limit_zeny_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<BuyingStoreItemlist>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMyitemlistBuyingStore {
        let packet_id = i16::from_le_bytes([0x13, 0x08]);
        let packet_id_raw = [0x13, 0x08];
        PacketZcMyitemlistBuyingStore {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        limit_zeny: 0,
        limit_zeny_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcMyitemlistBuyingStore {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMyitemlistBuyingStore::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcBuyingStoreEntry {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1408"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcBuyingStoreEntry {
        let mut offset: usize = 0;
        PacketZcBuyingStoreEntry {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            maker_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            store_name: {
                let field =  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[offset..offset + 80].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            store_name_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[offset..offset + 80]);
                offset += 80;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.store_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.store_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.maker_aid_raw.to_vec());
        wtr.append(&mut self.store_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 86;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_maker_aid(&mut self, value: u32) {
        self.maker_aid = value;
    }
    pub fn set_maker_aid_raw(&mut self, value: [u8; 4]) {
        self.maker_aid_raw = value;
    }
    pub fn set_store_name(&mut self, value: [char; 80]) {
        self.store_name = value;
    }
    pub fn set_store_name_raw(&mut self, value: [u8; 80]) {
        self.store_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcBuyingStoreEntry {
        let packet_id = i16::from_le_bytes([0x14, 0x08]);
        let packet_id_raw = [0x14, 0x08];
        PacketZcBuyingStoreEntry {
        raw: vec![],
        packet_id,
        packet_id_raw,
        maker_aid: 0,
        maker_aid_raw: [0; 4],
        store_name: [0 as char; 80],
        store_name_raw: [0; 80],
        }
    }
}

impl Packet for PacketZcBuyingStoreEntry {
    fn id(&self, packetver: u32) -> &str {
       PacketZcBuyingStoreEntry::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqCloseBuyingStore {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1508"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqCloseBuyingStore {
        let mut offset: usize = 0;
        PacketCzReqCloseBuyingStore {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqCloseBuyingStore {
        let packet_id = i16::from_le_bytes([0x15, 0x08]);
        let packet_id_raw = [0x15, 0x08];
        PacketCzReqCloseBuyingStore {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzReqCloseBuyingStore {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqCloseBuyingStore::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcDisappearBuyingStoreEntry {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1608"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcDisappearBuyingStoreEntry {
        let mut offset: usize = 0;
        PacketZcDisappearBuyingStoreEntry {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            maker_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.maker_aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_maker_aid(&mut self, value: u32) {
        self.maker_aid = value;
    }
    pub fn set_maker_aid_raw(&mut self, value: [u8; 4]) {
        self.maker_aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcDisappearBuyingStoreEntry {
        let packet_id = i16::from_le_bytes([0x16, 0x08]);
        let packet_id_raw = [0x16, 0x08];
        PacketZcDisappearBuyingStoreEntry {
        raw: vec![],
        packet_id,
        packet_id_raw,
        maker_aid: 0,
        maker_aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcDisappearBuyingStoreEntry {
    fn id(&self, packetver: u32) -> &str {
       PacketZcDisappearBuyingStoreEntry::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqClickToBuyingStore {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1708"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqClickToBuyingStore {
        let mut offset: usize = 0;
        PacketCzReqClickToBuyingStore {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            maker_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.maker_aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_maker_aid(&mut self, value: u32) {
        self.maker_aid = value;
    }
    pub fn set_maker_aid_raw(&mut self, value: [u8; 4]) {
        self.maker_aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqClickToBuyingStore {
        let packet_id = i16::from_le_bytes([0x17, 0x08]);
        let packet_id_raw = [0x17, 0x08];
        PacketCzReqClickToBuyingStore {
        raw: vec![],
        packet_id,
        packet_id_raw,
        maker_aid: 0,
        maker_aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqClickToBuyingStore {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqClickToBuyingStore::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckItemlistBuyingStore {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1808"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckItemlistBuyingStore {
        let mut offset: usize = 0;
        let vec_type_len = BuyingStoreItemlist::base_len(packetver);
        let iter_count = (&buffer.len() - 16) / vec_type_len;
        let mut vec_field: Vec<BuyingStoreItemlist> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 16 + (vec_type_len * (i - 1));
            let end_pos = 16 + vec_type_len * i;
            vec_field.push(BuyingStoreItemlist::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcAckItemlistBuyingStore {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            maker_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            store_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            store_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            limit_zeny: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            limit_zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            item_list: {
                let field = vec_field.clone();
                field
            },
            item_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.store_id).unwrap();
        self.store_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.limit_zeny).unwrap();
        self.limit_zeny_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.maker_aid_raw.to_vec());
        wtr.append(&mut self.store_id_raw.to_vec());
        wtr.append(&mut self.limit_zeny_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 16;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_maker_aid(&mut self, value: u32) {
        self.maker_aid = value;
    }
    pub fn set_maker_aid_raw(&mut self, value: [u8; 4]) {
        self.maker_aid_raw = value;
    }
    pub fn set_store_id(&mut self, value: u32) {
        self.store_id = value;
    }
    pub fn set_store_id_raw(&mut self, value: [u8; 4]) {
        self.store_id_raw = value;
    }
    pub fn set_limit_zeny(&mut self, value: i32) {
        self.limit_zeny = value;
    }
    pub fn set_limit_zeny_raw(&mut self, value: [u8; 4]) {
        self.limit_zeny_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<BuyingStoreItemlist>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckItemlistBuyingStore {
        let packet_id = i16::from_le_bytes([0x18, 0x08]);
        let packet_id_raw = [0x18, 0x08];
        PacketZcAckItemlistBuyingStore {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        maker_aid: 0,
        maker_aid_raw: [0; 4],
        store_id: 0,
        store_id_raw: [0; 4],
        limit_zeny: 0,
        limit_zeny_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketZcAckItemlistBuyingStore {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckItemlistBuyingStore::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqTradeBuyingStore {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1908"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqTradeBuyingStore {
        let mut offset: usize = 0;
        let vec_type_len = TradeItemBuyingStore::base_len(packetver);
        let iter_count = (&buffer.len() - 12) / vec_type_len;
        let mut vec_field: Vec<TradeItemBuyingStore> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 12 + (vec_type_len * (i - 1));
            let end_pos = 12 + vec_type_len * i;
            vec_field.push(TradeItemBuyingStore::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketCzReqTradeBuyingStore {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            maker_aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            maker_aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            store_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            store_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            item_list: {
                let field = vec_field.clone();
                field
            },
            item_list_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maker_aid).unwrap();
        self.maker_aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.store_id).unwrap();
        self.store_id_raw = wtr.try_into().unwrap();
        self.item_list_raw = {
            self.item_list.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.item_list.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.maker_aid_raw.to_vec());
        wtr.append(&mut self.store_id_raw.to_vec());
        self.item_list.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 12;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_maker_aid(&mut self, value: u32) {
        self.maker_aid = value;
    }
    pub fn set_maker_aid_raw(&mut self, value: [u8; 4]) {
        self.maker_aid_raw = value;
    }
    pub fn set_store_id(&mut self, value: u32) {
        self.store_id = value;
    }
    pub fn set_store_id_raw(&mut self, value: [u8; 4]) {
        self.store_id_raw = value;
    }
    pub fn set_item_list(&mut self, value: Vec<TradeItemBuyingStore>) {
        self.item_list = value;
    }
    pub fn set_item_list_raw(&mut self, value: Vec<Vec<u8>>) {
        self.item_list_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqTradeBuyingStore {
        let packet_id = i16::from_le_bytes([0x19, 0x08]);
        let packet_id_raw = [0x19, 0x08];
        PacketCzReqTradeBuyingStore {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        maker_aid: 0,
        maker_aid_raw: [0; 4],
        store_id: 0,
        store_id_raw: [0; 4],
        item_list: vec![],
        item_list_raw: vec![],
        }
    }
}

impl Packet for PacketCzReqTradeBuyingStore {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqTradeBuyingStore::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcFailedTradeBuyingStoreToBuyer {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1a08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcFailedTradeBuyingStoreToBuyer {
        let mut offset: usize = 0;
        PacketZcFailedTradeBuyingStoreToBuyer {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcFailedTradeBuyingStoreToBuyer {
        let packet_id = i16::from_le_bytes([0x1a, 0x08]);
        let packet_id_raw = [0x1a, 0x08];
        PacketZcFailedTradeBuyingStoreToBuyer {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcFailedTradeBuyingStoreToBuyer {
    fn id(&self, packetver: u32) -> &str {
       PacketZcFailedTradeBuyingStoreToBuyer::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcUpdateItemFromBuyingStore {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1b08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcUpdateItemFromBuyingStore {
        let mut offset: usize = 0;
        PacketZcUpdateItemFromBuyingStore {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            limit_zeny: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            limit_zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.limit_zeny).unwrap();
        self.limit_zeny_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.limit_zeny_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_limit_zeny(&mut self, value: i32) {
        self.limit_zeny = value;
    }
    pub fn set_limit_zeny_raw(&mut self, value: [u8; 4]) {
        self.limit_zeny_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcUpdateItemFromBuyingStore {
        let packet_id = i16::from_le_bytes([0x1b, 0x08]);
        let packet_id_raw = [0x1b, 0x08];
        PacketZcUpdateItemFromBuyingStore {
        raw: vec![],
        packet_id,
        packet_id_raw,
        itid: 0,
        itid_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        limit_zeny: 0,
        limit_zeny_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcUpdateItemFromBuyingStore {
    fn id(&self, packetver: u32) -> &str {
       PacketZcUpdateItemFromBuyingStore::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcItemDeleteBuyingStore {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1c08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcItemDeleteBuyingStore {
        let mut offset: usize = 0;
        PacketZcItemDeleteBuyingStore {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            zeny: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            zeny_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.zeny).unwrap();
        self.zeny_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.zeny_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_zeny(&mut self, value: i32) {
        self.zeny = value;
    }
    pub fn set_zeny_raw(&mut self, value: [u8; 4]) {
        self.zeny_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcItemDeleteBuyingStore {
        let packet_id = i16::from_le_bytes([0x1c, 0x08]);
        let packet_id_raw = [0x1c, 0x08];
        PacketZcItemDeleteBuyingStore {
        raw: vec![],
        packet_id,
        packet_id_raw,
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        zeny: 0,
        zeny_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcItemDeleteBuyingStore {
    fn id(&self, packetver: u32) -> &str {
       PacketZcItemDeleteBuyingStore::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcElInit {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1d08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcElInit {
        let mut offset: usize = 0;
        PacketZcElInit {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            hp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            max_hp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            max_hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            sp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            sp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            max_sp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            max_sp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.sp).unwrap();
        self.sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_sp).unwrap();
        self.max_sp_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.max_hp_raw.to_vec());
        wtr.append(&mut self.sp_raw.to_vec());
        wtr.append(&mut self.max_sp_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 22;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: i32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_hp(&mut self, value: i32) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 4]) {
        self.hp_raw = value;
    }
    pub fn set_max_hp(&mut self, value: i32) {
        self.max_hp = value;
    }
    pub fn set_max_hp_raw(&mut self, value: [u8; 4]) {
        self.max_hp_raw = value;
    }
    pub fn set_sp(&mut self, value: i32) {
        self.sp = value;
    }
    pub fn set_sp_raw(&mut self, value: [u8; 4]) {
        self.sp_raw = value;
    }
    pub fn set_max_sp(&mut self, value: i32) {
        self.max_sp = value;
    }
    pub fn set_max_sp_raw(&mut self, value: [u8; 4]) {
        self.max_sp_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcElInit {
        let packet_id = i16::from_le_bytes([0x1d, 0x08]);
        let packet_id_raw = [0x1d, 0x08];
        PacketZcElInit {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        hp: 0,
        hp_raw: [0; 4],
        max_hp: 0,
        max_hp_raw: [0; 4],
        sp: 0,
        sp_raw: [0; 4],
        max_sp: 0,
        max_sp_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcElInit {
    fn id(&self, packetver: u32) -> &str {
       PacketZcElInit::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcElParChange {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1e08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcElParChange {
        let mut offset: usize = 0;
        PacketZcElParChange {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            var: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            var_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            value: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.var).unwrap();
        self.var_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.var_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_var(&mut self, value: u16) {
        self.var = value;
    }
    pub fn set_var_raw(&mut self, value: [u8; 2]) {
        self.var_raw = value;
    }
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcElParChange {
        let packet_id = i16::from_le_bytes([0x1e, 0x08]);
        let packet_id_raw = [0x1e, 0x08];
        PacketZcElParChange {
        raw: vec![],
        packet_id,
        packet_id_raw,
        var: 0,
        var_raw: [0; 2],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcElParChange {
    fn id(&self, packetver: u32) -> &str {
       PacketZcElParChange::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcBroadcast4 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1f08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcBroadcast4 {
        let mut offset: usize = 0;
        PacketZcBroadcast4 {
            pakcet_type: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            pakcet_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msgtype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            msgtype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            color_rgb: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            color_rgb_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            msg: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            msg_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.pakcet_type).unwrap();
        self.pakcet_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.msgtype).unwrap();
        self.msgtype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.color_rgb).unwrap();
        self.color_rgb_raw = wtr.try_into().unwrap();
        self.msg_raw = self.msg.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.pakcet_type_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.msgtype_raw.to_vec());
        wtr.append(&mut self.color_rgb_raw.to_vec());
        wtr.append(&mut self.msg_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_pakcet_type(&mut self, value: i16) {
        self.pakcet_type = value;
    }
    pub fn set_pakcet_type_raw(&mut self, value: [u8; 2]) {
        self.pakcet_type_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_msgtype(&mut self, value: u8) {
        self.msgtype = value;
    }
    pub fn set_msgtype_raw(&mut self, value: [u8; 1]) {
        self.msgtype_raw = value;
    }
    pub fn set_color_rgb(&mut self, value: u32) {
        self.color_rgb = value;
    }
    pub fn set_color_rgb_raw(&mut self, value: [u8; 4]) {
        self.color_rgb_raw = value;
    }
    pub fn set_msg(&mut self, value: String) {
        self.msg = value;
    }
    pub fn set_msg_raw(&mut self, value: Vec<u8>) {
        self.msg_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcBroadcast4 {
        let packet_id = i16::from_le_bytes([0x1f, 0x08]);
        let packet_id_raw = [0x1f, 0x08];
        PacketZcBroadcast4 {
        raw: vec![],
        pakcet_type: 0,
        pakcet_type_raw: [0; 2],
        packet_length: 0,
        packet_length_raw: [0; 2],
        msgtype: 0,
        msgtype_raw: [0; 1],
        color_rgb: 0,
        color_rgb_raw: [0; 4],
        msg: String::new(),
        msg_raw: vec![],
        }
    }
}

impl Packet for PacketZcBroadcast4 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcBroadcast4::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcCostumeSpriteChange {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2008"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcCostumeSpriteChange {
        let mut offset: usize = 0;
        PacketZcCostumeSpriteChange {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            value: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            value_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.value).unwrap();
        self.value_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.value_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 11;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
    pub fn set_value_raw(&mut self, value: [u8; 4]) {
        self.value_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcCostumeSpriteChange {
        let packet_id = i16::from_le_bytes([0x20, 0x08]);
        let packet_id_raw = [0x20, 0x08];
        PacketZcCostumeSpriteChange {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        value: 0,
        value_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcCostumeSpriteChange {
    fn id(&self, packetver: u32) -> &str {
       PacketZcCostumeSpriteChange::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcOtpUser {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2108"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcOtpUser {
        let mut offset: usize = 0;
        PacketAcOtpUser {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcOtpUser {
        let packet_id = i16::from_le_bytes([0x21, 0x08]);
        let packet_id_raw = [0x21, 0x08];
        PacketAcOtpUser {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketAcOtpUser {
    fn id(&self, packetver: u32) -> &str {
       PacketAcOtpUser::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCaOtpAuthReq {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2208"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaOtpAuthReq {
        let mut offset: usize = 0;
        PacketCaOtpAuthReq {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            otpcode: {
                let field =  {
                let mut dst: [char; 7] = [0 as char; 7];
                for (index, byte) in buffer[offset..offset + 7].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            otpcode_raw: {
                let mut dst: [u8; 7] = [0u8; 7];
                dst.clone_from_slice(&buffer[offset..offset + 7]);
                offset += 7;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.otpcode {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.otpcode_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.otpcode_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 9;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_otpcode(&mut self, value: [char; 7]) {
        self.otpcode = value;
    }
    pub fn set_otpcode_raw(&mut self, value: [u8; 7]) {
        self.otpcode_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaOtpAuthReq {
        let packet_id = i16::from_le_bytes([0x22, 0x08]);
        let packet_id_raw = [0x22, 0x08];
        PacketCaOtpAuthReq {
        raw: vec![],
        packet_id,
        packet_id_raw,
        otpcode: [0 as char; 7],
        otpcode_raw: [0; 7],
        }
    }
}

impl Packet for PacketCaOtpAuthReq {
    fn id(&self, packetver: u32) -> &str {
       PacketCaOtpAuthReq::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcOtpAuthAck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2308"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcOtpAuthAck {
        let mut offset: usize = 0;
        PacketAcOtpAuthAck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            login_result: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            login_result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.login_result).unwrap();
        self.login_result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.login_result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_login_result(&mut self, value: u16) {
        self.login_result = value;
    }
    pub fn set_login_result_raw(&mut self, value: [u8; 2]) {
        self.login_result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcOtpAuthAck {
        let packet_id = i16::from_le_bytes([0x23, 0x08]);
        let packet_id_raw = [0x23, 0x08];
        PacketAcOtpAuthAck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        login_result: 0,
        login_result_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcOtpAuthAck {
    fn id(&self, packetver: u32) -> &str {
       PacketAcOtpAuthAck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcFailedTradeBuyingStoreToSeller {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2408"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcFailedTradeBuyingStoreToSeller {
        let mut offset: usize = 0;
        PacketZcFailedTradeBuyingStoreToSeller {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: i16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcFailedTradeBuyingStoreToSeller {
        let packet_id = i16::from_le_bytes([0x24, 0x08]);
        let packet_id_raw = [0x24, 0x08];
        PacketZcFailedTradeBuyingStoreToSeller {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcFailedTradeBuyingStoreToSeller {
    fn id(&self, packetver: u32) -> &str {
       PacketZcFailedTradeBuyingStoreToSeller::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCaSsoLoginReqa {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5a82"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaSsoLoginReqa {
        let mut offset: usize = 0;
        PacketCaSsoLoginReqa {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            version: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            clienttype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            id: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            mac_addr: {
                let field =  {
                let mut dst: [char; 17] = [0 as char; 17];
                for (index, byte) in buffer[offset..offset + 17].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            mac_addr_raw: {
                let mut dst: [u8; 17] = [0u8; 17];
                dst.clone_from_slice(&buffer[offset..offset + 17]);
                offset += 17;
                dst
            },
            ip_addr: {
                let field =  {
                let mut dst: [char; 15] = [0 as char; 15];
                for (index, byte) in buffer[offset..offset + 15].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            ip_addr_raw: {
                let mut dst: [u8; 15] = [0u8; 15];
                dst.clone_from_slice(&buffer[offset..offset + 15]);
                offset += 15;
                dst
            },
            t1: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            t1_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mac_addr {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mac_addr_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.ip_addr {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.ip_addr_raw = wtr.try_into().unwrap();
        self.t1_raw = self.t1.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.version_raw.to_vec());
        wtr.append(&mut self.clienttype_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.mac_addr_raw.to_vec());
        wtr.append(&mut self.ip_addr_raw.to_vec());
        wtr.append(&mut self.t1_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 64;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_version(&mut self, value: u32) {
        self.version = value;
    }
    pub fn set_version_raw(&mut self, value: [u8; 4]) {
        self.version_raw = value;
    }
    pub fn set_clienttype(&mut self, value: u8) {
        self.clienttype = value;
    }
    pub fn set_clienttype_raw(&mut self, value: [u8; 1]) {
        self.clienttype_raw = value;
    }
    pub fn set_id(&mut self, value: [char; 24]) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 24]) {
        self.id_raw = value;
    }
    pub fn set_mac_addr(&mut self, value: [char; 17]) {
        self.mac_addr = value;
    }
    pub fn set_mac_addr_raw(&mut self, value: [u8; 17]) {
        self.mac_addr_raw = value;
    }
    pub fn set_ip_addr(&mut self, value: [char; 15]) {
        self.ip_addr = value;
    }
    pub fn set_ip_addr_raw(&mut self, value: [u8; 15]) {
        self.ip_addr_raw = value;
    }
    pub fn set_t1(&mut self, value: String) {
        self.t1 = value;
    }
    pub fn set_t1_raw(&mut self, value: Vec<u8>) {
        self.t1_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaSsoLoginReqa {
        let packet_id = i16::from_le_bytes([0x5a, 0x82]);
        let packet_id_raw = [0x5a, 0x82];
        PacketCaSsoLoginReqa {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        version: 0,
        version_raw: [0; 4],
        clienttype: 0,
        clienttype_raw: [0; 1],
        id: [0 as char; 24],
        id_raw: [0; 24],
        mac_addr: [0 as char; 17],
        mac_addr_raw: [0; 17],
        ip_addr: [0 as char; 15],
        ip_addr_raw: [0; 15],
        t1: String::new(),
        t1_raw: vec![],
        }
    }
}

impl Packet for PacketCaSsoLoginReqa {
    fn id(&self, packetver: u32) -> &str {
       PacketCaSsoLoginReqa::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCaSsoLoginReq {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2508"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCaSsoLoginReq {
        let mut offset: usize = 0;
        PacketCaSsoLoginReq {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            version: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            version_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            clienttype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            clienttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            id: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            id_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            passwd: {
                let field =  {
                let mut dst: [char; 27] = [0 as char; 27];
                for (index, byte) in buffer[offset..offset + 27].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            passwd_raw: {
                let mut dst: [u8; 27] = [0u8; 27];
                dst.clone_from_slice(&buffer[offset..offset + 27]);
                offset += 27;
                dst
            },
            mac_adress: {
                let field =  {
                let mut dst: [char; 17] = [0 as char; 17];
                for (index, byte) in buffer[offset..offset + 17].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            mac_adress_raw: {
                let mut dst: [u8; 17] = [0u8; 17];
                dst.clone_from_slice(&buffer[offset..offset + 17]);
                offset += 17;
                dst
            },
            ip: {
                let field =  {
                let mut dst: [char; 15] = [0 as char; 15];
                for (index, byte) in buffer[offset..offset + 15].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            ip_raw: {
                let mut dst: [u8; 15] = [0u8; 15];
                dst.clone_from_slice(&buffer[offset..offset + 15]);
                offset += 15;
                dst
            },
            t1: {
                let field = String::from_utf8_lossy(&buffer[offset..buffer.len()]).to_string();
                field
            },
            t1_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.version).unwrap();
        self.version_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.clienttype).unwrap();
        self.clienttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.id {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.passwd {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.passwd_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mac_adress {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mac_adress_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.ip {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.ip_raw = wtr.try_into().unwrap();
        self.t1_raw = self.t1.as_bytes().to_vec();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.version_raw.to_vec());
        wtr.append(&mut self.clienttype_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.passwd_raw.to_vec());
        wtr.append(&mut self.mac_adress_raw.to_vec());
        wtr.append(&mut self.ip_raw.to_vec());
        wtr.append(&mut self.t1_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 91;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_version(&mut self, value: u32) {
        self.version = value;
    }
    pub fn set_version_raw(&mut self, value: [u8; 4]) {
        self.version_raw = value;
    }
    pub fn set_clienttype(&mut self, value: u8) {
        self.clienttype = value;
    }
    pub fn set_clienttype_raw(&mut self, value: [u8; 1]) {
        self.clienttype_raw = value;
    }
    pub fn set_id(&mut self, value: [char; 24]) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 24]) {
        self.id_raw = value;
    }
    pub fn set_passwd(&mut self, value: [char; 27]) {
        self.passwd = value;
    }
    pub fn set_passwd_raw(&mut self, value: [u8; 27]) {
        self.passwd_raw = value;
    }
    pub fn set_mac_adress(&mut self, value: [char; 17]) {
        self.mac_adress = value;
    }
    pub fn set_mac_adress_raw(&mut self, value: [u8; 17]) {
        self.mac_adress_raw = value;
    }
    pub fn set_ip(&mut self, value: [char; 15]) {
        self.ip = value;
    }
    pub fn set_ip_raw(&mut self, value: [u8; 15]) {
        self.ip_raw = value;
    }
    pub fn set_t1(&mut self, value: String) {
        self.t1 = value;
    }
    pub fn set_t1_raw(&mut self, value: Vec<u8>) {
        self.t1_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCaSsoLoginReq {
        let packet_id = i16::from_le_bytes([0x25, 0x08]);
        let packet_id_raw = [0x25, 0x08];
        PacketCaSsoLoginReq {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        version: 0,
        version_raw: [0; 4],
        clienttype: 0,
        clienttype_raw: [0; 1],
        id: [0 as char; 24],
        id_raw: [0; 24],
        passwd: [0 as char; 27],
        passwd_raw: [0; 27],
        mac_adress: [0 as char; 17],
        mac_adress_raw: [0; 17],
        ip: [0 as char; 15],
        ip_raw: [0; 15],
        t1: String::new(),
        t1_raw: vec![],
        }
    }
}

impl Packet for PacketCaSsoLoginReq {
    fn id(&self, packetver: u32) -> &str {
       PacketCaSsoLoginReq::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcSsoLoginAck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2608"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcSsoLoginAck {
        let mut offset: usize = 0;
        PacketAcSsoLoginAck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            result: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_result(&mut self, value: u16) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 2]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcSsoLoginAck {
        let packet_id = i16::from_le_bytes([0x26, 0x08]);
        let packet_id_raw = [0x26, 0x08];
        PacketAcSsoLoginAck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        result: 0,
        result_raw: [0; 2],
        }
    }
}

impl Packet for PacketAcSsoLoginAck {
    fn id(&self, packetver: u32) -> &str {
       PacketAcSsoLoginAck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketChDeleteChar3Reserved {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2708"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketChDeleteChar3Reserved {
        let mut offset: usize = 0;
        PacketChDeleteChar3Reserved {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketChDeleteChar3Reserved {
        let packet_id = i16::from_le_bytes([0x27, 0x08]);
        let packet_id_raw = [0x27, 0x08];
        PacketChDeleteChar3Reserved {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketChDeleteChar3Reserved {
    fn id(&self, packetver: u32) -> &str {
       PacketChDeleteChar3Reserved::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcDeleteChar3Reserved {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2808"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcDeleteChar3Reserved {
        let mut offset: usize = 0;
        PacketHcDeleteChar3Reserved {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            result: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            delete_reserved_date: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            delete_reserved_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.delete_reserved_date).unwrap();
        self.delete_reserved_date_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.delete_reserved_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_result(&mut self, value: i32) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 4]) {
        self.result_raw = value;
    }
    pub fn set_delete_reserved_date(&mut self, value: i32) {
        self.delete_reserved_date = value;
    }
    pub fn set_delete_reserved_date_raw(&mut self, value: [u8; 4]) {
        self.delete_reserved_date_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcDeleteChar3Reserved {
        let packet_id = i16::from_le_bytes([0x28, 0x08]);
        let packet_id_raw = [0x28, 0x08];
        PacketHcDeleteChar3Reserved {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        result: 0,
        result_raw: [0; 4],
        delete_reserved_date: 0,
        delete_reserved_date_raw: [0; 4],
        }
    }
}

impl Packet for PacketHcDeleteChar3Reserved {
    fn id(&self, packetver: u32) -> &str {
       PacketHcDeleteChar3Reserved::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketChDeleteChar3 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2908"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketChDeleteChar3 {
        let mut offset: usize = 0;
        PacketChDeleteChar3 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            birth: {
                let field =  {
                let mut dst: [char; 6] = [0 as char; 6];
                for (index, byte) in buffer[offset..offset + 6].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            birth_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[offset..offset + 6]);
                offset += 6;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.birth {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.birth_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.birth_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 12;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_birth(&mut self, value: [char; 6]) {
        self.birth = value;
    }
    pub fn set_birth_raw(&mut self, value: [u8; 6]) {
        self.birth_raw = value;
    }
    pub fn new(packetver: u32) -> PacketChDeleteChar3 {
        let packet_id = i16::from_le_bytes([0x29, 0x08]);
        let packet_id_raw = [0x29, 0x08];
        PacketChDeleteChar3 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        birth: [0 as char; 6],
        birth_raw: [0; 6],
        }
    }
}

impl Packet for PacketChDeleteChar3 {
    fn id(&self, packetver: u32) -> &str {
       PacketChDeleteChar3::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcDeleteChar3 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2a08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcDeleteChar3 {
        let mut offset: usize = 0;
        PacketHcDeleteChar3 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            result: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_result(&mut self, value: i32) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 4]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcDeleteChar3 {
        let packet_id = i16::from_le_bytes([0x2a, 0x08]);
        let packet_id_raw = [0x2a, 0x08];
        PacketHcDeleteChar3 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        result: 0,
        result_raw: [0; 4],
        }
    }
}

impl Packet for PacketHcDeleteChar3 {
    fn id(&self, packetver: u32) -> &str {
       PacketHcDeleteChar3::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketChDeleteChar3Cancel {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2b08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketChDeleteChar3Cancel {
        let mut offset: usize = 0;
        PacketChDeleteChar3Cancel {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketChDeleteChar3Cancel {
        let packet_id = i16::from_le_bytes([0x2b, 0x08]);
        let packet_id_raw = [0x2b, 0x08];
        PacketChDeleteChar3Cancel {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketChDeleteChar3Cancel {
    fn id(&self, packetver: u32) -> &str {
       PacketChDeleteChar3Cancel::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcDeleteChar3Cancel {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2c08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcDeleteChar3Cancel {
        let mut offset: usize = 0;
        PacketHcDeleteChar3Cancel {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            result: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_result(&mut self, value: i32) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 4]) {
        self.result_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcDeleteChar3Cancel {
        let packet_id = i16::from_le_bytes([0x2c, 0x08]);
        let packet_id_raw = [0x2c, 0x08];
        PacketHcDeleteChar3Cancel {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        result: 0,
        result_raw: [0; 4],
        }
    }
}

impl Packet for PacketHcDeleteChar3Cancel {
    fn id(&self, packetver: u32) -> &str {
       PacketHcDeleteChar3Cancel::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzSearchStoreInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3508"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzSearchStoreInfo {
        let mut offset: usize = 0;
        PacketCzSearchStoreInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            store_type: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            store_type_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            max_price: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            max_price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            min_price: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            min_price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            item_idlist_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            item_idlist_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            card_idlist_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            card_idlist_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.store_type).unwrap();
        self.store_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.max_price).unwrap();
        self.max_price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.min_price).unwrap();
        self.min_price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_idlist_size).unwrap();
        self.item_idlist_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.card_idlist_size).unwrap();
        self.card_idlist_size_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.store_type_raw.to_vec());
        wtr.append(&mut self.max_price_raw.to_vec());
        wtr.append(&mut self.min_price_raw.to_vec());
        wtr.append(&mut self.item_idlist_size_raw.to_vec());
        wtr.append(&mut self.card_idlist_size_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 15;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_store_type(&mut self, value: u8) {
        self.store_type = value;
    }
    pub fn set_store_type_raw(&mut self, value: [u8; 1]) {
        self.store_type_raw = value;
    }
    pub fn set_max_price(&mut self, value: u32) {
        self.max_price = value;
    }
    pub fn set_max_price_raw(&mut self, value: [u8; 4]) {
        self.max_price_raw = value;
    }
    pub fn set_min_price(&mut self, value: u32) {
        self.min_price = value;
    }
    pub fn set_min_price_raw(&mut self, value: [u8; 4]) {
        self.min_price_raw = value;
    }
    pub fn set_item_idlist_size(&mut self, value: u8) {
        self.item_idlist_size = value;
    }
    pub fn set_item_idlist_size_raw(&mut self, value: [u8; 1]) {
        self.item_idlist_size_raw = value;
    }
    pub fn set_card_idlist_size(&mut self, value: u8) {
        self.card_idlist_size = value;
    }
    pub fn set_card_idlist_size_raw(&mut self, value: [u8; 1]) {
        self.card_idlist_size_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzSearchStoreInfo {
        let packet_id = i16::from_le_bytes([0x35, 0x08]);
        let packet_id_raw = [0x35, 0x08];
        PacketCzSearchStoreInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        store_type: 0,
        store_type_raw: [0; 1],
        max_price: 0,
        max_price_raw: [0; 4],
        min_price: 0,
        min_price_raw: [0; 4],
        item_idlist_size: 0,
        item_idlist_size_raw: [0; 1],
        card_idlist_size: 0,
        card_idlist_size_raw: [0; 1],
        }
    }
}

impl Packet for PacketCzSearchStoreInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketCzSearchStoreInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSearchStoreInfoAck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3608"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSearchStoreInfoAck {
        let mut offset: usize = 0;
        let vec_type_len = ResultItemInfo::base_len(packetver);
        let iter_count = (&buffer.len() - 7) / vec_type_len;
        let mut vec_field: Vec<ResultItemInfo> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 7 + (vec_type_len * (i - 1));
            let end_pos = 7 + vec_type_len * i;
            vec_field.push(ResultItemInfo::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcSearchStoreInfoAck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_first_page: {
                let field = buffer[offset] == 1;
                field
            },
            is_first_page_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_nex_page: {
                let field = buffer[offset] == 1;
                field
            },
            is_nex_page_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            remained_search_cnt: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            remained_search_cnt_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            ssilist: {
                let field = vec_field.clone();
                field
            },
            ssilist_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_first_page as u8).unwrap();
        self.is_first_page_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_nex_page as u8).unwrap();
        self.is_nex_page_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.remained_search_cnt).unwrap();
        self.remained_search_cnt_raw = wtr.try_into().unwrap();
        self.ssilist_raw = {
            self.ssilist.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.ssilist.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.is_first_page_raw.to_vec());
        wtr.append(&mut self.is_nex_page_raw.to_vec());
        wtr.append(&mut self.remained_search_cnt_raw.to_vec());
        self.ssilist.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_is_first_page(&mut self, value: bool) {
        self.is_first_page = value;
    }
    pub fn set_is_first_page_raw(&mut self, value: [u8; 1]) {
        self.is_first_page_raw = value;
    }
    pub fn set_is_nex_page(&mut self, value: bool) {
        self.is_nex_page = value;
    }
    pub fn set_is_nex_page_raw(&mut self, value: [u8; 1]) {
        self.is_nex_page_raw = value;
    }
    pub fn set_remained_search_cnt(&mut self, value: u8) {
        self.remained_search_cnt = value;
    }
    pub fn set_remained_search_cnt_raw(&mut self, value: [u8; 1]) {
        self.remained_search_cnt_raw = value;
    }
    pub fn set_ssilist(&mut self, value: Vec<ResultItemInfo>) {
        self.ssilist = value;
    }
    pub fn set_ssilist_raw(&mut self, value: Vec<Vec<u8>>) {
        self.ssilist_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSearchStoreInfoAck {
        let packet_id = i16::from_le_bytes([0x36, 0x08]);
        let packet_id_raw = [0x36, 0x08];
        PacketZcSearchStoreInfoAck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        is_first_page: false,
        is_first_page_raw: [0; 1],
        is_nex_page: false,
        is_nex_page_raw: [0; 1],
        remained_search_cnt: 0,
        remained_search_cnt_raw: [0; 1],
        ssilist: vec![],
        ssilist_raw: vec![],
        }
    }
}

impl Packet for PacketZcSearchStoreInfoAck {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSearchStoreInfoAck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSearchStoreInfoFailed {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3708"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSearchStoreInfoFailed {
        let mut offset: usize = 0;
        PacketZcSearchStoreInfoFailed {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            reason: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            reason_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.reason).unwrap();
        self.reason_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.reason_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 3;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_reason(&mut self, value: u8) {
        self.reason = value;
    }
    pub fn set_reason_raw(&mut self, value: [u8; 1]) {
        self.reason_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSearchStoreInfoFailed {
        let packet_id = i16::from_le_bytes([0x37, 0x08]);
        let packet_id_raw = [0x37, 0x08];
        PacketZcSearchStoreInfoFailed {
        raw: vec![],
        packet_id,
        packet_id_raw,
        reason: 0,
        reason_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcSearchStoreInfoFailed {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSearchStoreInfoFailed::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzSearchStoreInfoNextPage {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3808"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzSearchStoreInfoNextPage {
        let mut offset: usize = 0;
        PacketCzSearchStoreInfoNextPage {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzSearchStoreInfoNextPage {
        let packet_id = i16::from_le_bytes([0x38, 0x08]);
        let packet_id_raw = [0x38, 0x08];
        PacketCzSearchStoreInfoNextPage {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzSearchStoreInfoNextPage {
    fn id(&self, packetver: u32) -> &str {
       PacketCzSearchStoreInfoNextPage::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckBanGuildSso {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3908"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckBanGuildSso {
        let mut offset: usize = 0;
        PacketZcAckBanGuildSso {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            char_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            reason_desc: {
                let field =  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[offset..offset + 40].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            reason_desc_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[offset..offset + 40]);
                offset += 40;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason_desc {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_desc_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.char_name_raw.to_vec());
        wtr.append(&mut self.reason_desc_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 66;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_char_name(&mut self, value: [char; 24]) {
        self.char_name = value;
    }
    pub fn set_char_name_raw(&mut self, value: [u8; 24]) {
        self.char_name_raw = value;
    }
    pub fn set_reason_desc(&mut self, value: [char; 40]) {
        self.reason_desc = value;
    }
    pub fn set_reason_desc_raw(&mut self, value: [u8; 40]) {
        self.reason_desc_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckBanGuildSso {
        let packet_id = i16::from_le_bytes([0x39, 0x08]);
        let packet_id_raw = [0x39, 0x08];
        PacketZcAckBanGuildSso {
        raw: vec![],
        packet_id,
        packet_id_raw,
        char_name: [0 as char; 24],
        char_name_raw: [0; 24],
        reason_desc: [0 as char; 40],
        reason_desc_raw: [0; 40],
        }
    }
}

impl Packet for PacketZcAckBanGuildSso {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckBanGuildSso::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcOpenSearchStoreInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3a08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcOpenSearchStoreInfo {
        let mut offset: usize = 0;
        PacketZcOpenSearchStoreInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            open_type: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            open_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            search_cnt_max: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            search_cnt_max_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.open_type).unwrap();
        self.open_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.search_cnt_max).unwrap();
        self.search_cnt_max_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.open_type_raw.to_vec());
        wtr.append(&mut self.search_cnt_max_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_open_type(&mut self, value: i16) {
        self.open_type = value;
    }
    pub fn set_open_type_raw(&mut self, value: [u8; 2]) {
        self.open_type_raw = value;
    }
    pub fn set_search_cnt_max(&mut self, value: u8) {
        self.search_cnt_max = value;
    }
    pub fn set_search_cnt_max_raw(&mut self, value: [u8; 1]) {
        self.search_cnt_max_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcOpenSearchStoreInfo {
        let packet_id = i16::from_le_bytes([0x3a, 0x08]);
        let packet_id_raw = [0x3a, 0x08];
        PacketZcOpenSearchStoreInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        open_type: 0,
        open_type_raw: [0; 2],
        search_cnt_max: 0,
        search_cnt_max_raw: [0; 1],
        }
    }
}

impl Packet for PacketZcOpenSearchStoreInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcOpenSearchStoreInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzCloseSearchStoreInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3b08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzCloseSearchStoreInfo {
        let mut offset: usize = 0;
        PacketCzCloseSearchStoreInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzCloseSearchStoreInfo {
        let packet_id = i16::from_le_bytes([0x3b, 0x08]);
        let packet_id_raw = [0x3b, 0x08];
        PacketCzCloseSearchStoreInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzCloseSearchStoreInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketCzCloseSearchStoreInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzSsilistItemClick {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3c08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzSsilistItemClick {
        let mut offset: usize = 0;
        PacketCzSsilistItemClick {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            ssiid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            ssiid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.ssiid).unwrap();
        self.ssiid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.ssiid_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 12;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_ssiid(&mut self, value: u32) {
        self.ssiid = value;
    }
    pub fn set_ssiid_raw(&mut self, value: [u8; 4]) {
        self.ssiid_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzSsilistItemClick {
        let packet_id = i16::from_le_bytes([0x3c, 0x08]);
        let packet_id_raw = [0x3c, 0x08];
        PacketCzSsilistItemClick {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        ssiid: 0,
        ssiid_raw: [0; 4],
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzSsilistItemClick {
    fn id(&self, packetver: u32) -> &str {
       PacketCzSsilistItemClick::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcSsilistItemClickAck {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3d08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcSsilistItemClickAck {
        let mut offset: usize = 0;
        PacketZcSsilistItemClickAck {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            x: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            x_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            y: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            y_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.x).unwrap();
        self.x_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.y).unwrap();
        self.y_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.x_raw.to_vec());
        wtr.append(&mut self.y_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_x(&mut self, value: i16) {
        self.x = value;
    }
    pub fn set_x_raw(&mut self, value: [u8; 2]) {
        self.x_raw = value;
    }
    pub fn set_y(&mut self, value: i16) {
        self.y = value;
    }
    pub fn set_y_raw(&mut self, value: [u8; 2]) {
        self.y_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcSsilistItemClickAck {
        let packet_id = i16::from_le_bytes([0x3d, 0x08]);
        let packet_id_raw = [0x3d, 0x08];
        PacketZcSsilistItemClickAck {
        raw: vec![],
        packet_id,
        packet_id_raw,
        x: 0,
        x_raw: [0; 2],
        y: 0,
        y_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcSsilistItemClickAck {
    fn id(&self, packetver: u32) -> &str {
       PacketZcSsilistItemClickAck::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketAcRefuseLoginR2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3e08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketAcRefuseLoginR2 {
        let mut offset: usize = 0;
        PacketAcRefuseLoginR2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            error_code: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            error_code_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            block_date: {
                let field =  {
                let mut dst: [char; 20] = [0 as char; 20];
                for (index, byte) in buffer[offset..offset + 20].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            block_date_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[offset..offset + 20]);
                offset += 20;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.error_code).unwrap();
        self.error_code_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.block_date {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.block_date_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.error_code_raw.to_vec());
        wtr.append(&mut self.block_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 26;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_error_code(&mut self, value: u32) {
        self.error_code = value;
    }
    pub fn set_error_code_raw(&mut self, value: [u8; 4]) {
        self.error_code_raw = value;
    }
    pub fn set_block_date(&mut self, value: [char; 20]) {
        self.block_date = value;
    }
    pub fn set_block_date_raw(&mut self, value: [u8; 20]) {
        self.block_date_raw = value;
    }
    pub fn new(packetver: u32) -> PacketAcRefuseLoginR2 {
        let packet_id = i16::from_le_bytes([0x3e, 0x08]);
        let packet_id_raw = [0x3e, 0x08];
        PacketAcRefuseLoginR2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        error_code: 0,
        error_code_raw: [0; 4],
        block_date: [0 as char; 20],
        block_date_raw: [0; 20],
        }
    }
}

impl Packet for PacketAcRefuseLoginR2 {
    fn id(&self, packetver: u32) -> &str {
       PacketAcRefuseLoginR2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketChSelectAccessibleMapname {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4108"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketChSelectAccessibleMapname {
        let mut offset: usize = 0;
        PacketChSelectAccessibleMapname {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            char_num: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            char_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            map_list_num: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            map_list_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.char_num).unwrap();
        self.char_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.map_list_num).unwrap();
        self.map_list_num_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.char_num_raw.to_vec());
        wtr.append(&mut self.map_list_num_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_char_num(&mut self, value: u8) {
        self.char_num = value;
    }
    pub fn set_char_num_raw(&mut self, value: [u8; 1]) {
        self.char_num_raw = value;
    }
    pub fn set_map_list_num(&mut self, value: u8) {
        self.map_list_num = value;
    }
    pub fn set_map_list_num_raw(&mut self, value: [u8; 1]) {
        self.map_list_num_raw = value;
    }
    pub fn new(packetver: u32) -> PacketChSelectAccessibleMapname {
        let packet_id = i16::from_le_bytes([0x41, 0x08]);
        let packet_id_raw = [0x41, 0x08];
        PacketChSelectAccessibleMapname {
        raw: vec![],
        packet_id,
        packet_id_raw,
        char_num: 0,
        char_num_raw: [0; 1],
        map_list_num: 0,
        map_list_num_raw: [0; 1],
        }
    }
}

impl Packet for PacketChSelectAccessibleMapname {
    fn id(&self, packetver: u32) -> &str {
       PacketChSelectAccessibleMapname::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRequestMove2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x5f03"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRequestMove2 {
        let mut offset: usize = 0;
        PacketCzRequestMove2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            dest: {
                let field =  {
                let mut dst: [u16; 3] = [0_u16; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            };
                field
            },
            dest_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[offset..offset + 6]);
                offset += 6;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.dest {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.dest_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.dest_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_dest(&mut self, value: [u16; 3]) {
        self.dest = value;
    }
    pub fn set_dest_raw(&mut self, value: [u8; 6]) {
        self.dest_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRequestMove2 {
        let packet_id = i16::from_le_bytes([0x5f, 0x03]);
        let packet_id_raw = [0x5f, 0x03];
        PacketCzRequestMove2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        dest: [0; 3],
        dest_raw: [0; 6],
        }
    }
}

impl Packet for PacketCzRequestMove2 {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRequestMove2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketChSendMapInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc50a"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketChSendMapInfo {
        let mut offset: usize = 0;
        PacketChSendMapInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            map_name: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            map_server_ip: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            map_server_ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            map_server_port: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            map_server_port_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            dns_host: {
                let field =  {
                let mut dst: [char; 128] = [0 as char; 128];
                for (index, byte) in buffer[offset..offset + 128].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            dns_host_raw: {
                let mut dst: [u8; 128] = [0u8; 128];
                dst.clone_from_slice(&buffer[offset..offset + 128]);
                offset += 128;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.map_server_ip).unwrap();
        self.map_server_ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.map_server_port).unwrap();
        self.map_server_port_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.dns_host {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.dns_host_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.map_server_ip_raw.to_vec());
        wtr.append(&mut self.map_server_port_raw.to_vec());
        wtr.append(&mut self.dns_host_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 156;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_map_server_ip(&mut self, value: u32) {
        self.map_server_ip = value;
    }
    pub fn set_map_server_ip_raw(&mut self, value: [u8; 4]) {
        self.map_server_ip_raw = value;
    }
    pub fn set_map_server_port(&mut self, value: i16) {
        self.map_server_port = value;
    }
    pub fn set_map_server_port_raw(&mut self, value: [u8; 2]) {
        self.map_server_port_raw = value;
    }
    pub fn set_dns_host(&mut self, value: [char; 128]) {
        self.dns_host = value;
    }
    pub fn set_dns_host_raw(&mut self, value: [u8; 128]) {
        self.dns_host_raw = value;
    }
    pub fn new(packetver: u32) -> PacketChSendMapInfo {
        let packet_id = i16::from_le_bytes([0xc5, 0x0a]);
        let packet_id_raw = [0xc5, 0x0a];
        PacketChSendMapInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        map_server_ip: 0,
        map_server_ip_raw: [0; 4],
        map_server_port: 0,
        map_server_port_raw: [0; 2],
        dns_host: [0 as char; 128],
        dns_host_raw: [0; 128],
        }
    }
}

impl Packet for PacketChSendMapInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketChSendMapInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcAcceptEnterNeoUnionHeader {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2d08"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcAcceptEnterNeoUnionHeader {
        let mut offset: usize = 0;
        PacketHcAcceptEnterNeoUnionHeader {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_len: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_len_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            char_slot: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            char_slot_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            max_char: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            max_char_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            premium_slot_start: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            premium_slot_start_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            premium_slot_end: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            premium_slot_end_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            empty_buffer: {
                let field =  {
                let mut dst: [char; 20] = [0 as char; 20];
                for (index, byte) in buffer[offset..offset + 20].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            empty_buffer_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[offset..offset + 20]);
                offset += 20;
                dst
            },
            char_info: {
                let field = PacketHcAcceptEnterNeoUnion::from(&buffer[offset..offset + PacketHcAcceptEnterNeoUnion::base_len(packetver)], packetver);
                field
            },
            char_info_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_len).unwrap();
        self.packet_len_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.char_slot).unwrap();
        self.char_slot_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_char).unwrap();
        self.max_char_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.premium_slot_start).unwrap();
        self.premium_slot_start_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.premium_slot_end).unwrap();
        self.premium_slot_end_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.empty_buffer {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.empty_buffer_raw = wtr.try_into().unwrap();
        self.char_info.fill_raw_with_packetver(packetver);
        self.char_info_raw = self.char_info.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_len_raw.to_vec());
        wtr.append(&mut self.char_slot_raw.to_vec());
        wtr.append(&mut self.max_char_raw.to_vec());
        wtr.append(&mut self.premium_slot_start_raw.to_vec());
        wtr.append(&mut self.premium_slot_end_raw.to_vec());
        wtr.append(&mut self.empty_buffer_raw.to_vec());
        wtr.append(&mut self.char_info_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 28;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_len(&mut self, value: i16) {
        self.packet_len = value;
    }
    pub fn set_packet_len_raw(&mut self, value: [u8; 2]) {
        self.packet_len_raw = value;
    }
    pub fn set_char_slot(&mut self, value: i8) {
        self.char_slot = value;
    }
    pub fn set_char_slot_raw(&mut self, value: [u8; 1]) {
        self.char_slot_raw = value;
    }
    pub fn set_max_char(&mut self, value: i16) {
        self.max_char = value;
    }
    pub fn set_max_char_raw(&mut self, value: [u8; 2]) {
        self.max_char_raw = value;
    }
    pub fn set_premium_slot_start(&mut self, value: i8) {
        self.premium_slot_start = value;
    }
    pub fn set_premium_slot_start_raw(&mut self, value: [u8; 1]) {
        self.premium_slot_start_raw = value;
    }
    pub fn set_premium_slot_end(&mut self, value: i8) {
        self.premium_slot_end = value;
    }
    pub fn set_premium_slot_end_raw(&mut self, value: [u8; 1]) {
        self.premium_slot_end_raw = value;
    }
    pub fn set_empty_buffer(&mut self, value: [char; 20]) {
        self.empty_buffer = value;
    }
    pub fn set_empty_buffer_raw(&mut self, value: [u8; 20]) {
        self.empty_buffer_raw = value;
    }
    pub fn set_char_info(&mut self, value: PacketHcAcceptEnterNeoUnion) {
        self.char_info = value;
    }
    pub fn set_char_info_raw(&mut self, value: Vec<u8>) {
        self.char_info_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcAcceptEnterNeoUnionHeader {
        let packet_id = i16::from_le_bytes([0x2d, 0x08]);
        let packet_id_raw = [0x2d, 0x08];
        PacketHcAcceptEnterNeoUnionHeader {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_len: 0,
        packet_len_raw: [0; 2],
        char_slot: 0,
        char_slot_raw: [0; 1],
        max_char: 0,
        max_char_raw: [0; 2],
        premium_slot_start: 0,
        premium_slot_start_raw: [0; 1],
        premium_slot_end: 0,
        premium_slot_end_raw: [0; 1],
        empty_buffer: [0 as char; 20],
        empty_buffer_raw: [0; 20],
        char_info: PacketHcAcceptEnterNeoUnion::new(packetver),
        char_info_raw: vec![],
        }
    }
}

impl Packet for PacketHcAcceptEnterNeoUnionHeader {
    fn id(&self, packetver: u32) -> &str {
       PacketHcAcceptEnterNeoUnionHeader::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzPing {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8701"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzPing {
        let mut offset: usize = 0;
        PacketCzPing {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzPing {
        let packet_id = i16::from_le_bytes([0x87, 0x01]);
        let packet_id_raw = [0x87, 0x01];
        PacketCzPing {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzPing {
    fn id(&self, packetver: u32) -> &str {
       PacketCzPing::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAid2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8701"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAid2 {
        let mut offset: usize = 0;
        PacketZcAid2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAid2 {
        let packet_id = i16::from_le_bytes([0x87, 0x01]);
        let packet_id_raw = [0x87, 0x01];
        PacketZcAid2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcAid2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAid2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketMapConnection {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8302"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketMapConnection {
        let mut offset: usize = 0;
        PacketMapConnection {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketMapConnection {
        let packet_id = i16::from_le_bytes([0x83, 0x02]);
        let packet_id_raw = [0x83, 0x02];
        PacketMapConnection {
        raw: vec![],
        packet_id,
        packet_id_raw,
        aid: 0,
        aid_raw: [0; 4],
        }
    }
}

impl Packet for PacketMapConnection {
    fn id(&self, packetver: u32) -> &str {
       PacketMapConnection::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketPincodeLoginstate {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xb908"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketPincodeLoginstate {
        let mut offset: usize = 0;
        PacketPincodeLoginstate {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            pincode_seed: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            pincode_seed_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            response: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            response_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.pincode_seed).unwrap();
        self.pincode_seed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.response).unwrap();
        self.response_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.pincode_seed_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.response_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 12;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_pincode_seed(&mut self, value: i32) {
        self.pincode_seed = value;
    }
    pub fn set_pincode_seed_raw(&mut self, value: [u8; 4]) {
        self.pincode_seed_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_response(&mut self, value: i16) {
        self.response = value;
    }
    pub fn set_response_raw(&mut self, value: [u8; 2]) {
        self.response_raw = value;
    }
    pub fn new(packetver: u32) -> PacketPincodeLoginstate {
        let packet_id = i16::from_le_bytes([0xb9, 0x08]);
        let packet_id_raw = [0xb9, 0x08];
        PacketPincodeLoginstate {
        raw: vec![],
        packet_id,
        packet_id_raw,
        pincode_seed: 0,
        pincode_seed_raw: [0; 4],
        aid: 0,
        aid_raw: [0; 4],
        response: 0,
        response_raw: [0; 2],
        }
    }
}

impl Packet for PacketPincodeLoginstate {
    fn id(&self, packetver: u32) -> &str {
       PacketPincodeLoginstate::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketChMakeChar3 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x390a"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketChMakeChar3 {
        let mut offset: usize = 0;
        PacketChMakeChar3 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            char_num: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            char_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            head_pal: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_pal_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            class: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            class_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.char_num).unwrap();
        self.char_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_pal).unwrap();
        self.head_pal_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.class).unwrap();
        self.class_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.char_num_raw.to_vec());
        wtr.append(&mut self.head_pal_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.class_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 36;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_char_num(&mut self, value: u8) {
        self.char_num = value;
    }
    pub fn set_char_num_raw(&mut self, value: [u8; 1]) {
        self.char_num_raw = value;
    }
    pub fn set_head_pal(&mut self, value: i16) {
        self.head_pal = value;
    }
    pub fn set_head_pal_raw(&mut self, value: [u8; 2]) {
        self.head_pal_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_class(&mut self, value: i32) {
        self.class = value;
    }
    pub fn set_class_raw(&mut self, value: [u8; 4]) {
        self.class_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn new(packetver: u32) -> PacketChMakeChar3 {
        let packet_id = i16::from_le_bytes([0x39, 0x0a]);
        let packet_id_raw = [0x39, 0x0a];
        PacketChMakeChar3 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        name: [0 as char; 24],
        name_raw: [0; 24],
        char_num: 0,
        char_num_raw: [0; 1],
        head_pal: 0,
        head_pal_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        class: 0,
        class_raw: [0; 4],
        sex: 0,
        sex_raw: [0; 1],
        }
    }
}

impl Packet for PacketChMakeChar3 {
    fn id(&self, packetver: u32) -> &str {
       PacketChMakeChar3::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketChDeleteChar4Reserved {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2708"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketChDeleteChar4Reserved {
        let mut offset: usize = 0;
        PacketChDeleteChar4Reserved {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketChDeleteChar4Reserved {
        let packet_id = i16::from_le_bytes([0x27, 0x08]);
        let packet_id_raw = [0x27, 0x08];
        PacketChDeleteChar4Reserved {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketChDeleteChar4Reserved {
    fn id(&self, packetver: u32) -> &str {
       PacketChDeleteChar4Reserved::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketHcDeleteChar4Reserved {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x2808"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketHcDeleteChar4Reserved {
        let mut offset: usize = 0;
        PacketHcDeleteChar4Reserved {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            result: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            result_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            delete_reserved_date: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            delete_reserved_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.result).unwrap();
        self.result_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.delete_reserved_date).unwrap();
        self.delete_reserved_date_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.result_raw.to_vec());
        wtr.append(&mut self.delete_reserved_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_result(&mut self, value: i32) {
        self.result = value;
    }
    pub fn set_result_raw(&mut self, value: [u8; 4]) {
        self.result_raw = value;
    }
    pub fn set_delete_reserved_date(&mut self, value: i32) {
        self.delete_reserved_date = value;
    }
    pub fn set_delete_reserved_date_raw(&mut self, value: [u8; 4]) {
        self.delete_reserved_date_raw = value;
    }
    pub fn new(packetver: u32) -> PacketHcDeleteChar4Reserved {
        let packet_id = i16::from_le_bytes([0x28, 0x08]);
        let packet_id_raw = [0x28, 0x08];
        PacketHcDeleteChar4Reserved {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        result: 0,
        result_raw: [0; 4],
        delete_reserved_date: 0,
        delete_reserved_date_raw: [0; 4],
        }
    }
}

impl Packet for PacketHcDeleteChar4Reserved {
    fn id(&self, packetver: u32) -> &str {
       PacketHcDeleteChar4Reserved::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcInventoryExpansionInfo {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x180b"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcInventoryExpansionInfo {
        let mut offset: usize = 0;
        PacketZcInventoryExpansionInfo {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            expansion_size: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            expansion_size_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.expansion_size).unwrap();
        self.expansion_size_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.expansion_size_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_expansion_size(&mut self, value: i16) {
        self.expansion_size = value;
    }
    pub fn set_expansion_size_raw(&mut self, value: [u8; 2]) {
        self.expansion_size_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcInventoryExpansionInfo {
        let packet_id = i16::from_le_bytes([0x18, 0x0b]);
        let packet_id_raw = [0x18, 0x0b];
        PacketZcInventoryExpansionInfo {
        raw: vec![],
        packet_id,
        packet_id_raw,
        expansion_size: 0,
        expansion_size_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcInventoryExpansionInfo {
    fn id(&self, packetver: u32) -> &str {
       PacketZcInventoryExpansionInfo::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcOverweightPercent {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xde0a"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcOverweightPercent {
        let mut offset: usize = 0;
        PacketZcOverweightPercent {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            percent: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            percent_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.percent).unwrap();
        self.percent_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.percent_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_percent(&mut self, value: i32) {
        self.percent = value;
    }
    pub fn set_percent_raw(&mut self, value: [u8; 4]) {
        self.percent_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcOverweightPercent {
        let packet_id = i16::from_le_bytes([0xde, 0x0a]);
        let packet_id_raw = [0xde, 0x0a];
        PacketZcOverweightPercent {
        raw: vec![],
        packet_id,
        packet_id_raw,
        percent: 0,
        percent_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcOverweightPercent {
    fn id(&self, packetver: u32) -> &str {
       PacketZcOverweightPercent::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqDisconnect2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8a01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqDisconnect2 {
        let mut offset: usize = 0;
        PacketCzReqDisconnect2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            empty: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            empty_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.empty).unwrap();
        self.empty_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.empty_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_empty(&mut self, value: i16) {
        self.empty = value;
    }
    pub fn set_empty_raw(&mut self, value: [u8; 2]) {
        self.empty_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqDisconnect2 {
        let packet_id = i16::from_le_bytes([0x8a, 0x01]);
        let packet_id_raw = [0x8a, 0x01];
        PacketCzReqDisconnect2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        empty: 0,
        empty_raw: [0; 2],
        }
    }
}

impl Packet for PacketCzReqDisconnect2 {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqDisconnect2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcReqDisconnectAck2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x8b01"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcReqDisconnectAck2 {
        let mut offset: usize = 0;
        PacketZcReqDisconnectAck2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            empty: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            empty_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.empty).unwrap();
        self.empty_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.empty_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_empty(&mut self, value: i16) {
        self.empty = value;
    }
    pub fn set_empty_raw(&mut self, value: [u8; 2]) {
        self.empty_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcReqDisconnectAck2 {
        let packet_id = i16::from_le_bytes([0x8b, 0x01]);
        let packet_id_raw = [0x8b, 0x01];
        PacketZcReqDisconnectAck2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        empty: 0,
        empty_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcReqDisconnectAck2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcReqDisconnectAck2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzReqnameall2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6803"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzReqnameall2 {
        let mut offset: usize = 0;
        PacketCzReqnameall2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzReqnameall2 {
        let packet_id = i16::from_le_bytes([0x68, 0x03]);
        let packet_id_raw = [0x68, 0x03];
        PacketCzReqnameall2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzReqnameall2 {
    fn id(&self, packetver: u32) -> &str {
       PacketCzReqnameall2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcAckReqnameall2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x300a"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcAckReqnameall2 {
        let mut offset: usize = 0;
        PacketZcAckReqnameall2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            party_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            party_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            guild_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            guild_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            position_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            position_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            title_id: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            title_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.party_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.party_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.guild_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guild_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.position_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.position_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.title_id).unwrap();
        self.title_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.party_name_raw.to_vec());
        wtr.append(&mut self.guild_name_raw.to_vec());
        wtr.append(&mut self.position_name_raw.to_vec());
        wtr.append(&mut self.title_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 106;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_party_name(&mut self, value: [char; 24]) {
        self.party_name = value;
    }
    pub fn set_party_name_raw(&mut self, value: [u8; 24]) {
        self.party_name_raw = value;
    }
    pub fn set_guild_name(&mut self, value: [char; 24]) {
        self.guild_name = value;
    }
    pub fn set_guild_name_raw(&mut self, value: [u8; 24]) {
        self.guild_name_raw = value;
    }
    pub fn set_position_name(&mut self, value: [char; 24]) {
        self.position_name = value;
    }
    pub fn set_position_name_raw(&mut self, value: [u8; 24]) {
        self.position_name_raw = value;
    }
    pub fn set_title_id(&mut self, value: i32) {
        self.title_id = value;
    }
    pub fn set_title_id_raw(&mut self, value: [u8; 4]) {
        self.title_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcAckReqnameall2 {
        let packet_id = i16::from_le_bytes([0x30, 0x0a]);
        let packet_id_raw = [0x30, 0x0a];
        PacketZcAckReqnameall2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        party_name: [0 as char; 24],
        party_name_raw: [0; 24],
        guild_name: [0 as char; 24],
        guild_name_raw: [0; 24],
        position_name: [0 as char; 24],
        position_name_raw: [0; 24],
        title_id: 0,
        title_id_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcAckReqnameall2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcAckReqnameall2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzRequestTime2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x6003"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzRequestTime2 {
        let mut offset: usize = 0;
        PacketCzRequestTime2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            client_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            client_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.client_time).unwrap();
        self.client_time_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.client_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_client_time(&mut self, value: u32) {
        self.client_time = value;
    }
    pub fn set_client_time_raw(&mut self, value: [u8; 4]) {
        self.client_time_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzRequestTime2 {
        let packet_id = i16::from_le_bytes([0x60, 0x03]);
        let packet_id_raw = [0x60, 0x03];
        PacketCzRequestTime2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        client_time: 0,
        client_time_raw: [0; 4],
        }
    }
}

impl Packet for PacketCzRequestTime2 {
    fn id(&self, packetver: u32) -> &str {
       PacketCzRequestTime2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcMsgColor {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xcd09"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMsgColor {
        let mut offset: usize = 0;
        PacketZcMsgColor {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msg_id: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            msg_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            msg_color: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            msg_color_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.msg_id).unwrap();
        self.msg_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.msg_color).unwrap();
        self.msg_color_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.msg_id_raw.to_vec());
        wtr.append(&mut self.msg_color_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_msg_id(&mut self, value: u16) {
        self.msg_id = value;
    }
    pub fn set_msg_id_raw(&mut self, value: [u8; 2]) {
        self.msg_id_raw = value;
    }
    pub fn set_msg_color(&mut self, value: u32) {
        self.msg_color = value;
    }
    pub fn set_msg_color_raw(&mut self, value: [u8; 4]) {
        self.msg_color_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMsgColor {
        let packet_id = i16::from_le_bytes([0xcd, 0x09]);
        let packet_id_raw = [0xcd, 0x09];
        PacketZcMsgColor {
        raw: vec![],
        packet_id,
        packet_id_raw,
        msg_id: 0,
        msg_id_raw: [0; 2],
        msg_color: 0,
        msg_color_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcMsgColor {
    fn id(&self, packetver: u32) -> &str {
       PacketZcMsgColor::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyMapproperty2 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x9b09"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyMapproperty2 {
        let mut offset: usize = 0;
        PacketZcNotifyMapproperty2 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            flags: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            flags_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.flags).unwrap();
        self.flags_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.flags_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_atype(&mut self, value: i16) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 2]) {
        self.atype_raw = value;
    }
    pub fn set_flags(&mut self, value: u32) {
        self.flags = value;
    }
    pub fn set_flags_raw(&mut self, value: [u8; 4]) {
        self.flags_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyMapproperty2 {
        let packet_id = i16::from_le_bytes([0x9b, 0x09]);
        let packet_id_raw = [0x9b, 0x09];
        PacketZcNotifyMapproperty2 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        atype: 0,
        atype_raw: [0; 2],
        flags: 0,
        flags_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyMapproperty2 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyMapproperty2::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcHatEffect {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x3b0a"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcHatEffect {
        let mut offset: usize = 0;
        PacketZcHatEffect {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            len: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            len_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            status: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            status_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            effect: {
                let field =  {
                let dst: Vec<u8> = buffer[offset..buffer.len()].to_vec();
                dst
            };
                field
            },
            effect_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.len).unwrap();
        self.len_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.status).unwrap();
        self.status_raw = wtr.try_into().unwrap();


        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.len_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.status_raw.to_vec());
        wtr.append(&mut self.effect_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_len(&mut self, value: i16) {
        self.len = value;
    }
    pub fn set_len_raw(&mut self, value: [u8; 2]) {
        self.len_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_status(&mut self, value: u8) {
        self.status = value;
    }
    pub fn set_status_raw(&mut self, value: [u8; 1]) {
        self.status_raw = value;
    }
    pub fn set_effect(&mut self, value: Vec<u8>) {
        self.effect = value;
    }
    pub fn set_effect_raw(&mut self, value: Vec<u8>) {
        self.effect_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcHatEffect {
        let packet_id = i16::from_le_bytes([0x3b, 0x0a]);
        let packet_id_raw = [0x3b, 0x0a];
        PacketZcHatEffect {
        raw: vec![],
        packet_id,
        packet_id_raw,
        len: 0,
        len_raw: [0; 2],
        aid: 0,
        aid_raw: [0; 4],
        status: 0,
        status_raw: [0; 1],
        effect: vec![],
        effect_raw: vec![],
        }
    }
}

impl Packet for PacketZcHatEffect {
    fn id(&self, packetver: u32) -> &str {
       PacketZcHatEffect::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketCzBlockingPlayCancel {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x4704"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketCzBlockingPlayCancel {
        let mut offset: usize = 0;
        PacketCzBlockingPlayCancel {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketCzBlockingPlayCancel {
        let packet_id = i16::from_le_bytes([0x47, 0x04]);
        let packet_id_raw = [0x47, 0x04];
        PacketCzBlockingPlayCancel {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketCzBlockingPlayCancel {
    fn id(&self, packetver: u32) -> &str {
       PacketCzBlockingPlayCancel::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcLoadConfirm {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1B0B"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcLoadConfirm {
        let mut offset: usize = 0;
        PacketZcLoadConfirm {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcLoadConfirm {
        let packet_id = i16::from_le_bytes([0x1B, 0x0B]);
        let packet_id_raw = [0x1B, 0x0B];
        PacketZcLoadConfirm {
        raw: vec![],
        packet_id,
        packet_id_raw,
        }
    }
}

impl Packet for PacketZcLoadConfirm {
    fn id(&self, packetver: u32) -> &str {
       PacketZcLoadConfirm::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyStandentry6 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xff09"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyStandentry6 {
        let mut offset: usize = 0;
        PacketZcNotifyStandentry6 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            objecttype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            shield: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            shield_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory2: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            robe: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            robe_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gemblem_ver: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            honor: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            virtue: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            pos_dir: {
                let field =  {
                let mut dst: [u8; 3] = [0_u8; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[offset..offset + 3]);
                offset += 3;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            state: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            clevel: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            font: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            max_hp: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            max_hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            hp: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_boss: {
                let field = buffer[offset] == 1;
                field
            },
            is_boss_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            body: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.robe).unwrap();
        self.robe_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_boss as u8).unwrap();
        self.is_boss_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body).unwrap();
        self.body_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.objecttype_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.shield_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.robe_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        wtr.append(&mut self.font_raw.to_vec());
        wtr.append(&mut self.max_hp_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.is_boss_raw.to_vec());
        wtr.append(&mut self.body_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 108;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_objecttype(&mut self, value: u8) {
        self.objecttype = value;
    }
    pub fn set_objecttype_raw(&mut self, value: [u8; 1]) {
        self.objecttype_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: u32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: u16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_shield(&mut self, value: u32) {
        self.shield = value;
    }
    pub fn set_shield_raw(&mut self, value: [u8; 4]) {
        self.shield_raw = value;
    }
    pub fn set_accessory2(&mut self, value: u16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: u16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: u16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: u16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: u16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_robe(&mut self, value: u16) {
        self.robe = value;
    }
    pub fn set_robe_raw(&mut self, value: [u8; 2]) {
        self.robe_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [u8; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_state(&mut self, value: u8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn set_font(&mut self, value: i16) {
        self.font = value;
    }
    pub fn set_font_raw(&mut self, value: [u8; 2]) {
        self.font_raw = value;
    }
    pub fn set_max_hp(&mut self, value: u32) {
        self.max_hp = value;
    }
    pub fn set_max_hp_raw(&mut self, value: [u8; 4]) {
        self.max_hp_raw = value;
    }
    pub fn set_hp(&mut self, value: u32) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 4]) {
        self.hp_raw = value;
    }
    pub fn set_is_boss(&mut self, value: bool) {
        self.is_boss = value;
    }
    pub fn set_is_boss_raw(&mut self, value: [u8; 1]) {
        self.is_boss_raw = value;
    }
    pub fn set_body(&mut self, value: i16) {
        self.body = value;
    }
    pub fn set_body_raw(&mut self, value: [u8; 2]) {
        self.body_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyStandentry6 {
        let packet_id = i16::from_le_bytes([0xff, 0x09]);
        let packet_id_raw = [0xff, 0x09];
        PacketZcNotifyStandentry6 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        objecttype: 0,
        objecttype_raw: [0; 1],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        shield: 0,
        shield_raw: [0; 4],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        robe: 0,
        robe_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        state: 0,
        state_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        font: 0,
        font_raw: [0; 2],
        max_hp: 0,
        max_hp_raw: [0; 4],
        hp: 0,
        hp_raw: [0; 4],
        is_boss: false,
        is_boss_raw: [0; 1],
        body: 0,
        body_raw: [0; 2],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcNotifyStandentry6 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyStandentry6::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyStandentry7 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0x1509"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyStandentry7 {
        let mut offset: usize = 0;
        PacketZcNotifyStandentry7 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = if packetver >= 20091103 {
                   i16::from_le_bytes([buffer[offset], buffer[offset + 1]])
                } else {
                   0 as i16
                };
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                if packetver >= 20091103 {
                    dst.clone_from_slice(&buffer[offset..offset + 2]);
                    offset += 2;
                }
                dst
            },
            objecttype: {
                let field = if packetver >= 20091103 {
                   u8::from_le_bytes([buffer[offset]])
                } else {
                   0 as u8
                };
                field
            },
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                if packetver >= 20091103 {
                    dst.clone_from_slice(&buffer[offset..offset + 1]);
                    offset += 1;
                }
                dst
            },
            aid: {
                let field = if packetver >= 20131223 {
                   u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]])
                } else {
                   0 as u32
                };
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                if packetver >= 20131223 {
                    dst.clone_from_slice(&buffer[offset..offset + 4]);
                    offset += 4;
                }
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            shield: {
                let field = if packetver >= 20181121 {
                   u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]])
                } else {
                   0 as u32
                };
                field
            },
            shield_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                if packetver >= 20181121 {
                    dst.clone_from_slice(&buffer[offset..offset + 4]);
                    offset += 4;
                }
                dst
            },
            accessory2: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            robe: {
                let field = if packetver >= 20101124 {
                   u16::from_le_bytes([buffer[offset], buffer[offset + 1]])
                } else {
                   0 as u16
                };
                field
            },
            robe_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                if packetver >= 20101124 {
                    dst.clone_from_slice(&buffer[offset..offset + 2]);
                    offset += 2;
                }
                dst
            },
            guid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gemblem_ver: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            honor: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            virtue: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            pos_dir: {
                let field =  {
                let mut dst: [u8; 3] = [0_u8; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[offset..offset + 3]);
                offset += 3;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            state: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            clevel: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            font: {
                let field = if packetver >= 20080102 {
                   i16::from_le_bytes([buffer[offset], buffer[offset + 1]])
                } else {
                   0 as i16
                };
                field
            },
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                if packetver >= 20080102 {
                    dst.clone_from_slice(&buffer[offset..offset + 2]);
                    offset += 2;
                }
                dst
            },
            max_hp: {
                let field = if packetver >= 20120221 {
                   u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]])
                } else {
                   0 as u32
                };
                field
            },
            max_hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                if packetver >= 20120221 {
                    dst.clone_from_slice(&buffer[offset..offset + 4]);
                    offset += 4;
                }
                dst
            },
            hp: {
                let field = if packetver >= 20120221 {
                   u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]])
                } else {
                   0 as u32
                };
                field
            },
            hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                if packetver >= 20120221 {
                    dst.clone_from_slice(&buffer[offset..offset + 4]);
                    offset += 4;
                }
                dst
            },
            is_boss: {
                let field = if packetver >= 20120221 {
                   buffer[offset] == 1
                } else {
                   false
                };
                field
            },
            is_boss_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                if packetver >= 20120221 {
                    dst.clone_from_slice(&buffer[offset..offset + 1]);
                    offset += 1;
                }
                dst
            },
            body: {
                let field = if packetver >= 20150513 {
                   i16::from_le_bytes([buffer[offset], buffer[offset + 1]])
                } else {
                   0 as i16
                };
                field
            },
            body_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                if packetver >= 20150513 {
                    dst.clone_from_slice(&buffer[offset..offset + 2]);
                    offset += 2;
                }
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.robe).unwrap();
        self.robe_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_boss as u8).unwrap();
        self.is_boss_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body).unwrap();
        self.body_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        if packetver.is_none() {
          wtr.append(&mut self.packet_length_raw.to_vec());
        } else if packetver.unwrap() >= 20091103 {
            wtr.append(&mut self.packet_length_raw.to_vec());
        }
        if packetver.is_none() {
          wtr.append(&mut self.objecttype_raw.to_vec());
        } else if packetver.unwrap() >= 20091103 {
            wtr.append(&mut self.objecttype_raw.to_vec());
        }
        if packetver.is_none() {
          wtr.append(&mut self.aid_raw.to_vec());
        } else if packetver.unwrap() >= 20131223 {
            wtr.append(&mut self.aid_raw.to_vec());
        }
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        if packetver.is_none() {
          wtr.append(&mut self.shield_raw.to_vec());
        } else if packetver.unwrap() >= 20181121 {
            wtr.append(&mut self.shield_raw.to_vec());
        }
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        if packetver.is_none() {
          wtr.append(&mut self.robe_raw.to_vec());
        } else if packetver.unwrap() >= 20101124 {
            wtr.append(&mut self.robe_raw.to_vec());
        }
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        if packetver.is_none() {
          wtr.append(&mut self.font_raw.to_vec());
        } else if packetver.unwrap() >= 20080102 {
            wtr.append(&mut self.font_raw.to_vec());
        }
        if packetver.is_none() {
          wtr.append(&mut self.max_hp_raw.to_vec());
        } else if packetver.unwrap() >= 20120221 {
            wtr.append(&mut self.max_hp_raw.to_vec());
        }
        if packetver.is_none() {
          wtr.append(&mut self.hp_raw.to_vec());
        } else if packetver.unwrap() >= 20120221 {
            wtr.append(&mut self.hp_raw.to_vec());
        }
        if packetver.is_none() {
          wtr.append(&mut self.is_boss_raw.to_vec());
        } else if packetver.unwrap() >= 20120221 {
            wtr.append(&mut self.is_boss_raw.to_vec());
        }
        if packetver.is_none() {
          wtr.append(&mut self.body_raw.to_vec());
        } else if packetver.unwrap() >= 20150513 {
            wtr.append(&mut self.body_raw.to_vec());
        }
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let mut base_len: usize = 58;
        if packetver >= 20091103 {
            base_len += 2;
        }
        if packetver >= 20091103 {
            base_len += 1;
        }
        if packetver >= 20131223 {
            base_len += 4;
        }
        if packetver >= 20181121 {
            base_len += 4;
        }
        if packetver >= 20101124 {
            base_len += 2;
        }
        if packetver >= 20080102 {
            base_len += 2;
        }
        if packetver >= 20120221 {
            base_len += 4;
        }
        if packetver >= 20120221 {
            base_len += 4;
        }
        if packetver >= 20120221 {
            base_len += 1;
        }
        if packetver >= 20150513 {
            base_len += 2;
        }
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_objecttype(&mut self, value: u8) {
        self.objecttype = value;
    }
    pub fn set_objecttype_raw(&mut self, value: [u8; 1]) {
        self.objecttype_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: u32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: u16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_shield(&mut self, value: u32) {
        self.shield = value;
    }
    pub fn set_shield_raw(&mut self, value: [u8; 4]) {
        self.shield_raw = value;
    }
    pub fn set_accessory2(&mut self, value: u16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: u16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: u16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: u16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: u16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_robe(&mut self, value: u16) {
        self.robe = value;
    }
    pub fn set_robe_raw(&mut self, value: [u8; 2]) {
        self.robe_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [u8; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_state(&mut self, value: u8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn set_font(&mut self, value: i16) {
        self.font = value;
    }
    pub fn set_font_raw(&mut self, value: [u8; 2]) {
        self.font_raw = value;
    }
    pub fn set_max_hp(&mut self, value: u32) {
        self.max_hp = value;
    }
    pub fn set_max_hp_raw(&mut self, value: [u8; 4]) {
        self.max_hp_raw = value;
    }
    pub fn set_hp(&mut self, value: u32) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 4]) {
        self.hp_raw = value;
    }
    pub fn set_is_boss(&mut self, value: bool) {
        self.is_boss = value;
    }
    pub fn set_is_boss_raw(&mut self, value: [u8; 1]) {
        self.is_boss_raw = value;
    }
    pub fn set_body(&mut self, value: i16) {
        self.body = value;
    }
    pub fn set_body_raw(&mut self, value: [u8; 2]) {
        self.body_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyStandentry7 {
        let packet_id = i16::from_le_bytes([0x15, 0x09]);
        let packet_id_raw = [0x15, 0x09];
        PacketZcNotifyStandentry7 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        objecttype: 0,
        objecttype_raw: [0; 1],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        shield: 0,
        shield_raw: [0; 4],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        robe: 0,
        robe_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        state: 0,
        state_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        font: 0,
        font_raw: [0; 2],
        max_hp: 0,
        max_hp_raw: [0; 4],
        hp: 0,
        hp_raw: [0; 4],
        is_boss: false,
        is_boss_raw: [0; 1],
        body: 0,
        body_raw: [0; 2],
        }
    }
}

impl Packet for PacketZcNotifyStandentry7 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyStandentry7::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyMoveentry8 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xfd09"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyMoveentry8 {
        let mut offset: usize = 0;
        PacketZcNotifyMoveentry8 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            packet_length: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_length_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            objecttype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            objecttype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            speed: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            health_state: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            health_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            effect_state: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            effect_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            weapon: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            move_start_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            move_start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            shield: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            shield_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            accessory2: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            accessory3: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            accessory3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            headpalette: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            headpalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            bodypalette: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bodypalette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_dir: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_dir_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            robe: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            robe_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            guid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gemblem_ver: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            gemblem_ver_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            honor: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            virtue: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_pkmode_on: {
                let field = buffer[offset] == 1;
                field
            },
            is_pkmode_on_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            sex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            pos_dir: {
                let field =  {
                let mut dst: [u8; 3] = [0_u8; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u8;
                }
                dst
            };
                field
            },
            pos_dir_raw: {
                let mut dst: [u8; 3] = [0u8; 3];
                dst.clone_from_slice(&buffer[offset..offset + 3]);
                offset += 3;
                dst
            },
            x_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            x_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            y_size: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            y_size_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            clevel: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            clevel_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            font: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            font_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            max_hp: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            max_hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            hp: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_boss: {
                let field = buffer[offset] == 1;
                field
            },
            is_boss_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            body: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_length).unwrap();
        self.packet_length_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.objecttype).unwrap();
        self.objecttype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body_state).unwrap();
        self.body_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.health_state).unwrap();
        self.health_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effect_state).unwrap();
        self.effect_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.accessory).unwrap();
        self.accessory_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.move_start_time).unwrap();
        self.move_start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.accessory2).unwrap();
        self.accessory2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.accessory3).unwrap();
        self.accessory3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.headpalette).unwrap();
        self.headpalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.bodypalette).unwrap();
        self.bodypalette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.head_dir).unwrap();
        self.head_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.robe).unwrap();
        self.robe_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.guid).unwrap();
        self.guid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.gemblem_ver).unwrap();
        self.gemblem_ver_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_pkmode_on as u8).unwrap();
        self.is_pkmode_on_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_dir {
            wtr.write_u8(item).unwrap();
        }
        self.pos_dir_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.x_size).unwrap();
        self.x_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.y_size).unwrap();
        self.y_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.clevel).unwrap();
        self.clevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.font).unwrap();
        self.font_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.max_hp).unwrap();
        self.max_hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_boss as u8).unwrap();
        self.is_boss_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.body).unwrap();
        self.body_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.packet_length_raw.to_vec());
        wtr.append(&mut self.objecttype_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.body_state_raw.to_vec());
        wtr.append(&mut self.health_state_raw.to_vec());
        wtr.append(&mut self.effect_state_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.accessory_raw.to_vec());
        wtr.append(&mut self.move_start_time_raw.to_vec());
        wtr.append(&mut self.shield_raw.to_vec());
        wtr.append(&mut self.accessory2_raw.to_vec());
        wtr.append(&mut self.accessory3_raw.to_vec());
        wtr.append(&mut self.headpalette_raw.to_vec());
        wtr.append(&mut self.bodypalette_raw.to_vec());
        wtr.append(&mut self.head_dir_raw.to_vec());
        wtr.append(&mut self.robe_raw.to_vec());
        wtr.append(&mut self.guid_raw.to_vec());
        wtr.append(&mut self.gemblem_ver_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.is_pkmode_on_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.pos_dir_raw.to_vec());
        wtr.append(&mut self.x_size_raw.to_vec());
        wtr.append(&mut self.y_size_raw.to_vec());
        wtr.append(&mut self.clevel_raw.to_vec());
        wtr.append(&mut self.font_raw.to_vec());
        wtr.append(&mut self.max_hp_raw.to_vec());
        wtr.append(&mut self.hp_raw.to_vec());
        wtr.append(&mut self.is_boss_raw.to_vec());
        wtr.append(&mut self.body_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 111;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_packet_length(&mut self, value: i16) {
        self.packet_length = value;
    }
    pub fn set_packet_length_raw(&mut self, value: [u8; 2]) {
        self.packet_length_raw = value;
    }
    pub fn set_objecttype(&mut self, value: u8) {
        self.objecttype = value;
    }
    pub fn set_objecttype_raw(&mut self, value: [u8; 1]) {
        self.objecttype_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_speed(&mut self, value: i16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_body_state(&mut self, value: i16) {
        self.body_state = value;
    }
    pub fn set_body_state_raw(&mut self, value: [u8; 2]) {
        self.body_state_raw = value;
    }
    pub fn set_health_state(&mut self, value: i16) {
        self.health_state = value;
    }
    pub fn set_health_state_raw(&mut self, value: [u8; 2]) {
        self.health_state_raw = value;
    }
    pub fn set_effect_state(&mut self, value: i32) {
        self.effect_state = value;
    }
    pub fn set_effect_state_raw(&mut self, value: [u8; 4]) {
        self.effect_state_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_weapon(&mut self, value: u32) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 4]) {
        self.weapon_raw = value;
    }
    pub fn set_accessory(&mut self, value: u16) {
        self.accessory = value;
    }
    pub fn set_accessory_raw(&mut self, value: [u8; 2]) {
        self.accessory_raw = value;
    }
    pub fn set_move_start_time(&mut self, value: u32) {
        self.move_start_time = value;
    }
    pub fn set_move_start_time_raw(&mut self, value: [u8; 4]) {
        self.move_start_time_raw = value;
    }
    pub fn set_shield(&mut self, value: u32) {
        self.shield = value;
    }
    pub fn set_shield_raw(&mut self, value: [u8; 4]) {
        self.shield_raw = value;
    }
    pub fn set_accessory2(&mut self, value: u16) {
        self.accessory2 = value;
    }
    pub fn set_accessory2_raw(&mut self, value: [u8; 2]) {
        self.accessory2_raw = value;
    }
    pub fn set_accessory3(&mut self, value: u16) {
        self.accessory3 = value;
    }
    pub fn set_accessory3_raw(&mut self, value: [u8; 2]) {
        self.accessory3_raw = value;
    }
    pub fn set_headpalette(&mut self, value: u16) {
        self.headpalette = value;
    }
    pub fn set_headpalette_raw(&mut self, value: [u8; 2]) {
        self.headpalette_raw = value;
    }
    pub fn set_bodypalette(&mut self, value: u16) {
        self.bodypalette = value;
    }
    pub fn set_bodypalette_raw(&mut self, value: [u8; 2]) {
        self.bodypalette_raw = value;
    }
    pub fn set_head_dir(&mut self, value: u16) {
        self.head_dir = value;
    }
    pub fn set_head_dir_raw(&mut self, value: [u8; 2]) {
        self.head_dir_raw = value;
    }
    pub fn set_robe(&mut self, value: u16) {
        self.robe = value;
    }
    pub fn set_robe_raw(&mut self, value: [u8; 2]) {
        self.robe_raw = value;
    }
    pub fn set_guid(&mut self, value: u32) {
        self.guid = value;
    }
    pub fn set_guid_raw(&mut self, value: [u8; 4]) {
        self.guid_raw = value;
    }
    pub fn set_gemblem_ver(&mut self, value: i16) {
        self.gemblem_ver = value;
    }
    pub fn set_gemblem_ver_raw(&mut self, value: [u8; 2]) {
        self.gemblem_ver_raw = value;
    }
    pub fn set_honor(&mut self, value: i16) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 2]) {
        self.honor_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_is_pkmode_on(&mut self, value: bool) {
        self.is_pkmode_on = value;
    }
    pub fn set_is_pkmode_on_raw(&mut self, value: [u8; 1]) {
        self.is_pkmode_on_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn set_pos_dir(&mut self, value: [u8; 3]) {
        self.pos_dir = value;
    }
    pub fn set_pos_dir_raw(&mut self, value: [u8; 3]) {
        self.pos_dir_raw = value;
    }
    pub fn set_x_size(&mut self, value: u8) {
        self.x_size = value;
    }
    pub fn set_x_size_raw(&mut self, value: [u8; 1]) {
        self.x_size_raw = value;
    }
    pub fn set_y_size(&mut self, value: u8) {
        self.y_size = value;
    }
    pub fn set_y_size_raw(&mut self, value: [u8; 1]) {
        self.y_size_raw = value;
    }
    pub fn set_clevel(&mut self, value: i16) {
        self.clevel = value;
    }
    pub fn set_clevel_raw(&mut self, value: [u8; 2]) {
        self.clevel_raw = value;
    }
    pub fn set_font(&mut self, value: i16) {
        self.font = value;
    }
    pub fn set_font_raw(&mut self, value: [u8; 2]) {
        self.font_raw = value;
    }
    pub fn set_max_hp(&mut self, value: u32) {
        self.max_hp = value;
    }
    pub fn set_max_hp_raw(&mut self, value: [u8; 4]) {
        self.max_hp_raw = value;
    }
    pub fn set_hp(&mut self, value: u32) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 4]) {
        self.hp_raw = value;
    }
    pub fn set_is_boss(&mut self, value: bool) {
        self.is_boss = value;
    }
    pub fn set_is_boss_raw(&mut self, value: [u8; 1]) {
        self.is_boss_raw = value;
    }
    pub fn set_body(&mut self, value: i16) {
        self.body = value;
    }
    pub fn set_body_raw(&mut self, value: [u8; 2]) {
        self.body_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyMoveentry8 {
        let packet_id = i16::from_le_bytes([0xfd, 0x09]);
        let packet_id_raw = [0xfd, 0x09];
        PacketZcNotifyMoveentry8 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        packet_length: 0,
        packet_length_raw: [0; 2],
        objecttype: 0,
        objecttype_raw: [0; 1],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        speed: 0,
        speed_raw: [0; 2],
        body_state: 0,
        body_state_raw: [0; 2],
        health_state: 0,
        health_state_raw: [0; 2],
        effect_state: 0,
        effect_state_raw: [0; 4],
        job: 0,
        job_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 4],
        accessory: 0,
        accessory_raw: [0; 2],
        move_start_time: 0,
        move_start_time_raw: [0; 4],
        shield: 0,
        shield_raw: [0; 4],
        accessory2: 0,
        accessory2_raw: [0; 2],
        accessory3: 0,
        accessory3_raw: [0; 2],
        headpalette: 0,
        headpalette_raw: [0; 2],
        bodypalette: 0,
        bodypalette_raw: [0; 2],
        head_dir: 0,
        head_dir_raw: [0; 2],
        robe: 0,
        robe_raw: [0; 2],
        guid: 0,
        guid_raw: [0; 4],
        gemblem_ver: 0,
        gemblem_ver_raw: [0; 2],
        honor: 0,
        honor_raw: [0; 2],
        virtue: 0,
        virtue_raw: [0; 4],
        is_pkmode_on: false,
        is_pkmode_on_raw: [0; 1],
        sex: 0,
        sex_raw: [0; 1],
        pos_dir: [0; 3],
        pos_dir_raw: [0; 3],
        x_size: 0,
        x_size_raw: [0; 1],
        y_size: 0,
        y_size_raw: [0; 1],
        clevel: 0,
        clevel_raw: [0; 2],
        font: 0,
        font_raw: [0; 2],
        max_hp: 0,
        max_hp_raw: [0; 4],
        hp: 0,
        hp_raw: [0; 4],
        is_boss: false,
        is_boss_raw: [0; 1],
        body: 0,
        body_raw: [0; 2],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl Packet for PacketZcNotifyMoveentry8 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyMoveentry8::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl PacketZcNotifyAct3 {
    pub fn packet_id(packetver: u32) -> &'static str {
        "0xc808"
    }
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcNotifyAct3 {
        let mut offset: usize = 0;
        PacketZcNotifyAct3 {
            packet_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            packet_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            target_gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            target_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            start_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            start_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            attack_mt: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            attack_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            attacked_mt: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            attacked_mt_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            damage: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            damage_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            is_sp_damaged: {
                let field = buffer[offset] == 1;
                field
            },
            is_sp_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            action: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            action_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            left_damage: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            left_damage_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.packet_id).unwrap();
        self.packet_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.target_gid).unwrap();
        self.target_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.start_time).unwrap();
        self.start_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attack_mt).unwrap();
        self.attack_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.attacked_mt).unwrap();
        self.attacked_mt_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.damage).unwrap();
        self.damage_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_sp_damaged as u8).unwrap();
        self.is_sp_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.action).unwrap();
        self.action_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.left_damage).unwrap();
        self.left_damage_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.packet_id_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.target_gid_raw.to_vec());
        wtr.append(&mut self.start_time_raw.to_vec());
        wtr.append(&mut self.attack_mt_raw.to_vec());
        wtr.append(&mut self.attacked_mt_raw.to_vec());
        wtr.append(&mut self.damage_raw.to_vec());
        wtr.append(&mut self.is_sp_damaged_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.action_raw.to_vec());
        wtr.append(&mut self.left_damage_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 34;
        base_len
    }
    pub fn set_packet_id(&mut self, value: i16) {
        self.packet_id = value;
    }
    pub fn set_packet_id_raw(&mut self, value: [u8; 2]) {
        self.packet_id_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_target_gid(&mut self, value: u32) {
        self.target_gid = value;
    }
    pub fn set_target_gid_raw(&mut self, value: [u8; 4]) {
        self.target_gid_raw = value;
    }
    pub fn set_start_time(&mut self, value: u32) {
        self.start_time = value;
    }
    pub fn set_start_time_raw(&mut self, value: [u8; 4]) {
        self.start_time_raw = value;
    }
    pub fn set_attack_mt(&mut self, value: i32) {
        self.attack_mt = value;
    }
    pub fn set_attack_mt_raw(&mut self, value: [u8; 4]) {
        self.attack_mt_raw = value;
    }
    pub fn set_attacked_mt(&mut self, value: i32) {
        self.attacked_mt = value;
    }
    pub fn set_attacked_mt_raw(&mut self, value: [u8; 4]) {
        self.attacked_mt_raw = value;
    }
    pub fn set_damage(&mut self, value: i32) {
        self.damage = value;
    }
    pub fn set_damage_raw(&mut self, value: [u8; 4]) {
        self.damage_raw = value;
    }
    pub fn set_is_sp_damaged(&mut self, value: bool) {
        self.is_sp_damaged = value;
    }
    pub fn set_is_sp_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_sp_damaged_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_action(&mut self, value: u8) {
        self.action = value;
    }
    pub fn set_action_raw(&mut self, value: [u8; 1]) {
        self.action_raw = value;
    }
    pub fn set_left_damage(&mut self, value: i32) {
        self.left_damage = value;
    }
    pub fn set_left_damage_raw(&mut self, value: [u8; 4]) {
        self.left_damage_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcNotifyAct3 {
        let packet_id = i16::from_le_bytes([0xc8, 0x08]);
        let packet_id_raw = [0xc8, 0x08];
        PacketZcNotifyAct3 {
        raw: vec![],
        packet_id,
        packet_id_raw,
        gid: 0,
        gid_raw: [0; 4],
        target_gid: 0,
        target_gid_raw: [0; 4],
        start_time: 0,
        start_time_raw: [0; 4],
        attack_mt: 0,
        attack_mt_raw: [0; 4],
        attacked_mt: 0,
        attacked_mt_raw: [0; 4],
        damage: 0,
        damage_raw: [0; 4],
        is_sp_damaged: false,
        is_sp_damaged_raw: [0; 1],
        count: 0,
        count_raw: [0; 2],
        action: 0,
        action_raw: [0; 1],
        left_damage: 0,
        left_damage_raw: [0; 4],
        }
    }
}

impl Packet for PacketZcNotifyAct3 {
    fn id(&self, packetver: u32) -> &str {
       PacketZcNotifyAct3::packet_id(packetver)
    }
    fn debug(&self) {
            println!("{:?}", self)
    }
    fn display(&self) {
            println!("{}", self)
    }
    fn pretty_debug(&self) {
            println!("{:#?}", self)
    }
    fn raw(&self) -> &Vec<u8> {
            &self.raw
    }
    fn raw_mut(&mut self) -> &mut Vec<u8> {
            &mut self.raw
    }
    fn as_any(&self) -> &dyn Any{
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any{
        self
    }
    fn base_len(&self, packetver: u32) -> usize {
        Self::base_len(packetver)
    }
}

impl ServerAddr {
    pub fn from(buffer: &[u8], packetver: u32) -> ServerAddr {
        let mut offset: usize = 0;
        ServerAddr {
            ip: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            port: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            port_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 20] = [0 as char; 20];
                for (index, byte) in buffer[offset..offset + 20].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[offset..offset + 20]);
                offset += 20;
                dst
            },
            user_count: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            user_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            state: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            property: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            property_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.ip).unwrap();
        self.ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.port).unwrap();
        self.port_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.user_count).unwrap();
        self.user_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.property).unwrap();
        self.property_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.ip_raw.to_vec());
        wtr.append(&mut self.port_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.user_count_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.property_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 32;
        base_len
    }
    pub fn set_ip(&mut self, value: u32) {
        self.ip = value;
    }
    pub fn set_ip_raw(&mut self, value: [u8; 4]) {
        self.ip_raw = value;
    }
    pub fn set_port(&mut self, value: i16) {
        self.port = value;
    }
    pub fn set_port_raw(&mut self, value: [u8; 2]) {
        self.port_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 20]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 20]) {
        self.name_raw = value;
    }
    pub fn set_user_count(&mut self, value: u16) {
        self.user_count = value;
    }
    pub fn set_user_count_raw(&mut self, value: [u8; 2]) {
        self.user_count_raw = value;
    }
    pub fn set_state(&mut self, value: u16) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 2]) {
        self.state_raw = value;
    }
    pub fn set_property(&mut self, value: u16) {
        self.property = value;
    }
    pub fn set_property_raw(&mut self, value: [u8; 2]) {
        self.property_raw = value;
    }
    pub fn new(packetver: u32) -> ServerAddr {
        ServerAddr {
        raw: vec![],
        ip: 0,
        ip_raw: [0; 4],
        port: 0,
        port_raw: [0; 2],
        name: [0 as char; 20],
        name_raw: [0; 20],
        user_count: 0,
        user_count_raw: [0; 2],
        state: 0,
        state_raw: [0; 2],
        property: 0,
        property_raw: [0; 2],
        }
    }
}

impl ServerAddr2 {
    pub fn from(buffer: &[u8], packetver: u32) -> ServerAddr2 {
        let mut offset: usize = 0;
        ServerAddr2 {
            ip: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            port: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            port_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 20] = [0 as char; 20];
                for (index, byte) in buffer[offset..offset + 20].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[offset..offset + 20]);
                offset += 20;
                dst
            },
            user_count: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            user_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            state: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            property: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            property_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            unknown2: {
                let field =  {
                let mut dst: [char; 128] = [0 as char; 128];
                for (index, byte) in buffer[offset..offset + 128].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            unknown2_raw: {
                let mut dst: [u8; 128] = [0u8; 128];
                dst.clone_from_slice(&buffer[offset..offset + 128]);
                offset += 128;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.ip).unwrap();
        self.ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.port).unwrap();
        self.port_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.user_count).unwrap();
        self.user_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.property).unwrap();
        self.property_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.unknown2 {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.unknown2_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.ip_raw.to_vec());
        wtr.append(&mut self.port_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.user_count_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        wtr.append(&mut self.property_raw.to_vec());
        wtr.append(&mut self.unknown2_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 160;
        base_len
    }
    pub fn set_ip(&mut self, value: u32) {
        self.ip = value;
    }
    pub fn set_ip_raw(&mut self, value: [u8; 4]) {
        self.ip_raw = value;
    }
    pub fn set_port(&mut self, value: i16) {
        self.port = value;
    }
    pub fn set_port_raw(&mut self, value: [u8; 2]) {
        self.port_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 20]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 20]) {
        self.name_raw = value;
    }
    pub fn set_user_count(&mut self, value: u16) {
        self.user_count = value;
    }
    pub fn set_user_count_raw(&mut self, value: [u8; 2]) {
        self.user_count_raw = value;
    }
    pub fn set_state(&mut self, value: u16) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 2]) {
        self.state_raw = value;
    }
    pub fn set_property(&mut self, value: u16) {
        self.property = value;
    }
    pub fn set_property_raw(&mut self, value: [u8; 2]) {
        self.property_raw = value;
    }
    pub fn set_unknown2(&mut self, value: [char; 128]) {
        self.unknown2 = value;
    }
    pub fn set_unknown2_raw(&mut self, value: [u8; 128]) {
        self.unknown2_raw = value;
    }
    pub fn new(packetver: u32) -> ServerAddr2 {
        ServerAddr2 {
        raw: vec![],
        ip: 0,
        ip_raw: [0; 4],
        port: 0,
        port_raw: [0; 2],
        name: [0 as char; 20],
        name_raw: [0; 20],
        user_count: 0,
        user_count_raw: [0; 2],
        state: 0,
        state_raw: [0; 2],
        property: 0,
        property_raw: [0; 2],
        unknown2: [0 as char; 128],
        unknown2_raw: [0; 128],
        }
    }
}

impl CharacterInfoNeoUnion {
    pub fn from(buffer: &[u8], packetver: u32) -> CharacterInfoNeoUnion {
        let mut offset: usize = 0;
        CharacterInfoNeoUnion {
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            exp_64: {
                let field = if packetver >= 20170830 {
                   u64::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3], buffer[offset + 4], buffer[offset + 5], buffer[offset + 6], buffer[offset + 7]])
                } else {
                   0 as u64
                };
                field
            },
            exp_64_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                if packetver >= 20170830 {
                    dst.clone_from_slice(&buffer[offset..offset + 8]);
                    offset += 8;
                }
                dst
            },
            exp: {
                let field = if packetver < 20170830 {
                   u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]])
                } else {
                   0 as u32
                };
                field
            },
            exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                if packetver < 20170830 {
                    dst.clone_from_slice(&buffer[offset..offset + 4]);
                    offset += 4;
                }
                dst
            },
            money: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            money_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            jobexp_64: {
                let field = if packetver >= 20170830 {
                   u64::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3], buffer[offset + 4], buffer[offset + 5], buffer[offset + 6], buffer[offset + 7]])
                } else {
                   0 as u64
                };
                field
            },
            jobexp_64_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                if packetver >= 20170830 {
                    dst.clone_from_slice(&buffer[offset..offset + 8]);
                    offset += 8;
                }
                dst
            },
            jobexp: {
                let field = if packetver < 20170830 {
                   u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]])
                } else {
                   0 as u32
                };
                field
            },
            jobexp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                if packetver < 20170830 {
                    dst.clone_from_slice(&buffer[offset..offset + 4]);
                    offset += 4;
                }
                dst
            },
            joblevel: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            joblevel_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            bodystate: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            bodystate_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            healthstate: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            healthstate_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            effectstate: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            effectstate_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            virtue: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            virtue_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            honor: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            honor_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            status_point: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            status_point_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            hp: {
                let field = if packetver > 20081217 {
                   u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]])
                } else {
                   0 as u32
                };
                field
            },
            hp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                if packetver > 20081217 {
                    dst.clone_from_slice(&buffer[offset..offset + 4]);
                    offset += 4;
                }
                dst
            },
            hp_16: {
                let field = if packetver <= 20081217 {
                   u16::from_le_bytes([buffer[offset], buffer[offset + 1]])
                } else {
                   0 as u16
                };
                field
            },
            hp_16_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                if packetver <= 20081217 {
                    dst.clone_from_slice(&buffer[offset..offset + 2]);
                    offset += 2;
                }
                dst
            },
            maxhp: {
                let field = if packetver > 20081217 {
                   u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]])
                } else {
                   0 as u32
                };
                field
            },
            maxhp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                if packetver > 20081217 {
                    dst.clone_from_slice(&buffer[offset..offset + 4]);
                    offset += 4;
                }
                dst
            },
            maxhp_16: {
                let field = if packetver <= 20081217 {
                   u16::from_le_bytes([buffer[offset], buffer[offset + 1]])
                } else {
                   0 as u16
                };
                field
            },
            maxhp_16_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                if packetver <= 20081217 {
                    dst.clone_from_slice(&buffer[offset..offset + 2]);
                    offset += 2;
                }
                dst
            },
            sp: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            sp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            maxsp: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            maxsp_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            speed: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            speed_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            class: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            class_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body: {
                let field = if packetver >= 20141022 {
                   u16::from_le_bytes([buffer[offset], buffer[offset + 1]])
                } else {
                   0 as u16
                };
                field
            },
            body_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                if packetver >= 20141022 {
                    dst.clone_from_slice(&buffer[offset..offset + 2]);
                    offset += 2;
                }
                dst
            },
            weapon: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            weapon_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            level: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skill_point: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skill_point_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_bottom: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_bottom_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            shield: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            shield_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_top: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_top_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_mid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_mid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            hair_color: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            hair_color_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            body_color: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            body_color_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            str: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            str_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            agi: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            agi_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            vit: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            vit_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            int: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            int_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            dex: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            dex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            luk: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            luk_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            char_num: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            char_num_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            haircolor: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            haircolor_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            b_is_changed_char_name: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            b_is_changed_char_name_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            last_map: {
                let field = if packetver >= 20100720 {
                    {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            }
                } else {
                   [0 as char; 16]
                };
                field
            },
            last_map_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                if packetver >= 20100720 {
                    dst.clone_from_slice(&buffer[offset..offset + 16]);
                    offset += 16;
                }
                dst
            },
            delete_date: {
                let field = if packetver >= 20100803 {
                   u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]])
                } else {
                   0 as u32
                };
                field
            },
            delete_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                if packetver >= 20100803 {
                    dst.clone_from_slice(&buffer[offset..offset + 4]);
                    offset += 4;
                }
                dst
            },
            robe: {
                let field = if packetver >= 20110111 {
                   u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]])
                } else {
                   0 as u32
                };
                field
            },
            robe_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                if packetver >= 20110111 {
                    dst.clone_from_slice(&buffer[offset..offset + 4]);
                    offset += 4;
                }
                dst
            },
            slot_addon: {
                let field = if packetver >= 20110928 {
                   u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]])
                } else {
                   0 as u32
                };
                field
            },
            slot_addon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                if packetver >= 20110928 {
                    dst.clone_from_slice(&buffer[offset..offset + 4]);
                    offset += 4;
                }
                dst
            },
            rename_addon: {
                let field = if packetver >= 20111025 {
                   u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]])
                } else {
                   0 as u32
                };
                field
            },
            rename_addon_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                if packetver >= 20111025 {
                    dst.clone_from_slice(&buffer[offset..offset + 4]);
                    offset += 4;
                }
                dst
            },
            sex: {
                let field = if packetver >= 20141016 {
                   u8::from_le_bytes([buffer[offset]])
                } else {
                   0 as u8
                };
                field
            },
            sex_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                if packetver >= 20141016 {
                    dst.clone_from_slice(&buffer[offset..offset + 1]);
                    offset += 1;
                }
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u64::<LittleEndian>(self.exp_64).unwrap();
        self.exp_64_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.exp).unwrap();
        self.exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.money).unwrap();
        self.money_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u64::<LittleEndian>(self.jobexp_64).unwrap();
        self.jobexp_64_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.jobexp).unwrap();
        self.jobexp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.joblevel).unwrap();
        self.joblevel_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bodystate).unwrap();
        self.bodystate_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.healthstate).unwrap();
        self.healthstate_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.effectstate).unwrap();
        self.effectstate_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.virtue).unwrap();
        self.virtue_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.honor).unwrap();
        self.honor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.status_point).unwrap();
        self.status_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.hp).unwrap();
        self.hp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.hp_16).unwrap();
        self.hp_16_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.maxhp).unwrap();
        self.maxhp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.maxhp_16).unwrap();
        self.maxhp_16_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.sp).unwrap();
        self.sp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.maxsp).unwrap();
        self.maxsp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.speed).unwrap();
        self.speed_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.class).unwrap();
        self.class_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.body).unwrap();
        self.body_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.weapon).unwrap();
        self.weapon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skill_point).unwrap();
        self.skill_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.head_bottom).unwrap();
        self.head_bottom_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.shield).unwrap();
        self.shield_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.head_top).unwrap();
        self.head_top_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.head_mid).unwrap();
        self.head_mid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.hair_color).unwrap();
        self.hair_color_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.body_color).unwrap();
        self.body_color_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.str).unwrap();
        self.str_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.agi).unwrap();
        self.agi_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.vit).unwrap();
        self.vit_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.int).unwrap();
        self.int_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dex).unwrap();
        self.dex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.luk).unwrap();
        self.luk_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.char_num).unwrap();
        self.char_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.haircolor).unwrap();
        self.haircolor_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.b_is_changed_char_name).unwrap();
        self.b_is_changed_char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.last_map {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.last_map_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.delete_date).unwrap();
        self.delete_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.robe).unwrap();
        self.robe_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.slot_addon).unwrap();
        self.slot_addon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.rename_addon).unwrap();
        self.rename_addon_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.gid_raw.to_vec());
        if packetver.is_none() {
          wtr.append(&mut self.exp_64_raw.to_vec());
        } else if packetver.unwrap() >= 20170830 {
            wtr.append(&mut self.exp_64_raw.to_vec());
        }
        if packetver.is_none() {
          wtr.append(&mut self.exp_raw.to_vec());
        } else if packetver.unwrap() < 20170830 {
            wtr.append(&mut self.exp_raw.to_vec());
        }
        wtr.append(&mut self.money_raw.to_vec());
        if packetver.is_none() {
          wtr.append(&mut self.jobexp_64_raw.to_vec());
        } else if packetver.unwrap() >= 20170830 {
            wtr.append(&mut self.jobexp_64_raw.to_vec());
        }
        if packetver.is_none() {
          wtr.append(&mut self.jobexp_raw.to_vec());
        } else if packetver.unwrap() < 20170830 {
            wtr.append(&mut self.jobexp_raw.to_vec());
        }
        wtr.append(&mut self.joblevel_raw.to_vec());
        wtr.append(&mut self.bodystate_raw.to_vec());
        wtr.append(&mut self.healthstate_raw.to_vec());
        wtr.append(&mut self.effectstate_raw.to_vec());
        wtr.append(&mut self.virtue_raw.to_vec());
        wtr.append(&mut self.honor_raw.to_vec());
        wtr.append(&mut self.status_point_raw.to_vec());
        if packetver.is_none() {
          wtr.append(&mut self.hp_raw.to_vec());
        } else if packetver.unwrap() > 20081217 {
            wtr.append(&mut self.hp_raw.to_vec());
        }
        if packetver.is_none() {
          wtr.append(&mut self.hp_16_raw.to_vec());
        } else if packetver.unwrap() <= 20081217 {
            wtr.append(&mut self.hp_16_raw.to_vec());
        }
        if packetver.is_none() {
          wtr.append(&mut self.maxhp_raw.to_vec());
        } else if packetver.unwrap() > 20081217 {
            wtr.append(&mut self.maxhp_raw.to_vec());
        }
        if packetver.is_none() {
          wtr.append(&mut self.maxhp_16_raw.to_vec());
        } else if packetver.unwrap() <= 20081217 {
            wtr.append(&mut self.maxhp_16_raw.to_vec());
        }
        wtr.append(&mut self.sp_raw.to_vec());
        wtr.append(&mut self.maxsp_raw.to_vec());
        wtr.append(&mut self.speed_raw.to_vec());
        wtr.append(&mut self.class_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        if packetver.is_none() {
          wtr.append(&mut self.body_raw.to_vec());
        } else if packetver.unwrap() >= 20141022 {
            wtr.append(&mut self.body_raw.to_vec());
        }
        wtr.append(&mut self.weapon_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.skill_point_raw.to_vec());
        wtr.append(&mut self.head_bottom_raw.to_vec());
        wtr.append(&mut self.shield_raw.to_vec());
        wtr.append(&mut self.head_top_raw.to_vec());
        wtr.append(&mut self.head_mid_raw.to_vec());
        wtr.append(&mut self.hair_color_raw.to_vec());
        wtr.append(&mut self.body_color_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        wtr.append(&mut self.str_raw.to_vec());
        wtr.append(&mut self.agi_raw.to_vec());
        wtr.append(&mut self.vit_raw.to_vec());
        wtr.append(&mut self.int_raw.to_vec());
        wtr.append(&mut self.dex_raw.to_vec());
        wtr.append(&mut self.luk_raw.to_vec());
        wtr.append(&mut self.char_num_raw.to_vec());
        wtr.append(&mut self.haircolor_raw.to_vec());
        wtr.append(&mut self.b_is_changed_char_name_raw.to_vec());
        if packetver.is_none() {
          wtr.append(&mut self.last_map_raw.to_vec());
        } else if packetver.unwrap() >= 20100720 {
            wtr.append(&mut self.last_map_raw.to_vec());
        }
        if packetver.is_none() {
          wtr.append(&mut self.delete_date_raw.to_vec());
        } else if packetver.unwrap() >= 20100803 {
            wtr.append(&mut self.delete_date_raw.to_vec());
        }
        if packetver.is_none() {
          wtr.append(&mut self.robe_raw.to_vec());
        } else if packetver.unwrap() >= 20110111 {
            wtr.append(&mut self.robe_raw.to_vec());
        }
        if packetver.is_none() {
          wtr.append(&mut self.slot_addon_raw.to_vec());
        } else if packetver.unwrap() >= 20110928 {
            wtr.append(&mut self.slot_addon_raw.to_vec());
        }
        if packetver.is_none() {
          wtr.append(&mut self.rename_addon_raw.to_vec());
        } else if packetver.unwrap() >= 20111025 {
            wtr.append(&mut self.rename_addon_raw.to_vec());
        }
        if packetver.is_none() {
          wtr.append(&mut self.sex_raw.to_vec());
        } else if packetver.unwrap() >= 20141016 {
            wtr.append(&mut self.sex_raw.to_vec());
        }
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let mut base_len: usize = 96;
        if packetver >= 20170830 {
            base_len += 8;
        }
        if packetver < 20170830 {
            base_len += 4;
        }
        if packetver >= 20170830 {
            base_len += 8;
        }
        if packetver < 20170830 {
            base_len += 4;
        }
        if packetver > 20081217 {
            base_len += 4;
        }
        if packetver <= 20081217 {
            base_len += 2;
        }
        if packetver > 20081217 {
            base_len += 4;
        }
        if packetver <= 20081217 {
            base_len += 2;
        }
        if packetver >= 20141022 {
            base_len += 2;
        }
        if packetver >= 20100720 {
            base_len += 16;
        }
        if packetver >= 20100803 {
            base_len += 4;
        }
        if packetver >= 20110111 {
            base_len += 4;
        }
        if packetver >= 20110928 {
            base_len += 4;
        }
        if packetver >= 20111025 {
            base_len += 4;
        }
        if packetver >= 20141016 {
            base_len += 1;
        }
        base_len
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_exp_64(&mut self, value: u64) {
        self.exp_64 = value;
    }
    pub fn set_exp_64_raw(&mut self, value: [u8; 8]) {
        self.exp_64_raw = value;
    }
    pub fn set_exp(&mut self, value: u32) {
        self.exp = value;
    }
    pub fn set_exp_raw(&mut self, value: [u8; 4]) {
        self.exp_raw = value;
    }
    pub fn set_money(&mut self, value: u32) {
        self.money = value;
    }
    pub fn set_money_raw(&mut self, value: [u8; 4]) {
        self.money_raw = value;
    }
    pub fn set_jobexp_64(&mut self, value: u64) {
        self.jobexp_64 = value;
    }
    pub fn set_jobexp_64_raw(&mut self, value: [u8; 8]) {
        self.jobexp_64_raw = value;
    }
    pub fn set_jobexp(&mut self, value: u32) {
        self.jobexp = value;
    }
    pub fn set_jobexp_raw(&mut self, value: [u8; 4]) {
        self.jobexp_raw = value;
    }
    pub fn set_joblevel(&mut self, value: u32) {
        self.joblevel = value;
    }
    pub fn set_joblevel_raw(&mut self, value: [u8; 4]) {
        self.joblevel_raw = value;
    }
    pub fn set_bodystate(&mut self, value: u32) {
        self.bodystate = value;
    }
    pub fn set_bodystate_raw(&mut self, value: [u8; 4]) {
        self.bodystate_raw = value;
    }
    pub fn set_healthstate(&mut self, value: u32) {
        self.healthstate = value;
    }
    pub fn set_healthstate_raw(&mut self, value: [u8; 4]) {
        self.healthstate_raw = value;
    }
    pub fn set_effectstate(&mut self, value: i32) {
        self.effectstate = value;
    }
    pub fn set_effectstate_raw(&mut self, value: [u8; 4]) {
        self.effectstate_raw = value;
    }
    pub fn set_virtue(&mut self, value: i32) {
        self.virtue = value;
    }
    pub fn set_virtue_raw(&mut self, value: [u8; 4]) {
        self.virtue_raw = value;
    }
    pub fn set_honor(&mut self, value: i32) {
        self.honor = value;
    }
    pub fn set_honor_raw(&mut self, value: [u8; 4]) {
        self.honor_raw = value;
    }
    pub fn set_status_point(&mut self, value: u16) {
        self.status_point = value;
    }
    pub fn set_status_point_raw(&mut self, value: [u8; 2]) {
        self.status_point_raw = value;
    }
    pub fn set_hp(&mut self, value: u32) {
        self.hp = value;
    }
    pub fn set_hp_raw(&mut self, value: [u8; 4]) {
        self.hp_raw = value;
    }
    pub fn set_hp_16(&mut self, value: u16) {
        self.hp_16 = value;
    }
    pub fn set_hp_16_raw(&mut self, value: [u8; 2]) {
        self.hp_16_raw = value;
    }
    pub fn set_maxhp(&mut self, value: u32) {
        self.maxhp = value;
    }
    pub fn set_maxhp_raw(&mut self, value: [u8; 4]) {
        self.maxhp_raw = value;
    }
    pub fn set_maxhp_16(&mut self, value: u16) {
        self.maxhp_16 = value;
    }
    pub fn set_maxhp_16_raw(&mut self, value: [u8; 2]) {
        self.maxhp_16_raw = value;
    }
    pub fn set_sp(&mut self, value: u16) {
        self.sp = value;
    }
    pub fn set_sp_raw(&mut self, value: [u8; 2]) {
        self.sp_raw = value;
    }
    pub fn set_maxsp(&mut self, value: u16) {
        self.maxsp = value;
    }
    pub fn set_maxsp_raw(&mut self, value: [u8; 2]) {
        self.maxsp_raw = value;
    }
    pub fn set_speed(&mut self, value: u16) {
        self.speed = value;
    }
    pub fn set_speed_raw(&mut self, value: [u8; 2]) {
        self.speed_raw = value;
    }
    pub fn set_class(&mut self, value: u16) {
        self.class = value;
    }
    pub fn set_class_raw(&mut self, value: [u8; 2]) {
        self.class_raw = value;
    }
    pub fn set_head(&mut self, value: u16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_body(&mut self, value: u16) {
        self.body = value;
    }
    pub fn set_body_raw(&mut self, value: [u8; 2]) {
        self.body_raw = value;
    }
    pub fn set_weapon(&mut self, value: u16) {
        self.weapon = value;
    }
    pub fn set_weapon_raw(&mut self, value: [u8; 2]) {
        self.weapon_raw = value;
    }
    pub fn set_level(&mut self, value: u16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_skill_point(&mut self, value: u16) {
        self.skill_point = value;
    }
    pub fn set_skill_point_raw(&mut self, value: [u8; 2]) {
        self.skill_point_raw = value;
    }
    pub fn set_head_bottom(&mut self, value: u16) {
        self.head_bottom = value;
    }
    pub fn set_head_bottom_raw(&mut self, value: [u8; 2]) {
        self.head_bottom_raw = value;
    }
    pub fn set_shield(&mut self, value: u16) {
        self.shield = value;
    }
    pub fn set_shield_raw(&mut self, value: [u8; 2]) {
        self.shield_raw = value;
    }
    pub fn set_head_top(&mut self, value: u16) {
        self.head_top = value;
    }
    pub fn set_head_top_raw(&mut self, value: [u8; 2]) {
        self.head_top_raw = value;
    }
    pub fn set_head_mid(&mut self, value: u16) {
        self.head_mid = value;
    }
    pub fn set_head_mid_raw(&mut self, value: [u8; 2]) {
        self.head_mid_raw = value;
    }
    pub fn set_hair_color(&mut self, value: u16) {
        self.hair_color = value;
    }
    pub fn set_hair_color_raw(&mut self, value: [u8; 2]) {
        self.hair_color_raw = value;
    }
    pub fn set_body_color(&mut self, value: u16) {
        self.body_color = value;
    }
    pub fn set_body_color_raw(&mut self, value: [u8; 2]) {
        self.body_color_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn set_str(&mut self, value: u8) {
        self.str = value;
    }
    pub fn set_str_raw(&mut self, value: [u8; 1]) {
        self.str_raw = value;
    }
    pub fn set_agi(&mut self, value: u8) {
        self.agi = value;
    }
    pub fn set_agi_raw(&mut self, value: [u8; 1]) {
        self.agi_raw = value;
    }
    pub fn set_vit(&mut self, value: u8) {
        self.vit = value;
    }
    pub fn set_vit_raw(&mut self, value: [u8; 1]) {
        self.vit_raw = value;
    }
    pub fn set_int(&mut self, value: u8) {
        self.int = value;
    }
    pub fn set_int_raw(&mut self, value: [u8; 1]) {
        self.int_raw = value;
    }
    pub fn set_dex(&mut self, value: u8) {
        self.dex = value;
    }
    pub fn set_dex_raw(&mut self, value: [u8; 1]) {
        self.dex_raw = value;
    }
    pub fn set_luk(&mut self, value: u8) {
        self.luk = value;
    }
    pub fn set_luk_raw(&mut self, value: [u8; 1]) {
        self.luk_raw = value;
    }
    pub fn set_char_num(&mut self, value: i8) {
        self.char_num = value;
    }
    pub fn set_char_num_raw(&mut self, value: [u8; 1]) {
        self.char_num_raw = value;
    }
    pub fn set_haircolor(&mut self, value: u8) {
        self.haircolor = value;
    }
    pub fn set_haircolor_raw(&mut self, value: [u8; 1]) {
        self.haircolor_raw = value;
    }
    pub fn set_b_is_changed_char_name(&mut self, value: u16) {
        self.b_is_changed_char_name = value;
    }
    pub fn set_b_is_changed_char_name_raw(&mut self, value: [u8; 2]) {
        self.b_is_changed_char_name_raw = value;
    }
    pub fn set_last_map(&mut self, value: [char; 16]) {
        self.last_map = value;
    }
    pub fn set_last_map_raw(&mut self, value: [u8; 16]) {
        self.last_map_raw = value;
    }
    pub fn set_delete_date(&mut self, value: u32) {
        self.delete_date = value;
    }
    pub fn set_delete_date_raw(&mut self, value: [u8; 4]) {
        self.delete_date_raw = value;
    }
    pub fn set_robe(&mut self, value: u32) {
        self.robe = value;
    }
    pub fn set_robe_raw(&mut self, value: [u8; 4]) {
        self.robe_raw = value;
    }
    pub fn set_slot_addon(&mut self, value: u32) {
        self.slot_addon = value;
    }
    pub fn set_slot_addon_raw(&mut self, value: [u8; 4]) {
        self.slot_addon_raw = value;
    }
    pub fn set_rename_addon(&mut self, value: u32) {
        self.rename_addon = value;
    }
    pub fn set_rename_addon_raw(&mut self, value: [u8; 4]) {
        self.rename_addon_raw = value;
    }
    pub fn set_sex(&mut self, value: u8) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 1]) {
        self.sex_raw = value;
    }
    pub fn new(packetver: u32) -> CharacterInfoNeoUnion {
        CharacterInfoNeoUnion {
        raw: vec![],
        gid: 0,
        gid_raw: [0; 4],
        exp_64: 0,
        exp_64_raw: [0; 8],
        exp: 0,
        exp_raw: [0; 4],
        money: 0,
        money_raw: [0; 4],
        jobexp_64: 0,
        jobexp_64_raw: [0; 8],
        jobexp: 0,
        jobexp_raw: [0; 4],
        joblevel: 0,
        joblevel_raw: [0; 4],
        bodystate: 0,
        bodystate_raw: [0; 4],
        healthstate: 0,
        healthstate_raw: [0; 4],
        effectstate: 0,
        effectstate_raw: [0; 4],
        virtue: 0,
        virtue_raw: [0; 4],
        honor: 0,
        honor_raw: [0; 4],
        status_point: 0,
        status_point_raw: [0; 2],
        hp: 0,
        hp_raw: [0; 4],
        hp_16: 0,
        hp_16_raw: [0; 2],
        maxhp: 0,
        maxhp_raw: [0; 4],
        maxhp_16: 0,
        maxhp_16_raw: [0; 2],
        sp: 0,
        sp_raw: [0; 2],
        maxsp: 0,
        maxsp_raw: [0; 2],
        speed: 0,
        speed_raw: [0; 2],
        class: 0,
        class_raw: [0; 2],
        head: 0,
        head_raw: [0; 2],
        body: 0,
        body_raw: [0; 2],
        weapon: 0,
        weapon_raw: [0; 2],
        level: 0,
        level_raw: [0; 2],
        skill_point: 0,
        skill_point_raw: [0; 2],
        head_bottom: 0,
        head_bottom_raw: [0; 2],
        shield: 0,
        shield_raw: [0; 2],
        head_top: 0,
        head_top_raw: [0; 2],
        head_mid: 0,
        head_mid_raw: [0; 2],
        hair_color: 0,
        hair_color_raw: [0; 2],
        body_color: 0,
        body_color_raw: [0; 2],
        name: [0 as char; 24],
        name_raw: [0; 24],
        str: 0,
        str_raw: [0; 1],
        agi: 0,
        agi_raw: [0; 1],
        vit: 0,
        vit_raw: [0; 1],
        int: 0,
        int_raw: [0; 1],
        dex: 0,
        dex_raw: [0; 1],
        luk: 0,
        luk_raw: [0; 1],
        char_num: 0,
        char_num_raw: [0; 1],
        haircolor: 0,
        haircolor_raw: [0; 1],
        b_is_changed_char_name: 0,
        b_is_changed_char_name_raw: [0; 2],
        last_map: [0 as char; 16],
        last_map_raw: [0; 16],
        delete_date: 0,
        delete_date_raw: [0; 4],
        robe: 0,
        robe_raw: [0; 4],
        slot_addon: 0,
        slot_addon_raw: [0; 4],
        rename_addon: 0,
        rename_addon_raw: [0; 4],
        sex: 0,
        sex_raw: [0; 1],
        }
    }
}

impl ZserverAddr {
    pub fn from(buffer: &[u8], packetver: u32) -> ZserverAddr {
        let mut offset: usize = 0;
        ZserverAddr {
            ip: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            ip_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            port: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            port_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.ip).unwrap();
        self.ip_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.port).unwrap();
        self.port_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.ip_raw.to_vec());
        wtr.append(&mut self.port_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_ip(&mut self, value: u32) {
        self.ip = value;
    }
    pub fn set_ip_raw(&mut self, value: [u8; 4]) {
        self.ip_raw = value;
    }
    pub fn set_port(&mut self, value: i16) {
        self.port = value;
    }
    pub fn set_port_raw(&mut self, value: [u8; 2]) {
        self.port_raw = value;
    }
    pub fn new(packetver: u32) -> ZserverAddr {
        ZserverAddr {
        raw: vec![],
        ip: 0,
        ip_raw: [0; 4],
        port: 0,
        port_raw: [0; 2],
        }
    }
}

impl EQUIPSLOTINFO {
    pub fn from(buffer: &[u8], packetver: u32) -> EQUIPSLOTINFO {
        let mut offset: usize = 0;
        EQUIPSLOTINFO {
            card1: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            card1_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            card2: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            card2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            card3: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            card3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            card4: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            card4_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card1).unwrap();
        self.card1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card2).unwrap();
        self.card2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card3).unwrap();
        self.card3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card4).unwrap();
        self.card4_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.card1_raw.to_vec());
        wtr.append(&mut self.card2_raw.to_vec());
        wtr.append(&mut self.card3_raw.to_vec());
        wtr.append(&mut self.card4_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_card1(&mut self, value: u16) {
        self.card1 = value;
    }
    pub fn set_card1_raw(&mut self, value: [u8; 2]) {
        self.card1_raw = value;
    }
    pub fn set_card2(&mut self, value: u16) {
        self.card2 = value;
    }
    pub fn set_card2_raw(&mut self, value: [u8; 2]) {
        self.card2_raw = value;
    }
    pub fn set_card3(&mut self, value: u16) {
        self.card3 = value;
    }
    pub fn set_card3_raw(&mut self, value: [u8; 2]) {
        self.card3_raw = value;
    }
    pub fn set_card4(&mut self, value: u16) {
        self.card4 = value;
    }
    pub fn set_card4_raw(&mut self, value: [u8; 2]) {
        self.card4_raw = value;
    }
    pub fn new(packetver: u32) -> EQUIPSLOTINFO {
        EQUIPSLOTINFO {
        raw: vec![],
        card1: 0,
        card1_raw: [0; 2],
        card2: 0,
        card2_raw: [0; 2],
        card3: 0,
        card3_raw: [0; 2],
        card4: 0,
        card4_raw: [0; 2],
        }
    }
}

impl NormalitemExtrainfo {
    pub fn from(buffer: &[u8], packetver: u32) -> NormalitemExtrainfo {
        let mut offset: usize = 0;
        NormalitemExtrainfo {
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            wear_state: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            wear_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_state).unwrap();
        self.wear_state_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.wear_state_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_wear_state(&mut self, value: u16) {
        self.wear_state = value;
    }
    pub fn set_wear_state_raw(&mut self, value: [u8; 2]) {
        self.wear_state_raw = value;
    }
    pub fn new(packetver: u32) -> NormalitemExtrainfo {
        NormalitemExtrainfo {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        is_identified: false,
        is_identified_raw: [0; 1],
        count: 0,
        count_raw: [0; 2],
        wear_state: 0,
        wear_state_raw: [0; 2],
        }
    }
}

impl EquipmentitemExtrainfo {
    pub fn from(buffer: &[u8], packetver: u32) -> EquipmentitemExtrainfo {
        let mut offset: usize = 0;
        EquipmentitemExtrainfo {
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            location: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            wear_state: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            wear_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_damaged: {
                let field = buffer[offset] == 1;
                field
            },
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            refining_level: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_state).unwrap();
        self.wear_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();


        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.location_raw.to_vec());
        wtr.append(&mut self.wear_state_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 20;
        base_len
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_location(&mut self, value: u16) {
        self.location = value;
    }
    pub fn set_location_raw(&mut self, value: [u8; 2]) {
        self.location_raw = value;
    }
    pub fn set_wear_state(&mut self, value: u16) {
        self.wear_state = value;
    }
    pub fn set_wear_state_raw(&mut self, value: [u8; 2]) {
        self.wear_state_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new(packetver: u32) -> EquipmentitemExtrainfo {
        EquipmentitemExtrainfo {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        is_identified: false,
        is_identified_raw: [0; 1],
        location: 0,
        location_raw: [0; 2],
        wear_state: 0,
        wear_state_raw: [0; 2],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        }
    }
}

impl PurchaseItem {
    pub fn from(buffer: &[u8], packetver: u32) -> PurchaseItem {
        let mut offset: usize = 0;
        PurchaseItem {
            price: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            discountprice: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            discountprice_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.discountprice).unwrap();
        self.discountprice_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.price_raw.to_vec());
        wtr.append(&mut self.discountprice_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 11;
        base_len
    }
    pub fn set_price(&mut self, value: i32) {
        self.price = value;
    }
    pub fn set_price_raw(&mut self, value: [u8; 4]) {
        self.price_raw = value;
    }
    pub fn set_discountprice(&mut self, value: i32) {
        self.discountprice = value;
    }
    pub fn set_discountprice_raw(&mut self, value: [u8; 4]) {
        self.discountprice_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new(packetver: u32) -> PurchaseItem {
        PurchaseItem {
        raw: vec![],
        price: 0,
        price_raw: [0; 4],
        discountprice: 0,
        discountprice_raw: [0; 4],
        atype: 0,
        atype_raw: [0; 1],
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl SellItem {
    pub fn from(buffer: &[u8], packetver: u32) -> SellItem {
        let mut offset: usize = 0;
        SellItem {
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            price: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            overchargeprice: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            overchargeprice_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.overchargeprice).unwrap();
        self.overchargeprice_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.price_raw.to_vec());
        wtr.append(&mut self.overchargeprice_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_price(&mut self, value: i32) {
        self.price = value;
    }
    pub fn set_price_raw(&mut self, value: [u8; 4]) {
        self.price_raw = value;
    }
    pub fn set_overchargeprice(&mut self, value: i32) {
        self.overchargeprice = value;
    }
    pub fn set_overchargeprice_raw(&mut self, value: [u8; 4]) {
        self.overchargeprice_raw = value;
    }
    pub fn new(packetver: u32) -> SellItem {
        SellItem {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        price: 0,
        price_raw: [0; 4],
        overchargeprice: 0,
        overchargeprice_raw: [0; 4],
        }
    }
}

impl CzPurchaseItem {
    pub fn from(buffer: &[u8], packetver: u32) -> CzPurchaseItem {
        let mut offset: usize = 0;
        CzPurchaseItem {
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new(packetver: u32) -> CzPurchaseItem {
        CzPurchaseItem {
        raw: vec![],
        count: 0,
        count_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl CzSellItem {
    pub fn from(buffer: &[u8], packetver: u32) -> CzSellItem {
        let mut offset: usize = 0;
        CzSellItem {
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> CzSellItem {
        CzSellItem {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl WhisperItem {
    pub fn from(buffer: &[u8], packetver: u32) -> WhisperItem {
        let mut offset: usize = 0;
        WhisperItem {
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 24;
        base_len
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> WhisperItem {
        WhisperItem {
        raw: vec![],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl RoomMember {
    pub fn from(buffer: &[u8], packetver: u32) -> RoomMember {
        let mut offset: usize = 0;
        RoomMember {
            role: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            role_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.role).unwrap();
        self.role_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.role_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 28;
        base_len
    }
    pub fn set_role(&mut self, value: u32) {
        self.role = value;
    }
    pub fn set_role_raw(&mut self, value: [u8; 4]) {
        self.role_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> RoomMember {
        RoomMember {
        raw: vec![],
        role: 0,
        role_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl GroupmemberInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> GroupmemberInfo {
        let mut offset: usize = 0;
        GroupmemberInfo {
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            character_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            character_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            map_name: {
                let field =  {
                let mut dst: [char; 16] = [0 as char; 16];
                for (index, byte) in buffer[offset..offset + 16].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            map_name_raw: {
                let mut dst: [u8; 16] = [0u8; 16];
                dst.clone_from_slice(&buffer[offset..offset + 16]);
                offset += 16;
                dst
            },
            role: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            role_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            state: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            state_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.character_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.character_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.map_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.map_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.role).unwrap();
        self.role_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.state).unwrap();
        self.state_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.character_name_raw.to_vec());
        wtr.append(&mut self.map_name_raw.to_vec());
        wtr.append(&mut self.role_raw.to_vec());
        wtr.append(&mut self.state_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 46;
        base_len
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_character_name(&mut self, value: [char; 24]) {
        self.character_name = value;
    }
    pub fn set_character_name_raw(&mut self, value: [u8; 24]) {
        self.character_name_raw = value;
    }
    pub fn set_map_name(&mut self, value: [char; 16]) {
        self.map_name = value;
    }
    pub fn set_map_name_raw(&mut self, value: [u8; 16]) {
        self.map_name_raw = value;
    }
    pub fn set_role(&mut self, value: u8) {
        self.role = value;
    }
    pub fn set_role_raw(&mut self, value: [u8; 1]) {
        self.role_raw = value;
    }
    pub fn set_state(&mut self, value: u8) {
        self.state = value;
    }
    pub fn set_state_raw(&mut self, value: [u8; 1]) {
        self.state_raw = value;
    }
    pub fn new(packetver: u32) -> GroupmemberInfo {
        GroupmemberInfo {
        raw: vec![],
        aid: 0,
        aid_raw: [0; 4],
        character_name: [0 as char; 24],
        character_name_raw: [0; 24],
        map_name: [0 as char; 16],
        map_name_raw: [0; 16],
        role: 0,
        role_raw: [0; 1],
        state: 0,
        state_raw: [0; 1],
        }
    }
}

impl SKILLINFO {
    pub fn from(buffer: &[u8], packetver: u32) -> SKILLINFO {
        let mut offset: usize = 0;
        SKILLINFO {
            skid: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            spcost: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            spcost_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            attack_range: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            attack_range_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            skill_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            skill_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            upgradable: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            upgradable_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.spcost).unwrap();
        self.spcost_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.attack_range).unwrap();
        self.attack_range_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.skill_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.skill_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.upgradable).unwrap();
        self.upgradable_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.spcost_raw.to_vec());
        wtr.append(&mut self.attack_range_raw.to_vec());
        wtr.append(&mut self.skill_name_raw.to_vec());
        wtr.append(&mut self.upgradable_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 37;
        base_len
    }
    pub fn set_skid(&mut self, value: i16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_spcost(&mut self, value: i16) {
        self.spcost = value;
    }
    pub fn set_spcost_raw(&mut self, value: [u8; 2]) {
        self.spcost_raw = value;
    }
    pub fn set_attack_range(&mut self, value: i16) {
        self.attack_range = value;
    }
    pub fn set_attack_range_raw(&mut self, value: [u8; 2]) {
        self.attack_range_raw = value;
    }
    pub fn set_skill_name(&mut self, value: [char; 24]) {
        self.skill_name = value;
    }
    pub fn set_skill_name_raw(&mut self, value: [u8; 24]) {
        self.skill_name_raw = value;
    }
    pub fn set_upgradable(&mut self, value: i8) {
        self.upgradable = value;
    }
    pub fn set_upgradable_raw(&mut self, value: [u8; 1]) {
        self.upgradable_raw = value;
    }
    pub fn new(packetver: u32) -> SKILLINFO {
        SKILLINFO {
        raw: vec![],
        skid: 0,
        skid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 4],
        level: 0,
        level_raw: [0; 2],
        spcost: 0,
        spcost_raw: [0; 2],
        attack_range: 0,
        attack_range_raw: [0; 2],
        skill_name: [0 as char; 24],
        skill_name_raw: [0; 24],
        upgradable: 0,
        upgradable_raw: [0; 1],
        }
    }
}

impl StoreItem {
    pub fn from(buffer: &[u8], packetver: u32) -> StoreItem {
        let mut offset: usize = 0;
        StoreItem {
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            price: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.price_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_price(&mut self, value: i32) {
        self.price = value;
    }
    pub fn set_price_raw(&mut self, value: [u8; 4]) {
        self.price_raw = value;
    }
    pub fn new(packetver: u32) -> StoreItem {
        StoreItem {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        price: 0,
        price_raw: [0; 4],
        }
    }
}

impl PurchaseItemFrommc {
    pub fn from(buffer: &[u8], packetver: u32) -> PurchaseItemFrommc {
        let mut offset: usize = 0;
        PurchaseItemFrommc {
            price: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_identified: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_damaged: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            refining_level: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();


        wtr = vec![];
        wtr.append(&mut self.price_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 22;
        base_len
    }
    pub fn set_price(&mut self, value: i32) {
        self.price = value;
    }
    pub fn set_price_raw(&mut self, value: [u8; 4]) {
        self.price_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: u8) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: u8) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new(packetver: u32) -> PurchaseItemFrommc {
        PurchaseItemFrommc {
        raw: vec![],
        price: 0,
        price_raw: [0; 4],
        count: 0,
        count_raw: [0; 2],
        index: 0,
        index_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: 0,
        is_identified_raw: [0; 1],
        is_damaged: 0,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        }
    }
}

impl CzPurchaseItemFrommc {
    pub fn from(buffer: &[u8], packetver: u32) -> CzPurchaseItemFrommc {
        let mut offset: usize = 0;
        CzPurchaseItemFrommc {
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 4;
        base_len
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn new(packetver: u32) -> CzPurchaseItemFrommc {
        CzPurchaseItemFrommc {
        raw: vec![],
        count: 0,
        count_raw: [0; 2],
        index: 0,
        index_raw: [0; 2],
        }
    }
}

impl PurchaseMyitem {
    pub fn from(buffer: &[u8], packetver: u32) -> PurchaseMyitem {
        let mut offset: usize = 0;
        PurchaseMyitem {
            price: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_identified: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_damaged: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            refining_level: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();


        wtr = vec![];
        wtr.append(&mut self.price_raw.to_vec());
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 22;
        base_len
    }
    pub fn set_price(&mut self, value: i32) {
        self.price = value;
    }
    pub fn set_price_raw(&mut self, value: [u8; 4]) {
        self.price_raw = value;
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_is_identified(&mut self, value: u8) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: u8) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new(packetver: u32) -> PurchaseMyitem {
        PurchaseMyitem {
        raw: vec![],
        price: 0,
        price_raw: [0; 4],
        index: 0,
        index_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        itid: 0,
        itid_raw: [0; 2],
        is_identified: 0,
        is_identified_raw: [0; 1],
        is_damaged: 0,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        }
    }
}

impl RelatedGuild {
    pub fn from(buffer: &[u8], packetver: u32) -> RelatedGuild {
        let mut offset: usize = 0;
        RelatedGuild {
            gdid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            relation: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            relation_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            guild_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            guild_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.relation).unwrap();
        self.relation_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.guild_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guild_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.relation_raw.to_vec());
        wtr.append(&mut self.guild_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 32;
        base_len
    }
    pub fn set_gdid(&mut self, value: i32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_relation(&mut self, value: i32) {
        self.relation = value;
    }
    pub fn set_relation_raw(&mut self, value: [u8; 4]) {
        self.relation_raw = value;
    }
    pub fn set_guild_name(&mut self, value: [char; 24]) {
        self.guild_name = value;
    }
    pub fn set_guild_name_raw(&mut self, value: [u8; 24]) {
        self.guild_name_raw = value;
    }
    pub fn new(packetver: u32) -> RelatedGuild {
        RelatedGuild {
        raw: vec![],
        gdid: 0,
        gdid_raw: [0; 4],
        relation: 0,
        relation_raw: [0; 4],
        guild_name: [0 as char; 24],
        guild_name_raw: [0; 24],
        }
    }
}

impl GuildMembermgrInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> GuildMembermgrInfo {
        let mut offset: usize = 0;
        GuildMembermgrInfo {
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            head_type: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_palette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_palette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            sex: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            member_exp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            member_exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            current_state: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            current_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gposition_id: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gposition_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            memo: {
                let field =  {
                let mut dst: [char; 50] = [0 as char; 50];
                for (index, byte) in buffer[offset..offset + 50].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            memo_raw: {
                let mut dst: [u8; 50] = [0u8; 50];
                dst.clone_from_slice(&buffer[offset..offset + 50]);
                offset += 50;
                dst
            },
            char_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_type).unwrap();
        self.head_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_palette).unwrap();
        self.head_palette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.member_exp).unwrap();
        self.member_exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.current_state).unwrap();
        self.current_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gposition_id).unwrap();
        self.gposition_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.memo {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.memo_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.head_type_raw.to_vec());
        wtr.append(&mut self.head_palette_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.member_exp_raw.to_vec());
        wtr.append(&mut self.current_state_raw.to_vec());
        wtr.append(&mut self.gposition_id_raw.to_vec());
        wtr.append(&mut self.memo_raw.to_vec());
        wtr.append(&mut self.char_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 104;
        base_len
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_head_type(&mut self, value: i16) {
        self.head_type = value;
    }
    pub fn set_head_type_raw(&mut self, value: [u8; 2]) {
        self.head_type_raw = value;
    }
    pub fn set_head_palette(&mut self, value: i16) {
        self.head_palette = value;
    }
    pub fn set_head_palette_raw(&mut self, value: [u8; 2]) {
        self.head_palette_raw = value;
    }
    pub fn set_sex(&mut self, value: i16) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 2]) {
        self.sex_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_member_exp(&mut self, value: i32) {
        self.member_exp = value;
    }
    pub fn set_member_exp_raw(&mut self, value: [u8; 4]) {
        self.member_exp_raw = value;
    }
    pub fn set_current_state(&mut self, value: i32) {
        self.current_state = value;
    }
    pub fn set_current_state_raw(&mut self, value: [u8; 4]) {
        self.current_state_raw = value;
    }
    pub fn set_gposition_id(&mut self, value: i32) {
        self.gposition_id = value;
    }
    pub fn set_gposition_id_raw(&mut self, value: [u8; 4]) {
        self.gposition_id_raw = value;
    }
    pub fn set_memo(&mut self, value: [char; 50]) {
        self.memo = value;
    }
    pub fn set_memo_raw(&mut self, value: [u8; 50]) {
        self.memo_raw = value;
    }
    pub fn set_char_name(&mut self, value: [char; 24]) {
        self.char_name = value;
    }
    pub fn set_char_name_raw(&mut self, value: [u8; 24]) {
        self.char_name_raw = value;
    }
    pub fn new(packetver: u32) -> GuildMembermgrInfo {
        GuildMembermgrInfo {
        raw: vec![],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        head_type: 0,
        head_type_raw: [0; 2],
        head_palette: 0,
        head_palette_raw: [0; 2],
        sex: 0,
        sex_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        level: 0,
        level_raw: [0; 2],
        member_exp: 0,
        member_exp_raw: [0; 4],
        current_state: 0,
        current_state_raw: [0; 4],
        gposition_id: 0,
        gposition_id_raw: [0; 4],
        memo: [0 as char; 50],
        memo_raw: [0; 50],
        char_name: [0 as char; 24],
        char_name_raw: [0; 24],
        }
    }
}

impl MemberPositionInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> MemberPositionInfo {
        let mut offset: usize = 0;
        MemberPositionInfo {
            aid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            position_id: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            position_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.position_id).unwrap();
        self.position_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.position_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 12;
        base_len
    }
    pub fn set_aid(&mut self, value: i32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: i32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_position_id(&mut self, value: i32) {
        self.position_id = value;
    }
    pub fn set_position_id_raw(&mut self, value: [u8; 4]) {
        self.position_id_raw = value;
    }
    pub fn new(packetver: u32) -> MemberPositionInfo {
        MemberPositionInfo {
        raw: vec![],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        position_id: 0,
        position_id_raw: [0; 4],
        }
    }
}

impl GuildMemberPositionInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> GuildMemberPositionInfo {
        let mut offset: usize = 0;
        GuildMemberPositionInfo {
            position_id: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            position_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            right: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            right_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            ranking: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            ranking_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            pay_rate: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            pay_rate_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.position_id).unwrap();
        self.position_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.right).unwrap();
        self.right_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.ranking).unwrap();
        self.ranking_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.pay_rate).unwrap();
        self.pay_rate_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.position_id_raw.to_vec());
        wtr.append(&mut self.right_raw.to_vec());
        wtr.append(&mut self.ranking_raw.to_vec());
        wtr.append(&mut self.pay_rate_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 16;
        base_len
    }
    pub fn set_position_id(&mut self, value: i32) {
        self.position_id = value;
    }
    pub fn set_position_id_raw(&mut self, value: [u8; 4]) {
        self.position_id_raw = value;
    }
    pub fn set_right(&mut self, value: i32) {
        self.right = value;
    }
    pub fn set_right_raw(&mut self, value: [u8; 4]) {
        self.right_raw = value;
    }
    pub fn set_ranking(&mut self, value: i32) {
        self.ranking = value;
    }
    pub fn set_ranking_raw(&mut self, value: [u8; 4]) {
        self.ranking_raw = value;
    }
    pub fn set_pay_rate(&mut self, value: i32) {
        self.pay_rate = value;
    }
    pub fn set_pay_rate_raw(&mut self, value: [u8; 4]) {
        self.pay_rate_raw = value;
    }
    pub fn new(packetver: u32) -> GuildMemberPositionInfo {
        GuildMemberPositionInfo {
        raw: vec![],
        position_id: 0,
        position_id_raw: [0; 4],
        right: 0,
        right_raw: [0; 4],
        ranking: 0,
        ranking_raw: [0; 4],
        pay_rate: 0,
        pay_rate_raw: [0; 4],
        }
    }
}

impl GuildRegPositionInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> GuildRegPositionInfo {
        let mut offset: usize = 0;
        GuildRegPositionInfo {
            position_id: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            position_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            right: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            right_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            ranking: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            ranking_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            pay_rate: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            pay_rate_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            pos_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            pos_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.position_id).unwrap();
        self.position_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.right).unwrap();
        self.right_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.ranking).unwrap();
        self.ranking_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.pay_rate).unwrap();
        self.pay_rate_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.position_id_raw.to_vec());
        wtr.append(&mut self.right_raw.to_vec());
        wtr.append(&mut self.ranking_raw.to_vec());
        wtr.append(&mut self.pay_rate_raw.to_vec());
        wtr.append(&mut self.pos_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 40;
        base_len
    }
    pub fn set_position_id(&mut self, value: i32) {
        self.position_id = value;
    }
    pub fn set_position_id_raw(&mut self, value: [u8; 4]) {
        self.position_id_raw = value;
    }
    pub fn set_right(&mut self, value: i32) {
        self.right = value;
    }
    pub fn set_right_raw(&mut self, value: [u8; 4]) {
        self.right_raw = value;
    }
    pub fn set_ranking(&mut self, value: i32) {
        self.ranking = value;
    }
    pub fn set_ranking_raw(&mut self, value: [u8; 4]) {
        self.ranking_raw = value;
    }
    pub fn set_pay_rate(&mut self, value: i32) {
        self.pay_rate = value;
    }
    pub fn set_pay_rate_raw(&mut self, value: [u8; 4]) {
        self.pay_rate_raw = value;
    }
    pub fn set_pos_name(&mut self, value: [char; 24]) {
        self.pos_name = value;
    }
    pub fn set_pos_name_raw(&mut self, value: [u8; 24]) {
        self.pos_name_raw = value;
    }
    pub fn new(packetver: u32) -> GuildRegPositionInfo {
        GuildRegPositionInfo {
        raw: vec![],
        position_id: 0,
        position_id_raw: [0; 4],
        right: 0,
        right_raw: [0; 4],
        ranking: 0,
        ranking_raw: [0; 4],
        pay_rate: 0,
        pay_rate_raw: [0; 4],
        pos_name: [0 as char; 24],
        pos_name_raw: [0; 24],
        }
    }
}

impl GuildBanInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> GuildBanInfo {
        let mut offset: usize = 0;
        GuildBanInfo {
            charname: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            charname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            account: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            account_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            reason: {
                let field =  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[offset..offset + 40].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            reason_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[offset..offset + 40]);
                offset += 40;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        for item in self.charname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.charname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.account {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.account_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.reason {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.reason_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.charname_raw.to_vec());
        wtr.append(&mut self.account_raw.to_vec());
        wtr.append(&mut self.reason_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 88;
        base_len
    }
    pub fn set_charname(&mut self, value: [char; 24]) {
        self.charname = value;
    }
    pub fn set_charname_raw(&mut self, value: [u8; 24]) {
        self.charname_raw = value;
    }
    pub fn set_account(&mut self, value: [char; 24]) {
        self.account = value;
    }
    pub fn set_account_raw(&mut self, value: [u8; 24]) {
        self.account_raw = value;
    }
    pub fn set_reason(&mut self, value: [char; 40]) {
        self.reason = value;
    }
    pub fn set_reason_raw(&mut self, value: [u8; 40]) {
        self.reason_raw = value;
    }
    pub fn new(packetver: u32) -> GuildBanInfo {
        GuildBanInfo {
        raw: vec![],
        charname: [0 as char; 24],
        charname_raw: [0; 24],
        account: [0 as char; 24],
        account_raw: [0; 24],
        reason: [0 as char; 40],
        reason_raw: [0; 40],
        }
    }
}

impl OtherGuildInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> OtherGuildInfo {
        let mut offset: usize = 0;
        OtherGuildInfo {
            guildname: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            guildname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            guild_level: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guild_level_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            guild_member_size: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guild_member_size_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            guild_ranking: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            guild_ranking_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        for item in self.guildname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guildname_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.guild_level).unwrap();
        self.guild_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.guild_member_size).unwrap();
        self.guild_member_size_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.guild_ranking).unwrap();
        self.guild_ranking_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.guildname_raw.to_vec());
        wtr.append(&mut self.guild_level_raw.to_vec());
        wtr.append(&mut self.guild_member_size_raw.to_vec());
        wtr.append(&mut self.guild_ranking_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 36;
        base_len
    }
    pub fn set_guildname(&mut self, value: [char; 24]) {
        self.guildname = value;
    }
    pub fn set_guildname_raw(&mut self, value: [u8; 24]) {
        self.guildname_raw = value;
    }
    pub fn set_guild_level(&mut self, value: i32) {
        self.guild_level = value;
    }
    pub fn set_guild_level_raw(&mut self, value: [u8; 4]) {
        self.guild_level_raw = value;
    }
    pub fn set_guild_member_size(&mut self, value: i32) {
        self.guild_member_size = value;
    }
    pub fn set_guild_member_size_raw(&mut self, value: [u8; 4]) {
        self.guild_member_size_raw = value;
    }
    pub fn set_guild_ranking(&mut self, value: i32) {
        self.guild_ranking = value;
    }
    pub fn set_guild_ranking_raw(&mut self, value: [u8; 4]) {
        self.guild_ranking_raw = value;
    }
    pub fn new(packetver: u32) -> OtherGuildInfo {
        OtherGuildInfo {
        raw: vec![],
        guildname: [0 as char; 24],
        guildname_raw: [0; 24],
        guild_level: 0,
        guild_level_raw: [0; 4],
        guild_member_size: 0,
        guild_member_size_raw: [0; 4],
        guild_ranking: 0,
        guild_ranking_raw: [0; 4],
        }
    }
}

impl MemberPositionIdNameInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> MemberPositionIdNameInfo {
        let mut offset: usize = 0;
        MemberPositionIdNameInfo {
            position_id: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            position_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            pos_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            pos_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.position_id).unwrap();
        self.position_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.pos_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.pos_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.position_id_raw.to_vec());
        wtr.append(&mut self.pos_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 28;
        base_len
    }
    pub fn set_position_id(&mut self, value: i32) {
        self.position_id = value;
    }
    pub fn set_position_id_raw(&mut self, value: [u8; 4]) {
        self.position_id_raw = value;
    }
    pub fn set_pos_name(&mut self, value: [char; 24]) {
        self.pos_name = value;
    }
    pub fn set_pos_name_raw(&mut self, value: [u8; 24]) {
        self.pos_name_raw = value;
    }
    pub fn new(packetver: u32) -> MemberPositionIdNameInfo {
        MemberPositionIdNameInfo {
        raw: vec![],
        position_id: 0,
        position_id_raw: [0; 4],
        pos_name: [0 as char; 24],
        pos_name_raw: [0; 24],
        }
    }
}

impl GuildMemberInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> GuildMemberInfo {
        let mut offset: usize = 0;
        GuildMemberInfo {
            aid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            head: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            head_palette: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            head_palette_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            sex: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            sex_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            job_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            contribution_exp: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            contribution_exp_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            current_state: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            current_state_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            position_id: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            position_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            intro: {
                let field =  {
                let mut dst: [char; 50] = [0 as char; 50];
                for (index, byte) in buffer[offset..offset + 50].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            intro_raw: {
                let mut dst: [u8; 50] = [0u8; 50];
                dst.clone_from_slice(&buffer[offset..offset + 50]);
                offset += 50;
                dst
            },
            charname: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            charname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head).unwrap();
        self.head_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.head_palette).unwrap();
        self.head_palette_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.sex).unwrap();
        self.sex_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.job).unwrap();
        self.job_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.contribution_exp).unwrap();
        self.contribution_exp_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.current_state).unwrap();
        self.current_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.position_id).unwrap();
        self.position_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.intro {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.intro_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.charname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.charname_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.head_raw.to_vec());
        wtr.append(&mut self.head_palette_raw.to_vec());
        wtr.append(&mut self.sex_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.contribution_exp_raw.to_vec());
        wtr.append(&mut self.current_state_raw.to_vec());
        wtr.append(&mut self.position_id_raw.to_vec());
        wtr.append(&mut self.intro_raw.to_vec());
        wtr.append(&mut self.charname_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 104;
        base_len
    }
    pub fn set_aid(&mut self, value: i32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: i32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_head(&mut self, value: i16) {
        self.head = value;
    }
    pub fn set_head_raw(&mut self, value: [u8; 2]) {
        self.head_raw = value;
    }
    pub fn set_head_palette(&mut self, value: i16) {
        self.head_palette = value;
    }
    pub fn set_head_palette_raw(&mut self, value: [u8; 2]) {
        self.head_palette_raw = value;
    }
    pub fn set_sex(&mut self, value: i16) {
        self.sex = value;
    }
    pub fn set_sex_raw(&mut self, value: [u8; 2]) {
        self.sex_raw = value;
    }
    pub fn set_job(&mut self, value: i16) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 2]) {
        self.job_raw = value;
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_contribution_exp(&mut self, value: i32) {
        self.contribution_exp = value;
    }
    pub fn set_contribution_exp_raw(&mut self, value: [u8; 4]) {
        self.contribution_exp_raw = value;
    }
    pub fn set_current_state(&mut self, value: i32) {
        self.current_state = value;
    }
    pub fn set_current_state_raw(&mut self, value: [u8; 4]) {
        self.current_state_raw = value;
    }
    pub fn set_position_id(&mut self, value: i32) {
        self.position_id = value;
    }
    pub fn set_position_id_raw(&mut self, value: [u8; 4]) {
        self.position_id_raw = value;
    }
    pub fn set_intro(&mut self, value: [char; 50]) {
        self.intro = value;
    }
    pub fn set_intro_raw(&mut self, value: [u8; 50]) {
        self.intro_raw = value;
    }
    pub fn set_charname(&mut self, value: [char; 24]) {
        self.charname = value;
    }
    pub fn set_charname_raw(&mut self, value: [u8; 24]) {
        self.charname_raw = value;
    }
    pub fn new(packetver: u32) -> GuildMemberInfo {
        GuildMemberInfo {
        raw: vec![],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        head: 0,
        head_raw: [0; 2],
        head_palette: 0,
        head_palette_raw: [0; 2],
        sex: 0,
        sex_raw: [0; 2],
        job: 0,
        job_raw: [0; 2],
        level: 0,
        level_raw: [0; 2],
        contribution_exp: 0,
        contribution_exp_raw: [0; 4],
        current_state: 0,
        current_state_raw: [0; 4],
        position_id: 0,
        position_id_raw: [0; 4],
        intro: [0 as char; 50],
        intro_raw: [0; 50],
        charname: [0 as char; 24],
        charname_raw: [0; 24],
        }
    }
}

impl RelatedGuildInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> RelatedGuildInfo {
        let mut offset: usize = 0;
        RelatedGuildInfo {
            relation: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            relation_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gdid: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gdid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            guildname: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            guildname_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.relation).unwrap();
        self.relation_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.gdid).unwrap();
        self.gdid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.guildname {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.guildname_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.relation_raw.to_vec());
        wtr.append(&mut self.gdid_raw.to_vec());
        wtr.append(&mut self.guildname_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 32;
        base_len
    }
    pub fn set_relation(&mut self, value: i32) {
        self.relation = value;
    }
    pub fn set_relation_raw(&mut self, value: [u8; 4]) {
        self.relation_raw = value;
    }
    pub fn set_gdid(&mut self, value: i32) {
        self.gdid = value;
    }
    pub fn set_gdid_raw(&mut self, value: [u8; 4]) {
        self.gdid_raw = value;
    }
    pub fn set_guildname(&mut self, value: [char; 24]) {
        self.guildname = value;
    }
    pub fn set_guildname_raw(&mut self, value: [u8; 24]) {
        self.guildname_raw = value;
    }
    pub fn new(packetver: u32) -> RelatedGuildInfo {
        RelatedGuildInfo {
        raw: vec![],
        relation: 0,
        relation_raw: [0; 4],
        gdid: 0,
        gdid_raw: [0; 4],
        guildname: [0 as char; 24],
        guildname_raw: [0; 24],
        }
    }
}

impl MonsterInfoElement {
    pub fn from(buffer: &[u8], packetver: u32) -> MonsterInfoElement {
        let mut offset: usize = 0;
        MonsterInfoElement {
            water: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            water_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            earth: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            earth_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            fire: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            fire_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            wind: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            wind_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            poison: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            poison_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            saint: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            saint_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            dark: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            dark_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            mental: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            mental_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            undead: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            undead_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u8(self.water).unwrap();
        self.water_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.earth).unwrap();
        self.earth_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.fire).unwrap();
        self.fire_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.wind).unwrap();
        self.wind_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.poison).unwrap();
        self.poison_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.saint).unwrap();
        self.saint_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.dark).unwrap();
        self.dark_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.mental).unwrap();
        self.mental_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.undead).unwrap();
        self.undead_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.water_raw.to_vec());
        wtr.append(&mut self.earth_raw.to_vec());
        wtr.append(&mut self.fire_raw.to_vec());
        wtr.append(&mut self.wind_raw.to_vec());
        wtr.append(&mut self.poison_raw.to_vec());
        wtr.append(&mut self.saint_raw.to_vec());
        wtr.append(&mut self.dark_raw.to_vec());
        wtr.append(&mut self.mental_raw.to_vec());
        wtr.append(&mut self.undead_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 9;
        base_len
    }
    pub fn set_water(&mut self, value: u8) {
        self.water = value;
    }
    pub fn set_water_raw(&mut self, value: [u8; 1]) {
        self.water_raw = value;
    }
    pub fn set_earth(&mut self, value: u8) {
        self.earth = value;
    }
    pub fn set_earth_raw(&mut self, value: [u8; 1]) {
        self.earth_raw = value;
    }
    pub fn set_fire(&mut self, value: u8) {
        self.fire = value;
    }
    pub fn set_fire_raw(&mut self, value: [u8; 1]) {
        self.fire_raw = value;
    }
    pub fn set_wind(&mut self, value: u8) {
        self.wind = value;
    }
    pub fn set_wind_raw(&mut self, value: [u8; 1]) {
        self.wind_raw = value;
    }
    pub fn set_poison(&mut self, value: u8) {
        self.poison = value;
    }
    pub fn set_poison_raw(&mut self, value: [u8; 1]) {
        self.poison_raw = value;
    }
    pub fn set_saint(&mut self, value: u8) {
        self.saint = value;
    }
    pub fn set_saint_raw(&mut self, value: [u8; 1]) {
        self.saint_raw = value;
    }
    pub fn set_dark(&mut self, value: u8) {
        self.dark = value;
    }
    pub fn set_dark_raw(&mut self, value: [u8; 1]) {
        self.dark_raw = value;
    }
    pub fn set_mental(&mut self, value: u8) {
        self.mental = value;
    }
    pub fn set_mental_raw(&mut self, value: [u8; 1]) {
        self.mental_raw = value;
    }
    pub fn set_undead(&mut self, value: u8) {
        self.undead = value;
    }
    pub fn set_undead_raw(&mut self, value: [u8; 1]) {
        self.undead_raw = value;
    }
    pub fn new(packetver: u32) -> MonsterInfoElement {
        MonsterInfoElement {
        raw: vec![],
        water: 0,
        water_raw: [0; 1],
        earth: 0,
        earth_raw: [0; 1],
        fire: 0,
        fire_raw: [0; 1],
        wind: 0,
        wind_raw: [0; 1],
        poison: 0,
        poison_raw: [0; 1],
        saint: 0,
        saint_raw: [0; 1],
        dark: 0,
        dark_raw: [0; 1],
        mental: 0,
        mental_raw: [0; 1],
        undead: 0,
        undead_raw: [0; 1],
        }
    }
}

impl MakableitemInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> MakableitemInfo {
        let mut offset: usize = 0;
        MakableitemInfo {
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            material_id: {
                let field =  {
                let mut dst: [u16; 3] = [0_u16; 3];
                for (index, byte) in buffer[offset..offset + 3].iter().enumerate() {
                    dst[index] = *byte as u16;
                }
                dst
            };
                field
            },
            material_id_raw: {
                let mut dst: [u8; 6] = [0u8; 6];
                dst.clone_from_slice(&buffer[offset..offset + 6]);
                offset += 6;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.material_id {
            wtr.write_u16::<LittleEndian>(item).unwrap();
        }
        self.material_id_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.material_id_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_material_id(&mut self, value: [u16; 3]) {
        self.material_id = value;
    }
    pub fn set_material_id_raw(&mut self, value: [u8; 6]) {
        self.material_id_raw = value;
    }
    pub fn new(packetver: u32) -> MakableitemInfo {
        MakableitemInfo {
        raw: vec![],
        itid: 0,
        itid_raw: [0; 2],
        material_id: [0; 3],
        material_id_raw: [0; 6],
        }
    }
}

impl PeteggitemInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> PeteggitemInfo {
        let mut offset: usize = 0;
        PeteggitemInfo {
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn new(packetver: u32) -> PeteggitemInfo {
        PeteggitemInfo {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        }
    }
}

impl ArrowitemInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> ArrowitemInfo {
        let mut offset: usize = 0;
        ArrowitemInfo {
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 2;
        base_len
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn new(packetver: u32) -> ArrowitemInfo {
        ArrowitemInfo {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        }
    }
}

impl NormalitemExtrainfo2 {
    pub fn from(buffer: &[u8], packetver: u32) -> NormalitemExtrainfo2 {
        let mut offset: usize = 0;
        NormalitemExtrainfo2 {
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            wear_state: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            wear_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_state).unwrap();
        self.wear_state_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();


        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.wear_state_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 18;
        base_len
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_wear_state(&mut self, value: u16) {
        self.wear_state = value;
    }
    pub fn set_wear_state_raw(&mut self, value: [u8; 2]) {
        self.wear_state_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new(packetver: u32) -> NormalitemExtrainfo2 {
        NormalitemExtrainfo2 {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        is_identified: false,
        is_identified_raw: [0; 1],
        count: 0,
        count_raw: [0; 2],
        wear_state: 0,
        wear_state_raw: [0; 2],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        }
    }
}

impl RepairitemInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> RepairitemInfo {
        let mut offset: usize = 0;
        RepairitemInfo {
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            refining_level: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();


        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 13;
        base_len
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn new(packetver: u32) -> RepairitemInfo {
        RepairitemInfo {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        }
    }
}

impl FRIEND {
    pub fn from(buffer: &[u8], packetver: u32) -> FRIEND {
        let mut offset: usize = 0;
        FRIEND {
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 32;
        base_len
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_name(&mut self, value: [char; 24]) {
        self.name = value;
    }
    pub fn set_name_raw(&mut self, value: [u8; 24]) {
        self.name_raw = value;
    }
    pub fn new(packetver: u32) -> FRIEND {
        FRIEND {
        raw: vec![],
        aid: 0,
        aid_raw: [0; 4],
        gid: 0,
        gid_raw: [0; 4],
        name: [0 as char; 24],
        name_raw: [0; 24],
        }
    }
}

impl TagCharacterBlockInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> TagCharacterBlockInfo {
        let mut offset: usize = 0;
        TagCharacterBlockInfo {
            gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            sz_expire_date: {
                let field =  {
                let mut dst: [char; 20] = [0 as char; 20];
                for (index, byte) in buffer[offset..offset + 20].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            sz_expire_date_raw: {
                let mut dst: [u8; 20] = [0u8; 20];
                dst.clone_from_slice(&buffer[offset..offset + 20]);
                offset += 20;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.gid).unwrap();
        self.gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.sz_expire_date {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.sz_expire_date_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.gid_raw.to_vec());
        wtr.append(&mut self.sz_expire_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 24;
        base_len
    }
    pub fn set_gid(&mut self, value: u32) {
        self.gid = value;
    }
    pub fn set_gid_raw(&mut self, value: [u8; 4]) {
        self.gid_raw = value;
    }
    pub fn set_sz_expire_date(&mut self, value: [char; 20]) {
        self.sz_expire_date = value;
    }
    pub fn set_sz_expire_date_raw(&mut self, value: [u8; 20]) {
        self.sz_expire_date_raw = value;
    }
    pub fn new(packetver: u32) -> TagCharacterBlockInfo {
        TagCharacterBlockInfo {
        raw: vec![],
        gid: 0,
        gid_raw: [0; 4],
        sz_expire_date: [0 as char; 20],
        sz_expire_date_raw: [0; 20],
        }
    }
}

impl PVPINFO {
    pub fn from(buffer: &[u8], packetver: u32) -> PVPINFO {
        let mut offset: usize = 0;
        PVPINFO {
            win_point: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            win_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            lose_point: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            lose_point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            point: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            point_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.win_point).unwrap();
        self.win_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.lose_point).unwrap();
        self.lose_point_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.point).unwrap();
        self.point_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.win_point_raw.to_vec());
        wtr.append(&mut self.lose_point_raw.to_vec());
        wtr.append(&mut self.point_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 12;
        base_len
    }
    pub fn set_win_point(&mut self, value: i32) {
        self.win_point = value;
    }
    pub fn set_win_point_raw(&mut self, value: [u8; 4]) {
        self.win_point_raw = value;
    }
    pub fn set_lose_point(&mut self, value: i32) {
        self.lose_point = value;
    }
    pub fn set_lose_point_raw(&mut self, value: [u8; 4]) {
        self.lose_point_raw = value;
    }
    pub fn set_point(&mut self, value: i32) {
        self.point = value;
    }
    pub fn set_point_raw(&mut self, value: [u8; 4]) {
        self.point_raw = value;
    }
    pub fn new(packetver: u32) -> PVPINFO {
        PVPINFO {
        raw: vec![],
        win_point: 0,
        win_point_raw: [0; 4],
        lose_point: 0,
        lose_point_raw: [0; 4],
        point: 0,
        point_raw: [0; 4],
        }
    }
}

impl Filetime {
    pub fn from(buffer: &[u8], packetver: u32) -> Filetime {
        let mut offset: usize = 0;
        Filetime {
            dw_low_date_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dw_low_date_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            dw_high_date_time: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dw_high_date_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_low_date_time).unwrap();
        self.dw_low_date_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_high_date_time).unwrap();
        self.dw_high_date_time_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.dw_low_date_time_raw.to_vec());
        wtr.append(&mut self.dw_high_date_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_dw_low_date_time(&mut self, value: u32) {
        self.dw_low_date_time = value;
    }
    pub fn set_dw_low_date_time_raw(&mut self, value: [u8; 4]) {
        self.dw_low_date_time_raw = value;
    }
    pub fn set_dw_high_date_time(&mut self, value: u32) {
        self.dw_high_date_time = value;
    }
    pub fn set_dw_high_date_time_raw(&mut self, value: [u8; 4]) {
        self.dw_high_date_time_raw = value;
    }
    pub fn new(packetver: u32) -> Filetime {
        Filetime {
        raw: vec![],
        dw_low_date_time: 0,
        dw_low_date_time_raw: [0; 4],
        dw_high_date_time: 0,
        dw_high_date_time_raw: [0; 4],
        }
    }
}

impl MailList {
    pub fn from(buffer: &[u8], packetver: u32) -> MailList {
        let mut offset: usize = 0;
        MailList {
            mail_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            mail_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            header: {
                let field =  {
                let mut dst: [char; 40] = [0 as char; 40];
                for (index, byte) in buffer[offset..offset + 40].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            header_raw: {
                let mut dst: [u8; 40] = [0u8; 40];
                dst.clone_from_slice(&buffer[offset..offset + 40]);
                offset += 40;
                dst
            },
            is_open: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            is_open_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            from_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            from_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            delete_time: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            delete_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.mail_id).unwrap();
        self.mail_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.header {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.header_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i8(self.is_open).unwrap();
        self.is_open_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.from_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.from_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.delete_time).unwrap();
        self.delete_time_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.mail_id_raw.to_vec());
        wtr.append(&mut self.header_raw.to_vec());
        wtr.append(&mut self.is_open_raw.to_vec());
        wtr.append(&mut self.from_name_raw.to_vec());
        wtr.append(&mut self.delete_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 73;
        base_len
    }
    pub fn set_mail_id(&mut self, value: u32) {
        self.mail_id = value;
    }
    pub fn set_mail_id_raw(&mut self, value: [u8; 4]) {
        self.mail_id_raw = value;
    }
    pub fn set_header(&mut self, value: [char; 40]) {
        self.header = value;
    }
    pub fn set_header_raw(&mut self, value: [u8; 40]) {
        self.header_raw = value;
    }
    pub fn set_is_open(&mut self, value: i8) {
        self.is_open = value;
    }
    pub fn set_is_open_raw(&mut self, value: [u8; 1]) {
        self.is_open_raw = value;
    }
    pub fn set_from_name(&mut self, value: [char; 24]) {
        self.from_name = value;
    }
    pub fn set_from_name_raw(&mut self, value: [u8; 24]) {
        self.from_name_raw = value;
    }
    pub fn set_delete_time(&mut self, value: i32) {
        self.delete_time = value;
    }
    pub fn set_delete_time_raw(&mut self, value: [u8; 4]) {
        self.delete_time_raw = value;
    }
    pub fn new(packetver: u32) -> MailList {
        MailList {
        raw: vec![],
        mail_id: 0,
        mail_id_raw: [0; 4],
        header: [0 as char; 40],
        header_raw: [0; 40],
        is_open: 0,
        is_open_raw: [0; 1],
        from_name: [0 as char; 24],
        from_name_raw: [0; 24],
        delete_time: 0,
        delete_time_raw: [0; 4],
        }
    }
}

impl AuctionItemSearchInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> AuctionItemSearchInfo {
        let mut offset: usize = 0;
        AuctionItemSearchInfo {
            auction_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            auction_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            seller_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            seller_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_damaged: {
                let field = buffer[offset] == 1;
                field
            },
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            refining_level: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            now_price: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            now_price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            max_price: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            max_price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            buyer_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            buyer_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            delete_time: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            delete_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.auction_id).unwrap();
        self.auction_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.seller_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.seller_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.now_price).unwrap();
        self.now_price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.max_price).unwrap();
        self.max_price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.buyer_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.buyer_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.delete_time).unwrap();
        self.delete_time_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.auction_id_raw.to_vec());
        wtr.append(&mut self.seller_name_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        wtr.append(&mut self.now_price_raw.to_vec());
        wtr.append(&mut self.max_price_raw.to_vec());
        wtr.append(&mut self.buyer_name_raw.to_vec());
        wtr.append(&mut self.delete_time_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 83;
        base_len
    }
    pub fn set_auction_id(&mut self, value: u32) {
        self.auction_id = value;
    }
    pub fn set_auction_id_raw(&mut self, value: [u8; 4]) {
        self.auction_id_raw = value;
    }
    pub fn set_seller_name(&mut self, value: [char; 24]) {
        self.seller_name = value;
    }
    pub fn set_seller_name_raw(&mut self, value: [u8; 24]) {
        self.seller_name_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: i32) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 4]) {
        self.atype_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn set_now_price(&mut self, value: i32) {
        self.now_price = value;
    }
    pub fn set_now_price_raw(&mut self, value: [u8; 4]) {
        self.now_price_raw = value;
    }
    pub fn set_max_price(&mut self, value: i32) {
        self.max_price = value;
    }
    pub fn set_max_price_raw(&mut self, value: [u8; 4]) {
        self.max_price_raw = value;
    }
    pub fn set_buyer_name(&mut self, value: [char; 24]) {
        self.buyer_name = value;
    }
    pub fn set_buyer_name_raw(&mut self, value: [u8; 24]) {
        self.buyer_name_raw = value;
    }
    pub fn set_delete_time(&mut self, value: i32) {
        self.delete_time = value;
    }
    pub fn set_delete_time_raw(&mut self, value: [u8; 4]) {
        self.delete_time_raw = value;
    }
    pub fn new(packetver: u32) -> AuctionItemSearchInfo {
        AuctionItemSearchInfo {
        raw: vec![],
        auction_id: 0,
        auction_id_raw: [0; 4],
        seller_name: [0 as char; 24],
        seller_name_raw: [0; 24],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 4],
        count: 0,
        count_raw: [0; 2],
        is_identified: false,
        is_identified_raw: [0; 1],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        now_price: 0,
        now_price_raw: [0; 4],
        max_price: 0,
        max_price_raw: [0; 4],
        buyer_name: [0 as char; 24],
        buyer_name_raw: [0; 24],
        delete_time: 0,
        delete_time_raw: [0; 4],
        }
    }
}

impl PacketMobHunting {
    pub fn from(buffer: &[u8], packetver: u32) -> PacketMobHunting {
        let mut offset: usize = 0;
        PacketMobHunting {
            quest_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            mob_gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            mob_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            max_count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            max_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.mob_gid).unwrap();
        self.mob_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.max_count).unwrap();
        self.max_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.quest_id_raw.to_vec());
        wtr.append(&mut self.mob_gid_raw.to_vec());
        wtr.append(&mut self.max_count_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 12;
        base_len
    }
    pub fn set_quest_id(&mut self, value: u32) {
        self.quest_id = value;
    }
    pub fn set_quest_id_raw(&mut self, value: [u8; 4]) {
        self.quest_id_raw = value;
    }
    pub fn set_mob_gid(&mut self, value: u32) {
        self.mob_gid = value;
    }
    pub fn set_mob_gid_raw(&mut self, value: [u8; 4]) {
        self.mob_gid_raw = value;
    }
    pub fn set_max_count(&mut self, value: i16) {
        self.max_count = value;
    }
    pub fn set_max_count_raw(&mut self, value: [u8; 2]) {
        self.max_count_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> PacketMobHunting {
        PacketMobHunting {
        raw: vec![],
        quest_id: 0,
        quest_id_raw: [0; 4],
        mob_gid: 0,
        mob_gid_raw: [0; 4],
        max_count: 0,
        max_count_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl EquipmentitemExtrainfo2 {
    pub fn from(buffer: &[u8], packetver: u32) -> EquipmentitemExtrainfo2 {
        let mut offset: usize = 0;
        EquipmentitemExtrainfo2 {
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            location: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            wear_state: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            wear_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_damaged: {
                let field = buffer[offset] == 1;
                field
            },
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            refining_level: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            hire_expire_date: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            hire_expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_state).unwrap();
        self.wear_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hire_expire_date).unwrap();
        self.hire_expire_date_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.location_raw.to_vec());
        wtr.append(&mut self.wear_state_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        wtr.append(&mut self.hire_expire_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 24;
        base_len
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_location(&mut self, value: u16) {
        self.location = value;
    }
    pub fn set_location_raw(&mut self, value: [u8; 2]) {
        self.location_raw = value;
    }
    pub fn set_wear_state(&mut self, value: u16) {
        self.wear_state = value;
    }
    pub fn set_wear_state_raw(&mut self, value: [u8; 2]) {
        self.wear_state_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn set_hire_expire_date(&mut self, value: i32) {
        self.hire_expire_date = value;
    }
    pub fn set_hire_expire_date_raw(&mut self, value: [u8; 4]) {
        self.hire_expire_date_raw = value;
    }
    pub fn new(packetver: u32) -> EquipmentitemExtrainfo2 {
        EquipmentitemExtrainfo2 {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        is_identified: false,
        is_identified_raw: [0; 1],
        location: 0,
        location_raw: [0; 2],
        wear_state: 0,
        wear_state_raw: [0; 2],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        hire_expire_date: 0,
        hire_expire_date_raw: [0; 4],
        }
    }
}

impl PggLingoKeyTemp {
    pub fn from(buffer: &[u8], packetver: u32) -> PggLingoKeyTemp {
        let mut offset: usize = 0;
        PggLingoKeyTemp {
            dw_alg_num: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dw_alg_num_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            dw_alg_key1: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dw_alg_key1_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            dw_alg_key2: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dw_alg_key2_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            dw_seed: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dw_seed_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_alg_num).unwrap();
        self.dw_alg_num_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_alg_key1).unwrap();
        self.dw_alg_key1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_alg_key2).unwrap();
        self.dw_alg_key2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_seed).unwrap();
        self.dw_seed_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.dw_alg_num_raw.to_vec());
        wtr.append(&mut self.dw_alg_key1_raw.to_vec());
        wtr.append(&mut self.dw_alg_key2_raw.to_vec());
        wtr.append(&mut self.dw_seed_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 16;
        base_len
    }
    pub fn set_dw_alg_num(&mut self, value: u32) {
        self.dw_alg_num = value;
    }
    pub fn set_dw_alg_num_raw(&mut self, value: [u8; 4]) {
        self.dw_alg_num_raw = value;
    }
    pub fn set_dw_alg_key1(&mut self, value: u32) {
        self.dw_alg_key1 = value;
    }
    pub fn set_dw_alg_key1_raw(&mut self, value: [u8; 4]) {
        self.dw_alg_key1_raw = value;
    }
    pub fn set_dw_alg_key2(&mut self, value: u32) {
        self.dw_alg_key2 = value;
    }
    pub fn set_dw_alg_key2_raw(&mut self, value: [u8; 4]) {
        self.dw_alg_key2_raw = value;
    }
    pub fn set_dw_seed(&mut self, value: u32) {
        self.dw_seed = value;
    }
    pub fn set_dw_seed_raw(&mut self, value: [u8; 4]) {
        self.dw_seed_raw = value;
    }
    pub fn new(packetver: u32) -> PggLingoKeyTemp {
        PggLingoKeyTemp {
        raw: vec![],
        dw_alg_num: 0,
        dw_alg_num_raw: [0; 4],
        dw_alg_key1: 0,
        dw_alg_key1_raw: [0; 4],
        dw_alg_key2: 0,
        dw_alg_key2_raw: [0; 4],
        dw_seed: 0,
        dw_seed_raw: [0; 4],
        }
    }
}

impl PacketZcQuestInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcQuestInfo {
        let mut offset: usize = 0;
        PacketZcQuestInfo {
            quest_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            active: {
                let field = buffer[offset] == 1;
                field
            },
            active_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.active as u8).unwrap();
        self.active_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.quest_id_raw.to_vec());
        wtr.append(&mut self.active_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_quest_id(&mut self, value: u32) {
        self.quest_id = value;
    }
    pub fn set_quest_id_raw(&mut self, value: [u8; 4]) {
        self.quest_id_raw = value;
    }
    pub fn set_active(&mut self, value: bool) {
        self.active = value;
    }
    pub fn set_active_raw(&mut self, value: [u8; 1]) {
        self.active_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcQuestInfo {
        PacketZcQuestInfo {
        raw: vec![],
        quest_id: 0,
        quest_id_raw: [0; 4],
        active: false,
        active_raw: [0; 1],
        }
    }
}

impl PacketZcMissionHunt {
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcMissionHunt {
        let mut offset: usize = 0;
        PacketZcMissionHunt {
            mob_gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            mob_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            hunt_count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            hunt_count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            mob_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            mob_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.mob_gid).unwrap();
        self.mob_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.hunt_count).unwrap();
        self.hunt_count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.mob_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.mob_name_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.mob_gid_raw.to_vec());
        wtr.append(&mut self.hunt_count_raw.to_vec());
        wtr.append(&mut self.mob_name_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 30;
        base_len
    }
    pub fn set_mob_gid(&mut self, value: u32) {
        self.mob_gid = value;
    }
    pub fn set_mob_gid_raw(&mut self, value: [u8; 4]) {
        self.mob_gid_raw = value;
    }
    pub fn set_hunt_count(&mut self, value: i16) {
        self.hunt_count = value;
    }
    pub fn set_hunt_count_raw(&mut self, value: [u8; 2]) {
        self.hunt_count_raw = value;
    }
    pub fn set_mob_name(&mut self, value: [char; 24]) {
        self.mob_name = value;
    }
    pub fn set_mob_name_raw(&mut self, value: [u8; 24]) {
        self.mob_name_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcMissionHunt {
        PacketZcMissionHunt {
        raw: vec![],
        mob_gid: 0,
        mob_gid_raw: [0; 4],
        hunt_count: 0,
        hunt_count_raw: [0; 2],
        mob_name: [0 as char; 24],
        mob_name_raw: [0; 24],
        }
    }
}

impl PacketZcQuestMissionInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> PacketZcQuestMissionInfo {
        let mut offset: usize = 0;
        let vec_type_len = PacketZcMissionHunt::base_len(packetver);
        let iter_count = (&buffer.len() - 14) / vec_type_len;
        let mut vec_field: Vec<PacketZcMissionHunt> = Vec::new();
        let mut i = 1;
        while i <= iter_count {
            let start_pos = 14 + (vec_type_len * (i - 1));
            let end_pos = 14 + vec_type_len * i;
            vec_field.push(PacketZcMissionHunt::from(&buffer[start_pos..end_pos], packetver));
            i += 1;
        }
        PacketZcQuestMissionInfo {
            quest_id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            quest_id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            quest_svr_time: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            quest_svr_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            quest_end_time: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            quest_end_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            hunt: {
                let field = vec_field.clone();
                field
            },
            hunt_raw: {
                vec_field.iter().map(|item| {
                  offset += item.raw.len();
                  item.raw.clone()
                }).collect::<Vec<Vec<u8>>>()
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.quest_id).unwrap();
        self.quest_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.quest_svr_time).unwrap();
        self.quest_svr_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.quest_end_time).unwrap();
        self.quest_end_time_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        self.hunt_raw = {
            self.hunt.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));
            self.hunt.iter().map(|item| item.raw.clone()).collect()
      };


        wtr = vec![];
        wtr.append(&mut self.quest_id_raw.to_vec());
        wtr.append(&mut self.quest_svr_time_raw.to_vec());
        wtr.append(&mut self.quest_end_time_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.hunt.iter_mut().for_each(|item| wtr.append(&mut item.raw));
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 14;
        base_len
    }
    pub fn set_quest_id(&mut self, value: u32) {
        self.quest_id = value;
    }
    pub fn set_quest_id_raw(&mut self, value: [u8; 4]) {
        self.quest_id_raw = value;
    }
    pub fn set_quest_svr_time(&mut self, value: i32) {
        self.quest_svr_time = value;
    }
    pub fn set_quest_svr_time_raw(&mut self, value: [u8; 4]) {
        self.quest_svr_time_raw = value;
    }
    pub fn set_quest_end_time(&mut self, value: i32) {
        self.quest_end_time = value;
    }
    pub fn set_quest_end_time_raw(&mut self, value: [u8; 4]) {
        self.quest_end_time_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_hunt(&mut self, value: Vec<PacketZcMissionHunt>) {
        self.hunt = value;
    }
    pub fn set_hunt_raw(&mut self, value: Vec<Vec<u8>>) {
        self.hunt_raw = value;
    }
    pub fn new(packetver: u32) -> PacketZcQuestMissionInfo {
        PacketZcQuestMissionInfo {
        raw: vec![],
        quest_id: 0,
        quest_id_raw: [0; 4],
        quest_svr_time: 0,
        quest_svr_time_raw: [0; 4],
        quest_end_time: 0,
        quest_end_time_raw: [0; 4],
        count: 0,
        count_raw: [0; 2],
        hunt: vec![],
        hunt_raw: vec![],
        }
    }
}

impl ShortCutKey {
    pub fn from(buffer: &[u8], packetver: u32) -> ShortCutKey {
        let mut offset: usize = 0;
        ShortCutKey {
            is_skill: {
                let field = i8::from_le_bytes([buffer[offset]]);
                field
            },
            is_skill_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            id: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            id_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i8(self.is_skill).unwrap();
        self.is_skill_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.id).unwrap();
        self.id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.is_skill_raw.to_vec());
        wtr.append(&mut self.id_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 7;
        base_len
    }
    pub fn set_is_skill(&mut self, value: i8) {
        self.is_skill = value;
    }
    pub fn set_is_skill_raw(&mut self, value: [u8; 1]) {
        self.is_skill_raw = value;
    }
    pub fn set_id(&mut self, value: u32) {
        self.id = value;
    }
    pub fn set_id_raw(&mut self, value: [u8; 4]) {
        self.id_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> ShortCutKey {
        ShortCutKey {
        raw: vec![],
        is_skill: 0,
        is_skill_raw: [0; 1],
        id: 0,
        id_raw: [0; 4],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl EquipmentitemExtrainfo301 {
    pub fn from(buffer: &[u8], packetver: u32) -> EquipmentitemExtrainfo301 {
        let mut offset: usize = 0;
        EquipmentitemExtrainfo301 {
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            location: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            location_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            wear_state: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            wear_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            is_damaged: {
                let field = buffer[offset] == 1;
                field
            },
            is_damaged_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            refining_level: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            hire_expire_date: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            hire_expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            bind_on_equip_type: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            bind_on_equip_type_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            w_item_sprite_number: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            w_item_sprite_number_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.location).unwrap();
        self.location_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_state).unwrap();
        self.wear_state_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_damaged as u8).unwrap();
        self.is_damaged_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hire_expire_date).unwrap();
        self.hire_expire_date_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.bind_on_equip_type).unwrap();
        self.bind_on_equip_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.w_item_sprite_number).unwrap();
        self.w_item_sprite_number_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.location_raw.to_vec());
        wtr.append(&mut self.wear_state_raw.to_vec());
        wtr.append(&mut self.is_damaged_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        wtr.append(&mut self.hire_expire_date_raw.to_vec());
        wtr.append(&mut self.bind_on_equip_type_raw.to_vec());
        wtr.append(&mut self.w_item_sprite_number_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 28;
        base_len
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_location(&mut self, value: u16) {
        self.location = value;
    }
    pub fn set_location_raw(&mut self, value: [u8; 2]) {
        self.location_raw = value;
    }
    pub fn set_wear_state(&mut self, value: u16) {
        self.wear_state = value;
    }
    pub fn set_wear_state_raw(&mut self, value: [u8; 2]) {
        self.wear_state_raw = value;
    }
    pub fn set_is_damaged(&mut self, value: bool) {
        self.is_damaged = value;
    }
    pub fn set_is_damaged_raw(&mut self, value: [u8; 1]) {
        self.is_damaged_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn set_hire_expire_date(&mut self, value: i32) {
        self.hire_expire_date = value;
    }
    pub fn set_hire_expire_date_raw(&mut self, value: [u8; 4]) {
        self.hire_expire_date_raw = value;
    }
    pub fn set_bind_on_equip_type(&mut self, value: u16) {
        self.bind_on_equip_type = value;
    }
    pub fn set_bind_on_equip_type_raw(&mut self, value: [u8; 2]) {
        self.bind_on_equip_type_raw = value;
    }
    pub fn set_w_item_sprite_number(&mut self, value: u16) {
        self.w_item_sprite_number = value;
    }
    pub fn set_w_item_sprite_number_raw(&mut self, value: [u8; 2]) {
        self.w_item_sprite_number_raw = value;
    }
    pub fn new(packetver: u32) -> EquipmentitemExtrainfo301 {
        EquipmentitemExtrainfo301 {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        is_identified: false,
        is_identified_raw: [0; 1],
        location: 0,
        location_raw: [0; 2],
        wear_state: 0,
        wear_state_raw: [0; 2],
        is_damaged: false,
        is_damaged_raw: [0; 1],
        refining_level: 0,
        refining_level_raw: [0; 1],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        hire_expire_date: 0,
        hire_expire_date_raw: [0; 4],
        bind_on_equip_type: 0,
        bind_on_equip_type_raw: [0; 2],
        w_item_sprite_number: 0,
        w_item_sprite_number_raw: [0; 2],
        }
    }
}

impl NormalitemExtrainfo3 {
    pub fn from(buffer: &[u8], packetver: u32) -> NormalitemExtrainfo3 {
        let mut offset: usize = 0;
        NormalitemExtrainfo3 {
            index: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            is_identified: {
                let field = buffer[offset] == 1;
                field
            },
            is_identified_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            wear_state: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            wear_state_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            slot: {
                let field = EQUIPSLOTINFO::from(&buffer[offset..offset + EQUIPSLOTINFO::base_len(packetver)], packetver);
                field
            },
            slot_raw: {
                let mut dst: [u8; 8] = [0u8; 8];
                dst.clone_from_slice(&buffer[offset..offset + 8]);
                offset += 8;
                dst
            },
            hire_expire_date: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            hire_expire_date_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.is_identified as u8).unwrap();
        self.is_identified_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.wear_state).unwrap();
        self.wear_state_raw = wtr.try_into().unwrap();
        self.slot.fill_raw_with_packetver(packetver);
        self.slot_raw = self.slot.clone().raw.try_into().unwrap();

        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.hire_expire_date).unwrap();
        self.hire_expire_date_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.is_identified_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.wear_state_raw.to_vec());
        wtr.append(&mut self.slot_raw.to_vec());
        wtr.append(&mut self.hire_expire_date_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 22;
        base_len
    }
    pub fn set_index(&mut self, value: i16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_is_identified(&mut self, value: bool) {
        self.is_identified = value;
    }
    pub fn set_is_identified_raw(&mut self, value: [u8; 1]) {
        self.is_identified_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_wear_state(&mut self, value: u16) {
        self.wear_state = value;
    }
    pub fn set_wear_state_raw(&mut self, value: [u8; 2]) {
        self.wear_state_raw = value;
    }
    pub fn set_slot(&mut self, value: EQUIPSLOTINFO) {
        self.slot = value;
    }
    pub fn set_slot_raw(&mut self, value: [u8; 8]) {
        self.slot_raw = value;
    }
    pub fn set_hire_expire_date(&mut self, value: i32) {
        self.hire_expire_date = value;
    }
    pub fn set_hire_expire_date_raw(&mut self, value: [u8; 4]) {
        self.hire_expire_date_raw = value;
    }
    pub fn new(packetver: u32) -> NormalitemExtrainfo3 {
        NormalitemExtrainfo3 {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        is_identified: false,
        is_identified_raw: [0; 1],
        count: 0,
        count_raw: [0; 2],
        wear_state: 0,
        wear_state_raw: [0; 2],
        slot: EQUIPSLOTINFO::new(packetver),
        slot_raw: [0; 8],
        hire_expire_date: 0,
        hire_expire_date_raw: [0; 4],
        }
    }
}

impl SkillPostdelay {
    pub fn from(buffer: &[u8], packetver: u32) -> SkillPostdelay {
        let mut offset: usize = 0;
        SkillPostdelay {
            skid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            skid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            delay_tm: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            delay_tm_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.skid).unwrap();
        self.skid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.delay_tm).unwrap();
        self.delay_tm_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.skid_raw.to_vec());
        wtr.append(&mut self.delay_tm_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_skid(&mut self, value: u16) {
        self.skid = value;
    }
    pub fn set_skid_raw(&mut self, value: [u8; 2]) {
        self.skid_raw = value;
    }
    pub fn set_delay_tm(&mut self, value: u32) {
        self.delay_tm = value;
    }
    pub fn set_delay_tm_raw(&mut self, value: [u8; 4]) {
        self.delay_tm_raw = value;
    }
    pub fn new(packetver: u32) -> SkillPostdelay {
        SkillPostdelay {
        raw: vec![],
        skid: 0,
        skid_raw: [0; 2],
        delay_tm: 0,
        delay_tm_raw: [0; 4],
        }
    }
}

impl CharacterList {
    pub fn from(buffer: &[u8], packetver: u32) -> CharacterList {
        let mut offset: usize = 0;
        CharacterList {
            dw_gid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            dw_gid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            slot_idx: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            slot_idx_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.dw_gid).unwrap();
        self.dw_gid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.slot_idx).unwrap();
        self.slot_idx_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.dw_gid_raw.to_vec());
        wtr.append(&mut self.slot_idx_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 5;
        base_len
    }
    pub fn set_dw_gid(&mut self, value: u32) {
        self.dw_gid = value;
    }
    pub fn set_dw_gid_raw(&mut self, value: [u8; 4]) {
        self.dw_gid_raw = value;
    }
    pub fn set_slot_idx(&mut self, value: u8) {
        self.slot_idx = value;
    }
    pub fn set_slot_idx_raw(&mut self, value: [u8; 1]) {
        self.slot_idx_raw = value;
    }
    pub fn new(packetver: u32) -> CharacterList {
        CharacterList {
        raw: vec![],
        dw_gid: 0,
        dw_gid_raw: [0; 4],
        slot_idx: 0,
        slot_idx_raw: [0; 1],
        }
    }
}

impl BattleFieldInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> BattleFieldInfo {
        let mut offset: usize = 0;
        BattleFieldInfo {
            bfno: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            bfno_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            battle_field_name: {
                let field =  {
                let mut dst: [char; 56] = [0 as char; 56];
                for (index, byte) in buffer[offset..offset + 56].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            battle_field_name_raw: {
                let mut dst: [u8; 56] = [0u8; 56];
                dst.clone_from_slice(&buffer[offset..offset + 56]);
                offset += 56;
                dst
            },
            join_team: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            join_team_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.bfno).unwrap();
        self.bfno_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.battle_field_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.battle_field_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.join_team).unwrap();
        self.join_team_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.bfno_raw.to_vec());
        wtr.append(&mut self.battle_field_name_raw.to_vec());
        wtr.append(&mut self.join_team_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 62;
        base_len
    }
    pub fn set_bfno(&mut self, value: u32) {
        self.bfno = value;
    }
    pub fn set_bfno_raw(&mut self, value: [u8; 4]) {
        self.bfno_raw = value;
    }
    pub fn set_battle_field_name(&mut self, value: [char; 56]) {
        self.battle_field_name = value;
    }
    pub fn set_battle_field_name_raw(&mut self, value: [u8; 56]) {
        self.battle_field_name_raw = value;
    }
    pub fn set_join_team(&mut self, value: i16) {
        self.join_team = value;
    }
    pub fn set_join_team_raw(&mut self, value: [u8; 2]) {
        self.join_team_raw = value;
    }
    pub fn new(packetver: u32) -> BattleFieldInfo {
        BattleFieldInfo {
        raw: vec![],
        bfno: 0,
        bfno_raw: [0; 4],
        battle_field_name: [0 as char; 56],
        battle_field_name_raw: [0; 56],
        join_team: 0,
        join_team_raw: [0; 2],
        }
    }
}

impl PartyBookingDetail {
    pub fn from(buffer: &[u8], packetver: u32) -> PartyBookingDetail {
        let mut offset: usize = 0;
        PartyBookingDetail {
            level: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            level_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            map_id: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            map_id_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            job: {
                let field =  {
                let mut dst: [i16; 6] = [0_i16; 6];
                for (index, byte) in buffer[offset..offset + 6].iter().enumerate() {
                    dst[index] = *byte as i16;
                }
                dst
            };
                field
            },
            job_raw: {
                let mut dst: [u8; 12] = [0u8; 12];
                dst.clone_from_slice(&buffer[offset..offset + 12]);
                offset += 12;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.level).unwrap();
        self.level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.map_id).unwrap();
        self.map_id_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.job {
            wtr.write_i16::<LittleEndian>(item).unwrap();
        }
        self.job_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.level_raw.to_vec());
        wtr.append(&mut self.map_id_raw.to_vec());
        wtr.append(&mut self.job_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 10;
        base_len
    }
    pub fn set_level(&mut self, value: i16) {
        self.level = value;
    }
    pub fn set_level_raw(&mut self, value: [u8; 2]) {
        self.level_raw = value;
    }
    pub fn set_map_id(&mut self, value: i16) {
        self.map_id = value;
    }
    pub fn set_map_id_raw(&mut self, value: [u8; 2]) {
        self.map_id_raw = value;
    }
    pub fn set_job(&mut self, value: [i16; 6]) {
        self.job = value;
    }
    pub fn set_job_raw(&mut self, value: [u8; 12]) {
        self.job_raw = value;
    }
    pub fn new(packetver: u32) -> PartyBookingDetail {
        PartyBookingDetail {
        raw: vec![],
        level: 0,
        level_raw: [0; 2],
        map_id: 0,
        map_id_raw: [0; 2],
        job: [0; 6],
        job_raw: [0; 12],
        }
    }
}

impl PartyBookingAdInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> PartyBookingAdInfo {
        let mut offset: usize = 0;
        PartyBookingAdInfo {
            index: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            char_name: {
                let field =  {
                let mut dst: [char; 24] = [0 as char; 24];
                for (index, byte) in buffer[offset..offset + 24].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            char_name_raw: {
                let mut dst: [u8; 24] = [0u8; 24];
                dst.clone_from_slice(&buffer[offset..offset + 24]);
                offset += 24;
                dst
            },
            expire_time: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            expire_time_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            detail: {
                let field = PartyBookingDetail::from(&buffer[offset..offset + PartyBookingDetail::base_len(packetver)], packetver);
                field
            },
            detail_raw: {
                let raw = buffer[offset..buffer.len()].to_vec();
                offset += raw.len();
                raw
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.char_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.char_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.expire_time).unwrap();
        self.expire_time_raw = wtr.try_into().unwrap();
        self.detail.fill_raw_with_packetver(packetver);
        self.detail_raw = self.detail.clone().raw;


        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.char_name_raw.to_vec());
        wtr.append(&mut self.expire_time_raw.to_vec());
        wtr.append(&mut self.detail_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 31;
        base_len
    }
    pub fn set_index(&mut self, value: u32) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 4]) {
        self.index_raw = value;
    }
    pub fn set_char_name(&mut self, value: [char; 24]) {
        self.char_name = value;
    }
    pub fn set_char_name_raw(&mut self, value: [u8; 24]) {
        self.char_name_raw = value;
    }
    pub fn set_expire_time(&mut self, value: i32) {
        self.expire_time = value;
    }
    pub fn set_expire_time_raw(&mut self, value: [u8; 4]) {
        self.expire_time_raw = value;
    }
    pub fn set_detail(&mut self, value: PartyBookingDetail) {
        self.detail = value;
    }
    pub fn set_detail_raw(&mut self, value: Vec<u8>) {
        self.detail_raw = value;
    }
    pub fn new(packetver: u32) -> PartyBookingAdInfo {
        PartyBookingAdInfo {
        raw: vec![],
        index: 0,
        index_raw: [0; 4],
        char_name: [0 as char; 24],
        char_name_raw: [0; 24],
        expire_time: 0,
        expire_time_raw: [0; 4],
        detail: PartyBookingDetail::new(packetver),
        detail_raw: vec![],
        }
    }
}

impl ProductinfoInBuyingStore {
    pub fn from(buffer: &[u8], packetver: u32) -> ProductinfoInBuyingStore {
        let mut offset: usize = 0;
        ProductinfoInBuyingStore {
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            price: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.price_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 8;
        base_len
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_price(&mut self, value: i32) {
        self.price = value;
    }
    pub fn set_price_raw(&mut self, value: [u8; 4]) {
        self.price_raw = value;
    }
    pub fn new(packetver: u32) -> ProductinfoInBuyingStore {
        ProductinfoInBuyingStore {
        raw: vec![],
        itid: 0,
        itid_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        price: 0,
        price_raw: [0; 4],
        }
    }
}

impl BuyingStoreItemlist {
    pub fn from(buffer: &[u8], packetver: u32) -> BuyingStoreItemlist {
        let mut offset: usize = 0;
        BuyingStoreItemlist {
            price: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            atype: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            atype_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.atype).unwrap();
        self.atype_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.price_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.atype_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 9;
        base_len
    }
    pub fn set_price(&mut self, value: i32) {
        self.price = value;
    }
    pub fn set_price_raw(&mut self, value: [u8; 4]) {
        self.price_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_atype(&mut self, value: u8) {
        self.atype = value;
    }
    pub fn set_atype_raw(&mut self, value: [u8; 1]) {
        self.atype_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn new(packetver: u32) -> BuyingStoreItemlist {
        BuyingStoreItemlist {
        raw: vec![],
        price: 0,
        price_raw: [0; 4],
        count: 0,
        count_raw: [0; 2],
        atype: 0,
        atype_raw: [0; 1],
        itid: 0,
        itid_raw: [0; 2],
        }
    }
}

impl TradeItemBuyingStore {
    pub fn from(buffer: &[u8], packetver: u32) -> TradeItemBuyingStore {
        let mut offset: usize = 0;
        TradeItemBuyingStore {
            index: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            index_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            count: {
                let field = i16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.index).unwrap();
        self.index_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.index_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 6;
        base_len
    }
    pub fn set_index(&mut self, value: u16) {
        self.index = value;
    }
    pub fn set_index_raw(&mut self, value: [u8; 2]) {
        self.index_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_count(&mut self, value: i16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn new(packetver: u32) -> TradeItemBuyingStore {
        TradeItemBuyingStore {
        raw: vec![],
        index: 0,
        index_raw: [0; 2],
        itid: 0,
        itid_raw: [0; 2],
        count: 0,
        count_raw: [0; 2],
        }
    }
}

impl ResultItemInfo {
    pub fn from(buffer: &[u8], packetver: u32) -> ResultItemInfo {
        let mut offset: usize = 0;
        ResultItemInfo {
            ssiid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            ssiid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            aid: {
                let field = u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            aid_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            store_name: {
                let field =  {
                let mut dst: [char; 80] = [0 as char; 80];
                for (index, byte) in buffer[offset..offset + 80].iter().enumerate() {
                    dst[index] = *byte as char;
                }
                dst
            };
                field
            },
            store_name_raw: {
                let mut dst: [u8; 80] = [0u8; 80];
                dst.clone_from_slice(&buffer[offset..offset + 80]);
                offset += 80;
                dst
            },
            itid: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            itid_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            item_type: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            item_type_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            price: {
                let field = i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]]);
                field
            },
            price_raw: {
                let mut dst: [u8; 4] = [0u8; 4];
                dst.clone_from_slice(&buffer[offset..offset + 4]);
                offset += 4;
                dst
            },
            count: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            count_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            refining_level: {
                let field = u8::from_le_bytes([buffer[offset]]);
                field
            },
            refining_level_raw: {
                let mut dst: [u8; 1] = [0u8; 1];
                dst.clone_from_slice(&buffer[offset..offset + 1]);
                offset += 1;
                dst
            },
            card1: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            card1_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            card2: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            card2_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            card3: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            card3_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            card4: {
                let field = u16::from_le_bytes([buffer[offset], buffer[offset + 1]]);
                field
            },
            card4_raw: {
                let mut dst: [u8; 2] = [0u8; 2];
                dst.clone_from_slice(&buffer[offset..offset + 2]);
                offset += 2;
                dst
            },
            raw: (&buffer[..offset]).to_vec(),
        }
    }
    pub fn fill_raw(&mut self) {
      self.fill_raw_with_packetver(None)
    }
    pub fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {
    let mut wtr;
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.ssiid).unwrap();
        self.ssiid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u32::<LittleEndian>(self.aid).unwrap();
        self.aid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        for item in self.store_name {
            wtr.write_u8(item as u8 ).unwrap();
        }
        self.store_name_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.itid).unwrap();
        self.itid_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.item_type).unwrap();
        self.item_type_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_i32::<LittleEndian>(self.price).unwrap();
        self.price_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.count).unwrap();
        self.count_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u8(self.refining_level).unwrap();
        self.refining_level_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card1).unwrap();
        self.card1_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card2).unwrap();
        self.card2_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card3).unwrap();
        self.card3_raw = wtr.try_into().unwrap();
        wtr = vec![];
        wtr.write_u16::<LittleEndian>(self.card4).unwrap();
        self.card4_raw = wtr.try_into().unwrap();

        wtr = vec![];
        wtr.append(&mut self.ssiid_raw.to_vec());
        wtr.append(&mut self.aid_raw.to_vec());
        wtr.append(&mut self.store_name_raw.to_vec());
        wtr.append(&mut self.itid_raw.to_vec());
        wtr.append(&mut self.item_type_raw.to_vec());
        wtr.append(&mut self.price_raw.to_vec());
        wtr.append(&mut self.count_raw.to_vec());
        wtr.append(&mut self.refining_level_raw.to_vec());
        wtr.append(&mut self.card1_raw.to_vec());
        wtr.append(&mut self.card2_raw.to_vec());
        wtr.append(&mut self.card3_raw.to_vec());
        wtr.append(&mut self.card4_raw.to_vec());
        self.raw = wtr;
    }
    pub fn base_len(packetver: u32) -> usize {
        let  base_len: usize = 106;
        base_len
    }
    pub fn set_ssiid(&mut self, value: u32) {
        self.ssiid = value;
    }
    pub fn set_ssiid_raw(&mut self, value: [u8; 4]) {
        self.ssiid_raw = value;
    }
    pub fn set_aid(&mut self, value: u32) {
        self.aid = value;
    }
    pub fn set_aid_raw(&mut self, value: [u8; 4]) {
        self.aid_raw = value;
    }
    pub fn set_store_name(&mut self, value: [char; 80]) {
        self.store_name = value;
    }
    pub fn set_store_name_raw(&mut self, value: [u8; 80]) {
        self.store_name_raw = value;
    }
    pub fn set_itid(&mut self, value: u16) {
        self.itid = value;
    }
    pub fn set_itid_raw(&mut self, value: [u8; 2]) {
        self.itid_raw = value;
    }
    pub fn set_item_type(&mut self, value: u8) {
        self.item_type = value;
    }
    pub fn set_item_type_raw(&mut self, value: [u8; 1]) {
        self.item_type_raw = value;
    }
    pub fn set_price(&mut self, value: i32) {
        self.price = value;
    }
    pub fn set_price_raw(&mut self, value: [u8; 4]) {
        self.price_raw = value;
    }
    pub fn set_count(&mut self, value: u16) {
        self.count = value;
    }
    pub fn set_count_raw(&mut self, value: [u8; 2]) {
        self.count_raw = value;
    }
    pub fn set_refining_level(&mut self, value: u8) {
        self.refining_level = value;
    }
    pub fn set_refining_level_raw(&mut self, value: [u8; 1]) {
        self.refining_level_raw = value;
    }
    pub fn set_card1(&mut self, value: u16) {
        self.card1 = value;
    }
    pub fn set_card1_raw(&mut self, value: [u8; 2]) {
        self.card1_raw = value;
    }
    pub fn set_card2(&mut self, value: u16) {
        self.card2 = value;
    }
    pub fn set_card2_raw(&mut self, value: [u8; 2]) {
        self.card2_raw = value;
    }
    pub fn set_card3(&mut self, value: u16) {
        self.card3 = value;
    }
    pub fn set_card3_raw(&mut self, value: [u8; 2]) {
        self.card3_raw = value;
    }
    pub fn set_card4(&mut self, value: u16) {
        self.card4 = value;
    }
    pub fn set_card4_raw(&mut self, value: [u8; 2]) {
        self.card4_raw = value;
    }
    pub fn new(packetver: u32) -> ResultItemInfo {
        ResultItemInfo {
        raw: vec![],
        ssiid: 0,
        ssiid_raw: [0; 4],
        aid: 0,
        aid_raw: [0; 4],
        store_name: [0 as char; 80],
        store_name_raw: [0; 80],
        itid: 0,
        itid_raw: [0; 2],
        item_type: 0,
        item_type_raw: [0; 1],
        price: 0,
        price_raw: [0; 4],
        count: 0,
        count_raw: [0; 2],
        refining_level: 0,
        refining_level_raw: [0; 1],
        card1: 0,
        card1_raw: [0; 2],
        card2: 0,
        card2_raw: [0; 2],
        card3: 0,
        card3_raw: [0; 2],
        card4: 0,
        card4_raw: [0; 2],
        }
    }
}

