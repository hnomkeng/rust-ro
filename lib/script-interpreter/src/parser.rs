// Generated by lib/script-interpreter/generator
// Auto generated file do not edit manually

use crate::token::Token;
use crate::ast::expression::*;
use crate::parser_state::ParserState;

pub fn parse(tokens: &Vec<Token>) -> Box<dyn Expression> {
    let mut parser_state = ParserState::new(tokens);
}
pub fn parse_token(parser_state: &mut ParserState, token_type: TokenType) -> bool {
    parser_state.consume(token_type)
}

// <declaration>
pub fn parse_root_expression(parser_state: &mut ParserState) -> bool {
    let mut result = false;
    if !result {
        result = parse_declaration(parser_state);
    }
    result
}
// "Identifier" | "Number" | "String" | "LeftParen" <any_expression> "RightParen"
pub fn parse_primary_expression(parser_state: &mut ParserState) -> bool {
    let mut result = false;
    if !result {
        result = parse_token(parser_state, TokenType::Identifier);
    }
    if !result {
        result = parse_token(parser_state, TokenType::Number);
    }
    if !result {
        result = parse_token(parser_state, TokenType::String);
    }
    if !result {
        result = parse_token(parser_state, TokenType::LeftParen);
        result = result && parse_any_expression(parser_state);
        result = result && parse_token(parser_state, TokenType::RightParen);
    }
    result
}
// <primary_expression> | <postfix_expression> "LeftBracket" <any_expression> "RightBracket" | <postfix_expression> "LeftParen" "RightParen" | <postfix_expression> "Dot" "Identifier" | <postfix_expression> "IncrementOp" | <postfix_expression> "DecrementOp"
pub fn parse_postfix_expression(parser_state: &mut ParserState) -> bool {
    let mut result = false;
    if !result {
        result = parse_primary_expression(parser_state);
    }
    if !result {
        result = parse_postfix_expression(parser_state);
        result = result && parse_token(parser_state, TokenType::LeftBracket);
        result = result && parse_any_expression(parser_state);
        result = result && parse_token(parser_state, TokenType::RightBracket);
    }
    if !result {
        result = parse_postfix_expression(parser_state);
        result = result && parse_token(parser_state, TokenType::LeftParen);
        result = result && parse_token(parser_state, TokenType::RightParen);
    }
    if !result {
        result = parse_postfix_expression(parser_state);
        result = result && parse_token(parser_state, TokenType::Dot);
        result = result && parse_token(parser_state, TokenType::Identifier);
    }
    if !result {
        result = parse_postfix_expression(parser_state);
        result = result && parse_token(parser_state, TokenType::IncrementOp);
    }
    if !result {
        result = parse_postfix_expression(parser_state);
        result = result && parse_token(parser_state, TokenType::DecrementOp);
    }
    result
}
// <conditional_expression> | <unary_expression> <assignment_operator> <assignment_expression>
pub fn parse_assignment_expression(parser_state: &mut ParserState) -> bool {
    let mut result = false;
    if !result {
        result = parse_conditional_expression(parser_state);
    }
    if !result {
        result = parse_unary_expression(parser_state);
        result = result && parse_assignment_operator(parser_state);
        result = result && parse_assignment_expression(parser_state);
    }
    result
}
// <logical_and_expression> | <logical_or_expression> "OrOp" <logical_and_expression>
pub fn parse_logical_or_expression(parser_state: &mut ParserState) -> bool {
    let mut result = false;
    if !result {
        result = parse_logical_and_expression(parser_state);
    }
    if !result {
        result = parse_logical_or_expression(parser_state);
        result = result && parse_token(parser_state, TokenType::OrOp);
        result = result && parse_logical_and_expression(parser_state);
    }
    result
}
// "Equal"
pub fn parse_logical_and_expression(parser_state: &mut ParserState) -> bool {
    let mut result = false;
    if !result {
        result = parse_token(parser_state, TokenType::Equal);
    }
    result
}
// <logical_or_expression> | <logical_or_expression> "QuestionMark" <any_expression> "Colon" <conditional_expression>
pub fn parse_conditional_expression(parser_state: &mut ParserState) -> bool {
    let mut result = false;
    if !result {
        result = parse_logical_or_expression(parser_state);
    }
    if !result {
        result = parse_logical_or_expression(parser_state);
        result = result && parse_token(parser_state, TokenType::QuestionMark);
        result = result && parse_any_expression(parser_state);
        result = result && parse_token(parser_state, TokenType::Colon);
        result = result && parse_conditional_expression(parser_state);
    }
    result
}
// "Equal"
pub fn parse_assignment_operator(parser_state: &mut ParserState) -> bool {
    let mut result = false;
    if !result {
        result = parse_token(parser_state, TokenType::Equal);
    }
    result
}
// <postfix_expression> | "IncrementOp" <unary_expression> | "DecrementOp" <unary_expression>
pub fn parse_unary_expression(parser_state: &mut ParserState) -> bool {
    let mut result = false;
    if !result {
        result = parse_postfix_expression(parser_state);
    }
    if !result {
        result = parse_token(parser_state, TokenType::IncrementOp);
        result = result && parse_unary_expression(parser_state);
    }
    if !result {
        result = parse_token(parser_state, TokenType::DecrementOp);
        result = result && parse_unary_expression(parser_state);
    }
    result
}
// <assignment_expression>
pub fn parse_any_expression(parser_state: &mut ParserState) -> bool {
    let mut result = false;
    if !result {
        result = parse_assignment_expression(parser_state);
    }
    result
}
// <declaration_specifiers> "SemiColon"
pub fn parse_declaration(parser_state: &mut ParserState) -> bool {
    let mut result = false;
    if !result {
        result = parse_declaration_specifiers(parser_state);
        result = result && parse_token(parser_state, TokenType::SemiColon);
    }
    result
}
// <variable> | <variable> "Equal" <assignment_expression>
pub fn parse_declaration_specifiers(parser_state: &mut ParserState) -> bool {
    let mut result = false;
    if !result {
        result = parse_variable(parser_state);
    }
    if !result {
        result = parse_variable(parser_state);
        result = result && parse_token(parser_state, TokenType::Equal);
        result = result && parse_assignment_expression(parser_state);
    }
    result
}
// <scope_specifier> "Identifier" | <scope_specifier> "Identifier" "Dollar"
pub fn parse_variable(parser_state: &mut ParserState) -> bool {
    let mut result = false;
    if !result {
        result = parse_scope_specifier(parser_state);
        result = result && parse_token(parser_state, TokenType::Identifier);
    }
    if !result {
        result = parse_scope_specifier(parser_state);
        result = result && parse_token(parser_state, TokenType::Identifier);
        result = result && parse_token(parser_state, TokenType::Dollar);
    }
    result
}
// "At" | "Dollar" | "DollarAt" | "Dot" | "DotAt" | "Quote" | "Sharp" | "DoubleSharp"
pub fn parse_scope_specifier(parser_state: &mut ParserState) -> bool {
    let mut result = false;
    if !result {
        result = parse_token(parser_state, TokenType::At);
    }
    if !result {
        result = parse_token(parser_state, TokenType::Dollar);
    }
    if !result {
        result = parse_token(parser_state, TokenType::DollarAt);
    }
    if !result {
        result = parse_token(parser_state, TokenType::Dot);
    }
    if !result {
        result = parse_token(parser_state, TokenType::DotAt);
    }
    if !result {
        result = parse_token(parser_state, TokenType::Quote);
    }
    if !result {
        result = parse_token(parser_state, TokenType::Sharp);
    }
    if !result {
        result = parse_token(parser_state, TokenType::DoubleSharp);
    }
    result
}
// "Identifier" | "Identifier" "Dollar"
pub fn parse_variable_name(parser_state: &mut ParserState) -> bool {
    let mut result = false;
    if !result {
        result = parse_token(parser_state, TokenType::Identifier);
    }
    if !result {
        result = parse_token(parser_state, TokenType::Identifier);
        result = result && parse_token(parser_state, TokenType::Dollar);
    }
    result
}
