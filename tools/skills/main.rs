use std::{fs, mem};
use std::fs::File;
use std::io::Write;
use std::path::Path;
use convert_case::{Case, Casing};
use lazy_static::lazy_static;
use std::collections::{HashMap, HashSet};
use regex::Regex;
use serde_json::Error;
use configuration::configuration::{JobSkillTree, SkillConfig, SkillsConfig};
use enums::EnumWithMaskValueU64;
use enums::skill::SkillFlags;

lazy_static! {
    pub static ref SHORT_CLASS_NAME: HashMap<&'static str, &'static str> = HashMap::from([
        ("nv", "Novice"),
        ("sm", "Swordsman"),
        ("al", "Acolyte"),
        ("mg", "Magician"),
        ("mc", "Merchant"),
        ("ac", "Archer"),
        ("tf", "Thief"),
        ("kn", "Knight"),
        ("pr", "Priest"),
        ("wz", "Wizard"),
        ("bs", "Blacksmith"),
        ("ht", "Hunter"),
        ("as", "Assassin"),
        ("rg", "Rogue"),
        ("cr", "Crusader"),
        ("mo", "Monk"),
        ("sa", "Sage"),
        ("am", "Alchemist"),
        ("ba", "Bard"),
        ("bd", "Bard"),
        ("dc", "Dancer"),
        ("lk", "LordKnight"),
        ("hp", "HighPriest"),
        ("ch", "Champion"),
        ("pa", "Paladin"),
        ("asc", "AssassinCross"),
        ("sn", "Sniper"),
        ("st", "Stalker"),
        ("pf", "Professor"),
        ("ws", "Whitesmith"),
        ("cg", "Clown"),
        ("gn", "Creator"),
        ("hw", "HighWizard"),
        ("tk", "Taekwon"),
        ("sg", "StarGladiator"),
        ("sl", "SoulLinker"),
        ("gs", "Gunslinger"),
        ("nj", "Ninja"),
    ]);
     static ref NON_ALPHA_REGEX: Regex = Regex::new(r"[^A-Za-z]*").unwrap();
}


pub fn main() {
    let path = Path::new("./config/skill.json");
    let skill_tree_path = Path::new("./config/skill_tree.json");
    let output_path = Path::new("lib/skills/src");
    if !path.exists() {
        panic!("config/skill.json file does not exists at {}", path.to_str().unwrap());
    }
    if !skill_tree_path.exists() {
        panic!("config/skill_tree.json file does not exists at {}", skill_tree_path.to_str().unwrap());
    }

    let json = fs::read_to_string(path).unwrap();
    let mut config_deserializer = serde_json::Deserializer::from_str(&json);
    let result: Result<SkillsConfig, _> = serde_path_to_error::deserialize(&mut config_deserializer);
    match result {
        Err(err) => {
            let path = err.path().to_string();
            println!("Path in error {}", path);
            panic!("{}", err);
        }
        _ => {}
    }
    let mut skills_config: SkillsConfig = result.unwrap();
    let mut skill_tree: Vec<JobSkillTree> = configuration::configuration::Config::load_jobs_skill_tree(".").unwrap();
    let mut vec: Vec<(u32, SkillConfig)> = skills_config.skills.into_iter().collect::<Vec<(u32, SkillConfig)>>();
    vec.sort_by_key(|&(k, _)| k);
    let skills: Vec<SkillConfig> = vec.into_iter().map(|(_, v)| v).collect();

    generate_skills_enum(output_path, &skills, &skill_tree);
    generate_skills_impl(output_path, &skills, &skill_tree);
}

fn generate_skills_impl(output_path: &Path, skills: &Vec<SkillConfig>, skill_tree: &Vec<JobSkillTree>) {
    let file_path = output_path.join("skills").join("mod.rs");
    let mut file = File::create(file_path.clone()).unwrap();

    file.write_all("// Generated by tools/skills/main.rs\n".to_string().as_bytes()).unwrap();
    file.write_all("// Auto generated file do not edit manually\n\n".to_string().as_bytes()).unwrap();
    file.write_all("#![allow(dead_code)]\n\n".to_string().as_bytes()).unwrap();
    file.write_all("use crate::skill_enums::Skill;\n\n".to_string().as_bytes()).unwrap();

    for skill in skills.iter() {
        file.write_all(format!("pub struct {};\n", to_enum_name(skill)).as_bytes()).unwrap();
    }
    let mut files: HashMap<String, File> = HashMap::new();
    let mut skills_already_generated: HashSet<String> = HashSet::with_capacity(1000);
    for job_tree in skill_tree.iter() {
        if job_tree.tree().is_empty() {
            continue;
        }
        let file_name = job_tree.name().to_lowercase().replace(' ', "");
        file.write_all(format!("pub mod {};\n", file_name).as_bytes()).unwrap();
        let mut job_skills_file = File::create(output_path.join("skills").join(format!("{}.rs", file_name))).unwrap();

        write_file_header(&mut job_skills_file);
        for skill in job_tree.tree().iter() {
            let skill_config = get_skill_config(skill.name(), &skills).unwrap();
            write_skills(&mut job_skills_file, skill_config);
            skills_already_generated.insert(skill.name().clone());
        }
    }

    // NPC and third classes
    // file.write_all(b"pub mod any;").unwrap();
    // let mut file = File::create(output_path.join("skills").join("any.rs")).unwrap();
    // write_file_header(&mut file);
    // for skill_config in skills.iter() {
    //     if skills_already_generated.contains(skill_config.name()) {
    //         continue;
    //     }
    //     write_skills(&mut file, skill_config);
    // }
}

fn write_file_header(file: &mut File) {
    write_file_header_comments(file);
    file.write_all(b"use crate::{Skill, SkillRequirementResult};\n\n").unwrap();
    file.write_all(b"use crate::skills::*;\n").unwrap();
    file.write_all(b"use enums::skill::*;\n").unwrap();
    file.write_all(b"use models::weapon::Weapon;\n").unwrap();
}

fn write_file_header_comments(file: &mut File) {
    file.write_all("// Generated by tools/skills/main.rs\n".to_string().as_bytes()).unwrap();
    file.write_all("// Auto generated file do not edit manually\n\n".to_string().as_bytes()).unwrap();
    file.write_all("#![allow(dead_code)]\n\n".to_string().as_bytes()).unwrap();
}

fn write_skills(job_skills_file: &mut File, skill_config: &SkillConfig) {

    job_skills_file.write_all(format!("// {}\n", skill_config.name).as_bytes()).unwrap();
    job_skills_file.write_all(format!("pub struct {} {{\n", to_skill_name(skill_config)).as_bytes()).unwrap();
    job_skills_file.write_all(b"    level: u8,\n").unwrap();
    job_skills_file.write_all(b"}\n").unwrap();

    job_skills_file.write_all(format!("impl Skill for {} {{\n", to_skill_name(skill_config)).as_bytes()).unwrap();
    job_skills_file.write_all(b"    fn new(level: u8) -> Self {\n").unwrap();
    job_skills_file.write_all(b"        Self { level }\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
    job_skills_file.write_all(b"    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {\n").unwrap();
    if let Some(requirements) = skill_config.requires() {
        if let Some(spcost) = requirements.sp_cost() {
            job_skills_file.write_all(format!("        if character_sp > {} {{ Ok({}) }} else {{Err(())}}\n", spcost, spcost).as_bytes()).unwrap();
        } else if let Some(sp_cost_per_level) = requirements.sp_cost_per_level() {
            for (level, cost_per_level) in sp_cost_per_level.iter().enumerate() {
                if level == 0 { continue; }
                job_skills_file.write_all(format!("        if self.level == {} {{\n", level).as_bytes()).unwrap();
                job_skills_file.write_all(format!("            if character_sp >= {} {{ return Ok({}) }} else {{return Err(())}}\n", cost_per_level, cost_per_level).as_bytes()).unwrap();
                job_skills_file.write_all(b"        }\n").unwrap();
            }
            job_skills_file.write_all(b"        Err(())\n").unwrap();
        } else {
            job_skills_file.write_all(b"        Ok(0)\n").unwrap();
        }
    } else {
        job_skills_file.write_all(b"        Ok(0)\n").unwrap();
    }
    job_skills_file.write_all(b"    }\n").unwrap();
    job_skills_file.write_all(b"    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {\n").unwrap();
    job_skills_file.write_all(b"        Ok(0)\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
    job_skills_file.write_all(b"    fn validate_level(&self, character_level: u32) -> SkillRequirementResult<()> {\n").unwrap();
    job_skills_file.write_all(b"        Ok(())\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
    job_skills_file.write_all(b"    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {\n").unwrap();
    job_skills_file.write_all(b"        Ok(())\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
    job_skills_file.write_all(b"    fn validate_weapon(&self, character_weapon: Weapon) -> SkillRequirementResult<()> {\n").unwrap();
    job_skills_file.write_all(b"        Ok(())\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
    job_skills_file.write_all(b"    fn validate_range(&self, character_weapon: Weapon) -> SkillRequirementResult<()> {\n").unwrap();
    job_skills_file.write_all(b"         Ok(())\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
    job_skills_file.write_all(b"    fn hit_count(&self) -> u8 {\n").unwrap();
    job_skills_file.write_all(b"        1\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
    job_skills_file.write_all(b"    fn cast_delay(&self) -> u32 {\n").unwrap();
    job_skills_file.write_all(b"        0\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
    job_skills_file.write_all(b"    fn after_cast_delay(&self) -> u32 {\n").unwrap();
    job_skills_file.write_all(b"        0\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
    job_skills_file.write_all(b"}\n").unwrap();
}

fn generate_skills_enum(output_path: &Path, skills: &Vec<SkillConfig>, skill_tree: &Vec<JobSkillTree>) {
    let file_path = output_path.join("skill_enums.rs");
    let mut file = File::create(file_path.clone()).unwrap();
    write_file_header_comments(&mut file);
    file.write_all("#[derive(Clone, Copy, PartialEq, Debug)]\n".to_string().as_bytes()).unwrap();
    file.write_all("pub enum Skill {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        let class_name = class_name(skill, skill_tree);
        if let Some(class_name) = class_name {
            file.write_all(format!("    // {} {}\n", class_name, skill.description).as_bytes()).unwrap();
        } else {
            file.write_all(format!("    // {}\n", skill.description).as_bytes()).unwrap();
        }
        file.write_all(format!("    {enum_name},\n").as_bytes()).unwrap();
    }
    file.write_all("}\n".to_string().as_bytes()).unwrap();
    file.write_all("impl Skill {\n".to_string().as_bytes()).unwrap();
    file.write_all("    pub fn id(&self) -> u32{\n".to_string().as_bytes()).unwrap();
    file.write_all("        match self {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            Self::{} => {},\n", enum_name, skill.id).as_bytes()).unwrap();
    }
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    pub fn from_id(id: u32) -> Self {\n".to_string().as_bytes()).unwrap();
    file.write_all("        match id {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            {} => Self::{},\n", skill.id, enum_name).as_bytes()).unwrap();
    }
    file.write_all("            _ => panic!(\"unknown skill with id {}\", id)\n".to_string().as_bytes()).unwrap();
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();

    file.write_all("    pub fn from_name(name: &str) -> Self {\n".to_string().as_bytes()).unwrap();
    file.write_all("        match name {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            \"{}\" => Self::{},\n", skill.name, enum_name).as_bytes()).unwrap();
    }
    file.write_all("            _ => panic!(\"unknown skill with name {}\", name)\n".to_string().as_bytes()).unwrap();
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();

    file.write_all("    pub fn to_name(&self) -> &str {\n".to_string().as_bytes()).unwrap();
    file.write_all("        match self {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            Self::{} => \"{}\",\n", enum_name, skill.name).as_bytes()).unwrap();
    }
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();


    file.write_all("    pub fn is_platinium(&self) -> bool {\n".to_string().as_bytes()).unwrap();
    file.write_all("        match self {\n".to_string().as_bytes()).unwrap();
    let default_flags = 0;
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            Self::{} => {},\n", enum_name,
                               SkillFlags::Iswedding.as_flag() & skill.flags.as_ref().unwrap_or(&default_flags) != 0 ||
                                   SkillFlags::Isquest.as_flag() & skill.flags.as_ref().unwrap_or(&default_flags) != 0
        ).as_bytes()).unwrap();
    }
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();

    file.write_all("}\n".to_string().as_bytes()).unwrap();
    println!("Skills enum generated at {}", file_path.to_str().unwrap());
}

fn to_enum_name(skill: &SkillConfig) -> String {
    skill.name.to_case(Case::Title).replace(' ', "")
}
fn to_skill_name(skill: &SkillConfig) -> String {
    NON_ALPHA_REGEX.replace_all(&skill.description, "").to_case(Case::UpperCamel)
}

fn get_skill_config<'a>(skill_name: &String, skills: &'a Vec<SkillConfig>) -> Option<&'a SkillConfig> {
    for skill_config in skills {
        if skill_name.eq(skill_config.name()) {
            return Some(skill_config);
        }
    }
    None
}

fn class_name<'a>(skill_config: &'a SkillConfig, skill_tree: &Vec<JobSkillTree>) -> Option<String> {
    for job_tree in skill_tree.iter() {
        for skill in job_tree.tree().iter() {
            if skill_config.name().to_lowercase().starts_with("bd") {
                return Some("Bard".to_string());
            }
            if skill_config.name().to_lowercase().starts_with("cg") {
                return Some("Clown".to_string());
            }
            if skill.name().eq(skill_config.name()) {
                return Some(job_tree.name().clone());
            }
        }
    }
    None
}