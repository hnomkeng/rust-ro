use std::{fs};
use std::fs::File;
use std::io::Write;
use std::path::Path;
use convert_case::{Case, Casing};
use lazy_static::lazy_static;
use std::collections::{HashMap, HashSet};
use regex::Regex;
use configuration::configuration::{JobSkillTree, SkillConfig, SkillsConfig};
use enums::{EnumWithMaskValueU64, EnumWithStringValue};
use enums::skill::SkillFlags;

lazy_static! {
    pub static ref SHORT_CLASS_NAME: HashMap<&'static str, &'static str> = HashMap::from([
        ("novice", "nv"),
        ("swordsman", "sm"),
        ("acolyte", "al"),
        ("magician", "mg"),
        ("mage", "mg"),
        ("merchant", "mc"),
        ("archer", "ac"),
        ("thief", "tf"),
        ("knight", "kn"),
        ("priest", "pr"),
        ("wizard", "wz"),
        ("blacksmith", "bs"),
        ("hunter", "ht"),
        ("assassin", "as"),
        ("rogue", "rg"),
        ("crusader", "cr"),
        ("monk", "mo"),
        ("sage", "sa"),
        ("alchemist", "am"),
        ("bard", "ba"),
        ("dancer", "dc"),
        ("lordknight", "lk"),
        ("highpriest", "hp"),
        ("champion", "ch"),
        ("paladin", "pa"),
        ("assassincross", "asc"),
        ("sniper", "sn"),
        ("stalker", "st"),
        ("professor", "pf"),
        ("whitesmith", "ws"),
        ("clown", "cg"),
        ("creator", "cr"),
        ("highwizard", "hw"),
        ("taekwon", "tk"),
        ("stargladiator", "sg"),
        ("soullinker", "sl"),
        ("gunslinger", "gs"),
        ("ninja", "nj"),
    ]);
     static ref NON_ALPHA_REGEX: Regex = Regex::new(r"[^A-Za-z0-9]*").unwrap();
}


pub fn main() {
    let path = Path::new("./config/skill.json");
    let skill_tree_path = Path::new("./config/skill_tree.json");
    let output_path = Path::new("lib/skills/src");
    if !path.exists() {
        panic!("config/skill.json file does not exists at {}", path.to_str().unwrap());
    }
    if !skill_tree_path.exists() {
        panic!("config/skill_tree.json file does not exists at {}", skill_tree_path.to_str().unwrap());
    }

    let json = fs::read_to_string(path).unwrap();
    let mut config_deserializer = serde_json::Deserializer::from_str(&json);
    let result: Result<SkillsConfig, _> = serde_path_to_error::deserialize(&mut config_deserializer);
    match result {
        Err(err) => {
            let path = err.path().to_string();
            println!("Path in error {}", path);
            panic!("{}", err);
        }
        _ => {}
    }
    let skills_config: SkillsConfig = result.unwrap();
    let skill_tree: Vec<JobSkillTree> = configuration::configuration::Config::load_jobs_skill_tree(".").unwrap();
    let mut vec: Vec<(u32, SkillConfig)> = skills_config.skills.into_iter().collect::<Vec<(u32, SkillConfig)>>();
    vec.sort_by_key(|&(k, _)| k);
    let skills: Vec<SkillConfig> = vec.into_iter().map(|(_, v)| v).collect();

    let mut skills_already_generated: HashSet<String> = HashSet::with_capacity(1000);
    let mut jobs_with_skills: HashSet<String> = HashSet::with_capacity(100);
    generate_skills_impl(output_path, &skills, &skill_tree, &mut skills_already_generated, &mut jobs_with_skills);
    generate_skills_enum(output_path, &skills, &skill_tree, &skills_already_generated, &jobs_with_skills);
}

fn generate_skills_impl(output_path: &Path, skills: &Vec<SkillConfig>, skill_tree: &Vec<JobSkillTree>, skills_already_generated: &mut HashSet<String>, jobs_with_skills: &mut HashSet<String>) {
    let file_path = output_path.join("skills").join("mod.rs");
    let mut file = File::create(file_path.clone()).unwrap();

    file.write_all("// Generated by tools/skills/main.rs\n".to_string().as_bytes()).unwrap();
    file.write_all("// Auto generated file do not edit manually\n\n".to_string().as_bytes()).unwrap();
    file.write_all("#![allow(dead_code)]\n\n".to_string().as_bytes()).unwrap();

    for skill in skills.iter() {
        file.write_all(format!("pub struct {};\n", to_enum_name(skill)).as_bytes()).unwrap();
    }

    for job_tree in skill_tree.iter() {
        if job_tree.tree().is_empty() {
            continue;
        }
        let file_name = job_tree.name().to_lowercase().replace(' ', "");
        file.write_all(format!("pub mod {};\n", file_name).as_bytes()).unwrap();
        let mut job_skills_file = File::create(output_path.join("skills").join(format!("{}.rs", file_name))).unwrap();

        write_file_header(&mut job_skills_file);
        for skill in job_tree.tree().iter() {
            if skills_already_generated.contains(skill.name()) {
                continue;
            }

            if let Some(job) = SHORT_CLASS_NAME.get(job_tree.name().to_lowercase().as_str()) {
                if (!skill.name().to_lowercase().starts_with(job) && !job_tree.name().to_lowercase().eq("bard")) || (job_tree.name().to_lowercase().eq("bard") && !(skill.name().to_lowercase().starts_with("bd") || skill.name().to_lowercase().starts_with("ba"))) {
                    println!("Skipping skill {} for job {}", skill.name(), job_tree.name());
                    continue;
                }
                let skill_config = get_skill_config(skill.name(), &skills).unwrap();
                write_skills(&mut job_skills_file, skill_config);
                skills_already_generated.insert(skill.name().clone());
                jobs_with_skills.insert(file_name.clone());
            }
        }
    }

    // NPC and third classes
    // file.write_all(b"pub mod any;").unwrap();
    // let mut file = File::create(output_path.join("skills").join("any.rs")).unwrap();
    // write_file_header(&mut file);
    // for skill_config in skills.iter() {
    //     if skills_already_generated.contains(skill_config.name()) {
    //         continue;
    //     }
    //     write_skills(&mut file, skill_config);
    // }
}

fn write_file_header(file: &mut File) {
    write_file_header_comments(file);
    file.write_all(b"use enums::{EnumWithMaskValueU64, EnumWithNumberValue};\n").unwrap();
    file.write_all(b"use enums::skill::*;\n").unwrap();
    file.write_all(b"use enums::weapon::AmmoType;\n").unwrap();
    file.write_all(b"\nuse models::item::WearWeapon;\n").unwrap();
    file.write_all(b"use models::item::NormalInventoryItem;\n").unwrap();
    file.write_all(b"\nuse crate::{Skill, SkillRequirementResult, DelegateSkill};\n\n").unwrap();
    file.write_all(b"use crate::skills::*;\n").unwrap();
}

fn write_file_header_comments(file: &mut File) {
    file.write_all("// Generated by tools/skills/main.rs\n".to_string().as_bytes()).unwrap();
    file.write_all("// Auto generated file do not edit manually\n\n".to_string().as_bytes()).unwrap();
    file.write_all("#![allow(dead_code, unused_must_use, unused_imports, unused_variables)]\n\n".to_string().as_bytes()).unwrap();
}

fn write_skills(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(format!("// {}\n", skill_config.name).as_bytes()).unwrap();

    generate_struct(job_skills_file, skill_config);
    generate_new(job_skills_file, skill_config);
    generate_getters(job_skills_file);

    generate_id(job_skills_file, skill_config);
    generate_validate_sp(job_skills_file, skill_config);
    generate_validate_hp(job_skills_file, skill_config);
    generate_validate_ammo(job_skills_file, skill_config);
    generate_validate_state(job_skills_file, skill_config);
    generate_validate_zeny(job_skills_file, skill_config);

    job_skills_file.write_all(b"    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {\n").unwrap();
    job_skills_file.write_all(b"        Ok(0)\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();

    job_skills_file.write_all(b"    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {\n").unwrap();
    job_skills_file.write_all(b"        Ok(None)\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();


    job_skills_file.write_all(b"    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {\n").unwrap();
    job_skills_file.write_all(b"        Ok(())\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();

    generate_validate_weapon(job_skills_file, skill_config);

    job_skills_file.write_all(b"    fn validate_range(&self, character_weapon: Option<WearWeapon>) -> SkillRequirementResult<()> {\n").unwrap();
    job_skills_file.write_all(b"         Ok(())\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();


    generate_skip_validation_item(job_skills_file, skill_config);

    generate_base_cast_time(job_skills_file, skill_config);
    generate_hit_count(job_skills_file, skill_config);
    generate_base_after_cast_act_delay(job_skills_file, skill_config);
    generate_base_after_cast_walk_delay(job_skills_file, skill_config);
    job_skills_file.write_all(b"}\n").unwrap();
}

fn generate_base_cast_time(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn base_cast_time(&self) -> u32 {\n").unwrap();
    generate_return_per_level_u32(job_skills_file, skill_config.cast_time(), skill_config.cast_time_per_level());
}

fn generate_id(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn id(&self) -> u32 {\n").unwrap();
    job_skills_file.write_all(format!("        {}\n", skill_config.id).as_bytes()).unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
}

fn generate_skip_validation_item(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn skip_item_validation(&self, state: Option<u64>) -> bool {\n").unwrap();
    if let Some(skip_requirement) = skill_config.skip_requires() {
        if let Some(item_cost) = skip_requirement.item_cost() {
            if let Some(state) = item_cost.state() {
                job_skills_file.write_all(format!("        // {}\n", state.as_str()).as_bytes()).unwrap();
                job_skills_file.write_all(format!("        if state.unwrap_or(0) & {} > 0 {{ return true; }}\n", state.as_flag()).as_bytes()).unwrap();
            }
        }
    }
    job_skills_file.write_all(b"        false\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
}

fn generate_base_after_cast_walk_delay(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn base_after_cast_walk_delay(&self) -> u32 {\n").unwrap();
    generate_return_per_level_u32(job_skills_file, &skill_config.after_cast_walk_delay(), &skill_config.after_cast_act_delay_per_level());
}

fn generate_base_after_cast_act_delay(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn base_after_cast_act_delay(&self) -> u32 {\n").unwrap();
    generate_return_per_level_u32(job_skills_file, &skill_config.after_cast_act_delay(), skill_config.after_cast_act_delay_per_level());
}

fn generate_hit_count(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn hit_count(&self) -> i8 {\n").unwrap();
    generate_return_per_level_i32(job_skills_file, skill_config.hit_count(), skill_config.hit_count_per_level());
}

fn generate_validate_weapon(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn validate_weapon(&self, character_weapon: Option<WearWeapon>) -> SkillRequirementResult<()> {\n").unwrap();
    if let Some(requirements) = skill_config.requires() {
        if let Some(weapon) = requirements.weapon_flags() {
            job_skills_file.write_all(b"        if let Some(character_weapon) = character_weapon {\n").unwrap();
            job_skills_file.write_all(format!("            if {} & character_weapon.weapon_type.as_flag() > 0 {{ Ok(()) }} else {{ Err(()) }}\n", weapon).as_bytes()).unwrap();
            job_skills_file.write_all(b"        } else {\n").unwrap();
            job_skills_file.write_all(b"            Err(())\n").unwrap();
            job_skills_file.write_all(b"        }\n").unwrap();
        } else {
            job_skills_file.write_all(b"        Ok(())\n").unwrap();
        }
    } else {
        job_skills_file.write_all(b"        Ok(())\n").unwrap();
    }
    job_skills_file.write_all(b"    }\n").unwrap();
}

fn generate_validate_zeny(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {\n").unwrap();
    let requirements = skill_config.requires().as_ref();
    generate_validate_per_level(job_skills_file, "zeny", requirements.map(|c| c.zeny_cost()).unwrap_or(&None), requirements.map(|c| c.zeny_cost_per_level()).unwrap_or(&None));
}

fn generate_validate_state(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn validate_state(&self, state: Option<u64>) -> SkillRequirementResult<()> {\n").unwrap();
    if let Some(requirements) = skill_config.requires() {
        if let Some(state) = requirements.state() {
            job_skills_file.write_all(b"        if let Some(state) = state {\n").unwrap();
            job_skills_file.write_all(format!("            // {}\n", state.as_str()).as_bytes()).unwrap();
            job_skills_file.write_all(format!("            if state & {} > 0 {{ Ok(()) }} else {{ Err(()) }}\n", state.as_flag()).as_bytes()).unwrap();
            job_skills_file.write_all(b"        } else {\n").unwrap();
            job_skills_file.write_all(b"            Err(())\n").unwrap();
            job_skills_file.write_all(b"        }\n").unwrap();
        } else {
            job_skills_file.write_all(b"        Ok(())\n").unwrap();
        }
    } else {
        job_skills_file.write_all(b"        Ok(())\n").unwrap();
    }
    job_skills_file.write_all(b"    }\n").unwrap();
}

fn generate_validate_ammo(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {\n").unwrap();
    if let Some(requirements) = skill_config.requires() {
        if let Some(ammo_amount) = requirements.ammo_amount() {
            if let Some(ammo_flags) = requirements.ammo_flags() {
                job_skills_file.write_all(b"        if let Some(ammo_and_amount) = character_ammo {\n").unwrap();
                job_skills_file.write_all(format!("            if ammo_and_amount.1 >= {} && ({} & ammo_and_amount.0.as_flag()) > 0 {{ Ok({}) }} else {{ Err(()) }}\n", ammo_amount, ammo_flags, ammo_amount).as_bytes()).unwrap();
                job_skills_file.write_all(b"        } else {\n").unwrap();
                job_skills_file.write_all(b"            Err(())\n").unwrap();
                job_skills_file.write_all(b"        }\n").unwrap();
            } else {
                panic!("Skill ({}) configuration has ammo amount requirement but no ammo flags", skill_config.name);
            }
        } else {
            job_skills_file.write_all(b"        Ok(0)\n").unwrap();
        }
    } else {
        job_skills_file.write_all(b"        Ok(0)\n").unwrap();
    }
    job_skills_file.write_all(b"    }\n").unwrap();
}

fn generate_validate_sp(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {\n").unwrap();
    let requirements = skill_config.requires().as_ref();
    generate_validate_per_level(job_skills_file, "character_sp", requirements.map(|c| c.sp_cost()).unwrap_or(&None), requirements.map(|c| c.sp_cost_per_level()).unwrap_or(&None));
}

fn generate_validate_hp(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {\n").unwrap();
    let requirements = skill_config.requires().as_ref();
    generate_validate_per_level(job_skills_file, "character_hp", requirements.map(|c| c.hp_cost()).unwrap_or(&None), requirements.map(|c| c.hp_cost_per_level()).unwrap_or(&None));
}


fn generate_struct(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(format!("pub struct {} {{\n", to_struct_name(skill_config)).as_bytes()).unwrap();
    job_skills_file.write_all(b"    level: u8,\n").unwrap();
    job_skills_file.write_all(b"    delegate: Option<Box<dyn DelegateSkill>>,\n").unwrap();
    job_skills_file.write_all(b"    cast_time: u32,\n").unwrap();
    job_skills_file.write_all(b"    after_cast_act_delay: u32,\n").unwrap();
    job_skills_file.write_all(b"    after_cast_walk_delay: u32,\n").unwrap();
    job_skills_file.write_all(b"}\n").unwrap();
}

fn generate_new(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(format!("impl Skill for {} {{\n", to_struct_name(skill_config)).as_bytes()).unwrap();
    job_skills_file.write_all(b"    fn new(level: u8) -> Option<Self> where Self : Sized {\n").unwrap();
    job_skills_file.write_all(format!("        if level < 1 || level > {} {{ return None }}\n", skill_config.max_level()).as_bytes()).unwrap();
    job_skills_file.write_all(b"        Some(Self { level, delegate: None, cast_time: 0, after_cast_act_delay: 0, after_cast_walk_delay: 0 })\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
}

fn generate_getters(job_skills_file: &mut File) {
    job_skills_file.write_all(b"    fn level(&self) -> u8 {\n").unwrap();
    job_skills_file.write_all(b"        self.level\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
    job_skills_file.write_all(b"    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {\n").unwrap();
    job_skills_file.write_all(b"        &self.delegate\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
    job_skills_file.write_all(b"    fn cast_time(&self) -> u32 {\n").unwrap();
    job_skills_file.write_all(b"        self.cast_time\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
    job_skills_file.write_all(b"    fn after_cast_act_delay(&self) -> u32 {\n").unwrap();
    job_skills_file.write_all(b"        self.after_cast_act_delay\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
    job_skills_file.write_all(b"    fn after_cast_walk_delay(&self) -> u32 {\n").unwrap();
    job_skills_file.write_all(b"        self.after_cast_walk_delay\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();


    job_skills_file.write_all(b"    fn update_cast_time(&mut self, new_value: u32) {\n").unwrap();
    job_skills_file.write_all(b"        self.cast_time = new_value;\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
    job_skills_file.write_all(b"    fn update_after_cast_act_delay(&mut self, new_value: u32) {\n").unwrap();
    job_skills_file.write_all(b"        self.after_cast_act_delay = new_value;\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
    job_skills_file.write_all(b"    fn update_after_cast_walk_delay(&mut self, new_value: u32) {\n").unwrap();
    job_skills_file.write_all(b"        self.after_cast_walk_delay = new_value;\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
}

macro_rules! generate_return_per_level {
    ($function:ident, $type:ty) => {
        fn $function(job_skills_file: &mut File, value: &Option<$type>, value_per_level: &Option<Vec<$type>>) {
            if let Some(value) = value{
                job_skills_file.write_all(format!("       {}\n", value).as_bytes()).unwrap();
            } else if let Some(value_per_level) = value_per_level {
                for (level, value_per_level) in value_per_level.iter().enumerate() {
                    if level == 0 { continue; }
                    job_skills_file.write_all(format!("        if self.level == {} {{\n", level).as_bytes()).unwrap();
                    job_skills_file.write_all(format!("            return {}\n", value_per_level).as_bytes()).unwrap();
                    job_skills_file.write_all(b"        }\n").unwrap();
                }
                job_skills_file.write_all(b"        0\n").unwrap();
            } else {
                job_skills_file.write_all(b"        0\n").unwrap();
            }
            job_skills_file.write_all(b"    }\n").unwrap();
        }
    }
}
generate_return_per_level!(generate_return_per_level_u32, u32);
generate_return_per_level!(generate_return_per_level_i32, i32);


fn generate_validate_per_level(job_skills_file: &mut File, field_name: &str, value: &Option<u32>, value_per_level: &Option<Vec<u32>>) {
    if let Some(value) = value {
        job_skills_file.write_all(format!("        if {} > {} {{ Ok({}) }} else {{Err(())}}\n", field_name, value, value).as_bytes()).unwrap();
    } else if let Some(value_per_level) = value_per_level {
        for (level, value_per_level) in value_per_level.iter().enumerate() {
            if level == 0 { continue; }
            job_skills_file.write_all(format!("        if self.level == {} {{\n", level).as_bytes()).unwrap();
            job_skills_file.write_all(format!("            if {} >= {} {{ return Ok({}) }} else {{return Err(())}}\n", field_name, value_per_level, value_per_level).as_bytes()).unwrap();
            job_skills_file.write_all(b"        }\n").unwrap();
        }
        job_skills_file.write_all(b"        Err(())\n").unwrap();
    } else {
        job_skills_file.write_all(b"        Ok(0)\n").unwrap();
    }
    job_skills_file.write_all(b"    }\n").unwrap();
}

fn generate_skills_enum(output_path: &Path, skills: &Vec<SkillConfig>, skill_tree: &Vec<JobSkillTree>, skills_already_generated: &HashSet<String>, jobs_with_skills: &HashSet<String>) {
    let file_path = output_path.join("skill_enums.rs");
    let mut file = File::create(file_path.clone()).unwrap();
    write_file_header_comments(&mut file);
    for job in jobs_with_skills {
        file.write_all(format!("use crate::skills::{}::{{*}};\n", job).as_bytes()).unwrap();
    }
    file.write_all("use crate::Skill;\n\n".to_string().as_bytes()).unwrap();
    file.write_all("#[derive(Clone, Copy, PartialEq, Debug)]\n".to_string().as_bytes()).unwrap();
    file.write_all("pub enum SkillEnum {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        let class_name = class_name(skill, skill_tree);
        if let Some(class_name) = class_name {
            file.write_all(format!("    // {} {}\n", class_name, skill.description).as_bytes()).unwrap();
        } else {
            file.write_all(format!("    // {}\n", skill.description).as_bytes()).unwrap();
        }
        file.write_all(format!("    {enum_name},\n").as_bytes()).unwrap();
    }
    file.write_all("}\n".to_string().as_bytes()).unwrap();
    file.write_all("impl SkillEnum {\n".to_string().as_bytes()).unwrap();
    file.write_all("    pub fn id(&self) -> u32{\n".to_string().as_bytes()).unwrap();
    file.write_all("        match self {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            Self::{} => {},\n", enum_name, skill.id).as_bytes()).unwrap();
    }
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    pub fn from_id(id: u32) -> Self {\n".to_string().as_bytes()).unwrap();
    file.write_all("        match id {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            {} => Self::{},\n", skill.id, enum_name).as_bytes()).unwrap();
    }
    file.write_all("            _ => panic!(\"unknown skill with id {}\", id)\n".to_string().as_bytes()).unwrap();
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();

    file.write_all("    pub fn from_name(name: &str) -> Self {\n".to_string().as_bytes()).unwrap();
    file.write_all("        match name {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            \"{}\" => Self::{},\n", skill.name, enum_name).as_bytes()).unwrap();
    }
    file.write_all("            _ => panic!(\"unknown skill with name {}\", name)\n".to_string().as_bytes()).unwrap();
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();

    file.write_all("    pub fn to_name(&self) -> &str {\n".to_string().as_bytes()).unwrap();
    file.write_all("        match self {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            Self::{} => \"{}\",\n", enum_name, skill.name).as_bytes()).unwrap();
    }
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();


    file.write_all("    pub fn to_object(&self, level: u8) -> Option<Box<dyn Skill>> {\n".to_string().as_bytes()).unwrap();
    file.write_all("        match self {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        if !skills_already_generated.contains(skill.name()) {
            continue;
        }
        file.write_all(format!("            Self::{} => {}::new(level).map(|s| Box::new(s) as Box<dyn Skill>),\n", to_enum_name(skill), to_struct_name(skill)).as_bytes()).unwrap();
    }
    file.write_all("        _ => None\n".to_string().as_bytes()).unwrap();
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();


    file.write_all("    pub fn is_platinium(&self) -> bool {\n".to_string().as_bytes()).unwrap();
    file.write_all("        match self {\n".to_string().as_bytes()).unwrap();
    let default_flags = 0;
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            Self::{} => {},\n", enum_name,
                               SkillFlags::Iswedding.as_flag() & skill.flags.as_ref().unwrap_or(&default_flags) != 0 ||
                                   SkillFlags::Isquest.as_flag() & skill.flags.as_ref().unwrap_or(&default_flags) != 0
        ).as_bytes()).unwrap();
    }
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();

    file.write_all("}\n".to_string().as_bytes()).unwrap();
    println!("Skills enum generated at {}", file_path.to_str().unwrap());
}

fn to_enum_name(skill: &SkillConfig) -> String {
    skill.name.to_case(Case::Title).replace(' ', "")
}

fn to_struct_name(skill: &SkillConfig) -> String {
    NON_ALPHA_REGEX.replace_all(&skill.description, "").to_case(Case::UpperCamel)
}

fn get_skill_config<'a>(skill_name: &String, skills: &'a Vec<SkillConfig>) -> Option<&'a SkillConfig> {
    for skill_config in skills {
        if skill_name.eq(skill_config.name()) {
            return Some(skill_config);
        }
    }
    None
}

fn class_name<'a>(skill_config: &'a SkillConfig, skill_tree: &Vec<JobSkillTree>) -> Option<String> {
    for job_tree in skill_tree.iter() {
        for skill in job_tree.tree().iter() {
            if skill_config.name().to_lowercase().starts_with("bd") {
                return Some("Bard".to_string());
            }
            if skill_config.name().to_lowercase().starts_with("cg") {
                return Some("Clown".to_string());
            }
            if skill.name().eq(skill_config.name()) {
                return Some(job_tree.name().clone());
            }
        }
    }
    None
}