use std::{fs, mem};
use std::fs::File;
use std::io::Write;
use std::path::Path;
use convert_case::{Case, Casing};
use lazy_static::lazy_static;
use std::collections::{HashMap, HashSet};
use std::fmt::format;
use configuration::configuration::{JobSkillTree, SkillConfig, SkillsConfig};
use enums::EnumWithMaskValueU64;
use enums::skill::SkillFlags;

lazy_static! {
    pub static ref SHORT_CLASS_NAME: HashMap<&'static str, &'static str> = HashMap::from([
        ("nv", "Novice"),
        ("sm", "Swordsman"),
        ("al", "Acolyte"),
        ("mg", "Magician"),
        ("mc", "Merchant"),
        ("ac", "Archer"),
        ("tf", "Thief"),
        ("kn", "Knight"),
        ("pr", "Priest"),
        ("wz", "Wizard"),
        ("bs", "Blacksmith"),
        ("ht", "Hunter"),
        ("as", "Assassin"),
        ("rg", "Rogue"),
        ("cr", "Crusader"),
        ("mo", "Monk"),
        ("sa", "Sage"),
        ("am", "Alchemist"),
        ("ba", "Bard"),
        ("bd", "Bard"),
        ("dc", "Dancer"),
        ("lk", "LordKnight"),
        ("hp", "HighPriest"),
        ("ch", "Champion"),
        ("pa", "Paladin"),
        ("asc", "AssassinCross"),
        ("sn", "Sniper"),
        ("st", "Stalker"),
        ("pf", "Professor"),
        ("ws", "Whitesmith"),
        ("cg", "Clown"),
        ("gn", "Creator"),
        ("hw", "HighWizard"),
        ("tk", "Taekwon"),
        ("sg", "StarGladiator"),
        ("sl", "SoulLinker"),
        ("gs", "Gunslinger"),
        ("nj", "Ninja"),
    ]);
}


pub fn main() {
    let path = Path::new("./config/skill.json");
    let skill_tree_path = Path::new("./config/skill_tree.json");
    let output_path = Path::new("lib/skills/src");
    if !path.exists() {
        panic!("config/skill.json file does not exists at {}", path.to_str().unwrap());
    }
    if !skill_tree_path.exists() {
        panic!("config/skill_tree.json file does not exists at {}", skill_tree_path.to_str().unwrap());
    }
    let mut skills_config: SkillsConfig = serde_json::from_str(&fs::read_to_string(path).unwrap()).unwrap();
    let mut skill_tree: Vec<JobSkillTree> = configuration::configuration::Config::load_jobs_skill_tree(".").unwrap();
    let mut vec: Vec<(u32, SkillConfig)> = skills_config.skills.into_iter().collect::<Vec<(u32, SkillConfig)>>();
    vec.sort_by_key(|&(k, _)| k);
    let skills: Vec<SkillConfig> = vec.into_iter().map(|(_, v)| v).collect();

    generate_skills_enum(output_path, &skills, &skill_tree);
    generate_skills_impl(output_path, &skills, &skill_tree);
}

fn generate_skills_impl(output_path: &Path, skills: &Vec<SkillConfig>, skill_tree: &Vec<JobSkillTree>) {
    let file_path = output_path.join("skills").join("mod.rs");
    let mut file = File::create(file_path.clone()).unwrap();

    file.write_all("// Generated by tools/skills/main.rs\n".to_string().as_bytes()).unwrap();
    file.write_all("// Auto generated file do not edit manually\n\n".to_string().as_bytes()).unwrap();
    file.write_all("#![allow(dead_code)]\n\n".to_string().as_bytes()).unwrap();
    file.write_all("use crate::skill_enums::Skill;\n\n".to_string().as_bytes()).unwrap();

    for skill in skills.iter() {
        file.write_all(format!("pub struct {};\n", to_enum_name(skill)).as_bytes()).unwrap();
    }
    let mut files: HashMap<String, File> = HashMap::new();
    let mut skills_already_generated: HashSet<String> = HashSet::with_capacity(1000);
    for job_tree in skill_tree.iter() {
        if job_tree.tree().is_empty() {
            continue;
        }
        let file_name = job_tree.name().to_lowercase().replace(' ', "");
        file.write_all(format!("pub mod {};\n", file_name).as_bytes()).unwrap();
        let mut job_skills_file = File::create(output_path.join("skills").join(format!("{}.rs", file_name))).unwrap();

        write_file_header(&mut job_skills_file);
        job_skills_file.write_all(b"use crate::Skill;\n\n").unwrap();
        job_skills_file.write_all(b"use crate::skills::*;\n").unwrap();
        for skill in job_tree.tree().iter() {
            let skill_config = get_skill_config(skill.name(), &skills).unwrap();
            write_skills(&mut job_skills_file, skill_config);
            skills_already_generated.insert(skill.name().clone());
        }
    }

    file.write_all(b"pub mod any;").unwrap();
    let mut file = File::create(output_path.join("skills").join("any.rs")).unwrap();
    write_file_header(&mut file);
    file.write_all(b"use crate::Skill;\n").unwrap();
    file.write_all(b"use crate::skills::*;\n\n").unwrap();
    for skill_config in skills.iter() {
        if skills_already_generated.contains(skill_config.name()) {
            continue;
        }
        write_skills(&mut file, skill_config);
    }
}

fn write_file_header(job_skills_file: &mut File) {
    job_skills_file.write_all("// Generated by tools/skills/main.rs\n".to_string().as_bytes()).unwrap();
    job_skills_file.write_all("// Auto generated file do not edit manually\n\n".to_string().as_bytes()).unwrap();
    job_skills_file.write_all("#![allow(dead_code)]\n\n".to_string().as_bytes()).unwrap();
}

fn write_skills(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(format!("impl Skill for {} {{\n", to_enum_name(skill_config)).as_bytes()).unwrap();
    job_skills_file.write_all(b"    pub fn skill_type(&self) -> SkillTargetType {\n").unwrap();
    // job_skills_file.write_all(format!("        {}", skill_config.).as_bytes()).unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
    job_skills_file.write_all(b"}\n").unwrap();
}

fn generate_skills_enum(output_path: &Path, skills: &Vec<SkillConfig>, skill_tree: &Vec<JobSkillTree>) {
    let file_path = output_path.join("skill_enums.rs");
    let mut file = File::create(file_path.clone()).unwrap();
    write_file_header(&mut file);
    file.write_all("#[derive(Clone, Copy, PartialEq, Debug)]\n".to_string().as_bytes()).unwrap();
    file.write_all("pub enum Skill {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        let class_name = class_name(skill, skill_tree);
        if let Some(class_name) = class_name {
            file.write_all(format!("    // {} {}\n", class_name, skill.description).as_bytes()).unwrap();
        } else {
            file.write_all(format!("    // {}\n", skill.description).as_bytes()).unwrap();
        }
        file.write_all(format!("    {enum_name},\n").as_bytes()).unwrap();
    }
    file.write_all("}\n".to_string().as_bytes()).unwrap();
    file.write_all("impl Skill {\n".to_string().as_bytes()).unwrap();
    file.write_all("    pub fn id(&self) -> u32{\n".to_string().as_bytes()).unwrap();
    file.write_all("        match self {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            Self::{} => {},\n", enum_name, skill.id).as_bytes()).unwrap();
    }
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    pub fn from_id(id: u32) -> Self {\n".to_string().as_bytes()).unwrap();
    file.write_all("        match id {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            {} => Self::{},\n", skill.id, enum_name).as_bytes()).unwrap();
    }
    file.write_all("            _ => panic!(\"unknown skill with id {}\", id)\n".to_string().as_bytes()).unwrap();
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();

    file.write_all("    pub fn from_name(name: &str) -> Self {\n".to_string().as_bytes()).unwrap();
    file.write_all("        match name {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            \"{}\" => Self::{},\n", skill.name, enum_name).as_bytes()).unwrap();
    }
    file.write_all("            _ => panic!(\"unknown skill with name {}\", name)\n".to_string().as_bytes()).unwrap();
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();

    file.write_all("    pub fn to_name(&self) -> &str {\n".to_string().as_bytes()).unwrap();
    file.write_all("        match self {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            Self::{} => \"{}\",\n", enum_name, skill.name).as_bytes()).unwrap();
    }
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();


    file.write_all("    pub fn is_platinium(&self) -> bool {\n".to_string().as_bytes()).unwrap();
    file.write_all("        match self {\n".to_string().as_bytes()).unwrap();
    let default_flags = 0;
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            Self::{} => {},\n", enum_name,
                               SkillFlags::Iswedding.as_flag() & skill.flags.as_ref().unwrap_or(&default_flags) != 0 ||
                                   SkillFlags::Isquest.as_flag() & skill.flags.as_ref().unwrap_or(&default_flags) != 0
        ).as_bytes()).unwrap();
    }
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();

    file.write_all("}\n".to_string().as_bytes()).unwrap();
    println!("Skills enum generated at {}", file_path.to_str().unwrap());
}

fn to_enum_name(skill: &SkillConfig) -> String {
    skill.name.to_case(Case::Title).replace(' ', "")
}

fn get_skill_config<'a>(skill_name: &String, skills: &'a Vec<SkillConfig>) -> Option<&'a SkillConfig> {
    for skill_config in skills {
        if skill_name.eq(skill_config.name()) {
            return Some(skill_config);
        }
    }
    None
}

fn class_name<'a>(skill_config: &'a SkillConfig, skill_tree: &Vec<JobSkillTree>) -> Option<String> {
    for job_tree in skill_tree.iter() {
        for skill in job_tree.tree().iter() {
            if skill_config.name().to_lowercase().starts_with("bd") {
                return Some("Bard".to_string());
            }
            if skill_config.name().to_lowercase().starts_with("cg") {
                return Some("Clown".to_string());
            }
            if skill.name().eq(skill_config.name()) {
                return Some(job_tree.name().clone());
            }
        }
    }
    None
}