use std::{fs, mem};
use std::fs::File;
use std::io::Write;
use std::path::Path;
use convert_case::{Case, Casing};
use lazy_static::lazy_static;
use std::collections::{HashMap, HashSet};
use futures::AsyncReadExt;
use regex::Regex;
use serde_json::Error;
use configuration::configuration::{JobSkillTree, SkillConfig, SkillsConfig};
use enums::{EnumWithMaskValueU64, EnumWithNumberValue};
use enums::skill::SkillFlags;

lazy_static! {
    pub static ref SHORT_CLASS_NAME: HashMap<&'static str, &'static str> = HashMap::from([
        ("nv", "Novice"),
        ("sm", "Swordsman"),
        ("al", "Acolyte"),
        ("mg", "Magician"),
        ("mc", "Merchant"),
        ("ac", "Archer"),
        ("tf", "Thief"),
        ("kn", "Knight"),
        ("pr", "Priest"),
        ("wz", "Wizard"),
        ("bs", "Blacksmith"),
        ("ht", "Hunter"),
        ("as", "Assassin"),
        ("rg", "Rogue"),
        ("cr", "Crusader"),
        ("mo", "Monk"),
        ("sa", "Sage"),
        ("am", "Alchemist"),
        ("ba", "Bard"),
        ("bd", "Bard"),
        ("dc", "Dancer"),
        ("lk", "LordKnight"),
        ("hp", "HighPriest"),
        ("ch", "Champion"),
        ("pa", "Paladin"),
        ("asc", "AssassinCross"),
        ("sn", "Sniper"),
        ("st", "Stalker"),
        ("pf", "Professor"),
        ("ws", "Whitesmith"),
        ("cg", "Clown"),
        ("gn", "Creator"),
        ("hw", "HighWizard"),
        ("tk", "Taekwon"),
        ("sg", "StarGladiator"),
        ("sl", "SoulLinker"),
        ("gs", "Gunslinger"),
        ("nj", "Ninja"),
    ]);
     static ref NON_ALPHA_REGEX: Regex = Regex::new(r"[^A-Za-z0-9]*").unwrap();
}


pub fn main() {
    let path = Path::new("./config/skill.json");
    let skill_tree_path = Path::new("./config/skill_tree.json");
    let output_path = Path::new("lib/skills/src");
    if !path.exists() {
        panic!("config/skill.json file does not exists at {}", path.to_str().unwrap());
    }
    if !skill_tree_path.exists() {
        panic!("config/skill_tree.json file does not exists at {}", skill_tree_path.to_str().unwrap());
    }

    let json = fs::read_to_string(path).unwrap();
    let mut config_deserializer = serde_json::Deserializer::from_str(&json);
    let result: Result<SkillsConfig, _> = serde_path_to_error::deserialize(&mut config_deserializer);
    match result {
        Err(err) => {
            let path = err.path().to_string();
            println!("Path in error {}", path);
            panic!("{}", err);
        }
        _ => {}
    }
    let mut skills_config: SkillsConfig = result.unwrap();
    let mut skill_tree: Vec<JobSkillTree> = configuration::configuration::Config::load_jobs_skill_tree(".").unwrap();
    let mut vec: Vec<(u32, SkillConfig)> = skills_config.skills.into_iter().collect::<Vec<(u32, SkillConfig)>>();
    vec.sort_by_key(|&(k, _)| k);
    let skills: Vec<SkillConfig> = vec.into_iter().map(|(_, v)| v).collect();

    generate_skills_enum(output_path, &skills, &skill_tree);
    generate_skills_impl(output_path, &skills, &skill_tree);
}

fn generate_skills_impl(output_path: &Path, skills: &Vec<SkillConfig>, skill_tree: &Vec<JobSkillTree>) {
    let file_path = output_path.join("skills").join("mod.rs");
    let mut file = File::create(file_path.clone()).unwrap();

    file.write_all("// Generated by tools/skills/main.rs\n".to_string().as_bytes()).unwrap();
    file.write_all("// Auto generated file do not edit manually\n\n".to_string().as_bytes()).unwrap();
    file.write_all("#![allow(dead_code)]\n\n".to_string().as_bytes()).unwrap();

    for skill in skills.iter() {
        file.write_all(format!("pub struct {};\n", to_enum_name(skill)).as_bytes()).unwrap();
    }
    let mut files: HashMap<String, File> = HashMap::new();
    let mut skills_already_generated: HashSet<String> = HashSet::with_capacity(1000);
    for job_tree in skill_tree.iter() {
        if job_tree.tree().is_empty() {
            continue;
        }
        let file_name = job_tree.name().to_lowercase().replace(' ', "");
        file.write_all(format!("pub mod {};\n", file_name).as_bytes()).unwrap();
        let mut job_skills_file = File::create(output_path.join("skills").join(format!("{}.rs", file_name))).unwrap();

        write_file_header(&mut job_skills_file);
        for skill in job_tree.tree().iter() {
            let skill_config = get_skill_config(skill.name(), &skills).unwrap();
            write_skills(&mut job_skills_file, skill_config);
            skills_already_generated.insert(skill.name().clone());
        }
    }

    // NPC and third classes
    // file.write_all(b"pub mod any;").unwrap();
    // let mut file = File::create(output_path.join("skills").join("any.rs")).unwrap();
    // write_file_header(&mut file);
    // for skill_config in skills.iter() {
    //     if skills_already_generated.contains(skill_config.name()) {
    //         continue;
    //     }
    //     write_skills(&mut file, skill_config);
    // }
}

fn write_file_header(file: &mut File) {
    write_file_header_comments(file);
    file.write_all(b"use enums::{EnumWithMaskValueU64, EnumWithNumberValue};\n").unwrap();
    file.write_all(b"use enums::skill::*;\n").unwrap();
    file.write_all(b"use enums::weapon::AmmoType;\n").unwrap();
    file.write_all(b"\nuse models::weapon::Weapon;\n").unwrap();
    file.write_all(b"use models::item::NormalInventoryItem;\n").unwrap();
    file.write_all(b"\nuse crate::{Skill, SkillRequirementResult, DelegateSkill};\n\n").unwrap();
    file.write_all(b"use crate::skills::*;\n").unwrap();
}

fn write_file_header_comments(file: &mut File) {
    file.write_all("// Generated by tools/skills/main.rs\n".to_string().as_bytes()).unwrap();
    file.write_all("// Auto generated file do not edit manually\n\n".to_string().as_bytes()).unwrap();
    file.write_all("#![allow(dead_code, unused_must_use, unused_imports, unused_variables)]\n\n".to_string().as_bytes()).unwrap();
}

fn write_skills(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(format!("// {}\n", skill_config.name).as_bytes()).unwrap();
    job_skills_file.write_all(format!("pub struct {} {{\n", to_skill_name(skill_config)).as_bytes()).unwrap();
    job_skills_file.write_all(b"    level: u8,\n").unwrap();
    job_skills_file.write_all(b"    delegate: Option<Box<dyn DelegateSkill>>,\n").unwrap();
    job_skills_file.write_all(b"}\n").unwrap();

    generate_new(job_skills_file, skill_config);
    generate_getters(job_skills_file);
    generate_validate_sp(job_skills_file, skill_config);
    generate_validate_hp(job_skills_file, skill_config);
    generate_validate_ammo(job_skills_file, skill_config);
    generate_validate_state(job_skills_file, skill_config);
    generate_validate_zeny(job_skills_file, skill_config);

    job_skills_file.write_all(b"    fn validate_spirit_sphere(&self, spirit_sphere: u32) -> SkillRequirementResult<u32> {\n").unwrap();
    job_skills_file.write_all(b"        Ok(0)\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
    job_skills_file.write_all(b"    fn validate_item(&self, item: &Vec<NormalInventoryItem>) -> SkillRequirementResult<Option<NormalInventoryItem>> {\n").unwrap();
    job_skills_file.write_all(b"        Ok(None)\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();


    job_skills_file.write_all(b"    fn validate_target(&self, target_type: SkillTargetType) -> SkillRequirementResult<()> {\n").unwrap();
    job_skills_file.write_all(b"        Ok(())\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();

    generate_validate_weapon(job_skills_file, skill_config);

    job_skills_file.write_all(b"    fn validate_range(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {\n").unwrap();
    job_skills_file.write_all(b"         Ok(())\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();

    job_skills_file.write_all(b"    fn cast_delay(&self) -> u32 {\n").unwrap();
    job_skills_file.write_all(b"        0\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
    generate_hit_count(job_skills_file, skill_config);
    generate_after_cast_act_delay(job_skills_file, skill_config);
    generate_after_cast_walk_delay(job_skills_file, skill_config);
    job_skills_file.write_all(b"}\n").unwrap();
}

fn generate_after_cast_walk_delay(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn after_cast_walk_delay(&self) -> u32 {\n").unwrap();
    generate_return_per_level(job_skills_file, &skill_config.after_cast_walk_delay().map(|v| v as i32), &skill_config.after_cast_act_delay_per_level().as_ref().map(|v| v.iter().map(|e| *e).collect::<Vec<i32>>()));
}

fn generate_after_cast_act_delay(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn after_cast_act_delay(&self) -> u32 {\n").unwrap();
    generate_return_per_level(job_skills_file, &skill_config.after_cast_act_delay().map(|v| v as i32), skill_config.after_cast_act_delay_per_level());
}

fn generate_hit_count(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn hit_count(&self) -> i8 {\n").unwrap();
    generate_return_per_level(job_skills_file, skill_config.hit_count(), skill_config.hit_count_per_level());
}

fn generate_validate_weapon(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn validate_weapon(&self, character_weapon: Option<Weapon>) -> SkillRequirementResult<()> {\n").unwrap();
    if let Some(requirements) = skill_config.requires() {
        if let Some(weapon) = requirements.weapon_flags() {
            job_skills_file.write_all(b"        if let Some(character_weapon) = character_weapon {\n").unwrap();
            job_skills_file.write_all(format!("            if {} & character_weapon.weapon_type.as_flag() > 0 {{ Ok(()) }} else {{ Err(()) }}\n", weapon).as_bytes()).unwrap();
            job_skills_file.write_all(b"        } else {\n").unwrap();
            job_skills_file.write_all(b"            Err(())\n").unwrap();
            job_skills_file.write_all(b"        }\n").unwrap();
        } else {
            job_skills_file.write_all(b"        Ok(())\n").unwrap();
        }
    } else {
        job_skills_file.write_all(b"        Ok(())\n").unwrap();
    }
    job_skills_file.write_all(b"    }\n").unwrap();
}

fn generate_validate_zeny(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn validate_zeny(&self, zeny: u32) -> SkillRequirementResult<u32> {\n").unwrap();
    let requirements = skill_config.requires().as_ref();
    generate_validate_per_level(job_skills_file, "zeny", requirements.map(|c| c.zeny_cost()).unwrap_or(&None), requirements.map(|c| c.zeny_cost_per_level()).unwrap_or(&None));
}

fn generate_validate_state(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn validate_state(&self, state: Option<SkillState>) -> SkillRequirementResult<()> {\n").unwrap();
    if let Some(requirements) = skill_config.requires() {
        if let Some(state) = requirements.state() {
            job_skills_file.write_all(b"        if let Some(state) = state {\n").unwrap();
            job_skills_file.write_all(format!("            if state.value() == {} {{ Ok(()) }} else {{ Err(()) }}\n", state.value()).as_bytes()).unwrap();
            job_skills_file.write_all(b"        } else {\n").unwrap();
            job_skills_file.write_all(b"            Err(())\n").unwrap();
            job_skills_file.write_all(b"        }\n").unwrap();
        } else {
            job_skills_file.write_all(b"        Ok(())\n").unwrap();
        }
    } else {
        job_skills_file.write_all(b"        Ok(())\n").unwrap();
    }
    job_skills_file.write_all(b"    }\n").unwrap();
}

fn generate_validate_ammo(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn validate_ammo(&self, character_ammo: Option<(AmmoType, u32)>) -> SkillRequirementResult<u32> {\n").unwrap();
    if let Some(requirements) = skill_config.requires() {
        if let Some(ammo_amount) = requirements.ammo_amount() {
            if let Some(ammo_flags) = requirements.ammo_flags() {
                job_skills_file.write_all(b"        if let Some(ammo_and_amount) = character_ammo {\n").unwrap();
                job_skills_file.write_all(format!("            if ammo_and_amount.1 >= {} && ({} & ammo_and_amount.0.as_flag()) > 0 {{ Ok({}) }} else {{ Err(()) }}\n", ammo_amount, ammo_flags, ammo_amount).as_bytes()).unwrap();
                job_skills_file.write_all(b"        } else {\n").unwrap();
                job_skills_file.write_all(b"            Err(())\n").unwrap();
                job_skills_file.write_all(b"        }\n").unwrap();
            } else {
                panic!("Skill ({}) configuration has ammo amount requirement but no ammo flags", skill_config.name);
            }
        } else {
            job_skills_file.write_all(b"        Ok(0)\n").unwrap();
        }
    } else {
        job_skills_file.write_all(b"        Ok(0)\n").unwrap();
    }
    job_skills_file.write_all(b"    }\n").unwrap();
}

fn generate_validate_sp(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn validate_sp(&self, character_sp: u32) -> SkillRequirementResult<u32> {\n").unwrap();
    let requirements = skill_config.requires().as_ref();
    generate_validate_per_level(job_skills_file, "character_sp", requirements.map(|c| c.sp_cost()).unwrap_or(&None), requirements.map(|c| c.sp_cost_per_level()).unwrap_or(&None));
}

fn generate_validate_hp(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(b"    fn validate_hp(&self, character_hp: u32) -> SkillRequirementResult<u32> {\n").unwrap();
    let requirements = skill_config.requires().as_ref();
    generate_validate_per_level(job_skills_file, "character_hp", requirements.map(|c| c.hp_cost()).unwrap_or(&None), requirements.map(|c| c.hp_cost_per_level()).unwrap_or(&None));
}


fn generate_getters(job_skills_file: &mut File) {
    job_skills_file.write_all(b"    fn level(&self) -> u8 {\n").unwrap();
    job_skills_file.write_all(b"        self.level\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
    job_skills_file.write_all(b"    fn delegate(&self) -> &Option<Box<dyn DelegateSkill>> {\n").unwrap();
    job_skills_file.write_all(b"        &self.delegate\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
}

fn generate_new(job_skills_file: &mut File, skill_config: &SkillConfig) {
    job_skills_file.write_all(format!("impl Skill for {} {{\n", to_skill_name(skill_config)).as_bytes()).unwrap();
    job_skills_file.write_all(b"    fn new(level: u8) -> Option<Self> where Self : Sized {\n").unwrap();
    job_skills_file.write_all(format!("        if level < 1 || level > {} {{ return None }}\n", skill_config.max_level()).as_bytes()).unwrap();
    job_skills_file.write_all(b"        Some(Self { level, delegate: None })\n").unwrap();
    job_skills_file.write_all(b"    }\n").unwrap();
}

fn generate_return_per_level(job_skills_file: &mut File, value: &Option<i32>, value_per_level: &Option<Vec<i32>>) {
    if let Some(value) = value{
        job_skills_file.write_all(format!("       {}\n", value).as_bytes()).unwrap();
    } else if let Some(value_per_level) = value_per_level {
        for (level, value_per_level) in value_per_level.iter().enumerate() {
            if level == 0 { continue; }
            job_skills_file.write_all(format!("        if self.level == {} {{\n", level).as_bytes()).unwrap();
            job_skills_file.write_all(format!("            return {}\n", value_per_level).as_bytes()).unwrap();
            job_skills_file.write_all(b"        }\n").unwrap();
        }
        job_skills_file.write_all(b"        0\n").unwrap();
    } else {
        job_skills_file.write_all(b"        0\n").unwrap();
    }
    job_skills_file.write_all(b"    }\n").unwrap();
}

fn generate_validate_per_level(job_skills_file: &mut File, field_name: &str, value: &Option<u32>, value_per_level: &Option<Vec<i32>>) {
    if let Some(value) = value {
        job_skills_file.write_all(format!("        if {} > {} {{ Ok({}) }} else {{Err(())}}\n", field_name, value, value).as_bytes()).unwrap();
    } else if let Some(value_per_level) = value_per_level {
        for (level, value_per_level) in value_per_level.iter().enumerate() {
            if level == 0 { continue; }
            job_skills_file.write_all(format!("        if self.level == {} {{\n", level).as_bytes()).unwrap();
            job_skills_file.write_all(format!("            if {} >= {} {{ return Ok({}) }} else {{return Err(())}}\n", field_name, value_per_level, value_per_level).as_bytes()).unwrap();
            job_skills_file.write_all(b"        }\n").unwrap();
        }
        job_skills_file.write_all(b"        Err(())\n").unwrap();
    } else {
        job_skills_file.write_all(b"        Ok(0)\n").unwrap();
    }
    job_skills_file.write_all(b"    }\n").unwrap();
}

fn generate_skills_enum(output_path: &Path, skills: &Vec<SkillConfig>, skill_tree: &Vec<JobSkillTree>) {
    let file_path = output_path.join("skill_enums.rs");
    let mut file = File::create(file_path.clone()).unwrap();
    write_file_header_comments(&mut file);
    file.write_all("#[derive(Clone, Copy, PartialEq, Debug)]\n".to_string().as_bytes()).unwrap();
    file.write_all("pub enum Skill {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        let class_name = class_name(skill, skill_tree);
        if let Some(class_name) = class_name {
            file.write_all(format!("    // {} {}\n", class_name, skill.description).as_bytes()).unwrap();
        } else {
            file.write_all(format!("    // {}\n", skill.description).as_bytes()).unwrap();
        }
        file.write_all(format!("    {enum_name},\n").as_bytes()).unwrap();
    }
    file.write_all("}\n".to_string().as_bytes()).unwrap();
    file.write_all("impl Skill {\n".to_string().as_bytes()).unwrap();
    file.write_all("    pub fn id(&self) -> u32{\n".to_string().as_bytes()).unwrap();
    file.write_all("        match self {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            Self::{} => {},\n", enum_name, skill.id).as_bytes()).unwrap();
    }
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    pub fn from_id(id: u32) -> Self {\n".to_string().as_bytes()).unwrap();
    file.write_all("        match id {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            {} => Self::{},\n", skill.id, enum_name).as_bytes()).unwrap();
    }
    file.write_all("            _ => panic!(\"unknown skill with id {}\", id)\n".to_string().as_bytes()).unwrap();
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();

    file.write_all("    pub fn from_name(name: &str) -> Self {\n".to_string().as_bytes()).unwrap();
    file.write_all("        match name {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            \"{}\" => Self::{},\n", skill.name, enum_name).as_bytes()).unwrap();
    }
    file.write_all("            _ => panic!(\"unknown skill with name {}\", name)\n".to_string().as_bytes()).unwrap();
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();

    file.write_all("    pub fn to_name(&self) -> &str {\n".to_string().as_bytes()).unwrap();
    file.write_all("        match self {\n".to_string().as_bytes()).unwrap();
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            Self::{} => \"{}\",\n", enum_name, skill.name).as_bytes()).unwrap();
    }
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();


    file.write_all("    pub fn is_platinium(&self) -> bool {\n".to_string().as_bytes()).unwrap();
    file.write_all("        match self {\n".to_string().as_bytes()).unwrap();
    let default_flags = 0;
    for skill in skills.iter() {
        let enum_name = to_enum_name(skill);
        file.write_all(format!("            Self::{} => {},\n", enum_name,
                               SkillFlags::Iswedding.as_flag() & skill.flags.as_ref().unwrap_or(&default_flags) != 0 ||
                                   SkillFlags::Isquest.as_flag() & skill.flags.as_ref().unwrap_or(&default_flags) != 0
        ).as_bytes()).unwrap();
    }
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();

    file.write_all("}\n".to_string().as_bytes()).unwrap();
    println!("Skills enum generated at {}", file_path.to_str().unwrap());
}

fn to_enum_name(skill: &SkillConfig) -> String {
    skill.name.to_case(Case::Title).replace(' ', "")
}

fn to_skill_name(skill: &SkillConfig) -> String {
    NON_ALPHA_REGEX.replace_all(&skill.description, "").to_case(Case::UpperCamel)
}

fn get_skill_config<'a>(skill_name: &String, skills: &'a Vec<SkillConfig>) -> Option<&'a SkillConfig> {
    for skill_config in skills {
        if skill_name.eq(skill_config.name()) {
            return Some(skill_config);
        }
    }
    None
}

fn class_name<'a>(skill_config: &'a SkillConfig, skill_tree: &Vec<JobSkillTree>) -> Option<String> {
    for job_tree in skill_tree.iter() {
        for skill in job_tree.tree().iter() {
            if skill_config.name().to_lowercase().starts_with("bd") {
                return Some("Bard".to_string());
            }
            if skill_config.name().to_lowercase().starts_with("cg") {
                return Some("Clown".to_string());
            }
            if skill.name().eq(skill_config.name()) {
                return Some(job_tree.name().clone());
            }
        }
    }
    None
}