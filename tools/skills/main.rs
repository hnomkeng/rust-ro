use std::fs;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use convert_case::{Case, Casing};
use lazy_static::lazy_static;
use serde::{Deserialize};
use std::collections::HashMap;

lazy_static! {
    pub static ref SHORT_CLASS_NAME: HashMap<&'static str, &'static str> = HashMap::from([
        ("nv", "novice"),
        ("sm", "Swordsman"),
        ("al", "Acolyte"),
        ("mg", "Magician"),
        ("mc", "Merchant"),
        ("ac", "Archer"),
        ("tf", "Thief"),
        ("kn", "Knight"),
        ("pr", "Priest"),
        ("wz", "Wizard"),
        ("bs", "Blacksmith"),
        ("ht", "Hunter"),
        ("as", "Assassin"),
        ("rg", "Rogue"),
        ("cr", "Crusader"),
        ("mo", "Monk"),
        ("sa", "Sage"),
        ("am", "Alchemist"),
        ("ba", "Bard"),
        ("dc", "Dancer"),
        ("lk", "LordKnight"),
        ("hp", "HighPriest"),
        ("ch", "Champion"),
        ("pa", "Paladin"),
        ("asc", "AssassinCross"),
        ("sn", "Sniper"),
        ("pf", "Professor"),
        ("ws", "Whitesmith"),
        ("cg", "Clown"),
        ("cr", "Creator"),
        ("hw", "HighWizard"),
        ("tk", "Taekwon"),
        ("sg", "StarGladiator"),
        ("sl", "SoulLinker"),
        ("gs", "Gunslinger"),
        ("nj", "Ninja"),
    ]);
}

#[derive(Deserialize, Debug, Clone)]
struct SkillsConfig {
    #[serde(rename = "skill")]
    skills: Vec<SkillConfig>,
}

#[derive(Deserialize, Debug, Clone)]
struct SkillConfig {
    pub id: u32,
    pub name: String,
    pub description: String,
}

pub fn main() {
    let path = Path::new("config/skill.toml");
    let output_path = Path::new("lib/enums/src");
    if !path.exists() {
        panic!("config/skill.toml file does not exists at {}", path.to_str().unwrap());
    }
    let skills: SkillsConfig = toml::from_str(&fs::read_to_string(path).unwrap()).unwrap();
    let file_path = output_path.join("skills.rs");
    let mut file = File::create(file_path.clone()).unwrap();
    file.write_all("// Generated by tools/skills/main.rs\n".to_string().as_bytes()).unwrap();
    file.write_all("// Auto generated file do not edit manually\n\n".to_string().as_bytes()).unwrap();
    file.write_all("#![allow(dead_code)]\n\n".to_string().as_bytes()).unwrap();
    file.write_all("pub enum Skill {\n".to_string().as_bytes()).unwrap();
    for skill in skills.skills.iter() {
        let enum_name = skill.name.to_case(Case::Title).replace(" ", "");
        let class_name = SHORT_CLASS_NAME.iter().find(|(k, _)| enum_name.to_lowercase().starts_with(*k)).map(|(_, v)| v);
        if let Some(class_name) = class_name {
            file.write_all(format!("  // {} {}\n", class_name, skill.description).as_bytes()).unwrap();
        } else {
            file.write_all(format!("  // {}\n", skill.description).as_bytes()).unwrap();
        }
        file.write_all(format!("  {},\n", enum_name).as_bytes()).unwrap();
    }
    file.write_all("}\n".to_string().as_bytes()).unwrap();
    file.write_all("impl Skill {\n".to_string().as_bytes()).unwrap();
    file.write_all("  pub fn id(&self) -> u32{\n".to_string().as_bytes()).unwrap();
    file.write_all("    match self {\n".to_string().as_bytes()).unwrap();
    for skill in skills.skills.iter() {
        let enum_name = skill.name.to_case(Case::Title).replace(" ", "");
        file.write_all(format!("      Self::{} => {},\n", enum_name, skill.id).as_bytes()).unwrap();
    }
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("  }\n".to_string().as_bytes()).unwrap();
    file.write_all("  pub fn from_id(id: u32) -> Self {\n".to_string().as_bytes()).unwrap();
    file.write_all("    match id {\n".to_string().as_bytes()).unwrap();
    for skill in skills.skills.iter() {
        let enum_name = skill.name.to_case(Case::Title).replace(" ", "");
        file.write_all(format!("      {} => Self::{},\n", skill.id, enum_name).as_bytes()).unwrap();
    }
    file.write_all("    _ => panic!(\"unknown skill with id {}\", id)\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("  }\n".to_string().as_bytes()).unwrap();

    file.write_all("  pub fn from_name(name: &str) -> Self {\n".to_string().as_bytes()).unwrap();
    file.write_all("    match name {\n".to_string().as_bytes()).unwrap();
    for skill in skills.skills.iter() {
        let enum_name = skill.name.to_case(Case::Title).replace(" ", "");
        file.write_all(format!("      \"{}\" => Self::{},\n", skill.name, enum_name).as_bytes()).unwrap();
    }
    file.write_all("    _ => panic!(\"unknown skill with name {}\", name)\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("  }\n".to_string().as_bytes()).unwrap();

    file.write_all("  pub fn to_name(&self) -> &str {\n".to_string().as_bytes()).unwrap();
    file.write_all("    match self {\n".to_string().as_bytes()).unwrap();
    for skill in skills.skills.iter() {
        let enum_name = skill.name.to_case(Case::Title).replace(" ", "");
        file.write_all(format!("      Self::{} => \"{}\",\n", enum_name, skill.name).as_bytes()).unwrap();
    }
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("  }\n".to_string().as_bytes()).unwrap();

    file.write_all("}\n".to_string().as_bytes()).unwrap();
    println!("Skills enum generated at {}", file_path.to_str().unwrap());
}