use crate::{PacketStructDefinition, StructDefinition, StructField};
use std::fs::File;
use std::io::Write;
use std::path::Path;
use crate::packet_db_parser::static_types_map;

pub fn write_packets_struct(packets: Vec<PacketStructDefinition>, nested_structures: &Vec<StructDefinition>, output_path: &Path) {
    let mut file_res = File::create(output_path);
    let mut file = file_res.unwrap();
    file.write(b"// Generated by tools/packets_db/main.rs\n").unwrap();
    file.write(b"// Auto generated file do not edit manually\n\n").unwrap();
    file.write(b"use std::fmt::{Formatter, Debug};\n\n").unwrap();
    write_packet_parser(&mut file, &packets);
    write_packet_id_trait(&mut file);
    for packet in packets {
        write_struct_definition(&mut file, &packet.struct_def);
        write_struct_impl(&mut file, &packet.struct_def, nested_structures);
        write_packet_id_trait_impl(&mut file, &packet);
        write_struct_info_trait(&mut file, &packet.struct_def, true);
    }

    for nested_struct in nested_structures {
        write_struct_definition(&mut file, &nested_struct);
        write_struct_impl(&mut file, &nested_struct, nested_structures);
        write_struct_info_trait(&mut file, &nested_struct, false);
    }
    write_unknown_packet(&mut file);
}

fn write_packet_parser(file: &mut File, packets: &Vec<PacketStructDefinition>) {
    file.write(b"pub fn parse(buffer: &[u8]) -> Box<dyn Packet> {\n").unwrap();
    for packet in packets {
        let packet_id = get_packet_id(packet).replace("0x", "");
        let (first_byte, second_byte) = packet_id.split_at(2);
        file.write(format!("    if buffer[0] == 0x{} && buffer[1] == 0x{} {{\n", first_byte, second_byte).as_bytes());
        file.write(format!("        return Box::new({}::from(buffer));\n", packet.struct_def.name).as_bytes());
        file.write(b"    }\n");
    }
    file.write(b"    Box::new(PacketUnknown::from(buffer))\n");
    file.write(b"}\n\n").unwrap();
}

fn write_packet_id_trait(file: &mut File) {
    file.write(b"pub trait Packet {\n");
    file.write(b"    fn id(&self) -> &str;\n");
    file.write(b"    fn debug(&self);\n");
    file.write(b"}\n\n");
}

fn write_packet_id_trait_impl(file: &mut File, packet: &PacketStructDefinition) {
    file.write(format!("impl Packet for {} {{\n", packet.struct_def.name).as_bytes());
    file.write(b"    fn id(&self) -> &str {\n");
    let id = get_packet_id(packet);
    file.write(format!("       \"{}\"\n", id).as_bytes());
    file.write(b"    }\n");
    file.write(b"    fn debug(&self) {\n").unwrap();
    file.write(b"            println!(\"{:?}\", self)\n");
    file.write(b"    }\n").unwrap();
    file.write(b"}\n\n");
}

fn get_packet_id(packet: &PacketStructDefinition) -> String {
    let mut id = packet.id.clone();
    if packet.id.len() == 4 {
        id = format!("{:0<6}", packet.id);
    } else if packet.id.len() == 5 {
        id = packet.id.replace("0x", "0x0");
    }
    id
}

fn write_struct_definition(file: &mut File, struct_definition: &StructDefinition) {
    file.write(format!("pub struct {} {{\n", struct_definition.name).as_bytes());
    for field in &struct_definition.fields {
        if &field.data_type.name == "Vec" {
            file.write(format!("    pub {}: Vec<{}>,\n", field.name, &field.complex_type.as_ref().unwrap()).as_bytes());
        } else if &field.data_type.name == "Struct" {
            file.write(format!("    pub {}: {},\n", field.name, &field.complex_type.as_ref().unwrap()).as_bytes());
        } else {
            file.write(format!("    pub {}: {},\n", field.name, field.data_type.name).as_bytes());
        }
    }
    file.write(b"}\n\n");
}

fn write_struct_info_trait(file: &mut File, struct_definition: &StructDefinition, is_packet: bool) {
    file.write(format!("impl Debug for {} {{\n", struct_definition.name).as_bytes());
    file.write(b"    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n");
    file.write(format!("        f.debug_struct(\"{}\")\n", struct_definition.name).as_bytes());
    if is_packet {
        file.write(b"            .field(\"id\", &self.id())\n");
    }
    for field in &struct_definition.fields {
        file.write(format!("            .field(\"{}{}\", &self.{})\n",
                           field.name,
                           format!("[{}, {}]", field.position, if field.length > -1 { (i32::from(field.position) + field.length).to_string() } else { "?".to_string() }),
                           field.name
        ).as_bytes());
    }
    file.write(b"        .finish()\n");
    file.write(b"    }\n");
    file.write(b"}\n\n");
}

fn write_struct_impl(file: &mut File, struct_definition: &StructDefinition, all_struct: &Vec<StructDefinition>) {
    file.write(format!("impl {} {{\n", struct_definition.name).as_bytes());
    file.write(format!("    pub fn from(buffer: &[u8]) -> {} {{\n", struct_definition.name).as_bytes());
    let field_with_vec = struct_definition.fields.iter().find(|field| field.data_type.name == "Vec");
    if field_with_vec.is_some() {
        write_vec_field(file, &field_with_vec.unwrap());
    }
    file.write(format!("        {} {{\n", struct_definition.name).as_bytes());
    for field in &struct_definition.fields {
        if field.data_type.name == "Vec" {
            file.write(format!("            {}: vec_field,\n", field.name).as_bytes());
        } else if field.data_type.name == "Struct" {
            file.write(format!("            {}: {}::from(&buffer[{}..{}]),\n", field.name, field.complex_type.as_ref().unwrap(), field.position, field_length(field)).as_bytes());
        } else {
            file.write(format!("            {}: {},\n", field.name, struct_impl_field_value(field)).as_bytes());
        }
    }
    file.write(b"        }\n");
    file.write(b"    }\n");
    file.write(b"}\n\n");
}

fn write_vec_field(file: &mut File, field: &StructField) {
    file.write(format!("        let iter_count = &buffer.len() / {};\n", field.length).as_bytes());
    file.write(format!("        let mut vec_field: Vec<{}> = Vec::new();\n", field.complex_type.as_ref().unwrap()).as_bytes());
    file.write(b"        let mut i = 1;\n");
    file.write(b"        while i <= iter_count {\n");
    file.write(format!("            let start_pos = {} * i;\n", field.position).as_bytes());
    file.write(format!("            let end_pos = {} * i;\n", field.position + field.length as i16).as_bytes());
    file.write(format!("            vec_field.push({}::from(&buffer[start_pos..end_pos]));\n", field.complex_type.as_ref().unwrap()).as_bytes());
    file.write(b"            i += 1;\n");
    file.write(b"        }\n");
}

fn struct_impl_field_value(field: &StructField) -> String {
    match field.data_type.name.as_str() {
        "char" => {
            format!("buffer[{}] as char", field.position)
        }
        "u16" => {
            format!("u16::from_le_bytes([buffer[{}], buffer[{}]])", field.position, field.position + 1)
        }
        "u32" => {
            format!("u32::from_le_bytes([buffer[{}], buffer[{}], buffer[{}], buffer[{}]])", field.position, field.position + 1, field.position + 2, field.position + 3)
        }
        "bool" => {
            format!("buffer[{}] == 1", field.position)
        }
        "String" => {
            format!("String::from_utf8_lossy(&buffer[{}..{}]).to_string()", field.position, field_length(field))
        }
        _ => {
            format!("\"found unknown type {} for field {}. this won't compile!\"", field.data_type.name, field.name)
        }
    }
}

fn field_length(field: &StructField) -> String {
    if field.length > -1 { (field.position + field.length as i16).to_string() } else { "buffer.len()".to_string() }
}

fn write_unknown_packet(file: &mut File) {
    file.write(b"#[derive(Debug)]\n");
    file.write(b"pub struct PacketUnknown {\n");
    file.write(b"    packet_id: String,\n");
    file.write(b"}\n");
    file.write(b"impl Packet for PacketUnknown {\n");
    file.write(b"    fn id(&self) -> &str {\n");
    file.write(b"        self.packet_id.as_str()\n");
    file.write(b"    }\n");
    file.write(b"    fn debug(&self) {\n").unwrap();
    file.write(b"            println!(\"{:?}\", self)\n");
    file.write(b"    }\n").unwrap();
    file.write(b"}\n");
    file.write(b"impl PacketUnknown {\n");
    file.write(b"    pub fn from(buffer: &[u8]) -> PacketUnknown {\n");
    file.write(b"        PacketUnknown { packet_id: format!(\"{:02X?}{:02X?}\", buffer[0], buffer[1])}\n");
    file.write(b"    }\n");
    file.write(b"}\n");
}